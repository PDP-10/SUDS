;<DRAW>FIRST.FAI;113,  7-AUG-75 14:24:58, EDIT BY HELLIWELL
;DEFINE ALL CONDITIONAL ASSEMBLY - SET TITLE

XALLNOLIT

DEFINE MWL,<IFN 0>	;WE AREN'T THE WIRELISTER
DEFINE MDPC,<IFE 0>	;WE ARE THE DRAWING PROG

DEFINE SETSW $ (NAME,DEFVAL)
<	IFNDEF NAME$SW,<NAME$SW__IFIDN <DEFVAL> <> <0;> DEFVAL
>
	NAME$SW__NAME$SW
>

DEFINE ONOFSW $ (NAME,DEFVAL)
<	SETSW(NAME,DEFVAL)
	IFN NAME$SW,<NAME$SW__-1>	;MAKE IT NICE FOR  AND 
>
DEFINE DEFSW $ (NAME)
<	DEFINE NAME,<IFN NAME$SW>
	DEFINE NO$NAME,<IFE NAME$SW>
>
DEFINE MAKESW(NAME,VAL)
<	ONOFSW(NAME,VAL)
	DEFSW(NAME)
>

MAKESW(STAN)
MAKESW(DEC)
MAKESW(CMU)
MAKESW(ITS)

DEFINE STANFO,<STAN>		;LONG FORM FOR HYSTERICAL RAISINS

DEFINE CHECK $ (SITE,VAR) <IFDEF VAR,<SITE$SW__-1;>>
IFE STANSW!DECSW!CMUSW!ITSSW,<
;IF NO SITE SET MANUALLY ABOVE, WE MUST DECIDE FOR OURSELVES WHERE WE ARE
CHECK(ITS,.IOT) CHECK(CMU,CMUDEC) CHECK(STAN,SPWBUT) DECSW__-1
>

DEFINE MOR (A)
<TMPSW__0
FOR B IN (A)
<	B,<TMPSW__-1>
>
IFN TMPSW>

NOCMU,<
NOITS,<

DEFINE PC<PCSW__-1
PRINTS /PC VERSION SELECTED
/>
DEFINE GT<GT40SW__-1

DEFINE GTBIG<GTSMAL__0
PRINTS /LARGE SCREEN SELECTED
/>
PRINTS /GT40 SELECTED
	TYPE	TO GET
	GTBIG	LARGE SCREEN GT40 (SQUARE)
/>
DEFINE NOVIROS<VIROSSW__0
PRINTS /NON-VIROS VERSION SELECTED
/>
DEFINE ROUTE<ROUTES__-1
PRINTS /RPH ROUTING VERSION SELECTED
/>
DEFINE NODLX<DLXSW__0
PRINTS /DL10 DESELECTED
/>
DEFINE PGP<PGPSW__-1
PRINTS /PGP SELECTED
/>
DEFINE LIB<LIBSW__-1
PRINTS /LIBRASCOPE LAYOUT VERSION SELECTED
/>
DEFINE TWO<TWOSW__-1
PRINTS /TWO SEGMENT LAYOUT VERSION SELECTED
/>
PRINTS /	TYPE	TO GET
	PC	PC PROGRAM
	GT	GT40 VERSION
	ROUTE	RPH ROUTER
/
DEC,<	PRINTS /	NOVIROS	NOT VIROS
	NODLX	NON-DL10 VERSION
	PGP	PGP VERSION
/>
STANFO,<	PRINTS /	LIB	LIBRASCOPE LAYOUT VERSION
	TWO	TWO SEGMENT LAYOUT VERSION
/>
PRINTS /	END WITH ;^Z
/

.INSERT TTY:

>;NOITS
>;NOCMU

DEFINE VERSION ' (PROG,VN)
<SUBTTL PROG V'VN
^^VERSUM__VERSUM+VN
>
VERSUM__0
VMAJOR__10	;MAJOR VERSION #
VMINOR__0	;MINOR VERSION LETTER
VGROUP__1	;MODIFYING GROUP

VERSION(FIRST,11)

MAKESW(DECOS,DECSW!CMUSW)

MAKESW(TWO)

TWO,<LIBSW__0>
MAKESW(LIB)

MAKESW(LAY,LIBSW!TWOSW)

ONOFSW(PC,0)
DEFINE MD,<IFE PCSW>
DEFINE MPC,<IFN PCSW>

DEFINE COLTIM,<IFN 0>	;AED COLLECT TIMING DATA (REQUIRES COLTIM.FAI[X335AD0L] FROM DEC.30, 1976 PUBLIC SAVE

MAKESW(BACK)		;BACKPANEL VERSION

MAKESW(GT40)
DEFINE GT<GT40>
DEFINE NOGT<NOGT40>

MAKESW(PGP)

MAKESW(VB10,<DECSW&<GT40SW>&<PGPSW>>)

DEC,<
ENTRY TODDT
IFNDEF GTSMAL,<GTSMAL__-1>		;FOR SMALL SCREEN GT40
GTSMAL__GTSMAL

MAKESW(VIROS,-1)	;ASSUME VIROS FOR NOW (WILL ALWAYS BE INSIDE DEC)

MAKESW(DLX,GT40SW)	;ASSUME DL10 FOR NOW IF GT40

>;DEC

MAKESW(VIROS)	;0 IF NOT DEFINED
MAKESW(DLX)	;0 IF NOT DEFINED

MAKESW(WAG,-1)	;WAGNERS PC ROUTER STUFF

MAKESW(UML,-1)	;ENABLE USE OF WDR FILES FOR FLASHING, ETC.

MAKESW(PART,-1)	;WAGNER PARTITIONER

MAKESW(SHORT,-1)	;FIND SHORTS

MAKESW(ROUTE)		;RPH ROUTING STUFF

SETSW(WW)		;ENABLES WIRE WRAP BOARD KNOWLEDGE
DEFSW(WW)

MAKESW(RHG,0)		;SPECIAL HACKS FOR RHG (RICHARD H. GUMPERTZ AT CMU)

MAKESW(CMUF,CMUSW!RHGSW)	;CMU FORMAT -- INDEPENDENT OF WHERE THE PROGRAM IS RUN
			;I.E. JUST THE STUFF CMU LIKES, NOT THAT IT NEEDS.

LAY,<
PASSNM__-1			;INITIALIZE TO PASS1
DEFINE PASS1<IFN PASSNM>
DEFINE PASS2<IFE PASSNM>
>;LAY
;TITLES
LAY,<
	ROUTE,<
		LIB,<TITLE LR
			DEFINE %PNAME<SIXBIT/LR/>>
		TWO,<TITLE TR
			DEFINE %PNAME<SIXBIT/TR/>>
	>;ROUTE
	NOROUTE,<
		LIB,<TITLE L
			DEFINE %PNAME<SIXBIT/L/>>
		TWO,<TITLE T
			DEFINE %PNAME<SIXBIT/T/>>
	>;NOROUTE
>;LAY
NOLAY,<
	MD,<
		NODEC,<TITLE D>
		DEC,<VB10,<TITLE D VB10 VERSION>
		       GT,<TITLE D GT40 VERSION>
		      PGP,<TITLE D PGP VERSION>
			>;DEC
			DEFINE %PNAME<SIXBIT/D/>
	>;MD
	MPC,<
		ROUTE,<TITLE RPC
			DEFINE %PNAME<SIXBIT/RPC/>>
		NOROUTE,<TITLE PC
			DEFINE %PNAME<SIXBIT/PC/>>
	>;MPC
>;NOLAY
;OPDEFS

ITS,<
OPDEF CALL	[ 40B8]
OPDEF INIT	[ 41B8]
OPDEF CALLI	[ 47B8]
OPDEF OPEN	[ 50B8]
OPDEF TTYUUO	[ 51B8]
OPDEF RENAME	[ 55B8]
OPDEF IN	[ 56B8]
OPDEF OUT	[ 57B8]
OPDEF SETSTS	[ 60B8]
OPDEF STATO	[ 61B8]
OPDEF GETSTS	[ 62B8]
OPDEF STATZ	[ 63B8]
OPDEF INBUF	[ 64B8]
OPDEF OUTBUF	[ 65B8]
OPDEF INPUT	[ 66B8]
OPDEF OUTPUT	[ 67B8]
OPDEF CLOSE	[ 70B8]
OPDEF RELEASE	[ 71B8]
OPDEF MTAPE	[ 72B8]
OPDEF UGETF	[ 73B8]
OPDEF USETI	[ 74B8]
OPDEF USETO	[ 75B8]
OPDEF LOOKUP	[ 76B8]
OPDEF ENTER	[ 77B8]
OPDEF UJEN	[100B8]
OPDEF DPYCLR	[701B8]
OPDEF PPIOT	[702B8]
OPDEF UPGIOT	[703B8]
OPDEF UINBF	[704B8]
OPDEF UOUTBF	[705B8]
OPDEF FBREAD	[706B8]
OPDEF FBWRT	[707B8]
OPDEF MAIL	[710B8]
OPDEF PTYUUO	[711B8]
OPDEF POINTS	[712B8]
OPDEF UPGMVE	[713B8]
OPDEF UPGMVM	[714B8]
OPDEF PGIOT	[715B8]

OPDEF TTCALL	[TTYUUO]
OPDEF INCHRW	[TTYUUO 0,]
OPDEF OUTCHR	[TTYUUO 1,]
OPDEF INCHRS	[TTYUUO 2,]
OPDEF OUTSTR	[TTYUUO 3,]
OPDEF INCHWL	[TTYUUO 4,]
OPDEF INCHSL	[TTYUUO 5,]
OPDEF GETLIN	[TTYUUO 6,]
OPDEF SETLIN	[TTYUUO 7,]
OPDEF RESCAN	[TTYUUO 10,]
OPDEF CLRBFI	[TTYUUO 11,]
OPDEF CLRBFO	[TTYUUO 12,]
OPDEF INSKIP	[TTYUUO 13,]
OPDEF INWAIT	[TTYUUO 14,]

OPDEF PTWR1S	[PTYUUO 7,]
OPDEF PTWRS9	[PTYUUO 12,]

OPDEF PPSEL	[PPIOT 0,]
OPDEF PPACT	[PPIOT 1,]
OPDEF DPYPOS	[PPIOT 2,]
OPDEF DPYSIZ	[PPIOT 3,]
OPDEF PPREL	[PPIOT 4,]
OPDEF PGSEL	[PGIOT 0,]
OPDEF PGACT	[PGIOT 1,]
OPDEF PGCLR	[PGIOT 2,]
OPDEF DPYOUT	[UPGIOT]

OPDEF DSKPPN	[CALLI 400071]
OPDEF SWAP	[CALLI 400004]
>;ITS

OPDEF PUTBYT[1B8]
OPDEF PUTSTR[2B8]

DEC,<
	OPDEF	DSKPPN	[10B8]
	OPDEF	TTYUUO	[51B8]
	OPDEF	DPYOUT	[3B8]
	OPDEF	DPYCLR	[4B8]
GT,<	OPDEF	IONEOU	[TTYUUO	15,]	;;JB DEFINE THE IMAGE OUT UUO.>
PGP,<	OPDEF	PLIT	[POINT 36,0,35]	>
>;DEC

NOSTANFO,<
VIROS,<
OPDEF COMPT. [CALLI 147]
SEARCH MONSYM		;GET JSYS DEFS
	VBLOCK__30	;LOCK CODE
	VBSTRT__31	;START CODE
	VBSTOP__32	;STOP CODE
	VBSTAT__33	;STATUS CODE
>;VIROS

OPDEF RESET [CALLI]
OPDEF CORE [CALLI 11]
OPDEF EXIT [CALLI 12]
OPDEF DATE [CALLI 14]
OPDEF APRENB [CALLI 16]
OPDEF TIMER [CALLI 22]
OPDEF MSTIME [CALLI 23]
OPDEF GETPPN [CALLI 24]
OPDEF PJOB [CALLI 30]
OPDEF SLEEP [CALLI 31]
OPDEF SETUWP [CALLI 36]
OPDEF GETTAB [CALLI 41]
OPDEF SETNAM [CALLI 43]
OPDEF LOCK [CALLI 60]
OPDEF DEVNAM [CALLI 64]
OPDEF HIBER [CALLI 72]
OPDEF PATH [CALLI 110]
OPDEF UNLOK. [CALLI 120]

OPDEF INCHRW [TTYUUO 0,]
OPDEF OUTCHR [TTYUUO 1,]
OPDEF INCHRS [TTYUUO 2,]
OPDEF OUTSTR [TTYUUO 3,]
OPDEF INCHWL [TTYUUO 4,]
OPDEF INCHSL [TTYUUO 5,]
OPDEF GETLIN [TTYUUO 6,]
OPDEF SETLIN [TTYUUO 7,]
OPDEF RESCAN [TTYUUO 10,]
OPDEF CLRBFI [TTYUUO 11,]
OPDEF CLRBFO [TTYUUO 12,]
OPDEF INSKIP [TTYUUO 13,]
>;NOSTANFO

NODECOS,<
DEFINE ENTPPN<>
>;NODECOS

DECOS,<
NODEC,<	OPDEF DSKPPN [GETPPN] >
DEFINE ENTPPN
<	SKIPN T,FILPPN
	DSKPPN T,
	MOVEM T,FILPPN
>
>;DECOS

EXTERNAL .JBOPC,.JBREN,.JBDDT,.JBFF,.JBSYM,.JBHRL,.JBSA,.JBREL
COLTIM,<INTERNAL MODE>
DEC,<
EXTERNAL	.JB41,.JBUUO,.JBTPC,.JBAPR,.JBCNI,.JBINT
GT,<
EXTERN	SAVER,RESTRE,GTINIT,TRANS8,CLEARS,GTRESET
EXTERNAL GTCHRW,GTCHRS,GTCHSL,GTCHWL	;;JB
EXTERN	SENDHD,STPSHW,SRTSHW,BMODDO,BREADM,STLPXY	;;JB
DLX,<INTERNAL DLXJFN,DLXFLG>
INTERNAL NBYTES,OPTFLG,GTX,GTY
>;GT
PGP,<	EXTERN	CHRTAB	>

;SPECIAL PUSHDOWN LIST FOR PDL OVFL HANDLER
SPD2SZ__200
>;DEC
SPPDSZ__10

ORG	137
	<BYTE (3) VGROUP (9) VMAJOR (6) VMINOR>+TOTSUM
ORG

IFN DECSW!CMUSW!TWOSW,<
SET LOWER,.
TWOSEG
RELOC 400000
SET UPPER,.

VB10,<
NOVIROS,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE UPPER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;NOVIROS
VIROS,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE UPPER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;VIROS
>;VB10

NOVB10,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE LOWER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;NOVB10
>;IFN DECSW!CMUSW!TWOSW
IFE DECSW!CMUSW!TWOSW,<
DEFINE STORAGE(A)
<>

ITS,<

SET LOWER,.
TWOSEG
RELOC 400000
SET UPPER,.

DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE LOWER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;ITS
>;IFE DECSW!CMUSW!TWOSW

;CTRL C INTERCEPT BLOCK
DEC,<
STORAGE(LOW)
INTBLK:	XWD	4,CTRLCI
	2		;CTRL C INTERCEPT
	0
	0
>;DEC
;SOME MACROES FOR THE GT-40 VERSION
IFN GT40SW,<					;;JB  DEFINE MACROS NOW.

DEFINE	STOPIC(PICNUM)		;;JB DEFINE STOP PICUTRE MACRO.
<	PUSH	P,16			;;JB SAVE DATA REGISTER.
	MOVEI	16,PICNUM		;;JB GET THE PICTURE NUMBERNOW.
	PUSHJ	P,STPSHW		;;JB STOP SHOWING THE PICUTRE NOW.
	POP	P,16			;;JB RESTORE DAMAGED REGISTER NOW.
>

DEFINE	STAPIC(PICNUM)		;;JB OPPOSITE OF THE ABOVE.
<	PUSH	P,16			;;JB SAVE REGISTER NOW.
	MOVEI	16,PICNUM		;;JB  GET THE PICUTRE NUMBER NOW.
	PUSHJ	P,SRTSHW		;;JB START SHOWING IT NOW.
	POP	P,16			;;JB RESTORE REGISTER NOW.
>

DEFINE	BMODS(PIC,OFF,NUM)	;;JB DEFINE PICTURE MODIFICATION MACRO.
<	PUSH	P,13			;;JB SAVE A BUNCH OF REGISTERS NOW.
	PUSH	P,14
	PUSH	P,15
	PUSH	P,16
	MOVEM	P,STCHPS		;;JB SAVE THE STACK NOW.
	PUSH	P,[PIC]			;;JB PLACE PIC NUMON STACK.
	MOVE	16,P			;;JB MOVE OVER POINTER TO START OF MODIFIFIER.
	PUSH	P,[OFF]			;;JB PUSH THE OFFSET NOW.
	PUSH	P,[NUM]			;;JB AND FINALLY PUSHTHE NUMBER.
>

DEFINE	BMODF			;;JB DEFINE CALLING AND POPPING MACRO.
<	PUSHJ	P,BMODDO		;;JB SEND IT OUT NOW.
	MOVE	P,STCHPS		;;JB RESET STACK TO A GOOD ONE.
	POP	P,16			;;JB RESTORE REGISTERS NOW.
	POP	P,15			;;JB
	POP	P,14			;;JB
	POP	P,13			;;JB
>

DEFINE	INCHRW(ARG)		;;JB DEFINE WAIT FOR CHAR AS MACRO
<					;;JB WHICH IS REALLY A PUSHJ TO
	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 0,ARG
			POPJ P,]
		PUSHJ P,GTCHRW	;;JB A PUSHJ WITH THE ARGUMENT AFTER
		POP P,ARG]		;;JB THE SECOND PUSHJ.
>

DEFINE	INCHRS(ARG)		;;JB LIKEWISE DO THE SAME FOR THE FOLLOWING.
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 2,ARG
			POPJ P,
			JRST CPOPJ1]
		PUSHJ P,GTCHRS	;;JB
		POP P,ARG]		;;JB
>

DEFINE	INCHWL(ARG)		;;JB DEFINE THE GET A CHAR (LINE MODE) [WAIT].
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 4,ARG
			POPJ P,]
		PUSHJ P,GTCHWL	;;JB CAL THE CORRECT ROUTINE NOW.
		POP P,ARG]		;;JB GIVE HIM BACK THE ANSWER NOW.
>

DEFINE	INCHSL(ARG)		;;JB AND THE GET CHAR(LINE MODE).
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 5,ARG
			POPJ P,
			JRST CPOPJ1]
		PUSHJ P,GTCHSL	;;JB
		POP P,ARG]		;;JB
>

DEFINE	GTMIX(C1,C2)		;;JB DEFINE A MACRO TO PUT THE CHARACTERS IN OK.
<	BYTE	(4) 0 (8) 0,0,C2,C1	;;JB
>

RDYCJ__25			;;JB DEFINE THE "READY" CONTROL CHARACTER
					;;JB AS BEING A ^U, WHICH IS NOT NORMALLY SENT.
NRDYCJ__17			;;JB LIKEWISE DEFINE THE NOT READY CHARACTER AS ^O.

>;GT					;;JB  END THE CONDITIONAL ASSEMBLY.

PGP,<				;SOME DEFINITIONS FOR THE PGP VERSION
$S__0		;BLISS STACK PTR
$V__3		;BLISS VALUE RETURN REG

DEFINE	RTNCAL	(NAME,A) <
EXTERN	NAME
	MOVE	$S,P
CNT$__0
IFIDN <A><><	FLG$__0	;>	FLG$__1
IFN FLG$,<
	FOR	I IN (A) <
	PUSH	$S,I
CNT$__CNT$+1
>;FOR
>;IFN FLG$
	PUSHJ	$S,NAME
IFN CNT$,<
	SUB	$S,[XWD CNT$,CNT$]
>
	SKIPLE	$V
	MOVEM	$V,$VAL
	MOVE	P,$S
>;RTNCAL
>;PGP
;AC'S - SPECIAL CHAR DEFS - OTHER DEFS

;0			;TEMPORARY FLAGS
M_1			;SEMI-PERMANENT FLAG REG
A_2
B_3
C_4
D_5
E_6
F_7
G_10
H_11
T_14
TT_T+1
TTT_TT+1
P_17

;IO CHANNEL NUMBERS
DAT__0		;DATA IN AND OUT
IDSK__1	;DISK INPUT
ODSK__2	;DISK OUTPUT
IOLAY__3	;LAYOUT I/O
ICARD__4	;CARD DEF INPUT CHANNEL
DEC,<	DISCHN__5	;VB10C CHANNEL
	PGPCHN__10	;PGP I/O CHANNEL
>;DEC
CMU,<	ATYO__5	;GDP2 OUTPUT CHANNEL
	ATYI__6	;GDP2 INPUT CHANNEL
>;CMU

;DEFAULT PROTECTION FOR OUTPUT FILES
DECOS,<DEFPRO__155>	;ALLOW EVERYTHING ON OTHER USERS AREA
NODECOS,<DEFPRO__000>
DEC,<DEFPRO__005>	;NOT HERE!!!!!!!

;CHARACTER SIZES
NODEC,<
CWIDTH__10
CHGHT__20
STDBIG__1	;DEFAULT TEXT SIZE
>;NODEC
DEC,<
CWIDTH__6
CHGHT__12
STDBIG__2
>;DEC

;NUMBER OF CHARS NECESSARY TO PRINT FILENAME INFO
NOSTAN,<NOITS,<NNCHRS__6+6+6+3>>	;FFFFFF[PPPPPP,NNNNNN]
STANFO,<NNCHRS__6+6+4>		;FFFFFF[PPP,NNN]
ITS,<NNCHRS__6+6+1>		;UUUUUU;FFFFFF
NNCHRE__NNCHRS+4		;.EEE	DEC,STANFO,CMU
				; EEE	ITS

;NUMBER OF WORDS NECESSARY TO SHOW DEFAULT FILENAME
NOLAY,<NFWRDS__(NNCHRS+4)/5	>;FFFFFF[PPP,NNN]
LAY,<NFWRDS__(NNCHRS*2+1+4)/5	>;FFFFFF[PPP,NNN]&FFFFFF[PPP,NNN]

;NUMBER OF WORDS NECESSARY FOR NAMBUF PRINTOUT BUFFER
NNWRDS__(NNCHRE+4)/5		;FFFFFF.EEE[PPP,NNN]
IFL NNWRDS-NFWRDS,<NNWRDS__NFWRDS>;MAKE ENOUGH FOR BOTH

;SPECIAL CHARACTERS, DEFINE AS YOU WISH
NODEC,<
CTRL__""	;CHARACTER INTERPRETED AS CONTROL BIT
META__3		;		"	  META BIT
CTLMTA__""	;		"	  CTRL META BITS
TTYCM__"'"	;HACK FOR TTY'S AT STANFORD, INC'S CTRL BITS
>;NODEC
LAMBDA__""	;FOR DISK IO START, STOP
CRCHR__24	;CR FOR DISKIN AND MACRO ALTER MODE
AMCTL__13	;ALTER MODE <CTRL> CHAR (1 ALT)
AMMTA__14	;ALTER MODE <META> CHAR (2 ALT)
NODEC,<TEXIST__"">	;THERE EXISTS, FOR FILENAME
DEC,<TEXIST__"">
BIGCHR__""	;GET BIGGER
DBLARR__""	;CRLF IN TEXT
NODEC,<ALTCHR__"}">	;ALTMODE FROM FILE AND FOR MACRO ALTER MODE
DEC,<	ALTCHR__7>	;BELL FOR DEC
NOCMU,<ACLOSE__176>	;CLOSING CHARACTER IN ";A"
CMU,<ACLOSE__175>
VRTBAR__"|"	;VERTICAL BAR
STANFO,<ALTMOD__175>	;ALTMODE CHAR
NOSTANFO,<ALTMOD__33>
NOT__""	;CHAR LIKE "-", BUT DIF.
NOTCHR__"-"	;FOR PERMUT AND ALPHA
TILDA__32	;LOW TRUE FOR SIGNAL NAME
GENCHR__"%"	;GENERATED SIGNAL NAME CHAR.
RHG,<GENCHR__"!">

;SPECIAL CHARS FOR SEARCH STUFF IN ALTER MODE AND F
QUOCHR__""	;QUOTE CHAR IN SEARCH STRINGS
BELCHR__"|"	;BEGINNING OR END OF LINE
NODEC,<ANYCHR__24>	;ANY CHAR IN SEARCH STRING
DEC,<ANYCHR__"?">	;	"
NODEC,<NFCHR__"}">	;NOT NEXT THING
DEC,<	NFCHR__""	>
INFCHR__""	;ANY # OF FOLLOWING
LETCHR__"$"		;MATCH ANY LETTER
DIGCHR__"%"		;MATCH ANY DIGIT
ALFCHR__""		;MATCH ANY ALPHANUMERIC

;SCREEN DEMENSIONS - - LEAVE TOP 3 LINES
NODEC,<
%TOP__700
%BOTTOM__-1000
%LEFT__-1000
%RIGHT__1000
NOSTAN,<SCRTOP__1000>
STAN,<SCRTOP__1000-2*CHGHT>
TITBRT__2
TITBIG__2
>;NODEC
DEC,<
VB10,<
%TOP__700
%BOTTOM__-770
%LEFT__-770
%RIGHT__766
SCRTOP__1000-10
>;VB10
GT,<
;HALF PHYSICAL HEIGHT AND WIDTH OF GT40 SCREEN
GTX__1000
IFN GTSMAL,<GTY__600>
IFE GTSMAL,<GTY__1000>
%TOP__GTY-10
%BOTTOM__-GTY+1
%LEFT__-GTX+1
%RIGHT__GTX-1
SCRTOP__GTY
>;GT
PGP,<
%TOP__700
%BOTTOM__-1000
%LEFT__-1000
%RIGHT__1000
SCRTOP__1000
>;PGP
TITBRT__5
TITBIG__STDBIG
>;DEC

;ALTER TEXT MODE DISPLAY PARAMETERS
AXPOS__%LEFT+200
AYPOS__%TOP-200
ACHRSZ__2		;CHAR SIZE
NODEC,<	MAXLIN__=30	;MAX CHARS PER LINE
	MAXPAG__=20
>;NODEC
DEC,<	MAXLIN__=60
NOGT,<	MAXPAG__=40 >
GT,<	MAXPAG__=32 >
>;DEC

GT,<	DPYLEN__1400	>
NOGT,<	DPYLEN__6000	>

;INITIALIZATION VALUES FOR FLAGS,SCALE
DEFINE	DFLT0	<<0,,MCHG!NEEDCL>>	;MACRO BECAUSE FLAGS NOT DEFINED YET
DEFINE	DFLTM	<<MD,<BLOCS!PLOCS!CLOCS!>DEC,<XWINDOW!>MD,<CMUF,<DIAMONDS!JUNC3!>>LWINDOW,,DEC,<SPACES!>0>>
MPC,<	DFSCL__=2 >
MD,<	DFSCL__=16
	DEC,<	DFSCL__=8 >
>;MD

;CONCATINATION
	DEFINE CAT $ (A,B)
<	A$B
>
;PG0 -- INFO LINE, CURSOR

NOCMU,<

STORAGE(DPY)	;KEEP ALL DISPLAY STUFF IN LOWER SEG

DEFINE RPNT(X,Y),<
	BYTE(11)<X>,<Y>(3)0,0(2)0,1(4)6
REPEAT 0,<	BYTE(11)0,0(3)0,0(2)0,1(4)6>
	BYTE(8)0,0,200(12)32
	BYTE(8)100,0,100(12)12
	XWD .+3,20
	XWD SAVWRD,64
	BYTE(8)200,0,0(12)12
>

DEFINE LIVW(X,Y,S)
<	BYTE (11)<X>,<Y>(3)3,S(2)1,2(4)6	>

DEFINE RDV(X,Y)
<	BYTE (7)<X>,<Y>(2)0(7)<X>,<Y>(2)2(4)2	>
DEC,<
VB10,<					;;JB ASSEMBLE IN THIS.
FBUF:	0				;BUFFER HEADER
	0
	XWD	030130+TITBRT,221000+SCRTOP-TITBIG*CHGHT-20	;LITE PEN OFF, SCALE-2 BRITE-7, Y
REDWRD:	BYTE (18) 061000+%RIGHT-30 (6) 35,"*",37	;RIGHT 1/2 VARIES
	BYTE (18) 020000,221000+SCRTOP-TITBIG*CHGHT
	BYTE(18) 061000+%LEFT (6) 35,"M","O"	;X,<SHIFT IN>"MO"
MODWRD:	BYTE(6) "D","E","=",35,35,35	;"DE=" RIGHT 1/2 VARIES
	BYTE (6) 35," ","S","C","L","="	;"SCL="
SCLWRD:	BYTE (6) 35,35,35,35," ","L"	;LEFT 1/2 VARIES
LVLWRD:	BYTE (6) "V","L","=",35,35,35	;"LVL=" RIGHT 1/2 VARIES
	BYTE (6) 35," ",37 (18) 100000	;ENTER VECTOR MODE
	XWD 200005,203000		;EXISTS IN VECTORS
	XWD 200204,101404
	XWD 200203,501405
	BYTE (18) 060000 (6) "=",35,35	;"="
FILWRD:
	REPEAT	NFWRDS-1,<
	BYTE (6) 35,35,35,35,35,35
>
	BYTE (6) 35,35,35,35,35,37
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
FVECT1:	0
	0
	0
	0
	0
	XWD 160000,400000
	XWD SAVWR1,0		;JSR SAVWR1
FVECT2:	0
	0
	0
	0
	0
FBRT:	XWD 0,160015		;0;BRITE 5
LOCAT:	XWD 0,%NLOC	;JMP %NLOC (OR JSR LOCATS)
	XWD 600100,160000	;RIGHT
	XWD 400000,LOCATS
	XWD 600300,160000	;LEFT
	XWD 400000,LOCATS
	XWD 640000,160000	;UP
	XWD 400000,LOCATS
	XWD 740000,0		;DOWN,0
%NLOC:	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 160000,0		;JMP ONOFF-1(OR JMP .+1)
%CLOC:	XWD ONOFF-1,0
	XWD 120160,600100	;SCALE-8,RIGHT
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,600300	;LEFT
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,640000	;UP
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,740000	;DOWN
	XWD 160120,400000	;SCALE-1,JSR SAVWR1
	XWD SAVWR1,0
	XWD	0,160000	;JSR CROSS(OR JUMP .+1)
ONOFF:	XWD 400000,CROSS
	XWD 160000,0		;JMP VBBUF
ENDPG1:	XWD	FBUF,0

CROSS:	0
	XWD 100137,002004	;INVIS NE
	XWD 304210,004000	;VISIB SW,INVIS N
	XWD 704010,160000	;VISIB SE, JMP @CROSS
	XWD 200000,CROSS
LOCATS:	0
	XWD 0,20000
LOCATW:	XWD 220000,160000
	XWD 320000,LOCATS	;JMP @LOCATS (INTO VEC CONT MODE)

SAVWR1:	0
	XWD 0,20000
SAVWRD:	XWD 221000,161000
	XWD 200000,SAVWR1
NULLO:	0			;NULL SUBROUTINE
	XWD	160000,200000
	XWD	NULLO,0

>;VB10					;;JB

GT,<					;;JB MY CRAP....

JBREDY:	0				;;JB REMEMBERS READY-NOT READY STATE.



	DISTOP__173400			;;JB DEFINE THE DISTOP INSTRUCTION.


PIC3:	117124				;;POSITION TO TOP LEFT OF SCREEN.
	0
	GTY+SCRTOP-CHGHT*2
	100000				;;GET INTO CHARACTER MODE.
	GTMIX	"M","O"			;;JB STICK IN THE CORRECT HEADING
	GTMIX	"D","E"			;;JB  USING 8 BIT GT40 CHARACTERS.
	GTMIX	"=",0			;;JB
GTMODE:	GTMIX	"J","B"			;;JB CHANGABLE MODE LETERS HERE.
	GTMIX	" ","S"			;;JB
	GTMIX	"C","L"			;;JB
	GTMIX	"=",0			;;JB
GTSWRD:	GTMIX	"0",0			;;JB CURRENT SCALING LEVEL.
	GTMIX	" ","L"			;;JB THE LEVEL NOW.
	GTMIX	"V","L"			;;JB
	GTMIX	"=",0			;;JB
GTLWRD:	GTMIX	"0",0			;;JB CURRENT LEVEL VALUE.
	GTMIX	" ",135			;;JB THE 'THERE EXISTS' SIGN.
	GTMIX	10,"-"			;;JB DONE BY SUPERIMPOSING.
	GTMIX	"=",0			;;JB
GTFNAM:	0				;;JB LEAVE ROOM FOR 25 CHARACTERS FOR
	0				;;JB  THE FILE NAME (13 WORDS).
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	DISTOP				;;JB END OF THE LIST NOW.
	0

PIC3Z__.-PIC3				;;JB SIZE OF THE LIST.
	XWD	3,1			;;JB DEFINE AS SUBPICTURE 3, REMEMBER CHANGES.

>;GT					;;JB END OF MYCRAP.

PGP,<
TSXDAT:	0
TSYDAT:	0
FILWRD:	BLOCK	NFWRDS
	0
MODWRD:	0
SCLWRD:	0
LOCAT:	0
LVLWRD:	0
	1
NULARG:	0
NILEV:	0
SEGN:	0
PSEGN:	0
$VAL:	0
FVECT1:	0
FVECT2:	0
BLNKIT:	0
PGBITS:	0
FBUF:	0			;DUMMY
SAVWRD:	0
>;PGP

>;DEC

NODEC,<
FBUF:	.+2
	FEND-.-1
	0
	LIVW(%RIGHT-CWIDTH*4,SCRTOP-CHGHT*4,6)
REDWRD:	ASCID/*/
	LIVW(%LEFT,SCRTOP-CHGHT*2,4)
	ASCID/MODE=/
MODWRD:	1
	ASCID/   SCL=/
SCLWRD:	1
	ASCID/   LVL=/
LVLWRD:	1
	ASCID/   =/
FILWRD:REPEAT NFWRDS,<1>
	XWD SAVWRD,54
FVECT1:	12
	XWD SAVWRD,54
FVECT2:	12
	XWD SAVWRD,54
FBRT:	BYTE(11)0,0(3)2,0(2)0,2(4)6	;USE CURBRT ON THE REST OF THIS
LOCAT:	XWD %NLOC,20		;NORMALLY JUMP TO %NLOC
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(20,0)		;GO RIGHT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(-20,0)		;GO LEFT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,20)		;GO UP
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,-20)		;GO DOWN
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
%NLOC:	XWD SAVWRD,54
%CLOC:	XWD ONOFF,20		;NORMALLY JUMP TO ONOFF
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(10,0)		;GO RIGHT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(-10,0)		;GO LEFT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,10)		;GO UP
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,-10)		;GO DOWN
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
ONOFF:	XWD CROSS,20		;INITIALLY USE CROSS
	BYTE(8)167,200,0(12)12
	RPNT 0,0
	RPNT 0,0
;INNER RING
	RPNT -4,0
	RPNT 4,-4
	RPNT 4,4
	RPNT -4,4
;START FIRST RING
	RPNT -10,-4
	RPNT 10,-10
	RPNT 10,10
	RPNT -10,10
;START SECOND RING
	RPNT -14,0
	RPNT 0,-20
	RPNT 14,-10
	RPNT 14,10
	RPNT 0,20
	RPNT -14,10
;START THIRD RING
	BYTE(8)0,0,200(12)12	;DON'T DRAW IF WE SAW LIGHT PEN.
	0
	RPNT -14,4
	RPNT -10,-10
	RPNT -4,-14
	RPNT 4,-14
	RPNT 10,-10
	RPNT 14,-4
	RPNT 14,4
	RPNT 10,10
	RPNT 4,14
	RPNT -4,14
	RPNT -10,10
	RPNT -14,4
;START FOURTH RING
	RPNT -16,6
	RPNT -12,-6
	RPNT -6,-12
	RPNT -2,-16
	RPNT 2,-16
	RPNT 6,-12
	RPNT 12,-6
	RPNT 16,-2
	RPNT 16,2
	RPNT 12,6
	RPNT 6,12
	RPNT 2,16
	RPNT -2,16
	RPNT -6,12
	RPNT -12,6
	RPNT -16,2
	0
	0
	0
CROSS:	BYTE(11)10,10(3)0,0(2)0,2(4)6
	BYTE(11)<-20>,<-20>(3)0,0(2)0,0(4)6
	BYTE(11)0,<20>(3)0,0(2)0,2(4)6
	BYTE(11)<20>,<-20>(3)0,0(2)0,0(4)6
	0
	0
SAVWRD:	1
	0
	0
	0
FEND__.

BLDPY:	DPYOUT BLINK	;PG # WILL BE FIXED UP
>;NODEC
STORAGE(IMPURE)	;IMPURE, BUT CAN GO IN UPPER
DPYDPY:	DPYOUT HEAD	;	"
HYDDPY:	DPYOUT [DPYBUF
		0	];	"

HEAD:	DPYBUF
	0

NODEC,<
BLINK:
NOITS,<	BLINKB	>
ITS,<	SETZ BLINKB	>	;SIGN BIT ON SAYS BLINK THIS PG
	0		;WORD COUNT

BLINKB:	1		;NO-OP IN CASE IT GETS EXECUTED(WHICH I DON'T THINK IT DOES!)
	XWD BPOS,74	;WHERE WE WERE LAST TIME!
	<BYTE(8)0,0,200>+12
	BYTE(11)400,0(3)0,0(2)0,2(4)6	;20 TO RIGHT OF THERE
	BYTE(11)40,0(3)0,0(2)0,2(4)6	;20 TO RIGHT OF THERE
	<BYTE(8)0,0,40>+12		;EDGE OVERFLOW?
	XWD BLEAV,20			;NO
	BYTE(11)0,0(3)0,0(2)1,2(4)6	;RESET TO CENTER
	<BYTE(8)240,200,0>+12		;CLEAR EO AND SET CONTROL BIT!
BLEAV:	XWD BPOS,64			;SAVE WHERE WE ARE NOW
	<BYTE(8)0,0,200>+12		;CONTROL BIT ON?
	0				;NO, STOP HERE
	XWD DPYBUF+1,20			;TRANSFER TO DPYBUF!
BPOS:	201				;THE 200 WONT HURT US, BUT ITS LIKES IT
BLINKL__.-BLINK
>;NODEC
>;NOCMU
CMU,<	STORAGE(DPY)>

DPYBUF:	BLOCK DPYLEN+200
CMU,<	STORAGE(PURE)>

NOCORE:	0
	OUTSTR[ASCIZ/YOU ARE SUFFERING FROM THE UNFORTUNATE FACT THAT
YOUR OVERBLOATED PROGRAM WILL NO LONGER FIT IN OUR
PUNY CORE!!!!!!!
/]
NODEC,<	HALT @NOCORE	>
DEC,<	PUSHJ	P,TODDT	;GO TRY DDT
	JRST	@NOCORE
>;DEC

;XTEXTF AND YTEXTF TABLES ARE USED TO OFFSET THE CURSOR FOR TEXT SUCH THAT
;A BOX CHGHT BY CWIDTH (IN WHICH THE CHARACTER IS ASSUMED TO BE CENTERED)
;HAS ITS LOWER LEFT CORNER AT THE CURRENT POSITION.

DEC,<
GT,<
XTEXTF:	-4	;1
	-10	;2
	-12	;3
	-22	;4

YTEXTF:	-1	;1
	-4	;2
	-4	;3
	-10	;4
>;GT
NOGT,<
XTEXTF:	-4	;1
	-6	;2
	-12	;3
	-22	;4

YTEXTF:	-1	;1
	-2	;2
	-4	;3
	-10	;4
>;NOGT
>;DEC

NODEC,<
NOITS,<
NOCMU,<
XTEXTF:	-2
	0
	0
	1
	4
	10
	0

YTEXTF:	1
	0
	0
	6
	14
	20
	0
>;NOCMU
CMU,<
XTEXTF:
FOR I IN(10,14,16,20,30,40,60)
<
I*(CWIDTH/2-3)/10
>

YTEXTF:
FOR I IN(10,14,16,20,30,40,60)
<
I*(CHGHT/2-5)/10
>
>;CMU
>;NOITS
ITS,<
XTEXTF:
FOR I IN (10,15,16,20)
<	2
>
FOR I IN(30,40,60)
<	4
>
YTEXTF:
FOR I IN (10,14,16,20)
<	1
>
FOR I IN(30,40,60)
<	14
>
>;ITS
>;NODEC

;MAX LEGAL SOFTWARE CHARACTER SIZE
CSIZES__4

;TABLE OF MULTIPLIERS TO USE ON CHGHT AND CWIDTH TO GET SIZE
;OF SOFTWARE CHARACTER
CMUL:	1
	1
	2
NODEC,<	3	>
DEC,<	4	>
NODEC,<	4	>
DEC,<	10	>

;CONVERT SOFTWARE CHARACTER SIZE TO HARDWARE CHARACTER SIZE
S2H:
NODEC,<	1
	1
	4
	5
	6
>;NODEC
DEC,<	1
	1
	2
	3
	4
>;DEC

	DATPPN_'DATDRW'
CMU,<	DATPPN_<10173,,101310>>		;E210DP00
DEC,<
NOVIROS,<PGP,<	DATPPN__<362,,5010>	;>	DATPPN__0	>
VIROS,<	DATPPN_<4,,253>	>
>;DEC

LIBPPN:	DATPPN
;CONSTANT DATA LOCS FOR LAYOUT
DEFINE CDATA(LABEL,SIZE,SEG)
<
IFIDN<SEG><LOW><STORAGE(LOW);>STORAGE(IMPURE)
LABEL:
IFIDN<SIZE><><0>
IFDIF<SIZE><><BLOCK SIZE>
>

STORAGE(LOW)

LAY,<
RDOFF:	'GODMOD'
	20
OFFSET:	0
REALLN:	0

WRTOFF:	'GODMOD'
	21
NEWOFF:	0
>;LAY


CDATA		PATCH0,40,LOW
NODEC,<
CDATA		SSSNAM
CDATA		SSSEXT
CDATA		SSSDAT
CDATA		SSSPPN
>;NODEC

ZLOWBEGIN:
LAY,<
TPDLLN__40	;TEMP PDL LENGTH

CDATA		TPDL,TPDLLN		;TEMP PDL FOR SAVE/GET ROUTINES
CDATA		IWD
CDATA		LAYPDL
CDATA		LAYBIT
CDATA		LAYM
CDATA		ODISP
TWO,<
CDATA		DNUM
CDATA		PCNUM
>;TWO
CDATA		DPCPNT			;POINT PASS LIST POINTER
CDATA		DOPASS
CDATA		LAYLET
CDATA		LAYNUM
CDATA		SWHICH
CDATA		SWHCHA
CDATA		SWHCHS
LIB,<
BLLEN__=400	;ENOUGH FOR 200 LOCATIONS TO BE PASSED
CDATA		BLDATA,BLLEN		;POINT PASS LIST SPACE (LIB)

;THE FOLLOWING MUST BE IN ORDER
CDATA		DBAND,4
CDATA		D2BAND,4
CDATA		PCBAND,4
CDATA		PC2BAND,4
;INDICIES INTO BAND STUFF
BAND__0
DLOC__1
LENGTH__2
SEC__3
BAND2__4

>;LIB
CDATA		SAVNAM
CDATA		SAVPPN
CDATA		LAYLOC
>;LAY
DEC,<
CDATA		RTIME
CDATA		QTIME
CDATA		DTIME
GT,<
CDATA		NBYTES
>;GT
VIROS,<
CDATA		TYPFLG
CDATA		VSTBUF,10
VSTEND__<POINT 7,VSTBUF+7,27>
DLX,<
CDATA	DLDVDS
CDATA	DLXBUF,8
>;DLX
>;VIROS
GT,<
CDATA	OPTFLG
DLX,<
CDATA	DLXFLG
>;DLX
>;GT
>;DEC
NODEC,<
CDATA		DPCNAM
CDATA		DPCEXT
CDATA		DPCDAT
CDATA		DPCPPN
CDATA		STRTLC
CDATA		SSSP
CDATA		TJOBDA,200		;TEMP JOB DATA AREA
CDATA	AUTOSM
CDATA	AUTOSN
>;NODEC
CDATA	RSAVET,,LOW
NODEC,<
CDATA	NAMBUF,NNWRDS
>;NODEC
DEC,<
CDATA	SPPDL2,SPD2SZ,LOW
CDATA	GOING
VB10,<
CDATA	PGTBL,4
>;VB10
CDATA	NAMBUF,6
>;DEC
CDATA	SPPDL,SPPDSZ,LOW
CMU,<	CDATA PPNBUF,3 >
CDATA	IOHD,3,LOW
CDATA	IOBUF,406,LOW
MPC,<
CDATA	CARDHD,3,LOW
CDATA	CRDBUF,406,LOW
>;MPC
CDATA	TTBUF,2,LOW
CDATA	CINST
CDATA	CHARP
CMU,<	CDATA	CHKSVC
	CDATA	PSVCNT
PSVLEN__100
	CDATA	PDLSAV,PSVLEN
>;CMU
CDATA	BSOR
CDATA	ISDPY
CDATA	DONTDPY
CDATA	POSS1
CDATA	CURCUR
CDATA	PAGACT
CDATA	REALACT
CDATA	SQRFLG
CDATA	FILNAM,,LOW
CDATA	FILEXT,,LOW
CDATA	FILDAT,,LOW
CDATA	FILPPN,,LOW
DEC,<
CDATA	TMPNAM,,LOW
CDATA	TMPEXT,2,LOW
CDATA	TMPPPN,,LOW
>;DEC
CDATA	DSKOPN
CDATA	DSKOHD,3,LOW
CDATA	DSKOBF,210,LOW
CDATA	BRKCHR
CDATA	DSKHD,3,LOW
CDATA	DSKBUF,210,LOW
ZLOWEND__.-1

ORG 40
UUO:	0
IFN 0,<	JSR UUOCON>
	PUSHJ P,.UUOCON
ORG

NODEC,<
STORAGE(IMPURE)
UUOSAV:	0
>;NODEC

ORG 124
REENTER
ORG

NOFST:	0
	JRST .NOFST

LCFLAG:	-1		;ALWAYS START WITH LOWER CASE ENABLED
BOOPCN:	0		;START WITH NO BOOPING
BOOPLR:	0

VIROS,<
NOGT,<
VBCJFN:	-1
>;NOGT
DLX,<
DLXJFN:	-1
>;DLX

STPPN:	3		;FUNCTION CODE FOR PPN TO/FROM DIRECTORY STRING
USRPPN:	0		;PPN RETURNED HERE
STPTR:	0		;POINT TO DIRECTORY STRING
>;VIROS

STORAGE(PURE)
CPOPJ3:	AOS (P)
CPOPJ2:	AOS (P)
CPOPJ1:	AOS (P)
CPOPJ:	POPJ P,
;LAYOUT INITIALIZATION CODE
NODEC,<
CMU,<	.JBSAV_73  .JBS41_122 >
NOCMU,<	EXTERNAL .JBSAV,.JBS41 >
EXTERNAL .JB41,.JBCOR
LAY,<
STORAGE(LOW)
SAVE:
	SETZB 0,M
	JSR LINIT
	MOVE P,[IOWD TPDLLN,TPDL]	;TEMP STACK SETUP
	OUTSTR[ASCIZ/BE CAREFUL, WILL NOT CHECK IF ALREADY EXISTS!
/]
	PUSHJ P,DMPNAM
	JRST [	MOVE T,[%PNAME]
		MOVEM T,FILNAM
		MOVE T,['  1  3']
		MOVEM T,FILPPN
		JRST .+1]
	ENTPPN
	MOVE T,[FILNAM,,DPCNAM]
	BLT T,DPCPPN
	MOVEI T,.STRTN
	MOVEM T,STRTLC
	SKIPE T,.JBSYM
	SUBI T,LAY2S-LAY1S+LAYBEG-LAY1S
	MOVEM T,LAYSYM-LAYBEG+LAY2S
	JSR ISAVE
	JRST [	OUTSTR[ASCIZ/SAVE OF FIRST PART FAILED!
/]
		EXIT]
LIB,<	SKIPN T,.JBSYM
	JRST [	MOVEI T,LAY1E-1
		SETZ TT,
		JRST CORDWN]
	HLRE TT,T
	MOVN TT,TT
	HRLZ T,T
	HRRI T,LAY1E
	BLT T,LAY1E-1(TT)		;MOVE SYMBOLS DOWN
	MOVEI T,LAY1E-1(TT)		;THIS IS TOP+1
	MOVE TT,.JBSYM
	HRRI TT,LAYBEG+LAY1E-LAY1S
	MOVEM TT,.JBSYM
CORDWN:	MOVEM TT,LAYSYM-LAYBEG+LAY1S
	CORE T,
	JFCL
	MOVEI T,-1
	HRLM T,.JBSA			;.JBFF IS ALWAYS WRONG, MAKE IT VERY WRONG
>;LIB
TWO,<	MOVEI T,LAY1E-LAY1S+400000
	CORE2 T,
	JRST [	OUTSTR[ASCIZ/CORE2 FAILED FOR SECOND PART!
/]
		EXIT]
	MOVE T,[LAY1S,,LAYBEG]
	BLT T,LAYBEG+LAY1E-LAY1S-1
	SKIPN T,.JBSYM
	JRST [	MOVEI T,LAY1S
		MOVEM T,.JBFF
		HRLM T,.JBSA
		SOJA T,CORDWN]
	HLRE TT,T
	MOVN TT,TT
	HRLZ T,T
	HRRI T,LAY1S
	BLT T,LAY1S-1(TT)
	MOVEI T,LAY1S(TT)
	MOVEM T,.JBFF
	HRLM T,.JBSA
	MOVEI TT,LAY1S
	HRRM TT,.JBSYM
	SUBI T,1
CORDWN:	CORE T,
	JFCL
>;TWO
	SETZM SWHCHS			;D IS AT END
	JSR SVREST
	OUTSTR[ASCIZ/SAVE OF SECOND PART FAILED!/]
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	OUTSTR[ASCIZ/
/]
	HLLZS .JBSA			;DISABLE RESTART!!!!!!
	EXIT

DOSAVD:	0
	JSR SAVSPC
	JRST @DOSAVD
	JSR SVFRST
	JRST [	JSR SAVSD
		JRST @DOSAVD
		JRST @DOSAVD]
	JSR SAVSD
	JRST @DOSAVD
	SETZM SWHCHS			;PC IS AT END
	JSR SVREST
	JRST @DOSAVD
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	AOS DOSAVD
	JRST @DOSAVD

DOSAVP:	0
	JSR SAVSD
	JRST @DOSAVP
	JSR SVFRST
	JRST [	JSR SAVSPC
		JRST @DOSAVP
		JRST @DOSAVP]
	JSR SAVSPC
	JRST @DOSAVP
	SETOM SWHCHS			;D IS AT END
	JSR SVREST
	JRST @DOSAVP
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	AOS DOSAVP
	JRST @DOSAVP

.STRTN:	JSR UPNAME
	JRST .STRT

CONTLC:	JSR UPNAME
	JSR LINIT
	JRST .CONT			;OTHER HALF WILL COME IN WHEN NEEDED

UPNAME:	0
	MOVEM 0,SSSNAM			;FILENAME HERE FROM RUN COMMAND
	HLLZM 1,SSSEXT
	MOVEM 4,SSSPPN
	MOVEI T,.STRT
	HRRM T,.JBSA			;NOW START HERE
	JRST @UPNAME

LINIT:	0
LIB,<	MOVEI T,LAYBEG
	MOVEM T,DBAND+DLOC
	MOVEM T,PCBAND+DLOC
	ADDI T,=76*2000
	MOVEM T,D2BAND+DLOC
	MOVEM T,PC2BAND+DLOC
	MOVEI T,4
	MOVEI TT,PC2BAND
LIBLOP:	MOVNM T,BAND(TT)
	SUBI TT,BAND2
	SOJG T,LIBLOP
	UFBCLR			;RELEASE ALL BANDS
>;LIB
TWO,<	SETZM DNUM
	SETZM PCNUM
	SETZ T,
	SETUWP T,		;MAKE SURE CURRENT ONE ISN'T WRITE PROTECTED
	JFCL
>;TWO
	JRST @LINIT
;LIBRASCOPE GETD, GETPC
GETD:	JSR SAVSD
	POPJ P,
	JRST DPCRET

GETPC:	JSR SAVSPC
	POPJ P,
DPCRET:	EXCH P,LAYPDL
	EXCH 0,LAYBIT
	EXCH M,LAYM
	JUMPE P,.STRTL
	PUSHJ P,SCRSET
	JRST .BLCHK

SAVSD:	0
	JSR RELPC
	JSR %GETD
	CAIA
	JRST [	AOS SAVSD
		JRST @SAVSD]
	OUTSTR[ASCIZ/CAN'T GET D PART, WILL TRY PC PART!
/]
	JSR %GETPC
	CAIA
	JRST @SAVSD
	OUTSTR[ASCIZ/CAN'T GET EITHER, I DIE NOW
/]
	HALT SAVSD+1

SAVSPC:	0
	JSR RELD
	JSR %GETPC
	CAIA
	JRST [	AOS SAVSPC
		JRST @SAVSPC]
	OUTSTR[ASCIZ/CAN'T GET PC PART, WILL TRY D PART!
/]
	JSR %GETD
	CAIA
	JRST @SAVSPC
	OUTSTR[ASCIZ/CAN'T GET EITHER, I DIE NOW
/]
	HALT SAVSPC+1


RELD:	0
LIB,<	MOVEI TT,DBAND		;START HERE
	JSR %PUTLIB
>;LIB
TWO,<	SETZ T,
	SEGNUM T,
	MOVEM T,DNUM
	DETSEG
>;TWO
	JRST @RELD

RELPC:	0
LIB,<	MOVEI TT,PCBAND
	JSR %PUTLIB
>;LIB
TWO,<	SETZ T,
	SEGNUM T,
	MOVEM T,PCNUM
	DETSEG
>;TWO
	JRST @RELPC

%GETD:	0
LIB,<	MOVEI TT,DBAND
	JSR %GETLIB
	JRST GETD1		;NOT IN YET
	JRST GETDX		;WAS IN, BUT LOST
>;LIB
TWO,<	SKIPN T,DNUM
	JRST GETD1
	ATTSEG T,
	JRST GETDX
>;TWO
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	AOS %GETD
	JRST @%GETD

GETDX:	OUTSTR[ASCIZ/REINITIALIZING "D" PART FROM DMP FILE!
/]
LIB,<	MOVM T,DBAND
	MOVNM T,DBAND
	MOVM T,D2BAND
	MOVNM T,D2BAND
>;LIB
TWO,<	SETZM DNUM
>;TWO
	SETZM LAYPDL
GETD1:	SETZ T,			;TELL HIM WE WANT D PART
	JSR GETDPC
	CAIA
	AOS %GETD
	JRST @%GETD

%GETPC:	0
LIB,<	MOVEI TT,PCBAND
	JSR %GETLIB
	JRST GETPC1
	JRST GETPCX
>;LIB
TWO,<	SKIPN T,PCNUM
	JRST GETPC1
	ATTSEG T,
	JRST GETPCX
>;TWO
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	AOS %GETPC
	JRST @%GETPC

GETPCX:	OUTSTR[ASCIZ/REINITIALIZING "PC" PART FROM DMP FILE!
/]
LIB,<	MOVM T,PCBAND
	MOVNM T,PCBAND
	MOVM T,PC2BAND
	MOVNM T,PC2BAND
>;LIB
TWO,<	SETZM PCNUM
>;TWO
	SETZM LAYPDL
GETPC1:	SETO T,				;TELL HIM WE WANT PC PART
	JSR GETDPC
	CAIA
	AOS %GETPC
	JRST @%GETPC
;SUBRS FOR LIBRASCOPE GETD, GETPC
LIB,<
%PUTLIB:0
	MOVE T,.JBREL
	SUBI T,LAYBEG-1
	CAILE T,=76*2000
	MOVEI T,=76*2000
	JSR ONEBND
	MOVE T,.JBREL
	SUBI T,LAYBEG-1+=76*2000
	JUMPLE T,@%PUTLIB
	ADDI TT,BAND2
	JSR ONEBND
	JRST @%PUTLIB

ONEBND:	0
	MOVEM T,LENGTH(TT)
	SKIPL T,BAND(TT)
	JRST GOTDBN
NODBN:	MOVM T,BAND(TT)
	UFBGIV T,
	MOVM T,BAND(TT)
	UFBGET T,
	JSR NOBAND
	MOVMS T,BAND(TT)
GOTDBN:	FBWRT T,DLOC(TT)
	JRST NODBN
	FBWAIT
	UFBERR
	JRST NODBN
	JRST @ONEBND		;DONE!

NOBAND:	0
	OUTSTR[ASCIZ/NO FAST BANDS, CONTINUE TO TRY AGAIN
/]
	SOS NOBAND
	SOS NOBAND
	HALT @NOBAND

%GETLIB:0
	SKIPGE T,BAND(TT)
	JRST @%GETLIB
	AOS %GETLIB
	JSR GETBND
	JRST @%GETLIB
	SKIPG LENGTH+BAND2(TT)
	JRST GETLDN
	ADDI TT,BAND2
	MOVE T,BAND(TT)
	JSR GETBND
	JRST @%GETLIB
GETLDN:	AOS %GETLIB
	JRST @%GETLIB

GETBND:	0
%GETL1:	MOVE TTT,LENGTH(TT)
	ADD TTT,DLOC(TT)
	SUBI TTT,1
	CORE TTT,
	JRST [	JSR NOCORE
		JRST %GETL1]
	FBREAD T,DLOC(TT)
	JRST [	OUTSTR[ASCIZ/FAST-BAND READ ERROR!
/]
		JRST @GETBND]
	FBWAIT
	UFBERR
	JRST @GETBND
	AOS GETBND
	JRST @GETBND
>;LIB
;GET OTHER PART FROM FILE
GETDPC:	0
	CAME T,SWHICH			;DO WE WANT THE ONE A THE END?
	TDZA T,T			;NO, GET FRONT ONE
	SETO T,				;YES, GET END ONE
	MOVEM T,SWHCHA
	MOVE T,[SSSNAM,,FILNAM]
	BLT T,FILPPN
	INIT IOLAY,17
	'DSK   '
	0
	JRST NOFIL
PGFIL:	OUTSTR[ASCIZ/GETTING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP IOLAY,FILNAM
	JRST [	OUTSTR[ASCIZ/, LOOKUP FAILED, ANOTHER /]
		MOVEM P,TPDL
		MOVE P,[IOWD TPDLLN,TPDL]
		PUSH P,(P)
		PUSHJ P,PUSHIT	;SAVE EVERYONE
		PUSHJ P,DMPNAM
		SETZM FILNAM
		PUSHJ P,POPIT
		POP P,P
		SKIPN FILNAM
		JRST NOFIL
		JRST PGFIL]
DEC,<	JSR IOLAY,LOOKCK	>;DETERMINE REAL PPN
	SKIPE SWHCHA		;WHICH PART DO WE WANT
	JRST ENDP
	MTAPE IOLAY,RDOFF	;GET OFFSET
	MOVE T,OFFSET
	MOVN T,T		;BACKWARD USET
	USETI IOLAY,1(T)
	MOVE T,OFFSET
	LSH T,7
LIB,<	MOVEI TT,LAY1S
	ANDI TT,177
>;LIB
TWO,<	SETZ TT,	>
	JRST FRONTP

ENDP:
LIB,<	MOVEI T,LAY1S-.JBSAV-1+200	>
TWO,<	MOVEI T,LAY1S-.JBSAV-2+400	>
	LSH T,-7		;MAKE RECORD NUMBER
	USETI IOLAY,(T)
	HLRO T,FILPPN
	MOVN T,T		;POS LENGTH OF FILE
LIB,<	MOVEI T,LAY1S-.JBSAV-1+200	>
TWO,<	MOVEI T,LAY1S-.JBSAV-2+400	>
	ANDCMI TT,177		;GET FIRST WORD WE WILL READ
FRONTP:	SUBB T,TT		;NUMBER OF WORDS TO READ!
	ADDI TT,LAYBEG-1		;THIS IS HOW MUCH ROOM WE NEED
LIB,<	CORE TT,	>
TWO,<	CORE2 TT,	>
	JRST NOFIL
	MOVN T,T
	MOVS T,T
	HRRI T,LAYBEG-1
	SETZ TT,
	IN IOLAY,T
	CAIA
	JRST NOFIL
LIB,<	SKIPN SWHCHA
	JRST GOTDPC
	MOVEI T,LAYBEG-74
	ANDI T,177		;HOW MUCH TO BLT DOWN
	JUMPE T,GOTDPC
	MOVE TT,.JBREL
	SUB TT,T
	MOVS T,T
	ADD T,[LAYBEG,,LAYBEG]
	BLT T,(TT)
>;LIB
GOTDPC:	AOS GETDPC
	OUTSTR[ASCIZ/
/]
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	RELEASE IOLAY,
	JRST @GETDPC

NOFIL:	OUTSTR[ASCIZ/COULDN'T GET DISK FILE!
/]
	RELEASE IOLAY,
	JRST @GETDPC
;SUBRS TO SAVE LAYOUT VERSIONS!
ISAVE:	0
	MOVE T,ISAVE
	MOVEM T,SVFRST
LIB,<	MOVEI T,LAY2S-1
	MOVEM T,IWD
	SKIPN T,.JBSYM
	JRST [	MOVNI TT,LAY2E
		JRST NOSYMS]
	HLRE TT,T
	SUBI TT,(T)
NOSYMS:	TRZ TT,177		;ROUND UP TO MULTIPLE OF 200 WORDS SO GET WON'T LOSE
	ADDI TT,LAY2S
	HRLM TT,IWD
>;LIB
TWO,<	MOVE TT,[LAY2S-LAY2E,,LAY2S-1]
	MOVEM TT,IWD
>;TWO
	JRST ISAVE1

SVFRST:	0
	MOVEI T,LAYBEG-1
	MOVEM T,IWD
LIB,<	MOVN T,.JBREL	>
TWO,<	HRRZ T,.JBHRL
	MOVN T,T
>;TWO
	ADDI T,LAYBEG-1
	HRLM T,IWD
ISAVE1:	OUTSTR[ASCIZ/SAVING /]
	MOVEI A,DPCNAM
	JSR FPRINT
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/, CAN'T GET DISK!
/]
		HALT SVFRST+1]
	MOVE T,[DPCNAM,,FILNAM]
	BLT T,FILPPN
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED, YOU LOSE!
/]
		JRST SVQTF]
	MOVE T,IWD
	SETZ TT,
	OUT DAT,T		;POOT OUT FIRST PART
	JRST OUTOK
	OUTSTR[ASCIZ/, OUTPUT ERROR!
/]
SVQTF:	RELEASE DAT,3
	JRST @SVFRST

OUTOK:	UGETF DAT,NEWOFF	;GET EOF+1
	MTAPE DAT,WRTOFF	;SET IT IN FILE
	JRST [	OUTSTR[ASCIZ/, MTAPE TO SET RECORD OFFSET FAILED!
/]
		JRST SVQTF]
	USETO DAT,1		;GET TO NEW END(BEGINNING)
	AOS SVFRST
	JRST @SVFRST		;SO FAR SO GOOD
>;LAY

HINAME__134			;UPPER SEGMENT NAME
HILOC__135			;LOC OF UPPER SEGMENT AFTER INPUT FROM DMP FILE

SVREST:	0
NOLAY,<
	OUTSTR[ASCIZ/SAVING /]
	MOVEI A,DPCNAM
	JSR FPRINT
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		HALT SVREST+1]
	MOVE T,[DPCNAM,,FILNAM]
	BLT T,FILPPN
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED, YOU LOSE!
/]
		JRST SVQUIT]
>;NOLAY
LAY,<	MOVE T,SWHCHS
	EXCH T,SWHICH
	MOVEM T,SWHCHS
>;LAY
	MOVE T,[.JBSAV+1,,TJOBDA]
	BLT T,TJOBDA+177	;SETUP A PSUEDO JOB DATA AREA
	MOVE T,STRTLC
	HRRM T,TJOBDA-.JBSAV-1+.JBSA	;STORE PLACE FOR IT TO START
	MOVE T,.JB41
	MOVEM T,TJOBDA-.JBSAV-1+.JBS41
	SETZM TJOBDA-.JBSAV-1+.JBCOR	;ALWAYS USE SIZE OF FILE
	SETZM TJOBDA-.JBSAV-1+HINAME	;ALWAYS 0 HINAME (EVEN FOR SEGMENTS)
NOTWO,<	SETZM TJOBDA-.JBSAV-1+HILOC
>;NOTWO
TWO,<	MOVE T,.JBREL
	SUBI T,.JBSAV+2
	IORI T,177
	ADDI T,.JBSAV+2		;THIS IS WHAT GET WANTS TO SEE
	MOVEM T,TJOBDA-.JBSAV-1+HILOC	;NO PROT OF ANY KIND
>;TWO
	MOVE T,[IOWD 200,TJOBDA]
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR FOR JOB DATA AREA!
/]
		JRST SVQUIT]
	MOVEI T,.JBSAV+200		;START OUTPUT HERE
	MOVN TT,.JBREL
	ADD TT,T
	HRL T,TT
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR ON LOW CORE WRITE!
/]
		JRST SVQUIT]
TWO,<	HRRZ TT,.JBHRL
	MOVN TT,TT
	MOVEI T,LAYBEG-1
	ADD TT,T
	HRL T,TT
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR ON HIGH CORE WRITE!
/]
		JRST SVQUIT]
>;TWO
	RELEASE DAT,
	AOS SVREST
	JRST @SVREST

SVQUIT:	RELEASE DAT,3			;FLUSH FILE
LAY,<	MOVE T,SWHCHS
	MOVEM T,SWHICH
>;LAY
	JRST @SVREST
;DMP FILENAME SCANNER
LAY,<
DMPNAM:	MOVSI T,'DMP'
	MOVEM T,FILEXT
	SETZB T,FILEXT+1	;CLEAR THIS WORD
	DSKPPN T,		;HIS OWN PPN
	MOVEM T,FILPPN
	OUTSTR [ASCIZ/DMP FILENAME?/]
NOITS,<	PUSHJ P,GETWRD	>	;SCAN FILENAME
ITS,<	PUSHJ P,GETNAM	>	;SCAN FILENAME
	CAIN C,12
	JUMPE T,CPOPJ		;LET HIM OUT IF HE TYPES NOTHING
NOITS,<
	MOVEM T,FILNAM		;SAVE FILENAME
	CAIN C,"["		;ANY EXTENSION?
	JRST NOEXT		;NO
	CAIN C,12
	JRST NOEXT		;NO
	CAIE C,"."
	JRST [	ILLNAM:	OUTSTR[ASCIZ/INPUT ERROR!
/]
			CLRBFI
			JRST DMPNAM]
	PUSHJ P,GETWRD		;SCAN EXTENSION
	HLLZM T,FILEXT		;SAVE IT.
NOEXT:	CAIN C,12		;HERE TO SCAN PPN
	JRST CPOPJ1		;LEAVE NOW
	CAIE C,"["
	JRST ILLNAM		;MUST BE [
	PUSHJ P,GETWRD		;SCAN P.
	JUMPE T,ILLNAM
	PUSHJ P,RJUST
	HRLZM T,FILPPN		;AND SAVE
	CAIE C,","		;BETTER BE COMMA
	JRST NOPRG
	PUSHJ P,GETWRD		;SCAN PN.
	JUMPE T,ILLNAM
	PUSHJ P,RJUST
	HRRM T,FILPPN		;AND SAVE
NOPRG:	SETZ T,
	CAIN C,"]"		;BETTER END WITH THIS
	PUSHJ P,GETWRD		;MAKE SURE HE DIDN'T TYPE TO MUCH
	JUMPN T,ILLNAM		;LOSE IF HE DID
	CAIE C,12
	JRST ILLNAM		;DIDN'T END WITH LF
	JRST CPOPJ1
>;NOITS
ITS,<
	CAIE C,";"
	JRST NOLST1
	MOVEM T,FILPPN
	PUSHJ P,GETNAM
	JUMPE T,CPOPJ	;STILL NOT REASONABLE
NOLST1:	CAIE C,40
	CAIN C,12
	SKIPA
	JRST [	ILLNAM:	OUTSTR[ASCIZ/INPUT ERROR!
/]
			CLRBFI
			JRST NAMCON]
	MOVEM T,FILNAM
	CAIN C,12
	JRST CPOPJ1	;DONE
	PUSHJ P,GETNAM	;GET SECOND FILE NAME
	CAIE C,12
	JRST ILLNAM	;EXTRA GARBAGE AT END
	JUMPE T,ILLNAM
	MOVEM T,FILEXT
	JRST CPOPJ1
>;ITS

RJUST:	TRZ T,-1		;THREE LETTERS ONLY
	CAIA
	LSH T,-6
	TRNN T,77		;RIGHT JUSTIFIED YET?
	JRST .-2		;NO
	POPJ P,
	
NOITS,<
GETWRD:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
CHRGET:	PUSHJ P,TTYIN		;READ A CHAR
ISCHRX:	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST CHRGET
	CAIL C,"0"		;NUMBERS ARE LEGAL
	CAILE C,"9"
	CAIA
	JRST CHROK
	CAILE C,"z"
	POPJ P,			;BREAK CHAR.
	CAIL C,"a"
	SUBI C,40		;CHANGE LOWER CASE TO UPPER
	CAIL C,"A"		;NOW ONLY UPPER CASE LETTERS ARE LEGAL
	CAILE C,"Z"
	POPJ P,			;BREAK
CHROK:	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST CHRGET
>;NOITS

;ITS NAME SCANNER
ITS,<
GETNAM:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
GETNM1:	PUSHJ P,TTYIN		;READ A CHAR
	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST GETNM1
	SKIPA
GETNM2:	PUSHJ P,TTYIN
	CAIN C,15
	JRST GETNM2
	CAIL C,"a"
	CAILE C,"z"
	CAIA
	SUBI C,40		;LOWERCASE
	CAILE C,40		;BREAK ON SPACE
	CAILE C,"_"
	POPJ P,			;NOT SIXBIT CHARACTER
	CAIE C,";"
	CAIN C,":"
	POPJ P,
	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST GETNM2
>;ITS

TTYIN:	INCHWL C
	ANDI C,177
	CAIN C,15
	JRST TTYIN
	POPJ P,
>;LAY
>;NODEC
;PUSHIT, POPIT
STORAGE(IMPURE)
FPRINT:	0
ITS,<	MOVE TTT,3(A)
	JSP T,.SIXP
	OUTCHR[";"]
>;ITS
	MOVE TTT,(A)
	JSP T,.SIXP
NOITS,<	OUTCHR["."]	>
ITS,<	OUTCHR[" "]	>
	HLLZ TTT,1(A)
	JSP T,.SIXP
NOITS,<
DEC,<	SKIPN 3(A)
	JRST @FPRINT
FPPPN:
>;DEC
	OUTCHR["["]
NOCMU,<
	HLLZ TTT,3(A)
	JSP T,.SIXPL
	OUTCHR[","]
	HRLZ TTT,3(A)
	JSP T,.SIXPL
>;NOCMU
CMU,<
	SKIPN TTT,3(A)
	DSKPPN TTT,
	MOVE T,[TTT,,PPNBUF]
	DECCMU T,
	JRST [	JSP T,.SIXPL	;IF DECCMU BLETCHES, SIXPRINT IT
		JRST PPNDON ]
	OUTSTR PPNBUF
PPNDON:
>;CMU
	OUTCHR ["]"]
>;NOITS
	JRST @FPRINT

STORAGE(PURE)
LOOKRR:	RELEASE DAT,
LOOKER:	HRRZ T,1(A)
	OUTSTR[ASCIZ/, /]
	CAIL T,LOKLEN
	MOVEI T,ULSERR
	OUTSTR @LOKETB(T)
	OUTSTR[ASCIZ/.
/]
NOLAY,<	JRST LERRET	>
LAY,<	JRST .LERRET	>

LOKETB:	[ASCIZ/FILE NOT FOUND/]
	[ASCIZ/ILLEGAL PPN/]
	[ASCIZ/PROTECTION FAILURE/]
	[ASCIZ/FILE IN USE/]
ULSERR__.-LOKETB
	[ASCIZ/UNKNOWN LOOKUP STATUS/]
	[ASCIZ/DATA TRANSMISSION ERROR/]
LOKLEN__.-LOKETB

DEC,<
STORAGE(IMPURE)
LOOKCK:	0
	JUMPE T,ANYPPN
	MOVEM T,3(A)		;SAVE AWAY HERE FOR NOW
	MOVE TTT,[3,,T]
	MOVE T,LOOKCK
	LDB T,[POINT 4,-1(T),12]	;GET CHANNEL #
	PATH TTT,
	DSKPPN TTT,		;PATH LOSES, GET USER PPN
	CAMN TTT,3(A)		;IS THIS FILE'S ORIGIN DIFFERENT THAN REQUESTED?
	JRST @LOOKCK		;NO, WIN
	SOS LOOKCK
	SOS LOOKCK
	HLLZS 1(A)		;MAKE IT FILE NOT FOUND
	JRST @LOOKCK		;THIS HAD BETTER RETURN TO LOOKUP ERROR FOR LOOKUP UUO

STORAGE(PURE)
ANYPPN:	MOVE TTT,[3,,T]
	MOVE T,LOOKCK
	LDB T,[POINT 4,-1(T),12]	;GET CHANNEL #
	PATH TTT,
	DSKPPN TTT,		;PATH LOSES, GET USER PPN
	MOVEM TTT,3(A)		;AND STORE
	MOVE T,LOOKCK
	MOVEM T,FPRINT		;TELL HIM WHERE TO GO
	JRST FPPPN		;NOW PRINT PPN AND RETURN
>;DEC

.SIXPL:
NODEC,<
	TLNN TTT,777700
	LSH TTT,14
	TLNN TTT,770000
	LSH TTT,6
>;NODEC
DEC,<
	MOVE	TT,TTT
	JUMPE	TT,(T)
	TRO	TT,400000
	ROT	TT,3
	TRNN	TT,7
	JRST	.-2
.SIXP2:	TRZ	TT,777770
	ADDI	TT,"0"
	OUTCHR TT
	ROT	TT,3
	TLNE	TT,-1
	JRST	.SIXP2
	JRST	(T)
>;DEC

.SIXP:	JUMPE TTT,(T)
	SETZ TT,
	LSHC TT,6
	ADDI TT,40
	OUTCHR TT
	JRST .SIXP

PGP,<
POPALL:	SKIPE	$VAL	;ANY ERROR OCCURED?
	PUSHJ	P,PGPERR;YES, PRINT MESSAGE
	POP	P,0	;GET RETURN ADR
	EXCH	0,-17(P);RESTORE 0, SAVE RETURN ADR
	PUSHJ	P,POPIT	;RESTORE ACS 2-17
	MOVEI	1,INTBLK;ENABLE CTRL C INTERCEPT
	MOVEM	1,.JBINT
	POP	P,1	;RESTORE 1
	POPJ	P,

PUSHAL:	SETZM	.JBINT	;DISABLE CTRL C INTERCEPT DURING PGP CODE
	SETZM	$VAL	;CLEAR ERROR ACCUMULATION
	EXCH	0,(P)	;SAVE 0 AND GET RETURN
	PUSH	P,1	;SAVE 1
	PUSH	P,0	;SAVE RETURN ADR
	MOVE	0,-2(P)	;RESTORE 0
>;PGP
;ONLY SAVE AC'S 2-17
PUSHIT:EXCH 2,(P)	;SAVE 2 AND GET RETURN.
	MOVEM 2,16(P)	;GEE, THIS WAY WE RETURN WITH A POPJ
	MOVEI 2,1(P)
	HRLI 2,3
	BLT 2,15(P)
	MOVE 2,(P)	;RESTORE 2
	ADD P,[XWD 16,16]
	POPJ P,		;RETURN TO SENDER

;ONLY RESTORES AC'S 2-17
POPIT:	MOVSI 17,-15(P)
	HRRI 17,3
	BLT 17,17
	MOVE 2,16(P)
	EXCH 2,(P)
	POPJ P,
STORAGE(IMPURE)
VAR
STORAGE(PURE)
LIT
  