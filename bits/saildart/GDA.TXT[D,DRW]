COMMENT    VALID 00427 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00029 00002	<DRAW>FIRST.FAI113,  7-AUG-75 14:24:58, EDIT BY HELLIWELL
C00035 00003	TITLES
C00036 00004	OPDEFS
C00043 00005	SOME MACROES FOR THE GT-40 VERSION
C00048 00006	AC'S - SPECIAL CHAR DEFS - OTHER DEFS
C00055 00007	PG0 -- INFO LINE, CURSOR
C00062 00008	NODEC,<
C00067 00009	STORAGE(IMPURE)	IMPURE, BUT CAN GO IN UPPER
C00069 00010	STANFO,<
C00072 00011	CONSTANT DATA LOCS FOR LAYOUT
C00077 00012	LAYOUT INITIALIZATION CODE
C00082 00013	LIBRASCOPE OR TWOSEG GETD, GETPC
C00086 00014	SUBRS FOR LIBRASCOPE GETD, GETPC
C00088 00015	GET OTHER PART FROM FILE
C00092 00016	SUBRS TO SAVE LAYOUT VERSIONS!
C00097 00017	DMP FILENAME SCANNER
C00102 00018	PUSHIT, POPIT
C00107 00019	STORAGE(IMPURE)
C00109 00020	<DRAW>LOWCOR.FAI116, 29-JUL-75 17:39:46, EDIT BY HELLIWELL
C00110 00021	VECTOR
C00112 00022	DEFINITIONS OF RANDOM PARAMETERS
C00117 00023	FILE EXTENSIONS
C00121 00024	AC 0 FLAG BITS
C00123 00025	AC M FLAG BITS
C00126 00026	PIN, BODY, LIBRARY, DEF AND NAMED MACRO BITS
C00131 00027	MACROS -- GETFS,FSTRET,SCALE,SCALET,UNSCALE,ADJUST,SWITCH
C00134 00028	MODES:
C00136 00029	DATA IN BOTH
C00142 00030	DATA IN ONE OR OTHER
C00148 00031	DIP BODY DEFS (PC), BOX TABLES (D)
C00153 00032	<DRAW>COM.FAI122, 29-JUL-75 17:37:10, EDIT BY HELLIWELL
C00158 00033	MAIN COMMAND LOOP
C00161 00034	0-9  SPC + - 
C00164 00035	A-D
C00168 00036	E-K
C00172 00037	L-Q
C00176 00038	R-V
C00179 00039	W-Z
C00181 00040	ALT BS . | & # 
C00184 00041	" ?     \ = ^Z ^K
C00187 00042	DTAB:	0
C00192 00043	DOOX:	TLNN M,DSKACT!MACACT
C00195 00044	DEFINE XARGS
C00205 00045	VERSION(EDIT,5)
C00209 00046	ENTER INSERT MODE (BOTH WAYS)
C00212 00047	INSERT MODE, PLUS, MINUS, SPACE, BS
C00215 00048	D, R+, R-
C00217 00049	P, N, EXIT EDIT MODE
C00223 00050	SPREAD PIN #'S OVER SAME PIN ID'S
C00225 00051	PLACE A PIN SUBR, UPDATE LOC OFFSET IN BODIES
C00229 00052	DELETE PIN
C00232 00053	GET -- G, SPACE
C00233 00054	GET -- Y
C00238 00055	CALC PIN LOC'S AND THUS OFFSET #'S
C00243 00056	DELETE TYPE
C00245 00057	DELETE LIBRARY
C00247 00058	RSPINI	RESET PINIDS CANONICALLY FROM DEFAULT PIN NAMES
C00251 00059	COMMENT    VALID 00036 PAGES
C00255 00060	<DRAW>POINT.FAI85, 29-JUL-75 17:40:21, EDIT BY HELLIWELL
C00257 00061	PUTPNT, ONSCR
C00259 00062	ALTMODE, SPACE, PNTPUT
C00260 00063	NOT (D)
C00262 00064	MINUS, PLUS (D)
C00265 00065	MINUS, PLUS SUBRS (D)
C00268 00066	MAKE FEEDTHROUGH(|), PLUS (PC)
C00271 00067	MINUS, FNDLNK, FRELNK (PC)
C00273 00068	PNTPLC, PN2DEL
C00276 00069	DELPNT
C00279 00070	DELPNT SUBRS
C00282 00071	DELNUL
C00287 00072	CHANGE PAD TYPES
C00290 00073	MAKE AND BREAK INNER PLANE CONNEX (PC)
C00292 00074	SET PAD TYPE, MAKE AND BREAK FEEDTHROUGHS (PC)
C00294 00075	PIN #'S, CONNECTOR AND BODY (D)
C00299 00076	SET BODY PIN #
C00302 00077	MUNGING SUBROUTINES (PC)
C00305 00078	LINE EDIT TEXT, CLRTHK, SETTHK, PNTZ
C00308 00079	POINT TEXT, POINT TEXT TO MACRO, TEXT AND CONNECTOR OFFSETS (D)
C00315 00080	OFFALL, OFFTXT, OFFCON (D)
C00324 00081	CALC HEIGHT AND LENGTH OF TEXT IN OFFSET UNITS (D)
C00327 00082	KILL TEXT (D,PC)
C00328 00083	DELETE LINE (D)
C00330 00084	LINES, SET MIDPOINT, MAKE JOG, ATTACH POINT (D)
C00332 00085	ATTACH POINT TO LINE (D)
C00335 00086	ATTACH POINT TO POINT (D)
C00340 00087	BREAK JUNCTION OF 3 OR 4 LINES (D)
C00344 00088	JUMP LINE TO OTHER SIDE OF CARD (PC)
C00347 00089	LJUMP SUBRS (PC)
C00350 00090	DELETE LINE, DELETE WIRE
C00353 00091	PUT MIDPOINT IN LINE (PC)
C00355 00092	ATTACH POINT TO POINT (PC)
C00359 00093	ATTACH POINT TO LINE (PC)
C00361 00094	COMMENT    VALID 00011 PAGES
C00363 00095	VERSION(BODY,5)
C00369 00096	PLACE A BODY
C00373 00097	BODY AND DIP NAME STUFF SUBRS
C00375 00098	COPY PINIDS TO PIN #'S -- TRANSPOSE -- BROT -- BODFIX
C00380 00099	GET PIN #'S FROM DIP DEF FILE
C00388 00100	SET BODY LOCATION
C00396 00101	DELETE BODY
C00399 00102	BODREN
C00401 00103	GET BODY
C00406 00104	ASSOCIATIVE BODY SET
C00410 00105	VERSION(BTEXT,2)
C00415 00106	EDIT MODE TEXT AND PROPERTY PLACEMENT
C00422 00107	PRINT ALL PROPERTIES FOR THIS BODY OR BODY DEF
C00425 00108	LINE EDIT TEXT
C00427 00109	TEXT, KILL
C00432 00110	ALL NEW BODY/BODY DEF PROPERTY/TEXT ROUTINES.
C00444 00111	VERSION(SET,2)
C00446 00112	SROT, STTFND, STBFND
C00449 00113	STMNS:	TRZN STBOX		DRAWING A BOX?
C00451 00114	END NEW SET
C00453 00115	KILL ALL SETS -- CALLED FROM CLEAR
C00455 00116	DELETE CONTENTS OF CLOSEST SET
C00459 00117	APPEND STUFF TO "CURRENT" SET
C00463 00118	REMOVE POINT FROM CURRENT SET
C00466 00119	WRITE CLOSEST SET INTO FILE
C00467 00120	ASSOCIATIVE SET
C00471 00121	REMPNT, REMBOD, INBOX
C00476 00122	MD,<
C00480 00123	NOW COPY STUFF ONTO NEW POINTS AND BODIES
C00484 00124	DEFINE MAKSEG $ (LOSE,INDEX,GET,PUT)
C00485 00125	MPC,<
C00488 00126		MOVE H,NEWSET		NEW SET IN H
C00490 00127	COPPNT:	MOVEM C,NEWPNT		STORE NEW POINT POINTER HERE
C00494 00128	COPSDN:	GETFS(A)		POINTER BLOCK FOR SET
C00495 00129	STRCOP:	GETFS (B)		RETURN POINTER IN B
C00498 00130	VERSION(ALT,3)
C00501 00131	LEAVE ALTER MODE
C00506 00132	GETONE, FORWRD, BAKWRD, SEARCH
C00510 00133	END OF LINE SEARCHES
C00512 00134	DELETE:	TRZN TYPNEG
C00516 00135	ALTN:	PUSHJ P,ALTNS
C00520 00136	REPLAC:	PUSHJ P,DELETE		<->nD, THEN INSERT
C00522 00137	HERE WE SEARCH FOR A SUBSTRING OF THE CURRENT STRING
C00526 00138	VERSION(FIND,1)
C00530 00139	ADDLST SUBR
C00536 00140	HERE WE FIND THE NEXT INSTANCE OF WHATEVER
C00541 00141	CLEAR BITS
C00543 00142	FIND TABLES
C00545 00143	MATCH
C00554 00144	VERSION(REP,1)
C00560 00145	SAMEDN:	MOVE G,NEWTYP
C00562 00146	REPLACE BY GEOMETRIC OVERLAY
C00564 00147	GEOMETIC OVERLAY FOR DIFF NUMBER OF PINS
C00567 00148	MAP BY DEFAULT PIN NAMES
C00572 00149	REPONE:	PUSHJ P,GETCLS
C00575 00150	REPIT:	PUSH P,G
C00582 00151	VERSION(CLOSE,1)
C00586 00152	FNDLIN:	SETZM CLOSES	CLEAR CLOSEST POINTER
C00590 00153	LRSLAN:	HLRE T,CURSE
C00592 00154	SQRT:	FINDS THE SQUARE ROOT OF THE INTEGER IN T.  USES TT AND TTT
C00594 00155	FNDSET, FNDBOD, FNDPNT, EDTFND, EDPFND, EDIFND
C00596 00156	CLFNDA:	HRRZ B,(F)
C00600 00157	UPCLOS
C00603 00158	.UPPNT
C00605 00159	.UPSET
C00607 00160	.UPLIN
C00608 00161	LINES, BOXES, BODY
C00609 00162	UPREP
C00610 00163	ANGLE (LINE OR SETBOX)
C00612 00164	SETBOX
C00613 00165	ARROW
C00617 00166	VERSION(MOVE,1)
C00619 00167	MOVE POINT
C00627 00168	MOVE TEXT OFFSET, CPIN OFFSET
C00630 00169	MOVE BODY AND BODY LOC
C00632 00170	EDIT MOVES
C00636 00171	MOVE SET
C00639 00172	MICRO MOVEMENT COMMANDS
C00643 00173	MOVE ALONG LINES
C00647 00174	COMMENT    VALID 00015 PAGES
C00649 00175	<DRAW>DRAW.FAI73, 29-JUL-75 17:39:04, EDIT BY HELLIWELL
C00650 00176	MAIN DISPLAY, CARD STUFF
C00653 00177	MAIN DISPLAY, BODIES AND POINTS
C00654 00178	BODIES
C00657 00179	POINTS
C00658 00180	MORE POINTS, SHOW PAD, DRILL HOLE, PLANE CONNECTIONS (PC)
C00661 00181	MORE POINTS, PIN NUMBERS, TEXT.
C00664 00182	POINT SUBR, DRAW LINES
C00666 00183	EDIT DISPLAY (D)
C00669 00184	OUTBOD:(PC)
C00672 00185	OUTBOD:(D)
C00676 00186	ALTER MODE DISPLAY
C00678 00187	ORIENTATION TABLES AND ROUTINES
C00680 00188	CARD SUBRS
C00687 00189	<DRAW>GDP2.FAI.5, 12-NOV-75 14:57:24, EDIT BY HELLIWELL
C00691 00190	IMPURE STORAGE FOR GDP2 STUFF
C00695 00191	FILES TO BE COPIED TO THE GDP ON INITILAIZATION
C00696 00192	IFN 0,<
C00697 00193	INITIALIZE COMMUNICATIONS WITH THE GDP2 VIA THE ATY LINE
C00701 00194	OPATYO:	INIT ATYO,4		CMU IMAGE MODE
C00702 00195	OPATYI:	INIT ATYI,4		CMU IMAGE MODE
C00703 00196	INITIALIZE A BUFFER TO HOLD A MESSAGE FOR THE DP2
C00705 00197	ROUTINES TO READ A BYTE FROM THE GDP2
C00706 00198	ROUTINES TO WRITE A BYTE OR WORD TO THE GDP2
C00707 00199	ATYONX:
C00708 00200	OUTPUT A BUFFER TO THE GDP2
C00710 00201	ROUTINES TO OUTPUT A PIECE OF GLASS TO THE GDP2
C00714 00202	IIILV:	TRNE A,77B27		BRIGHTNESS OR SIZE?
C00717 00203	LNGVEC:	SKIPG GDPMOD		ARE WE ALREADY IN LONG VECTOR MODE?
C00718 00204	IIISV:	SKIPE GDPMOD		MAKE SURE WE ARE IN MEDIUM VECTOR MODE
C00719 00205	LIOFF1:	SKIPA T,[6]		LONG NEEDS 6
C00720 00206	IIICH:	CAIN A,1		IS IT REALLY NULL STRING?
C00723 00207	MACROS TO SIMULATE III DPYCLR, DPYPOS, DPYSIZ
C00724 00208	NOLAST:	TLNN DSPACT
C00725 00209	PMODE:	TLNN DSPACT
C00726 00210	UPLVL:	TLNN DSPACT
C00727 00211	UPSCAL:	TLNN DSPACT
C00728 00212	READY:	PUSH P,T
C00729 00213	CURBRT:	TLNN DSPACT
C00730 00214	CLRCLC:	SKIPA TT,[TRZN T,BIGFLG]
C00731 00215	VHLINE:	TLNN DSPACT
C00732 00216	FOLOW1:	PUSHJ P,VECT
C00734 00217	>GDP
C00736 00218	VERSION(LAY,2)
C00743 00219	DISPLAY BLINKING STUFF
C00747 00220	LCENTER
C00750 00221	BLINE
C00753 00222	TRACE A WIRE
C00758 00223	PASS INFO TO OTHER PROG
C00761 00224	LOOK
C00765 00225	CALL ROUTING SUBRS FOR BLINKING PINS!
C00768 00226	PJUMP
C00773 00227	HERE RESIDES THE MAGICAL MYSTERY SHORT FINDER
C00776 00228	MAIN LOOP
C00781 00229	POINT TO POINT CHECK
C00783 00230	PUT ERRORS IN ERROR LIST
C00788 00231	POINT TO LINE CHECK, USES SAME ROUTINE AS CURSOR
C00792 00232	CHECK IF 2 LINES CROSS
C00796 00233	SORT SUBR
C00802 00234	SHOW AN ERROR
C00808 00235	bit array initializer - - clobbers T, TT, TTT, A, B, C, D, E, F, G.
C00813 00236	initialization routine - - mark all lines to this point
C00815 00237	MARK A LINE IN THE BIT ARRAY (UGH,BLETCH)!
C00817 00238	CASE1:	IMUL T,DX
C00819 00239	CASE2:	IMUL T,DY
C00821 00240	HERE WE TRY TO ACTUALLY ROUTE A WIRE
C00824 00241	RWIN:	MOVEM SID,SIDSAV		GET REAL SID FROM STORAGE
C00826 00242	MAKFED:	PUSH P,B
C00827 00243	STKN__6			NUMBER OF THINGS PUSHED ON STACK IN RECURSIVE ROUTINES
C00829 00244	NVB:	XCT VTAB(F)
C00830 00245	PHB:	XCT HTAB(F)
C00831 00246	NHB:	XCT HTAB(F)
C00832 00247	PNF:	XCT FTAB(F)
C00834 00248	LOSE:	MOVEI T,0
C00836 00249	SDIF__ARRAYB-ARRAYA
C00838 00250	%__0		SO BLANK CONCATINATED WITH % IS 0.
C00841 00251	XNV:	XD	PH1,NVA,NHA1,PNF,NVB,NHB1
C00844 00252	PWIN:	JUMPG G,SKIP2A		COUNT MUST BE EXACT!
C00845 00253	ROUTER DISPLAY
C00847 00254	BITBYA, BITBYT
C00851 00255	VERSION(MAC,4)
C00857 00256	GETCAN:	SKIPE LCFLAG		CONVERT LC TO UC?
C00862 00257	"D"
C00864 00258	"F"
C00867 00259	SEMI COLON DISPATCH	RENMAC	DELMAC	PMACRO
C00874 00260	"P" "V"
C00879 00261	":" "R" "S"
C00884 00262	"M" "C" , STUFF SUBRS
C00892 00263	"U" "T" "L" "^" "A" "N" "#" "="
C00898 00264	"E" "X" "O" "I"
C00903 00265	MACRO MAKERS
C00905 00266	READ/WRITE MACRO FILES
C00912 00267	HERE TO DEFINE A NEW (OR REDEFINE AN OLD) VARIABLE
C00915 00268	VARFND:	MOVEI	E,VARPNT	SEARCH VARIABLE LIST FOR A NAME
C00918 00269	VARNM:	GETFS	(B)		READ ONE VARIABLE NAME
C00920 00270	HERE TO TYPE THE VALUES OF ALL VARIABLES
C00923 00271	VARNX8:	SKIPL	(C)		ALPHABETIC VARIABLE?
C00925 00272	VARN17:	JUMPGE	T,VARN19	NEGATIVE?
C00927 00273	VARNX2:	PUSHJ	P,VARNUM	GET INCREMENT
C00930 00274	VARN14:	JUMPL	G,[CAMG T,TTT	ARGS IN RIGHT ORDER FOR NEG INCREMENT?
C00932 00275	VARN30:	AOS	D		STEP TO NEXT CHR
C00935 00276	COMMENT    VALID 00012 PAGES
C00937 00277	VERSION(PLT,5)
C00940 00278	PUT OUT BODYS
C00943 00279	CALL POINT SUBRS, DO END STUFF
C00947 00280	POINTS (D)
C00953 00281	LINE SUBR (D)
C00956 00282	DIAMONDS, RANDOM NUMBERS (D)
C00958 00283	LINE TABLES (D)
C00960 00284	POINTS (PC)
C00963 00285	OFFSET TEXT ROUTINE
C00967 00286	OUTPUT ROUTINES
C00970 00287	COMMENT    VALID 00033 PAGES
C00973 00288	<DRAW>SUB.FAI192, 30-JUL-75 14:42:03, EDIT BY HELLIWELL
C00977 00289	ESAVE, EWRITE, SETSM, SETWM, MAKEWD
C00980 00290	REENTER CODE
C00983 00291	NOFST, UNSCALE, PERRET
C00986 00292	NODEC,<
C00987 00293	TXTMAT, SIGMAT, SIGMAA
C00990 00294	CHANGE ONE SIGNAL NAME TO ANOTHER PERVASIVELY
C00994 00295	PUTFS, READN, TXREAD, READSZ, TREAD, SCARF, INNERR
C01000 00296	LOOKUP A SIGNAL IN WIRLST, AND FLASH IT!
C01004 00297	CURSOR MOVING
C01005 00298	SET AND CLEAR FLAGS
C01017 00299	TITLES, MUNGER, INNER, DIAMONDS
C01028 00300	MORE SET AND CLEAR STUFF
C01033 00301	ROUTING PARAMETERS
C01035 00302	SET CARD LOC(D,PC)
C01038 00303	UML STUFF
C01040 00304	MORE UML
C01043 00305	STILL MORE UML
C01045 00306	COUNT THINGS
C01049 00307	BRIGHTNESS, SCALE
C01052 00308	SIZE STUFF - ITSET, PICCEN
C01059 00309	MORE SIZE STUFF
C01062 00310	SHOWBOX
C01065 00311	PBOX
C01067 00312	SLICE
C01070 00313	MORE SLICE STUFF - EXPRESSION SUBRS
C01074 00314	CLEAR
C01078 00315	**C, OFFSET, MOVE, POSIT
C01082 00316	BIG, SMALL, SHIFT SCREEN
C01086 00317	MODE SWITCHING
C01088 00318	SIXBIT, FILEUP
C01090 00319	COMMENT    VALID 00013 PAGES
C01092 00320	VERSION(OUT,7)
C01098 00321	TYPES
C01101 00322			BODIES, CALL POINT SUBR (D,PC)
C01104 00323			POINT SUBR (D,PC)
C01109 00324			SETS, END STUFF (D,PC)
C01116 00325	'WD'	'WPC'	BODIES, CALL WIRE SUBRS
C01123 00326			WIRES, WRITE SIGNAL NAME AND PIN INFO
C01129 00327			WIRES, RECUR
C01133 00328	'DAT'		WRITE FILE FOR INPUT TO WAGNER'S ROUTER SYSTEM
C01139 00329			ROUTER OUTPUT SUBRS
C01146 00330			TABLES FOR ROUTER OUTPUT
C01148 00331	COMMENT    VALID 00031 PAGES
C01152 00332	<DRAW>IN.FAI112, 29-JUL-75 11:19:42, EDIT BY HELLIWELL
C01157 00333	READ CARD, FIX SET, FIX ID'S, FINISH UP
C01163 00334	READ VERSION NUMBER, LIBRARY SUBRS
C01172 00335	LIBRARY SUBRS
C01176 00336	HERE IS WHERE WE READ A NEW LIBRARY IN!
C01184 00337	READ TYPES
C01195 00338	CHECK IF TYPE EXISTS, REPLACE MAYBE
C01199 00339	CALL TYPE READING SUBR, READ INSTANCES OF TYPES
C01204 00340	PLACE INSTANCES OF TYPES
C01209 00341	READ POINT, FIND POINT, D PROG
C01212 00342	MORE READ POINT, LINES, D PROG
C01215 00343	READ POINT, FIND, MAKE LINES, PC PROG
C01219 00344	READ REST OF POINT INFO
C01223 00345	READ SETS
C01225 00346	SET IN, PUT IN STRUCTURE, OR FLUSH -- READ SPECIAL STRINGS -- CARD SUBR
C01232 00347	'DAT'		READ WAGNER'S ROUTER FILES
C01239 00348	'WDR'	'LES'	READ LOGIC WIRE LIST AND MAKE INTERNAL POINTERS
C01246 00349	'DAT'		PARTITION FILE
C01256 00350	WORDIN, CHKLOC
C01258 00351	GSTR, RSTR, FIND.P
C01260 00352	'UML'		READ REDAC PIN ASSIGMENTS
C01263 00353			FIND PIN OR BODY AND SET NEW LOC
C01265 00354			SUBRS FOR READING UML FILE
C01268 00355			READ LOCATION FROM STRING
C01269 00356	INPUT SIGNAL NAME CHANGE FILE
C01272 00357	CHANGE FILE INPUT SUBRS
C01274 00358	INPUT SIGNAL NAME CHANGE FILE
C01277 00359	IMPLEMENT ONE CHANGE LINE
C01279 00360	RDVER TABLES!
C01287 00361	COMMENT    VALID 00013 PAGES
C01289 00362	VERSION(IOSUB,4)
C01298 00363	VIROR DIRECTORY STRING TO PPN CONVERTER
C01301 00364	DSKIN
C01305 00365	DKSOUT
C01308 00366	PC CARD
C01312 00367	MORE PC CARD
C01316 00368	THERE EXISTS CHECK
C01318 00369	FIND THIS, THAT, AND THE OTHER THING
C01322 00370	SOME OUTPUT PRINTERS
C01328 00371	MORE OUTPUT ROUTINES
C01331 00372	DECOUT:	SKIPL T
C01332 00373	COMMENT    VALID 00011 PAGES
C01334 00374	<WIRELIST>SIGSUB.FAI112, 29-JUL-75 12:11:35, EDIT BY HELLIWELL
C01336 00375	DATA AREA
C01337 00376	TOP LEVEL CONTROL OF EXPRESSION EVALUATION
C01339 00377	BRACKET AND CONDITIONAL INTERPRETER
C01343 00378	EXPRESSION SUBRS
C01349 00379	SUBTTL	PERMUT STORAGE
C01352 00380	SUBTTL	PERMUT
C01368 00381	HANDLE QUALIFIER LETTERS AND WIRE RULE NUMBERS
C01373 00382	SIGONE, PUTIT, EPUTIT, AND SPTAB
C01375 00383	SUBTTL	ALPHA
C01383 00384	SUBTTL	LOCS.FAI: ROUTINES WITH KNOWLEDGE OF BOARD LOCATIONS
C01392 00385	SUBTTL	DISPATCH TABLE DEFINITIONS
C01394 00386	THIS IS THE TRANSFER VECTOR WHICH IS SETUP BY THE BOARD TYPE SETTING COMAND
C01396 00387	SUBTTL	L2N,N2L -- LETTER/NUMBER CONVERSION TABLES
C01397 00388	STORAGE(PURE)
C01398 00389	THESE ROUTINES SET UP THE BOARD TYPE
C01402 00390	PUT PIN ON END OF BODY LOCATION
C01403 00391	SUBTTL	LOCPIN -- PRINTS LOCATION AND PIN #
C01405 00392	SUBTTL	TP8LOC,NETPIN
C01407 00393	MORE WL ROUTINES
C01411 00394	SUBTTL	CSLTLT,LOCPNC,LOCPNW,PRCNPN -- CONNECTOR PIN PRINTING STUFF
C01412 00395	SUBTTL	DETECT IF THIS PIN NAME IS "WILD"
C01416 00396	SUBTTL	SLTOUT -- PRINTS DIP BAY/RACK/SLOT #
C01418 00397	SUBTTL	CSLTOUT -- PRINTS CONNECTOR PIN BAY/RACK/SLOT #
C01421 00398	CHKLET TWOLET TWOTAB SLTLN
C01427 00399	GETSLT -- READS A BAY/RACK/SLOT #
C01430 00400	SUBTTL	PUTDEC,NPUTDEC -- DECIMAL OUTPUT ROUTINES
C01431 00401	
C01435 00402	DISTANCE CALCULATOR FOR ROUTER STUFF
C01440 00403	NOW INSERT ALL OF THE APPROPRIATE BOARD FILES
C01443 00404	<DRAW>DECSUB.FAI145, 30-JUL-75 15:25:07, EDIT BY HELLIWELL
C01444 00405	SETPOL - INSERT DEFAULT POLARITY INTO BODY DEFINITION
C01446 00406	CHECK POLARITY OF ALL PINS AND SIGNALS ON A WIRE
C01453 00407	SIGMAT - SIGNAL NAME MATCHING WITH DEC-STYLE H & L, (1) & (0)
C01456 00408	DTRAIL:	PUSHJ	P,GETITA
C01459 00409	SIGMA7:	SKIPE	TTT,SPCNT	H OR L PRECEEDED BY SPACE?
C01461 00410	SIGM13:	MOVE	A,B		WHERE TO GO IF NO (0) FOUND
C01463 00411	UUO ROUTINES
C01465 00412	UUO DISPATCH TABLE
C01467 00413	DECGO, DCLAIM
C01481 00414	HERE IS THE DISPLAY START/STOP CODE
C01488 00415	MAKBRI:	MUL	T,NILEV			SCALE BY PGP CAPABILITY
C01489 00416	APR AND CTRL C TRAPS
C01492 00417	INTIALIZE LOG FILE
C01495 00418	TODDT:	RELEAS	ODSK,0
C01496 00419	VB10C INSTRUCTION COMPILER
C01497 00420	COMPAR:	PUSHJ	P,STASH
C01498 00421	CHKPR3:	PUSH	P,B
C01515 00422	CHRTBL:
C01517 00423	DISPNT:	TRNE	A,34000			
C01523 00424	GT,<					JB IF GT40, ASSEMBLE IN THE FOLLOWING.
C01524 00425	PGP,<				PGP CODE
C01532 00426	COME HERE TO PUT DEFAULT PPN IN AC OF THE UUO
C01534 00427	VERSION(LAST,2)
C01536 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;<DRAW>FIRST.FAI;113,  7-AUG-75 14:24:58, EDIT BY HELLIWELL
;DEFINE ALL CONDITIONAL ASSEMBLY - SET TITLE

XALL  NOLIT

DEFINE MWL,<IFN 0>	;WE AREN'T THE WIRELISTER
DEFINE NOWL,<IFE 0>
DEFINE MDPC,<IFE 0>	;WE ARE THE DRAWING PROG

DEFINE SETSW $ (NAME,DEFVAL)
<	IFNDEF NAME$SW,<NAME$SW__IFIDN <DEFVAL> <> <0;> DEFVAL
>
	NAME$SW__NAME$SW
>

DEFINE ONOFSW $ (NAME,DEFVAL)
<	SETSW(NAME,DEFVAL)
	IFN NAME$SW,<NAME$SW__-1>	;MAKE IT NICE FOR  AND 
>
DEFINE DEFSW $ (NAME)
<	DEFINE NAME,<IFN NAME$SW>
	DEFINE NO$NAME,<IFE NAME$SW>
>
DEFINE MAKESW(NAME,VAL)
<	ONOFSW(NAME,VAL)
	DEFSW(NAME)
>

MAKESW(STAN)
MAKESW(DEC)
MAKESW(CMU)
MAKESW(ITS)

DEFINE STANFO,<STAN>		;LONG FORM FOR HYSTERICAL RAISINS

DEFINE CHECK $ (SITE,VAR) <IFDEF VAR,<SITE$SW__-1;>>
IFE STANSW!DECSW!CMUSW!ITSSW,<
;IF NO SITE SET MANUALLY ABOVE, WE MUST DECIDE FOR OURSELVES WHERE WE ARE
CHECK(ITS,.IOT) CHECK(CMU,CMUDEC) CHECK(STAN,SPWBUT) DECSW__-1
>

DEFINE MOR (A)
<TMPSW__0
FOR B IN (A)
<	B,<TMPSW__-1>
>
IFN TMPSW>

NOITS,<

DEFINE PC<PCSW__-1
PRINTS /PC VERSION SELECTED
/>
DEFINE GT<GT40SW__-1

DEFINE GTBIG<GTSMAL__0
PRINTS /LARGE SCREEN SELECTED
/>
PRINTS /GT40 SELECTED
	TYPE	TO GET
	GTBIG	LARGE SCREEN GT40 (SQUARE)
/>
DEFINE NOVIROS<VIROSSW__0
PRINTS /NON-VIROS VERSION SELECTED
/>
DEFINE ROUTE<ROUTES__-1
PRINTS /RPH ROUTING VERSION SELECTED
/>
DEFINE NODLX<DLXSW__0
PRINTS /DL10 DESELECTED
/>
DEFINE PGP<PGPSW__-1
PRINTS /PGP SELECTED
/>
DEFINE LIB<LIBSW__-1
PRINTS /LIBRASCOPE LAYOUT VERSION SELECTED
/>
DEFINE TWO<TWOSW__-1
PRINTS /TWO SEGMENT LAYOUT VERSION SELECTED
/>
STANFO,<
DEFINE PUR2<PUR2SW__-1
PRINTS /TWO SEGMENT PURE UPPER VERSION SELECTED
/>
DEFINE GDP<S1GSW__-1
PRINTS /S1 GDP VERSION SELECTED
/>
>;STANFO
PRINTS /	TYPE	TO GET
	PC	PC PROGRAM
	GT	GT40 VERSION
	ROUTE	RPH ROUTER
/
DEC,<	PRINTS /	NOVIROS	NOT VIROS
	NODLX	NON-DL10 VERSION
	PGP	PGP VERSION
/>
STANFO,<	PRINTS /	LIB	LIBRASCOPE LAYOUT VERSION
	TWO	TWO SEGMENT LAYOUT VERSION
	PUR2	PURE UPPER VERSION OF D OR PC
	GDP	S1 WITH TEN SIMUATOR AND GDP VERSION
	END WITH CONTROL-META-LF
/>
NOSTAN,<
PRINTS /	END WITH ;^Z
/
>;NOSTAN

.INSERT TTY:

>;NOITS

DEFINE VERSION ' (PROG,VN)
<SUBTTL PROG V'VN
^^VERSUM__VERSUM+VN
>
VERSUM__0
VMAJOR__10	;MAJOR VERSION #
VMINOR__0	;MINOR VERSION LETTER
VGROUP__1	;MODIFYING GROUP

VERSION(FIRST,11)

MAKESW(DECOS,DECSW!CMUSW)

MAKESW(TWO)

TWO,<LIBSW__0>
MAKESW(LIB)

MAKESW(LAY,LIBSW!TWOSW)

MAKESW(PUR2)

MAKESW(S1G)

ONOFSW(PC,0)
DEFINE MD,<IFE PCSW>
DEFINE MPC,<IFN PCSW>

MAKESW(BACK)		;BACKPANEL VERSION

MAKESW(GT40)
DEFINE GT<GT40>
DEFINE NOGT<NOGT40>

MAKESW(PGP)

MAKESW(VB10,<DECSW&<GT40SW>&<PGPSW>>)

DEC,<
ENTRY TODDT
IFNDEF GTSMAL,<GTSMAL__-1>		;FOR SMALL SCREEN GT40
GTSMAL__GTSMAL

MAKESW(VIROS,-1)	;ASSUME VIROS FOR NOW (WILL ALWAYS BE INSIDE DEC)

MAKESW(DLX,GT40SW)	;ASSUME DL10 FOR NOW IF GT40

>;DEC

MAKESW(VIROS)	;0 IF NOT DEFINED
MAKESW(DLX)	;0 IF NOT DEFINED

MAKESW(WAG,-1)	;WAGNERS PC ROUTER STUFF

MAKESW(UML,-1)	;ENABLE USE OF WDR FILES FOR FLASHING, ETC.

MAKESW(PART,-1)	;WAGNER PARTITIONER

MAKESW(SHORT,-1)	;FIND SHORTS

MAKESW(ROUTE)		;RPH ROUTING STUFF

SETSW(WW)		;ENABLES WIRE WRAP BOARD KNOWLEDGE
DEFSW(WW)

MAKESW(RHG,0)		;SPECIAL HACKS FOR RHG (RICHARD H. GUMPERTZ AT CMU)

MAKESW(CMUF,CMUSW!RHGSW)	;CMU FORMAT -- INDEPENDENT OF WHERE THE PROGRAM IS RUN
			;I.E. JUST THE STUFF CMU LIKES, NOT THAT IT NEEDS.

MAKESW(GDP,CMUSW!S1GSW)	;WANT GDP CODE

LAY,<
PASSNM__-1			;INITIALIZE TO PASS1
DEFINE PASS1<IFN PASSNM>
DEFINE PASS2<IFE PASSNM>
>;LAY
                                                                                                                                                                         ;TITLES
LAY,<
	ROUTE,<
		LIB,<TITLE LR
			DEFINE %PNAME<SIXBIT/LR/>>
		TWO,<TITLE TR
			DEFINE %PNAME<SIXBIT/TR/>>
	>;ROUTE
	NOROUTE,<
		LIB,<TITLE L
			DEFINE %PNAME<SIXBIT/L/>>
		TWO,<TITLE T
			DEFINE %PNAME<SIXBIT/T/>>
	>;NOROUTE
>;LAY
NOLAY,<
	MD,<
		NODEC,<TITLE D>
		DEC,<VB10,<TITLE D VB10 VERSION>
		       GT,<TITLE D GT40 VERSION>
		      PGP,<TITLE D PGP VERSION>
			>;DEC
			DEFINE %PNAME<SIXBIT/D/>
	>;MD
	MPC,<
		ROUTE,<TITLE RPC
			DEFINE %PNAME<SIXBIT/RPC/>>
		NOROUTE,<TITLE PC
			DEFINE %PNAME<SIXBIT/PC/>>
	>;MPC
>;NOLAY
                                                                   ;OPDEFS

ITS,<
OPDEF CALL	[ 40B8]
OPDEF INIT	[ 41B8]
OPDEF CALLI	[ 47B8]
OPDEF OPEN	[ 50B8]
OPDEF TTYUUO	[ 51B8]
OPDEF RENAME	[ 55B8]
OPDEF IN	[ 56B8]
OPDEF OUT	[ 57B8]
OPDEF SETSTS	[ 60B8]
OPDEF STATO	[ 61B8]
OPDEF GETSTS	[ 62B8]
OPDEF STATZ	[ 63B8]
OPDEF INBUF	[ 64B8]
OPDEF OUTBUF	[ 65B8]
OPDEF INPUT	[ 66B8]
OPDEF OUTPUT	[ 67B8]
OPDEF CLOSE	[ 70B8]
OPDEF RELEASE	[ 71B8]
OPDEF MTAPE	[ 72B8]
OPDEF UGETF	[ 73B8]
OPDEF USETI	[ 74B8]
OPDEF USETO	[ 75B8]
OPDEF LOOKUP	[ 76B8]
OPDEF ENTER	[ 77B8]
OPDEF UJEN	[100B8]
OPDEF DPYCLR	[701B8]
OPDEF PPIOT	[702B8]
OPDEF UPGIOT	[703B8]
OPDEF UINBF	[704B8]
OPDEF UOUTBF	[705B8]
OPDEF FBREAD	[706B8]
OPDEF FBWRT	[707B8]
OPDEF MAIL	[710B8]
OPDEF PTYUUO	[711B8]
OPDEF POINTS	[712B8]
OPDEF UPGMVE	[713B8]
OPDEF UPGMVM	[714B8]
OPDEF PGIOT	[715B8]

OPDEF TTCALL	[TTYUUO]
OPDEF INCHRW	[TTYUUO 0,]
OPDEF OUTCHR	[TTYUUO 1,]
OPDEF INCHRS	[TTYUUO 2,]
OPDEF OUTSTR	[TTYUUO 3,]
OPDEF INCHWL	[TTYUUO 4,]
OPDEF INCHSL	[TTYUUO 5,]
OPDEF GETLIN	[TTYUUO 6,]
OPDEF SETLIN	[TTYUUO 7,]
OPDEF RESCAN	[TTYUUO 10,]
OPDEF CLRBFI	[TTYUUO 11,]
OPDEF CLRBFO	[TTYUUO 12,]
OPDEF INSKIP	[TTYUUO 13,]
OPDEF INWAIT	[TTYUUO 14,]

OPDEF PTWR1S	[PTYUUO 7,]
OPDEF PTWRS9	[PTYUUO 12,]

OPDEF PPSEL	[PPIOT 0,]
OPDEF PPACT	[PPIOT 1,]
OPDEF DPYPOS	[PPIOT 2,]
OPDEF DPYSIZ	[PPIOT 3,]
OPDEF PPREL	[PPIOT 4,]
OPDEF PGSEL	[PGIOT 0,]
OPDEF PGACT	[PGIOT 1,]
OPDEF PGCLR	[PGIOT 2,]
OPDEF DPYOUT	[UPGIOT]

OPDEF DSKPPN	[CALLI 400071]
OPDEF SWAP	[CALLI 400004]
>;ITS

OPDEF PUTBYT[1B8]
OPDEF PUTSTR[2B8]

DEC,<
	OPDEF	DSKPPN	[10B8]
	OPDEF	TTYUUO	[51B8]
	OPDEF	DPYOUT	[3B8]
	OPDEF	DPYCLR	[4B8]
GT,<	OPDEF	IONEOU	[TTYUUO	15,]	;;JB DEFINE THE IMAGE OUT UUO.>
PGP,<	OPDEF	PLIT	[POINT 36,0,35]	>
>;DEC

NOSTANFO,<
VIROS,<
OPDEF COMPT. [CALLI 147]
SEARCH MONSYM		;GET JSYS DEFS
	VBLOCK__30	;LOCK CODE
	VBSTRT__31	;START CODE
	VBSTOP__32	;STOP CODE
	VBSTAT__33	;STATUS CODE
>;VIROS

OPDEF RESET [CALLI]
OPDEF CORE [CALLI 11]
OPDEF EXIT [CALLI 12]
OPDEF DATE [CALLI 14]
OPDEF APRENB [CALLI 16]
OPDEF TIMER [CALLI 22]
OPDEF MSTIME [CALLI 23]
OPDEF GETPPN [CALLI 24]
OPDEF PJOB [CALLI 30]
OPDEF SLEEP [CALLI 31]
OPDEF SETUWP [CALLI 36]
OPDEF GETTAB [CALLI 41]
OPDEF SETNAM [CALLI 43]
OPDEF LOCK [CALLI 60]
OPDEF DEVNAM [CALLI 64]
OPDEF HIBER [CALLI 72]
OPDEF PATH [CALLI 110]
OPDEF UNLOK. [CALLI 120]

OPDEF INCHRW [TTYUUO 0,]
OPDEF OUTCHR [TTYUUO 1,]
OPDEF INCHRS [TTYUUO 2,]
OPDEF OUTSTR [TTYUUO 3,]
OPDEF INCHWL [TTYUUO 4,]
OPDEF INCHSL [TTYUUO 5,]
OPDEF GETLIN [TTYUUO 6,]
OPDEF SETLIN [TTYUUO 7,]
OPDEF RESCAN [TTYUUO 10,]
OPDEF CLRBFI [TTYUUO 11,]
OPDEF CLRBFO [TTYUUO 12,]
OPDEF INSKIP [TTYUUO 13,]
>;NOSTANFO

NODECOS,<
DEFINE ENTPPN<>
>;NODECOS

DECOS,<
NODEC,<	OPDEF DSKPPN [GETPPN] >
DEFINE ENTPPN
<	SKIPN T,FILPPN
	DSKPPN T,
	MOVEM T,FILPPN
>
>;DECOS

EXTERNAL .JBOPC,.JBREN,.JBDDT,.JBFF,.JBSYM,.JBHRL,.JBSA,.JBREL
DEC,<
EXTERNAL	.JB41,.JBUUO,.JBTPC,.JBAPR,.JBCNI,.JBINT
GT,<
EXTERN	SAVER,RESTRE,GTINIT,TRANS8,CLEARS,GTRESET
EXTERNAL GTCHRW,GTCHRS,GTCHSL,GTCHWL	;;JB
EXTERN	SENDHD,STPSHW,SRTSHW,BMODDO,BREADM,STLPXY	;;JB
DLX,<INTERNAL DLXJFN,DLXFLG>
INTERNAL NBYTES,OPTFLG,GTX,GTY
>;GT
PGP,<	EXTERN	CHRTAB	>

;SPECIAL PUSHDOWN LIST FOR PDL OVFL HANDLER
SPD2SZ__200
>;DEC
SPPDSZ__10

ORG	137
	<BYTE (3) VGROUP (9) VMAJOR (6) VMINOR>+TOTSUM
ORG

IFN DECSW!TWOSW!PUR2SW,<
SET LOWER,.
TWOSEG
RELOC 400000
SET UPPER,.

VB10,<
NOVIROS,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE UPPER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;NOVIROS
VIROS,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE UPPER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;VIROS
>;VB10

NOVB10,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE LOWER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;NOVB10
>;IFN DECSW!TWOSW!PUR2SW
IFE DECSW!TWOSW!PUR2SW,<
DEFINE STORAGE(A)
<>

ITS,<

SET LOWER,.
TWOSEG
RELOC 400000
SET UPPER,.

DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE LOWER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;ITS
>;IFE DECSW!TWOSW!PUR2SW

;CTRL C INTERCEPT BLOCK
DEC,<
STORAGE(LOW)
INTBLK:	XWD	4,CTRLCI
	2		;CTRL C INTERCEPT
	0
	0
>;DEC
                                                                                                             ;SOME MACROES FOR THE GT-40 VERSION
IFN GT40SW,<					;;JB  DEFINE MACROS NOW.

DEFINE	STOPIC(PICNUM)		;;JB DEFINE STOP PICUTRE MACRO.
<	PUSH	P,16			;;JB SAVE DATA REGISTER.
	MOVEI	16,PICNUM		;;JB GET THE PICTURE NUMBERNOW.
	PUSHJ	P,STPSHW		;;JB STOP SHOWING THE PICUTRE NOW.
	POP	P,16			;;JB RESTORE DAMAGED REGISTER NOW.
>

DEFINE	STAPIC(PICNUM)		;;JB OPPOSITE OF THE ABOVE.
<	PUSH	P,16			;;JB SAVE REGISTER NOW.
	MOVEI	16,PICNUM		;;JB  GET THE PICUTRE NUMBER NOW.
	PUSHJ	P,SRTSHW		;;JB START SHOWING IT NOW.
	POP	P,16			;;JB RESTORE REGISTER NOW.
>

DEFINE	BMODS(PIC,OFF,NUM)	;;JB DEFINE PICTURE MODIFICATION MACRO.
<	PUSH	P,13			;;JB SAVE A BUNCH OF REGISTERS NOW.
	PUSH	P,14
	PUSH	P,15
	PUSH	P,16
	MOVEM	P,STCHPS		;;JB SAVE THE STACK NOW.
	PUSH	P,[PIC]			;;JB PLACE PIC NUMON STACK.
	MOVE	16,P			;;JB MOVE OVER POINTER TO START OF MODIFIFIER.
	PUSH	P,[OFF]			;;JB PUSH THE OFFSET NOW.
	PUSH	P,[NUM]			;;JB AND FINALLY PUSHTHE NUMBER.
>

DEFINE	BMODF			;;JB DEFINE CALLING AND POPPING MACRO.
<	PUSHJ	P,BMODDO		;;JB SEND IT OUT NOW.
	MOVE	P,STCHPS		;;JB RESET STACK TO A GOOD ONE.
	POP	P,16			;;JB RESTORE REGISTERS NOW.
	POP	P,15			;;JB
	POP	P,14			;;JB
	POP	P,13			;;JB
>

DEFINE	INCHRW(ARG)		;;JB DEFINE WAIT FOR CHAR AS MACRO
<					;;JB WHICH IS REALLY A PUSHJ TO
	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 0,ARG
			POPJ P,]
		PUSHJ P,GTCHRW	;;JB A PUSHJ WITH THE ARGUMENT AFTER
		POP P,ARG]		;;JB THE SECOND PUSHJ.
>

DEFINE	INCHRS(ARG)		;;JB LIKEWISE DO THE SAME FOR THE FOLLOWING.
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 2,ARG
			POPJ P,
			JRST CPOPJ1]
		PUSHJ P,GTCHRS	;;JB
		POP P,ARG]		;;JB
>

DEFINE	INCHWL(ARG)		;;JB DEFINE THE GET A CHAR (LINE MODE) [WAIT].
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 4,ARG
			POPJ P,]
		PUSHJ P,GTCHWL	;;JB CAL THE CORRECT ROUTINE NOW.
		POP P,ARG]		;;JB GIVE HIM BACK THE ANSWER NOW.
>

DEFINE	INCHSL(ARG)		;;JB AND THE GET CHAR(LINE MODE).
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 5,ARG
			POPJ P,
			JRST CPOPJ1]
		PUSHJ P,GTCHSL	;;JB
		POP P,ARG]		;;JB
>

DEFINE	GTMIX(C1,C2)		;;JB DEFINE A MACRO TO PUT THE CHARACTERS IN OK.
<	BYTE	(4) 0 (8) 0,0,C2,C1	;;JB
>

RDYCJ__25			;;JB DEFINE THE "READY" CONTROL CHARACTER
					;;JB AS BEING A ^U, WHICH IS NOT NORMALLY SENT.
NRDYCJ__17			;;JB LIKEWISE DEFINE THE NOT READY CHARACTER AS ^O.

>;GT					;;JB  END THE CONDITIONAL ASSEMBLY.

PGP,<				;SOME DEFINITIONS FOR THE PGP VERSION
$S__0		;BLISS STACK PTR
$V__3		;BLISS VALUE RETURN REG

DEFINE	RTNCAL	(NAME,A) <
EXTERN	NAME
	MOVE	$S,P
CNT$__0
IFIDN <A><><	FLG$__0	;>	FLG$__1
IFN FLG$,<
	FOR	I IN (A) <
	PUSH	$S,I
CNT$__CNT$+1
>;FOR
>;IFN FLG$
	PUSHJ	$S,NAME
IFN CNT$,<
	SUB	$S,[XWD CNT$,CNT$]
>
	SKIPLE	$V
	MOVEM	$V,$VAL
	MOVE	P,$S
>;RTNCAL
>;PGP
                                                                                                                                                                                                                                                                                                           ;AC'S - SPECIAL CHAR DEFS - OTHER DEFS

;0			;TEMPORARY FLAGS
M_1			;SEMI-PERMANENT FLAG REG
A_2
B_3
C_4
D_5
E_6
F_7
G_10
H_11
T_14
TT_T+1
TTT_TT+1
P_17

;IO CHANNEL NUMBERS
DAT__0		;DATA IN AND OUT
IDSK__1	;DISK INPUT
ODSK__2	;DISK OUTPUT
IOLAY__3	;LAYOUT I/O
ICARD__4	;CARD DEF INPUT CHANNEL
DEC,<	DISCHN__5	;VB10C CHANNEL
	PGPCHN__10	;PGP I/O CHANNEL
>;DEC
GDP,<	ATYO__5	;GDP2 OUTPUT CHANNEL
	ATYI__6	;GDP2 INPUT CHANNEL
>;GDP

;DEFAULT PROTECTION FOR OUTPUT FILES
DECOS,<DEFPRO__155>	;ALLOW EVERYTHING ON OTHER USERS AREA
NODECOS,<DEFPRO__000>
DEC,<DEFPRO__005>	;NOT HERE!!!!!!!

;CHARACTER SIZES
NODEC,<
CWIDTH__10
CHGHT__20
STDBIG__1	;DEFAULT TEXT SIZE
>;NODEC
DEC,<
CWIDTH__6
CHGHT__12
STDBIG__2
>;DEC

;NUMBER OF CHARS NECESSARY TO PRINT FILENAME INFO
NOSTAN,<NOITS,<NNCHRS__6+6+6+3>>	;FFFFFF[PPPPPP,NNNNNN]
STANFO,<NNCHRS__6+6+4>		;FFFFFF[PPP,NNN]
ITS,<NNCHRS__6+6+1>		;UUUUUU;FFFFFF
NNCHRE__NNCHRS+4		;.EEE	DEC,STANFO,CMU
				; EEE	ITS

;NUMBER OF WORDS NECESSARY TO SHOW DEFAULT FILENAME
NOLAY,<NFWRDS__(NNCHRS+4)/5	>;FFFFFF[PPP,NNN]
LAY,<NFWRDS__(NNCHRS*2+1+4)/5	>;FFFFFF[PPP,NNN]&FFFFFF[PPP,NNN]

;NUMBER OF WORDS NECESSARY FOR NAMBUF PRINTOUT BUFFER
NNWRDS__(NNCHRE+4)/5		;FFFFFF.EEE[PPP,NNN]
IFL NNWRDS-NFWRDS,<NNWRDS__NFWRDS>;MAKE ENOUGH FOR BOTH

;SPECIAL CHARACTERS, DEFINE AS YOU WISH
NODEC,<
CTRL__""	;CHARACTER INTERPRETED AS CONTROL BIT
META__3		;		"	  META BIT
CTLMTA__""	;		"	  CTRL META BITS
TTYCM__"'"	;HACK FOR TTY'S AT STANFORD, INC'S CTRL BITS
>;NODEC
LAMBDA__""	;FOR DISK IO START, STOP
CRCHR__24	;CR FOR DISKIN AND MACRO ALTER MODE
AMCTL__13	;ALTER MODE <CTRL> CHAR (1 ALT)
AMMTA__14	;ALTER MODE <META> CHAR (2 ALT)
NODEC,<TEXIST__"">	;THERE EXISTS, FOR FILENAME
DEC,<TEXIST__"">
BIGCHR__""	;GET BIGGER
DBLARR__""	;CRLF IN TEXT
NODEC,<ALTCHR__"">	;ALTMODE FROM FILE AND FOR MACRO ALTER MODE
DEC,<	ALTCHR__7>	;BELL FOR DEC
NOCMU,<ACLOSE__176>	;CLOSING CHARACTER IN ";A"
CMU,<ACLOSE__175>
VRTBAR__"|"	;VERTICAL BAR
STANFO,<ALTMOD__175>	;ALTMODE CHAR
NOSTANFO,<ALTMOD__33>
NOT__""	;CHAR LIKE "-", BUT DIF.
NOTCHR__"-"	;FOR PERMUT AND ALPHA
TILDA__32	;LOW TRUE FOR SIGNAL NAME
GENCHR__"%"	;GENERATED SIGNAL NAME CHAR.
RHG,<GENCHR__"!">

;SPECIAL CHARS FOR SEARCH STUFF IN ALTER MODE AND F
QUOCHR__""	;QUOTE CHAR IN SEARCH STRINGS
BELCHR__"|"	;BEGINNING OR END OF LINE
NODEC,<ANYCHR__24>	;ANY CHAR IN SEARCH STRING
DEC,<ANYCHR__"?">	;	"
NODEC,<NFCHR__"">	;NOT NEXT THING
DEC,<	NFCHR__""	>
INFCHR__""	;ANY # OF FOLLOWING
LETCHR__"$"		;MATCH ANY LETTER
DIGCHR__"%"		;MATCH ANY DIGIT
ALFCHR__""		;MATCH ANY ALPHANUMERIC

;SCREEN DIMENSIONS - - LEAVE TOP 3 LINES
NODEC,<
%TOP__700
%BOTTOM__-1000
%LEFT__-1000
%RIGHT__1000
NOSTAN,<SCRTOP__1000>
STAN,<SCRTOP__1000-2*CHGHT>
TITBRT__2
TITBIG__2
>;NODEC
DEC,<
VB10,<
%TOP__700
%BOTTOM__-770
%LEFT__-770
%RIGHT__766
SCRTOP__1000-10
>;VB10
GT,<
;HALF PHYSICAL HEIGHT AND WIDTH OF GT40 SCREEN
GTX__1000
IFN GTSMAL,<GTY__600>
IFE GTSMAL,<GTY__1000>
%TOP__GTY-10
%BOTTOM__-GTY+1
%LEFT__-GTX+1
%RIGHT__GTX-1
SCRTOP__GTY
>;GT
PGP,<
%TOP__700
%BOTTOM__-1000
%LEFT__-1000
%RIGHT__1000
SCRTOP__1000
>;PGP
TITBRT__5
TITBIG__STDBIG
>;DEC

;ALTER TEXT MODE DISPLAY PARAMETERS
AXPOS__%LEFT+200
AYPOS__%TOP-200
ACHRSZ__2		;CHAR SIZE
NODEC,<	MAXLIN__=30	;MAX CHARS PER LINE
	MAXPAG__=20
>;NODEC
DEC,<	MAXLIN__=60
NOGT,<	MAXPAG__=40 >
GT,<	MAXPAG__=32 >
>;DEC

GT,<	DPYLEN__1400	>
NOGT,<	DPYLEN__6000	>

;INITIALIZATION VALUES FOR FLAGS,SCALE
DEFINE	DFLT0	<<0,,MCHG!NEEDCL>>	;MACRO BECAUSE FLAGS NOT DEFINED YET
DEFINE	DFLTM	<<MD,<BLOCS!PLOCS!CLOCS!>DEC,<XWINDOW!>CMUF,<DIAMONDS!JUNC3!>LWINDOW,,DEC,<SPACES!>0>>
MPC,<	DFSCL__=2 >
MD,<	DFSCL__=16
	DEC,<	DFSCL__=8 >
>;MD

;CONCATINATION
	DEFINE CAT $ (A,B)
<	A$B
>

DEFINE INFORM ! (A,B)
<PRINTS !A = B
>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;PG0 -- INFO LINE, CURSOR

NOGDP,<

STORAGE(DPY)	;KEEP ALL DISPLAY STUFF IN LOWER SEG

DEFINE RPNT(X,Y),<
	BYTE(11)<X>,<Y>(3)0,0(2)0,1(4)6
REPEAT 0,<	BYTE(11)0,0(3)0,0(2)0,1(4)6>
	BYTE(8)0,0,200(12)32
	BYTE(8)100,0,100(12)12
	XWD .+3,20
	XWD SAVWRD,64
	BYTE(8)200,0,0(12)12
>

DEFINE LIVW(X,Y,S)
<	BYTE (11)<X>,<Y>(3)3,S(2)1,2(4)6	>

DEFINE RDV(X,Y)
<	BYTE (7)<X>,<Y>(2)0(7)<X>,<Y>(2)2(4)2	>
DEC,<
VB10,<					;;JB ASSEMBLE IN THIS.
FBUF:	0				;BUFFER HEADER
	0
	XWD	030130+TITBRT,221000+SCRTOP-TITBIG*CHGHT-20	;LITE PEN OFF, SCALE-2 BRITE-7, Y
REDWRD:	BYTE (18) 061000+%RIGHT-30 (6) 35,"*",37	;RIGHT 1/2 VARIES
	BYTE (18) 020000,221000+SCRTOP-TITBIG*CHGHT
	BYTE(18) 061000+%LEFT (6) 35,"M","O"	;X,<SHIFT IN>"MO"
MODWRD:	BYTE(6) "D","E","=",35,35,35	;"DE=" RIGHT 1/2 VARIES
	BYTE (6) 35," ","S","C","L","="	;"SCL="
SCLWRD:	BYTE (6) 35,35,35,35," ","L"	;LEFT 1/2 VARIES
LVLWRD:	BYTE (6) "V","L","=",35,35,35	;"LVL=" RIGHT 1/2 VARIES
	BYTE (6) 35," ",37 (18) 100000	;ENTER VECTOR MODE
	XWD 200005,203000		;EXISTS IN VECTORS
	XWD 200204,101404
	XWD 200203,501405
	BYTE (18) 060000 (6) "=",35,35	;"="
FILWRD:
	REPEAT	NFWRDS-1,<
	BYTE (6) 35,35,35,35,35,35
>
	BYTE (6) 35,35,35,35,35,37
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
FVECT1:	0
	0
	0
	0
	0
	XWD 160000,400000
	XWD SAVWR1,0		;JSR SAVWR1
FVECT2:	0
	0
	0
	0
	0
FBRT:	XWD 0,160015		;0;BRITE 5
LOCAT:	XWD 0,%NLOC	;JMP %NLOC (OR JSR LOCATS)
	XWD 600100,160000	;RIGHT
	XWD 400000,LOCATS
	XWD 600300,160000	;LEFT
	XWD 400000,LOCATS
	XWD 640000,160000	;UP
	XWD 400000,LOCATS
	XWD 740000,0		;DOWN,0
%NLOC:	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 160000,0		;JMP ONOFF-1(OR JMP .+1)
%CLOC:	XWD ONOFF-1,0
	XWD 120160,600100	;SCALE-8,RIGHT
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,600300	;LEFT
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,640000	;UP
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,740000	;DOWN
	XWD 160120,400000	;SCALE-1,JSR SAVWR1
	XWD SAVWR1,0
	XWD	0,160000	;JSR CROSS(OR JUMP .+1)
ONOFF:	XWD 400000,CROSS
	XWD 160000,0		;JMP VBBUF
ENDPG1:	XWD	FBUF,0

CROSS:	0
	XWD 100137,002004	;INVIS NE
	XWD 304210,004000	;VISIB SW,INVIS N
	XWD 704010,160000	;VISIB SE, JMP @CROSS
	XWD 200000,CROSS
LOCATS:	0
	XWD 0,20000
LOCATW:	XWD 220000,160000
	XWD 320000,LOCATS	;JMP @LOCATS (INTO VEC CONT MODE)

SAVWR1:	0
	XWD 0,20000
SAVWRD:	XWD 221000,161000
	XWD 200000,SAVWR1
NULLO:	0			;NULL SUBROUTINE
	XWD	160000,200000
	XWD	NULLO,0

>;VB10					;;JB

GT,<					;;JB MY CRAP....

JBREDY:	0				;;JB REMEMBERS READY-NOT READY STATE.



	DISTOP__173400			;;JB DEFINE THE DISTOP INSTRUCTION.


PIC3:	117124				;;POSITION TO TOP LEFT OF SCREEN.
	0
	GTY+SCRTOP-CHGHT*2
	100000				;;GET INTO CHARACTER MODE.
	GTMIX	"M","O"			;;JB STICK IN THE CORRECT HEADING
	GTMIX	"D","E"			;;JB  USING 8 BIT GT40 CHARACTERS.
	GTMIX	"=",0			;;JB
GTMODE:	GTMIX	"J","B"			;;JB CHANGABLE MODE LETERS HERE.
	GTMIX	" ","S"			;;JB
	GTMIX	"C","L"			;;JB
	GTMIX	"=",0			;;JB
GTSWRD:	GTMIX	"0",0			;;JB CURRENT SCALING LEVEL.
	GTMIX	" ","L"			;;JB THE LEVEL NOW.
	GTMIX	"V","L"			;;JB
	GTMIX	"=",0			;;JB
GTLWRD:	GTMIX	"0",0			;;JB CURRENT LEVEL VALUE.
	GTMIX	" ",135			;;JB THE 'THERE EXISTS' SIGN.
	GTMIX	10,"-"			;;JB DONE BY SUPERIMPOSING.
	GTMIX	"=",0			;;JB
GTFNAM:	0				;;JB LEAVE ROOM FOR 25 CHARACTERS FOR
	0				;;JB  THE FILE NAME (13 WORDS).
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	DISTOP				;;JB END OF THE LIST NOW.
	0

PIC3Z__.-PIC3				;;JB SIZE OF THE LIST.
	XWD	3,1			;;JB DEFINE AS SUBPICTURE 3, REMEMBER CHANGES.

>;GT					;;JB END OF MYCRAP.

PGP,<
TSXDAT:	0
TSYDAT:	0
FILWRD:	BLOCK	NFWRDS
	0
MODWRD:	0
SCLWRD:	0
LOCAT:	0
LVLWRD:	0
	1
NULARG:	0
NILEV:	0
SEGN:	0
PSEGN:	0
$VAL:	0
FVECT1:	0
FVECT2:	0
BLNKIT:	0
PGBITS:	0
FBUF:	0			;DUMMY
SAVWRD:	0
>;PGP

>;DEC
                                                                                                                                                                                                                                                                          NODEC,<
FBUF:	.+2
	FEND-.-1
	0
	LIVW(%RIGHT-CWIDTH*4,SCRTOP-CHGHT*4,6)
REDWRD:	ASCID/*/
	LIVW(%LEFT,SCRTOP-CHGHT*2,4)
	ASCID/MODE=/
MODWRD:	1
	ASCID/   SCL=/
SCLWRD:	1
	ASCID/   LVL=/
LVLWRD:	1
	ASCID/   =/
FILWRD:REPEAT NFWRDS,<1>
	XWD SAVWRD,54
FVECT1:	12
	XWD SAVWRD,54
FVECT2:	12
	XWD SAVWRD,54
FBRT:	BYTE(11)0,0(3)2,0(2)0,2(4)6	;USE CURBRT ON THE REST OF THIS
LOCAT:	XWD %NLOC,20		;NORMALLY JUMP TO %NLOC
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(20,0)		;GO RIGHT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(-20,0)		;GO LEFT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,20)		;GO UP
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,-20)		;GO DOWN
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
%NLOC:	XWD SAVWRD,54
%CLOC:	XWD ONOFF,20		;NORMALLY JUMP TO ONOFF
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(10,0)		;GO RIGHT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(-10,0)		;GO LEFT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,10)		;GO UP
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,-10)		;GO DOWN
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
ONOFF:	XWD CROSS,20		;INITIALLY USE CROSS
	BYTE(8)167,200,0(12)12
	RPNT 0,0
	RPNT 0,0
;INNER RING
	RPNT -4,0
	RPNT 4,-4
	RPNT 4,4
	RPNT -4,4
;START FIRST RING
	RPNT -10,-4
	RPNT 10,-10
	RPNT 10,10
	RPNT -10,10
;START SECOND RING
	RPNT -14,0
	RPNT 0,-20
	RPNT 14,-10
	RPNT 14,10
	RPNT 0,20
	RPNT -14,10
;START THIRD RING
	BYTE(8)0,0,200(12)12	;DON'T DRAW IF WE SAW LIGHT PEN.
	0
	RPNT -14,4
	RPNT -10,-10
	RPNT -4,-14
	RPNT 4,-14
	RPNT 10,-10
	RPNT 14,-4
	RPNT 14,4
	RPNT 10,10
	RPNT 4,14
	RPNT -4,14
	RPNT -10,10
	RPNT -14,4
;START FOURTH RING
	RPNT -16,6
	RPNT -12,-6
	RPNT -6,-12
	RPNT -2,-16
	RPNT 2,-16
	RPNT 6,-12
	RPNT 12,-6
	RPNT 16,-2
	RPNT 16,2
	RPNT 12,6
	RPNT 6,12
	RPNT 2,16
	RPNT -2,16
	RPNT -6,12
	RPNT -12,6
	RPNT -16,2
	0
	0
	0
CROSS:	BYTE(11)10,10(3)0,0(2)0,2(4)6
	BYTE(11)<-20>,<-20>(3)0,0(2)0,0(4)6
	BYTE(11)0,<20>(3)0,0(2)0,2(4)6
	BYTE(11)<20>,<-20>(3)0,0(2)0,0(4)6
	0
	0
SAVWRD:	1
	0
	0
	0
FEND__.

BLDPY:	DPYOUT BLINK	;PG # WILL BE FIXED UP
>;NODEC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                STORAGE(IMPURE)	;IMPURE, BUT CAN GO IN UPPER
DPYDPY:	DPYOUT HEAD	;	"
HYDDPY:	DPYOUT [DPYBUF
		0	];	"

HEAD:	DPYBUF
	0

NODEC,<
BLINK:
NOITS,<	BLINKB	>
ITS,<	SETZ BLINKB	>	;SIGN BIT ON SAYS BLINK THIS PG
	0		;WORD COUNT

BLINKB:	1		;NO-OP IN CASE IT GETS EXECUTED(WHICH I DON'T THINK IT DOES!)
	XWD BPOS,74	;WHERE WE WERE LAST TIME!
	<BYTE(8)0,0,200>+12
	BYTE(11)400,0(3)0,0(2)0,2(4)6	;20 TO RIGHT OF THERE
	BYTE(11)40,0(3)0,0(2)0,2(4)6	;20 TO RIGHT OF THERE
	<BYTE(8)0,0,40>+12		;EDGE OVERFLOW?
	XWD BLEAV,20			;NO
	BYTE(11)0,0(3)0,0(2)1,2(4)6	;RESET TO CENTER
	<BYTE(8)240,200,0>+12		;CLEAR EO AND SET CONTROL BIT!
BLEAV:	XWD BPOS,64			;SAVE WHERE WE ARE NOW
	<BYTE(8)0,0,200>+12		;CONTROL BIT ON?
	0				;NO, STOP HERE
	XWD DPYBUF+1,20			;TRANSFER TO DPYBUF!
BPOS:	201				;THE 200 WONT HURT US, BUT ITS LIKES IT
BLINKL__.-BLINK
>;NODEC
>;NOGDP
                                                                                                                                                                                                                                                                                                                                                                                                                   STANFO,<
NOLAY,<
MPC,<
PCDPY:	DPYBUF
	0
>;MPC
>;NOLAY
>;STANFO
DPYBUF:	BLOCK DPYLEN+200

NOCORE:	0
	OUTSTR[ASCIZ/YOU ARE SUFFERING FROM THE UNFORTUNATE FACT THAT
YOUR OVERBLOATED PROGRAM WILL NO LONGER FIT IN OUR
PUNY CORE!!!!!!!
/]
NODEC,<	HALT @NOCORE	>
DEC,<	PUSHJ	P,TODDT	;GO TRY DDT
	JRST	@NOCORE
>;DEC

;XTEXTF AND YTEXTF TABLES ARE USED TO OFFSET THE CURSOR FOR TEXT SUCH THAT
;A BOX CHGHT BY CWIDTH (IN WHICH THE CHARACTER IS ASSUMED TO BE CENTERED)
;HAS ITS LOWER LEFT CORNER AT THE CURRENT POSITION.

DEC,<
GT,<
XTEXTF:	-4	;1
	-10	;2
	-12	;3
	-22	;4

YTEXTF:	-1	;1
	-4	;2
	-4	;3
	-10	;4
>;GT
NOGT,<
XTEXTF:	-4	;1
	-6	;2
	-12	;3
	-22	;4

YTEXTF:	-1	;1
	-2	;2
	-4	;3
	-10	;4
>;NOGT
>;DEC

NODEC,<
NOITS,<
NOGDP,<
XTEXTF:	-2
	0
	0
	1
	4
	10
	0

YTEXTF:	1
	0
	0
	6
	14
	20
	0
>;NOGDP
GDP,<
XTEXTF:
FOR I IN(10,14,16,20,30,40,60)
<
I*(CWIDTH/2-3)/10
>

YTEXTF:
FOR I IN(10,14,16,20,30,40,60)
<
I*(CHGHT/2-5)/10
>
>;GDP
>;NOITS
ITS,<
XTEXTF:
FOR I IN (10,15,16,20)
<	2
>
FOR I IN(30,40,60)
<	4
>
YTEXTF:
FOR I IN (10,14,16,20)
<	1
>
FOR I IN(30,40,60)
<	14
>
>;ITS
>;NODEC

;MAX LEGAL SOFTWARE CHARACTER SIZE
CSIZES__4

;TABLE OF MULTIPLIERS TO USE ON CHGHT AND CWIDTH TO GET SIZE
;OF SOFTWARE CHARACTER
CMUL:	1
	1
	2
NODEC,<	3	>
DEC,<	4	>
NODEC,<	4	>
DEC,<	10	>

;CONVERT SOFTWARE CHARACTER SIZE TO HARDWARE CHARACTER SIZE
S2H:
NODEC,<	1
	1
	4
	5
	6
>;NODEC
DEC,<	1
	1
	2
	3
	4
>;DEC

	DATPPN_' WLDRW'
CMU,<	DATPPN_<10053,,473002>>	;E130RG02
DEC,<
NOVIROS,<PGP,<	DATPPN__<362,,5010>	;>	DATPPN__0	>
VIROS,<	DATPPN_<4,,253>	>
>;DEC

LIBPPN:	DATPPN
                                                                                                                                                                                                                                        ;CONSTANT DATA LOCS FOR LAYOUT
DEFINE CDATA(LABEL,SIZE,SEG)
<
IFIDN<SEG><LOW><STORAGE(LOW);>STORAGE(IMPURE)
LABEL:
IFIDN<SIZE><><0>
IFDIF<SIZE><><BLOCK SIZE>
>

STORAGE(LOW)

LAY,<
RDOFF:	'GODMOD'
	20
OFFSET:	0
REALLN:	0

WRTOFF:	'GODMOD'
	21
NEWOFF:	0
>;LAY


CDATA		PATCH0,40,LOW
NODEC,<
CDATA		SSSNAM
CDATA		SSSEXT
CDATA		SSSDAT
CDATA		SSSPPN
>;NODEC

ZLOWBEGIN:
LAY,<
TPDLLN__40	;TEMP PDL LENGTH

CDATA		TPDL,TPDLLN		;TEMP PDL FOR SAVE/GET ROUTINES
CDATA		IWD
CDATA		LAYPDL
CDATA		LAYBIT
CDATA		LAYM
CDATA		ODISP
TWO,<
CDATA		DNUM
CDATA		PCNUM
>;TWO
CDATA		DPCPNT			;POINT PASS LIST POINTER
CDATA		DOPASS
CDATA		LAYLET
CDATA		LAYNUM
CDATA		SWHICH
CDATA		SWHCHA
CDATA		SWHCHS
LIB,<
BLLEN__=400	;ENOUGH FOR 200 LOCATIONS TO BE PASSED
CDATA		BLDATA,BLLEN		;POINT PASS LIST SPACE (LIB)

;THE FOLLOWING MUST BE IN ORDER
CDATA		DBAND,4
CDATA		D2BAND,4
CDATA		PCBAND,4
CDATA		PC2BAND,4
;INDICIES INTO BAND STUFF
BAND__0
DLOC__1
LENGTH__2
SEC__3
BAND2__4

>;LIB
CDATA		SAVNAM
CDATA		SAVPPN
CDATA		LAYLOC
>;LAY
DEC,<
CDATA		RTIME
CDATA		QTIME
CDATA		DTIME
GT,<
CDATA		NBYTES
>;GT
VIROS,<
CDATA		TYPFLG
CDATA		VSTBUF,10
VSTEND__<POINT 7,VSTBUF+7,27>
DLX,<
CDATA	DLDVDS
CDATA	DLXBUF,8
>;DLX
>;VIROS
GT,<
CDATA	OPTFLG
DLX,<
CDATA	DLXFLG
>;DLX
>;GT
>;DEC
NODEC,<
CDATA		DPCNAM
CDATA		DPCEXT
CDATA		DPCDAT
CDATA		DPCPPN
CDATA		STRTLC
CDATA		SSSP
CDATA		TJOBDA,200		;TEMP JOB DATA AREA
CDATA	AUTOSM
CDATA	AUTOSN
>;NODEC
CDATA	RSAVET,,LOW
NODEC,<
CDATA	NAMBUF,NNWRDS
>;NODEC
DEC,<
CDATA	SPPDL2,SPD2SZ,LOW
CDATA	GOING
VB10,<
CDATA	PGTBL,4
>;VB10
CDATA	NAMBUF,6
>;DEC
CDATA	SPPDL,SPPDSZ,LOW
CMU,<	CDATA PPNBUF,3 >
CDATA	IOHD,3,LOW
CDATA	IOBUF,406,LOW
CDATA	TTBUF,2,LOW
CDATA	CINST
CDATA	CHARP
GDP,<	CDATA	CHKSVC
	CDATA	PSVCNT
PSVLEN__100
	CDATA	PDLSAV,PSVLEN
>;GDP
CDATA	BSOR
CDATA	ISDPY
CDATA	DONTDPY
CDATA	POSS1
CDATA	CURCUR
CDATA	PAGACT
CDATA	REALACT
CDATA	SQRFLG
CDATA	FILNAM,,LOW
CDATA	FILEXT,,LOW
CDATA	FILDAT,,LOW
CDATA	FILPPN,,LOW
DEC,<
CDATA	TMPNAM,,LOW
CDATA	TMPEXT,2,LOW
CDATA	TMPPPN,,LOW
>;DEC
CDATA	DSKOPN
CDATA	DSKOHD,3,LOW
CDATA	DSKOBF,210,LOW
CDATA	BRKCHR
CDATA	DSKHD,3,LOW
CDATA	DSKBUF,210,LOW
ZLOWEND__.-1

ORG 40
UUO:	0
IFN 0,<	JSR UUOCON>
	PUSHJ P,.UUOCON
ORG

NODEC,<
STORAGE(IMPURE)
UUOSAV:	0
>;NODEC

ORG 124
REENTER
ORG

NOFST:	0
	JRST .NOFST

LCFLAG:	-1		;ALWAYS START WITH LOWER CASE ENABLED
BOOPCN:	0		;START WITH NO BOOPING
BOOPLR:	0

VIROS,<
NOGT,<
VBCJFN:	-1
>;NOGT
DLX,<
DLXJFN:	-1
>;DLX

STPPN:	3		;FUNCTION CODE FOR PPN TO/FROM DIRECTORY STRING
USRPPN:	0		;PPN RETURNED HERE
STPTR:	0		;POINT TO DIRECTORY STRING
>;VIROS

;STORAGE(PURE)
CPOPJ3:	AOS (P)
CPOPJ2:	AOS (P)
CPOPJ1:	AOS (P)
CPOPJ:	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                            ;LAYOUT INITIALIZATION CODE
NODEC,<
CMU,<	.JBSAV_73  .JBS41_122 >
NOCMU,<	EXTERNAL .JBSAV,.JBS41 >
EXTERNAL .JB41,.JBCOR
LAY,<
STORAGE(LOW)
SAVE:
	SETZB 0,M
	JSR LINIT
	MOVE P,[IOWD TPDLLN,TPDL]	;TEMP STACK SETUP
	OUTSTR[ASCIZ/BE CAREFUL, WILL NOT CHECK IF ALREADY EXISTS!
/]
	PUSHJ P,DMPNAM
	JRST [	MOVE T,[%PNAME]
		MOVEM T,FILNAM
		MOVE T,['  1  3']
		MOVEM T,FILPPN
		JRST .+1]
	ENTPPN
	MOVE T,[FILNAM,,DPCNAM]
	BLT T,DPCPPN
	MOVEI T,.STRTN
	MOVEM T,STRTLC
LIB,<
	SKIPE T,.JBSYM
	SUBI T,LAY2S-LAY1S+LAYBEG-LAY1S
	MOVEM T,LAYSYM-LAYBEG+LAY2S
>;LIB
	JSR ISAVE		;SAVE OUT LAY2S THROUGH LAY2E (PC)
	JRST [	OUTSTR[ASCIZ/SAVE OF FIRST PART FAILED!
/]
		EXIT]
LIB,<	SKIPN T,.JBSYM
	JRST [	MOVEI T,LAY1E-1
		SETZ TT,
		JRST CORDWN]
	HLRE TT,T
	MOVN TT,TT
	HRLZ T,T
	HRRI T,LAY1E
	BLT T,LAY1E-1(TT)		;MOVE SYMBOLS DOWN
	MOVEI T,LAY1E-1(TT)		;THIS IS TOP+1
	MOVE TT,.JBSYM
	HRRI TT,LAYBEG+LAY1E-LAY1S
	MOVEM TT,.JBSYM
CORDWN:	MOVEM TT,LAYSYM-LAYBEG+LAY1S
	CORE T,
	JFCL
	MOVEI T,-1
	HRLM T,.JBSA			;.JBFF IS ALWAYS WRONG, MAKE IT VERY WRONG
>;LIB
TWO,<
	MOVE T,[LAY1S,,400000]
	BLT T,400000+LAY1E-LAY1S-1	;MOVE UPPER DOWN TO 400000 SINCE LOADER INSISTS
	MOVEI T,LAY1E-1			;ON A VESTIGIAL JOB DATA AREA FOR UPPERS
	CORE2 T,
	JRST [	OUTSTR[ASCIZ/CORE2 FAILED FOR SECOND PART!
/]
		EXIT]
;	SETZM .JBSYM
;	MOVEI T,0
;	SETDDT T,
;	MOVEI T,LOWEND
;	HRRZM T,.JBFF
;	HRLM T,.JBSA

;	MOVE T,[LAY1S,,LAYBEG]
;	BLT T,LAYBEG+LAY1E-LAY1S-1
;	SKIPN T,.JBSYM
;	JRST [	MOVEI T,LAY1S
;		MOVEM T,.JBFF
;		HRLM T,.JBSA
;		SOJA T,CORDWN]
;	HLRE TT,T
;	MOVN TT,TT
;	HRLZ T,T
;	HRRI T,LAY1S
;	BLT T,LAY1S-1(TT)
;	MOVEI T,LAY1S(TT)
;	MOVEM T,.JBFF
;	HRLM T,.JBSA
;	MOVEI TT,LAY1S
;	HRRM TT,.JBSYM

;	SUBI T,1
;CORDWN:CORE T,
;	JFCL
>;TWO
	SETZM SWHCHS			;D IS AT END
	JSR SVREST
	OUTSTR[ASCIZ/SAVE OF SECOND PART FAILED!/]
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	OUTSTR[ASCIZ/
/]
	HLLZS .JBSA			;DISABLE RESTART!!!!!!
	EXIT

DOSAVD:	0
	JSR SAVSPC
	JRST @DOSAVD
	JSR SVFRST
	JRST [	JSR SAVSD
		JRST @DOSAVD
		JRST @DOSAVD]
	JSR SAVSD
	JRST @DOSAVD
	SETZM SWHCHS			;PC IS AT END
	JSR SVREST
	JRST @DOSAVD
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	AOS DOSAVD
	JRST @DOSAVD

DOSAVP:	0
	JSR SAVSD
	JRST @DOSAVP
	JSR SVFRST
	JRST [	JSR SAVSPC
		JRST @DOSAVP
		JRST @DOSAVP]
	JSR SAVSPC
	JRST @DOSAVP
	SETOM SWHCHS			;D IS AT END
	JSR SVREST
	JRST @DOSAVP
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	AOS DOSAVP
	JRST @DOSAVP

.STRTN:	JSR UPNAME
	UNPURE
	JFCL
	JRST .STRT

CONTLC:	JSR UPNAME
	JSR LINIT
	JRST .CONT			;OTHER HALF WILL COME IN WHEN NEEDED

UPNAME:	0
	MOVEM 0,SSSNAM			;FILENAME HERE FROM RUN COMMAND
	HLLZM 1,SSSEXT
	MOVEM 4,SSSPPN
	MOVEI T,.STRT
	HRRM T,.JBSA			;NOW START HERE
	JRST @UPNAME

LINIT:	0
LIB,<	MOVEI T,LAYBEG
	MOVEM T,DBAND+DLOC
	MOVEM T,PCBAND+DLOC
	ADDI T,=76*2000
	MOVEM T,D2BAND+DLOC
	MOVEM T,PC2BAND+DLOC
	MOVEI T,4
	MOVEI TT,PC2BAND
LIBLOP:	MOVNM T,BAND(TT)
	SUBI TT,BAND2
	SOJG T,LIBLOP
	UFBCLR			;RELEASE ALL BANDS
>;LIB
TWO,<	SETZM DNUM
	SETZM PCNUM
	UNPURE			;MAKE SURE CURRENT ONE ISN'T WRITE PROTECTED
	JFCL
>;TWO
	JRST @LINIT
  ;LIBRASCOPE OR TWOSEG GETD, GETPC
GETD:	JSR SAVSD
	POPJ P,
	JRST DPCRET

GETPC:	JSR SAVSPC
	POPJ P,
DPCRET:	EXCH P,LAYPDL
	EXCH 0,LAYBIT
	EXCH M,LAYM
	JUMPE P,.STRTL
	PUSHJ P,SCRSET
	JRST .BLCHK

SAVSD:	0
	JSR RELPC
	JSR %GETD
	CAIA
	JRST [	AOS SAVSD
		JRST @SAVSD]
	OUTSTR[ASCIZ/CAN'T GET D PART, WILL TRY PC PART!
/]
	JSR %GETPC
	CAIA
	JRST @SAVSD
	OUTSTR[ASCIZ/CAN'T GET EITHER, I DIE NOW
/]
	HALT SAVSD+1

SAVSPC:	0
	JSR RELD
	JSR %GETPC
	CAIA
	JRST [	AOS SAVSPC
		JRST @SAVSPC]
	OUTSTR[ASCIZ/CAN'T GET PC PART, WILL TRY D PART!
/]
	JSR %GETD
	CAIA
	JRST @SAVSPC
	OUTSTR[ASCIZ/CAN'T GET EITHER, I DIE NOW
/]
	HALT SAVSPC+1


RELD:	0
LIB,<	MOVEI TT,DBAND		;START HERE
	JSR %PUTLIB
>;LIB
TWO,<	SETZ T,
	SEGNUM T,		;GET SEGMENT # OF OUR UPPER
	MOVEM T,DNUM
	DETSEG
>;TWO
	JRST @RELD

RELPC:	0
LIB,<	MOVEI TT,PCBAND
	JSR %PUTLIB
>;LIB
TWO,<	SETZ T,
	SEGNUM T,		;GET SEGMENT # OF OUR UPPER
	MOVEM T,PCNUM
	DETSEG
>;TWO
	JRST @RELPC

%GETD:	0
LIB,<	MOVEI TT,DBAND
	JSR %GETLIB
	JRST GETD1		;NOT IN YET
	JRST GETDX		;WAS IN, BUT LOST
>;LIB
TWO,<	SKIPN T,DNUM
	JRST GETD1
	ATTSEG T,
	JRST GETDX
>;TWO
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	AOS %GETD
	JRST @%GETD

GETDX:	OUTSTR[ASCIZ/REINITIALIZING "D" PART FROM DMP FILE!
/]
LIB,<	MOVM T,DBAND
	MOVNM T,DBAND
	MOVM T,D2BAND
	MOVNM T,D2BAND
>;LIB
TWO,<	SETZM DNUM
>;TWO
	SETZM LAYPDL
GETD1:	SETZ T,			;TELL HIM WE WANT D PART
	JSR GETDPC
	CAIA
	AOS %GETD
	JRST @%GETD

%GETPC:	0
LIB,<	MOVEI TT,PCBAND
	JSR %GETLIB
	JRST GETPC1
	JRST GETPCX
>;LIB
TWO,<	SKIPN T,PCNUM
	JRST GETPC1
	ATTSEG T,
	JRST GETPCX
>;TWO
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	AOS %GETPC
	JRST @%GETPC

GETPCX:	OUTSTR[ASCIZ/REINITIALIZING "PC" PART FROM DMP FILE!
/]
LIB,<	MOVM T,PCBAND
	MOVNM T,PCBAND
	MOVM T,PC2BAND
	MOVNM T,PC2BAND
>;LIB
TWO,<	SETZM PCNUM
>;TWO
	SETZM LAYPDL
GETPC1:	SETO T,				;TELL HIM WE WANT PC PART
	JSR GETDPC
	CAIA
	AOS %GETPC
	JRST @%GETPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;SUBRS FOR LIBRASCOPE GETD, GETPC
LIB,<
%PUTLIB:0
	MOVE T,.JBREL
	SUBI T,LAYBEG-1
	CAILE T,=76*2000
	MOVEI T,=76*2000
	JSR ONEBND
	MOVE T,.JBREL
	SUBI T,LAYBEG-1+=76*2000
	JUMPLE T,@%PUTLIB
	ADDI TT,BAND2
	JSR ONEBND
	JRST @%PUTLIB

ONEBND:	0
	MOVEM T,LENGTH(TT)
	SKIPL T,BAND(TT)
	JRST GOTDBN
NODBN:	MOVM T,BAND(TT)
	UFBGIV T,
	MOVM T,BAND(TT)
	UFBGET T,
	JSR NOBAND
	MOVMS T,BAND(TT)
GOTDBN:	FBWRT T,DLOC(TT)
	JRST NODBN
	FBWAIT
	UFBERR
	JRST NODBN
	JRST @ONEBND		;DONE!

NOBAND:	0
	OUTSTR[ASCIZ/NO FAST BANDS, CONTINUE TO TRY AGAIN
/]
	SOS NOBAND
	SOS NOBAND
	HALT @NOBAND

%GETLIB:0
	SKIPGE T,BAND(TT)
	JRST @%GETLIB
	AOS %GETLIB
	JSR GETBND
	JRST @%GETLIB
	SKIPG LENGTH+BAND2(TT)
	JRST GETLDN
	ADDI TT,BAND2
	MOVE T,BAND(TT)
	JSR GETBND
	JRST @%GETLIB
GETLDN:	AOS %GETLIB
	JRST @%GETLIB

GETBND:	0
%GETL1:	MOVE TTT,LENGTH(TT)
	ADD TTT,DLOC(TT)
	SUBI TTT,1
	CORE TTT,
	JRST [	JSR NOCORE
		JRST %GETL1]
	FBREAD T,DLOC(TT)
	JRST [	OUTSTR[ASCIZ/FAST-BAND READ ERROR!
/]
		JRST @GETBND]
	FBWAIT
	UFBERR
	JRST @GETBND
	AOS GETBND
	JRST @GETBND
>;LIB
                                                                                                                                                               ;GET OTHER PART FROM FILE
GETDPC:	0
	CAME T,SWHICH			;DO WE WANT THE ONE AT THE END?
	TDZA T,T			;NO, GET FRONT ONE
	SETO T,				;YES, GET END ONE
	MOVEM T,SWHCHA
	MOVE T,[SSSNAM,,FILNAM]
	BLT T,FILPPN
	INIT IOLAY,17
	'DSK   '
	0
	JRST NOFIL
PGFIL:	OUTSTR[ASCIZ/GETTING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP IOLAY,FILNAM
	JRST [	OUTSTR[ASCIZ/, LOOKUP FAILED, ANOTHER /]
		MOVEM P,TPDL
		MOVE P,[IOWD TPDLLN,TPDL]
		PUSH P,(P)
		PUSHJ P,PUSHIT	;SAVE EVERYONE
		PUSHJ P,DMPNAM
		SETZM FILNAM
		PUSHJ P,POPIT
		POP P,P
		SKIPN FILNAM
		JRST NOFIL
		JRST PGFIL]
DEC,<	JSR IOLAY,LOOKCK	>;DETERMINE REAL PPN
	SKIPE SWHCHA		;WHICH PART DO WE WANT
	JRST ENDP
	MTAPE IOLAY,RDOFF	;GET OFFSET
	MOVN T,OFFSET
	USETI IOLAY,1(T)
	MOVE T,OFFSET
	LSH T,7
LIB,<	MOVEI TT,LAY1S
	ANDI TT,177
>;LIB
TWO,<	SETZ TT,	>
	JRST FRONTP

ENDP:
TWO,<
	MOVE T,[-200,,TJOBDA-1]
	MOVEI TT,0
	INPUT IOLAY,T
	MOVE T,TJOBDA-.JBSAV-1+HILOC	;GET STARTING FILE ADDRESS OF UPPER
	MOVE TT,T
	LSH T,-7
	USETI IOLAY,1(T)
>;TWO
LIB,<	MOVEI T,LAY1S-.JBSAV-1+200
	LSH T,-7		;MAKE RECORD NUMBER
	USETI IOLAY,(T)
>;LIB
	HLRO T,FILPPN
	MOVN T,T		;POS LENGTH OF FILE
LIB,<	MOVEI T,LAY1S-.JBSAV-1+200	>
	ANDCMI TT,177		;GET FIRST WORD WE WILL READ
FRONTP:	SUBB T,TT		;NUMBER OF WORDS TO READ!
LIB,<	ADDI TT,LAYBEG-1		;THIS IS HOW MUCH ROOM WE NEED
	CORE TT,
>;LIB
TWO,<
	ADDI TT,400000-1
	CORE2 TT,
>;TWO
	JRST NOFIL
	MOVN T,T
	MOVS T,T
LIB,<	HRRI T,LAYBEG-1>
TWO,<	HRRI T,400000-1>
	SETZ TT,
	IN IOLAY,T
	CAIA
	JRST NOFIL
LIB,<	SKIPN SWHCHA
	JRST GOTDPC
	MOVEI T,LAYBEG-74
	ANDI T,177		;HOW MUCH TO BLT DOWN
	JUMPE T,GOTDPC
	MOVE TT,.JBREL
	SUB TT,T
	MOVS T,T
	ADD T,[LAYBEG,,LAYBEG]
	BLT T,(TT)
>;LIB
GOTDPC:	AOS GETDPC
	OUTSTR[ASCIZ/
/]
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	RELEASE IOLAY,
	JRST @GETDPC

NOFIL:	OUTSTR[ASCIZ/COULDN'T GET DISK FILE!
/]
	RELEASE IOLAY,
	JRST @GETDPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;SUBRS TO SAVE LAYOUT VERSIONS!
ISAVE:	0
	MOVE T,ISAVE
	MOVEM T,SVFRST
LIB,<	MOVEI T,LAY2S-1
	MOVEM T,IWD
	SKIPN T,.JBSYM
	JRST [	MOVNI TT,LAY2E
		JRST NOSYMS]
	HLRE TT,T
	SUBI TT,(T)
NOSYMS:	TRZ TT,177		;ROUND UP TO MULTIPLE OF 200 WORDS SO GET WON'T LOSE
	ADDI TT,LAY2S
	HRLM TT,IWD
>;LIB
TWO,<	MOVE TT,[LAY2S-LAY2E,,LAY2S-1]	;IOWD FOR SECOND PROGRAM (PC)
	MOVEM TT,IWD
>;TWO
	JRST ISAVE1

SVFRST:	0
	MOVEI T,LAYBEG-1
	MOVEM T,IWD
LIB,<	MOVN T,.JBREL	>
TWO,<	HRRZ T,.JBHRL
	MOVN T,T
>;TWO
	ADDI T,LAYBEG-1
	HRLM T,IWD
ISAVE1:	OUTSTR[ASCIZ/SAVING /]
	MOVEI A,DPCNAM
	JSR FPRINT
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/, CAN'T GET DISK!
/]
		HALT SVFRST+1]
	MOVE T,[DPCNAM,,FILNAM]
	BLT T,FILPPN
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED, YOU LOSE!
/]
		JRST SVQTF]
	MOVE T,IWD
	SETZ TT,
	OUT DAT,T		;POOT OUT FIRST PART
	JRST OUTOK
	OUTSTR[ASCIZ/, OUTPUT ERROR!
/]
SVQTF:	RELEASE DAT,3
	JRST @SVFRST

OUTOK:	UGETF DAT,NEWOFF	;GET EOF+1
	MTAPE DAT,WRTOFF	;SET IT IN FILE
	JRST [	OUTSTR[ASCIZ/, MTAPE TO SET RECORD OFFSET FAILED!
/]
		JRST SVQTF]
	USETO DAT,1		;GET TO NEW END(BEGINNING)
	AOS SVFRST
	JRST @SVFRST		;SO FAR SO GOOD
>;LAY

HINAME__134			;UPPER SEGMENT NAME
HILOC__135			;LOC OF UPPER SEGMENT AFTER INPUT FROM DMP FILE

SVREST:	0
NOLAY,<
	OUTSTR[ASCIZ/SAVING /]
	MOVEI A,DPCNAM
	JSR FPRINT
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		HALT SVREST+1]
	MOVE T,[DPCNAM,,FILNAM]
	BLT T,FILPPN
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED, YOU LOSE!
/]
		JRST SVQUIT]
>;NOLAY
LAY,<	MOVE T,SWHCHS
	EXCH T,SWHICH
	MOVEM T,SWHCHS
>;LAY
	MOVE T,[.JBSAV+1,,TJOBDA]
	BLT T,TJOBDA+177	;SETUP A PSUEDO JOB DATA AREA
	MOVE T,STRTLC
	HRRM T,TJOBDA-.JBSAV-1+.JBSA	;STORE PLACE FOR IT TO START
	MOVE T,.JB41
	MOVEM T,TJOBDA-.JBSAV-1+.JBS41
	SETZM TJOBDA-.JBSAV-1+.JBCOR	;ALWAYS USE SIZE OF FILE
	SETZM TJOBDA-.JBSAV-1+HINAME	;ALWAYS 0 HINAME (EVEN FOR SEGMENTS)
NOTWO,<
	SETZM TJOBDA-.JBSAV-1+HILOC
>;NOTWO
TWO,<	MOVE T,.JBREL
	SUBI T,.JBSAV+1
	IORI T,177
	ADD T,[400000,,.JBSAV+2]	;THIS IS WHAT GET WANTS TO SEE
	MOVEM T,TJOBDA-.JBSAV-1+HILOC	;WRITE PROTECT THE UPPER, START UP UNPURIFIES IT
					;TO MAKE SURE TWO L JOBS GET DIFFERENT UPPERS
>;TWO
	MOVE T,[IOWD 200,TJOBDA]
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR FOR JOB DATA AREA!
/]
		JRST SVQUIT]
	MOVEI T,.JBSAV+1+200-1		;START OUTPUT HERE (-1 FOR IOWD)
	MOVN TT,.JBREL
	ADD TT,T
	HRL T,TT
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR ON LOW CORE WRITE!
/]
		JRST SVQUIT]
TWO,<	HRRZ TT,.JBHRL
	MOVN TT,TT
	MOVEI T,400000-1
	ADD TT,T
	HRL T,TT
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR ON HIGH CORE WRITE!
/]
		JRST SVQUIT]
>;TWO
	RELEASE DAT,
	AOS SVREST
	JRST @SVREST

SVQUIT:	RELEASE DAT,3			;FLUSH FILE
LAY,<	MOVE T,SWHCHS
	MOVEM T,SWHICH
>;LAY
	JRST @SVREST
                                                                                                                                                                                                                                         ;DMP FILENAME SCANNER
LAY,<
DMPNAM:	MOVSI T,'DMP'
	MOVEM T,FILEXT
	SETZB T,FILEXT+1	;CLEAR THIS WORD
	DSKPPN T,		;HIS OWN PPN
	MOVEM T,FILPPN
	OUTSTR [ASCIZ/DMP FILENAME?/]
NOITS,<	PUSHJ P,GETWRD	>	;SCAN FILENAME
ITS,<	PUSHJ P,GETNAM	>	;SCAN FILENAME
	CAIN C,12
	JUMPE T,CPOPJ		;LET HIM OUT IF HE TYPES NOTHING
NOITS,<
	MOVEM T,FILNAM		;SAVE FILENAME
	CAIN C,"["		;ANY EXTENSION?
	JRST NOEXT		;NO
	CAIN C,12
	JRST NOEXT		;NO
	CAIE C,"."
	JRST [	ILLNAM:	OUTSTR[ASCIZ/INPUT ERROR!
/]
			CLRBFI
			JRST DMPNAM]
	PUSHJ P,GETWRD		;SCAN EXTENSION
	HLLZM T,FILEXT		;SAVE IT.
NOEXT:	CAIN C,12		;HERE TO SCAN PPN
	JRST CPOPJ1		;LEAVE NOW
	CAIE C,"["
	JRST ILLNAM		;MUST BE [
	PUSHJ P,GETWRD		;SCAN P.
	JUMPE T,ILLNAM
	PUSHJ P,RJUST
	HRLZM T,FILPPN		;AND SAVE
	CAIE C,","		;BETTER BE COMMA
	JRST NOPRG
	PUSHJ P,GETWRD		;SCAN PN.
	JUMPE T,ILLNAM
	PUSHJ P,RJUST
	HRRM T,FILPPN		;AND SAVE
NOPRG:	SETZ T,
	CAIN C,"]"		;BETTER END WITH THIS
	PUSHJ P,GETWRD		;MAKE SURE HE DIDN'T TYPE TO MUCH
	JUMPN T,ILLNAM		;LOSE IF HE DID
	CAIE C,12
	JRST ILLNAM		;DIDN'T END WITH LF
	JRST CPOPJ1
>;NOITS
ITS,<
	CAIE C,";"
	JRST NOLST1
	MOVEM T,FILPPN
	PUSHJ P,GETNAM
	JUMPE T,CPOPJ	;STILL NOT REASONABLE
NOLST1:	CAIE C,40
	CAIN C,12
	SKIPA
	JRST [	ILLNAM:	OUTSTR[ASCIZ/INPUT ERROR!
/]
			CLRBFI
			JRST NAMCON]
	MOVEM T,FILNAM
	CAIN C,12
	JRST CPOPJ1	;DONE
	PUSHJ P,GETNAM	;GET SECOND FILE NAME
	CAIE C,12
	JRST ILLNAM	;EXTRA GARBAGE AT END
	JUMPE T,ILLNAM
	MOVEM T,FILEXT
	JRST CPOPJ1
>;ITS

RJUST:	TRZ T,-1		;THREE LETTERS ONLY
	CAIA
	LSH T,-6
	TRNN T,77		;RIGHT JUSTIFIED YET?
	JRST .-2		;NO
	POPJ P,
	
NOITS,<
GETWRD:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
CHRGET:	PUSHJ P,TTYIN		;READ A CHAR
ISCHRX:	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST CHRGET
	CAIL C,"0"		;NUMBERS ARE LEGAL
	CAILE C,"9"
	CAIA
	JRST CHROK
	CAILE C,"z"
	POPJ P,			;BREAK CHAR.
	CAIL C,"a"
	SUBI C,40		;CHANGE LOWER CASE TO UPPER
	CAIL C,"A"		;NOW ONLY UPPER CASE LETTERS ARE LEGAL
	CAILE C,"Z"
	POPJ P,			;BREAK
CHROK:	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST CHRGET
>;NOITS

;ITS NAME SCANNER
ITS,<
GETNAM:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
GETNM1:	PUSHJ P,TTYIN		;READ A CHAR
	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST GETNM1
	SKIPA
GETNM2:	PUSHJ P,TTYIN
	CAIN C,15
	JRST GETNM2
	CAIL C,"a"
	CAILE C,"z"
	CAIA
	SUBI C,40		;LOWERCASE
	CAILE C,40		;BREAK ON SPACE
	CAILE C,"_"
	POPJ P,			;NOT SIXBIT CHARACTER
	CAIE C,";"
	CAIN C,":"
	POPJ P,
	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST GETNM2
>;ITS

TTYIN:	INCHWL C
	ANDI C,177
	CAIN C,15
	JRST TTYIN
	POPJ P,
>;LAY
>;NODEC
                                                                                                                                                                                                                                                                                                                           ;PUSHIT, POPIT
STORAGE(IMPURE)
FPRINT:	0
ITS,<	MOVE TTT,3(A)
	JSP T,.SIXP
	OUTCHR[";"]
>;ITS
	MOVE TTT,(A)
	JSP T,.SIXP
NOITS,<	OUTCHR["."]	>
ITS,<	OUTCHR[" "]	>
	HLLZ TTT,1(A)
	JSP T,.SIXP
NOITS,<
DEC,<	SKIPN 3(A)
	JRST @FPRINT
FPPPN:
>;DEC
	OUTCHR["["]
NOCMU,<
	HLLZ TTT,3(A)
	JSP T,.SIXPL
	OUTCHR[","]
	HRLZ TTT,3(A)
	JSP T,.SIXPL
>;NOCMU
CMU,<
	SKIPN TTT,3(A)
	DSKPPN TTT,
	MOVE T,[TTT,,PPNBUF]
	DECCMU T,
	JRST [	JSP T,.SIXPL	;IF DECCMU BLETCHES, SIXPRINT IT
		JRST PPNDON ]
	OUTSTR PPNBUF
PPNDON:
>;CMU
	OUTCHR ["]"]
>;NOITS
	JRST @FPRINT

LOOKRR:	RELEASE DAT,
LOOKER:	HRRZ T,1(A)
	OUTSTR[ASCIZ/, /]
	CAIL T,LOKLEN
	MOVEI T,ULSERR
	OUTSTR @LOKETB(T)
	OUTSTR[ASCIZ/.
/]
NOLAY,<	JRST LERRET	>
LAY,<	JRST .LERRET	>

LOKETB:	[ASCIZ/FILE NOT FOUND/]
	[ASCIZ/ILLEGAL PPN/]
	[ASCIZ/PROTECTION FAILURE/]
	[ASCIZ/FILE IN USE/]
ULSERR__.-LOKETB
	[ASCIZ/UNKNOWN LOOKUP STATUS/]
	[ASCIZ/DATA TRANSMISSION ERROR/]
LOKLEN__.-LOKETB

DEC,<
LOOKCK:	0
	JUMPE T,ANYPPN
	MOVEM T,3(A)		;SAVE AWAY HERE FOR NOW
	MOVE TTT,[3,,T]
	MOVE T,LOOKCK
	LDB T,[POINT 4,-1(T),12]	;GET CHANNEL #
	PATH TTT,
	DSKPPN TTT,		;PATH LOSES, GET USER PPN
	CAMN TTT,3(A)		;IS THIS FILE'S ORIGIN DIFFERENT THAN REQUESTED?
	JRST @LOOKCK		;NO, WIN
	SOS LOOKCK
	SOS LOOKCK
	HLLZS 1(A)		;MAKE IT FILE NOT FOUND
	JRST @LOOKCK		;THIS HAD BETTER RETURN TO LOOKUP ERROR FOR LOOKUP UUO

ANYPPN:	MOVE TTT,[3,,T]
	MOVE T,LOOKCK
	LDB T,[POINT 4,-1(T),12]	;GET CHANNEL #
	PATH TTT,
	DSKPPN TTT,		;PATH LOSES, GET USER PPN
	MOVEM TTT,3(A)		;AND STORE
	MOVE T,LOOKCK
	MOVEM T,FPRINT		;TELL HIM WHERE TO GO
	JRST FPPPN		;NOW PRINT PPN AND RETURN
>;DEC

.SIXPL:
NODEC,<
	TLNN TTT,777700
	LSH TTT,14
	TLNN TTT,770000
	LSH TTT,6
>;NODEC
DEC,<
	MOVE	TT,TTT
	JUMPE	TT,(T)
	TRO	TT,400000
	ROT	TT,3
	TRNN	TT,7
	JRST	.-2
.SIXP2:	TRZ	TT,777770
	ADDI	TT,"0"
	OUTCHR TT
	ROT	TT,3
	TLNE	TT,-1
	JRST	.SIXP2
	JRST	(T)
>;DEC

.SIXP:	JUMPE TTT,(T)
	SETZ TT,
	LSHC TT,6
	ADDI TT,40
	OUTCHR TT
	JRST .SIXP

PGP,<
POPALL:	SKIPE	$VAL	;ANY ERROR OCCURED?
	PUSHJ	P,PGPERR;YES, PRINT MESSAGE
	POP	P,0	;GET RETURN ADR
	EXCH	0,-17(P);RESTORE 0, SAVE RETURN ADR
	PUSHJ	P,POPIT	;RESTORE ACS 2-17
	MOVEI	1,INTBLK;ENABLE CTRL C INTERCEPT
	MOVEM	1,.JBINT
	POP	P,1	;RESTORE 1
	POPJ	P,

PUSHAL:	SETZM	.JBINT	;DISABLE CTRL C INTERCEPT DURING PGP CODE
	SETZM	$VAL	;CLEAR ERROR ACCUMULATION
	EXCH	0,(P)	;SAVE 0 AND GET RETURN
	PUSH	P,1	;SAVE 1
	PUSH	P,0	;SAVE RETURN ADR
	MOVE	0,-2(P)	;RESTORE 0
>;PGP
;ONLY SAVE AC'S 2-17
PUSHIT:EXCH 2,(P)	;SAVE 2 AND GET RETURN.
	MOVEM 2,16(P)	;GEE, THIS WAY WE RETURN WITH A POPJ
	MOVEI 2,1(P)
	HRLI 2,3
	BLT 2,15(P)
	MOVE 2,(P)	;RESTORE 2
	ADD P,[XWD 16,16]
	POPJ P,		;RETURN TO SENDER

;ONLY RESTORES AC'S 2-17
POPIT:	MOVSI 17,-15(P)
	HRRI 17,3
	BLT 17,17
	MOVE 2,16(P)
	EXCH 2,(P)
	POPJ P,
                                                                                                                                                                                                                                                                                                               STORAGE(IMPURE)
VAR
;STORAGE(PURE)		;FLUSHED SINCE THE PHASE HASN'T HAPPENED YET (SEE LOWCOR)
LIT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         COMMENT    VALID 00013 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	<DRAW>LOWCOR.FAI116, 29-JUL-75 17:39:46, EDIT BY HELLIWELL
C00003 00003	VECTOR
C00005 00004	DEFINITIONS OF RANDOM PARAMETERS
C00010 00005	FILE EXTENSIONS
C00014 00006	AC 0 FLAG BITS
C00016 00007	AC M FLAG BITS
C00019 00008	PIN, BODY, LIBRARY, DEF AND NAMED MACRO BITS
C00024 00009	MACROS -- GETFS,FSTRET,SCALE,SCALET,UNSCALE,ADJUST,SWITCH
C00027 00010	MODES:
C00029 00011	DATA IN BOTH
C00035 00012	DATA IN ONE OR OTHER
C00041 00013	DIP BODY DEFS (PC), BOX TABLES (D)
C00045 ENDMK
C;
                                                         ;<DRAW>LOWCOR.FAI;116, 29-JUL-75 17:39:46, EDIT BY HELLIWELL
VERSION(LOWCOR,6)
;ASSEMBLY SWITCHES
LAY,<
PASS1,<PCSW__0>
PASS2,<PCSW__1>
>;LAY

PCSW__PCSW

LAY,<
MD,<BEGIN D>
MPC,<BEGIN PC>
>;LAY

MPC,<SID_13>

;TURN SOME THINGS OFF IN CURRENT BLOCK
MPC,<
DEFINE PART<REPEAT 0>
DEFINE NOPART<REPEAT 0>
>;MPC
MD,<
DEFINE SHORT<REPEAT 0>
DEFINE NOSHORT<REPEAT 0>
DEFINE WAG<REPEAT 0>
DEFINE NOWAG<REPEAT 0>
>;MD
                                                                                                                                                                                                        ;VECTOR
STORAGE(PURE)
DEFINE VECVAL(ADDR,VALUE)
<
PASS1,<^ADDR:>JRST VALUE
>

LAY,<

TWO,<PASS1,<^^LAYBEG:>>

PASS1,<^^LAY1S:>
PASS2,<^^LAY2S:>

TWO,<
PHASE 400000
>;TWO

LIB,<PASS1,<^^LAYBEG:>>

LIB,<
PASS2,<
GLOBAL LAYBEG
PHASE LAYBEG
>;PASS2
>;LIB

	VECVAL	LAYSYM,0		;SYMBOL TABLE POINTER IN THIS HALF
	VECVAL	.STRT,STRT		;NORMAL START
	VECVAL	.STRTL,STRTL		;START ONE SIDE
	VECVAL	SCRSET,DSPOUT		;DISPLAY UPDATE
	VECVAL	.CONT,CNTSAV		;CONTINUE LOC
	VECVAL	.BLCHK,BLCHK		;BLINK CHECK
	VECVAL	.NOFST,NOFSTA		;GETFS
	VECVAL	REENTER,%R		;REE
	VECVAL	.LERRET,LERRET		;LOOKUP ERROR RETURN
	VECVAL	.UUOCON,%UUOCON		;UUO'S
>;LAY
NOLAY,<
.NOFST:	JRST NOFSTA
REENTER:JRST %R
.UUOCON:JRST %UUOCON
>;NOLAY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;DEFINITIONS OF RANDOM PARAMETERS

MD,<
;NULL DIP NAME (BODY FOR VISUAL EFFECT ONLY!)
NULNAM__<ASCIZ/*/>
CABNAM__<ASCIZ/CABLE/>	;ALSO FORCES SIGNAL NAME "\C\" ON WIRE


;DRAWING SIZES ***********
;A	8.5 X 11
AH__=8500
AW__=11000
LABH__=1000	;HEIGHT OF REGULAR LABEL BOX

;X	8.5 X 11 WITH SMALLER LABEL BOX
XH__=8500
XW__=11000
LABX__=300	;HEIGHT OF XGP LABEL BOX

;B	11 X 17
BH__=11000
BW__=17000

;C	17 X 22
CH__=17000
CW__=22000

;D	22 X 34
DH__=22000
DW__=34000
;E	34 X 44
EH__=34000
EW__=44000
>;MD

;MAX STRING LENGTH IN WORDS FOR PERMUT
MXSTLN__=500/5

;BITS RETURNED BY PERMUT IN SAVBIT
GLB1__1		;1 UP ARROW
GLB2__2		;2 UP ARROWS
SGND__4		;GND
SPWR__10	;VCC
SHI__20		;+3
SNC__40		;NC

MPC,<
;MAX PAD TYPE NUMBER THAT DOESN'T PRINT ON INPUT OR OUTPUT
STDMAX__3	;TYPE 3 FOR NOW

;1/2 THE WIDTH OF A CONNECTOR FINGER IN MILS
FWIDTH__=40

WAG,<
;ROUTER SPECIFICATIONS
ROUSCL__=20		;ROUTER HAS 50 MIL RESOLUTION
SIDDIF__=256		;THIS NUMBER IS THE DIFFERENCE BETWEEN SIDES
ROUXMT__=255		;MAXIMUM X VALUE (PER SIDE)
ROUXMM__=128		;OFFSET IN X (BECAUSE CENTER OF BOARD IS 0,0)
ROUXMB__2		;MINIMUM X VALUE
NODEC,<
ROUYMT__=199		;MAX Y VALUE
ROUYMM__=100		;OFFSET IN Y
>;NODEC
DEC,<
ROUYMT__=319
ROUYMM__=160
>;DEC
ROUYMB__2		;MINIMUM Y VALUE
ROUANY__ROUYMT+2	;SPECIFIES "ANY" PIN ON THIS EDGE
NEVERC__=1023		;SIGNAL # SPECIFIES NEVER CONNECT HERE
LCEDGE__=6		;FUDGE FOR LEFT CONNECTOR EDGE
NODEC,<RCEDGE__=243	>	;FUDGE FOR RIGHT CONNECTOR EDGE
DEC,<RCEDGE__=205	>
>;WAG
>;MPC

ROUTE,<
BYTSIZ__2		;USE 2 BIT BYTES FOR NOW!
%GRAIN__=50/5*2
%SEPAR__=50/5*2		;50 MILS MINIMUM BETWEEN WIRES!

%STEP__%SEPAR/%GRAIN

%XSIZ__=11000/5*2		;10 INCHES BY
%YSIZ__=16000/5*2		;16 INCHES

%ROW__%XSIZ/(%GRAIN*(=36/BYTSIZ))+1	;# OF WORDS PER ROW

%XCEN__=%XSIZ/2
%YCEN__%YSIZ/2			;CENTER OF ARRAY
;HERE WE SET THE WEIGHTING FACTORS FOR DIFFERENT ROUTINGS!

%CNR__3		;CORNER COST
%FED__3		;FEED THROUGH COST
%BAK__2		;GOING AWAY FROM POINT COST
%SID__2		;ONE STEP ON WRONG SIDE COST
>;ROUTE


UML,<
;TYPE BITS FOUND IN LEFT HALF OF SECOND WORD
;OF WIRE HEADER IN WIRLST
INLD__400000		;INPUT LOAD
OUTLD__200000		;OUTPUT LOAD
NULLD__100000		;NO LOADING AT PRESENT
GND__40000		;GROUND CONNECTION
PWR__20000		;POWER CONNECTION
TRI__10000		;TRI-STATE OUTPUT
SHARE__4000		;SHARE INPUT LOAD BIT
OPENC__2000		;OPEN COLLECTOR OUTPUT
PULL__1000		;THIS OUTPUT IS A PULLUP

CBACK__2		;INTERNAL HEADER BIT FOR BACK STRAP CONNECTOR
CFRONT__1		;INTERNAL HEADER BIT FOR BACK PANEL CONNECTOR
>;UML
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;FILE EXTENSIONS
;DEFAULT DISK FILE EXTENSIONS & IO VERSION NUMBERS FOR MAINTAINING CONSISTENCY

MD,<IOVER__25>
MPC,<IOVER__21>

;IOVBRD AND MODIOV ARE DEFINED HERE BECAUSE JARVIS FUCKED UP AND USED IOVER 21
;TO INTRODUCE THE BOARD TYPE WHILE HELLIWELL WAS  USING THE SAME IOVER FOR THE
;NEW MODULE AND REVISION STUFF.  SINCE NO DRW FILES EXIST AT ITS WITH IOVER 22
;THE FOLLOWING KLUDGE WORKS.

ITS,<	BRDIOV__21	MODIOV__23	>
NOITS,<	BRDIOV__21	MODIOV__21	>

MD,<
EXTFIL__<'DRW'>			;DRAWING FILES
EXTEWR__EXTFIL			;EXTENSION FOR EWRITE COMMAND
CMU,<	EXTEWR__<'DRX'> >	;DON'T CLOBBER ORIGINAL IN AUTO EWRITE!
EXTLIB__EXTFIL			;LIBRARY SAME AS DRAWING
EXTBDL__<'LST'>			;BODY DEF LISTING
EXTDIP__<'DIP'>			;DIP DEF FILE
	DIPVER__3		;DIP FILE VERSION NUMBER
EXTWIR__<'WD '>			;WIRE LIST FILES
	WDVER__13	;WD
NODEC,<
EXTPLT__<'PLT'>			;PLOT FILES
>;NODEC
DEC,<
EXTPLT__<'DPL'>			;DEC ALREADY USES PLT
>;DEC
	PLTVER__13	;PLT
EXTPAR__<'DAT'>			;PARTITION OUTPUT FILE
EXTUML__<'UML'>			;UML INPUT FILE
EXTCHG__<'CHG'>			;CHG INPUT FILE
EXTCPN__<'CPN'>			;CPN INPUT FILE
>;MD
MPC,<
EXTFIL__<'PC '>			;DRAWING FILES
EXTEWR__EXTFIL			;EXTENSION FOR EWRITE COMMAND
CMU,<	EXTEWR__<'PD '> >	;DON'T CLOBBER ORIGINAL IN AUTO EWRITE
EXTWIR__<'WPC'>			;WIRE LIST FILES
	WPCVER__400002	;WPC
EXTPLT__<'PCP'>			;PLOT FILES
	PCPVER__5	;PCP
EXTROU__<'DAT'>			;ROUTER DATA FILES
EXTCRD__<'CRD'>			;EXTENSION FOR PC CARD DEFS
	CRDVER__1		;CRD FILE VERSION NUMBER
>;MPC
UML,<
EXTWDR__<'WDR'>			;DRW WIRE LIST FOR ROUTER GENERATION
	WDRVER__1	;WDR
MD,<
EXTLES__<'LES'>			;LOGIC ERROR SUMMARY FROM WL
	LESVER__1	;LES
		LESWIR__1	;CODE FOR WIRES IN LOGIC ERROR SUMMARY
>;MD
>;UML
EXTSIG__<'SIG'>			;SIGNATURE FILE EXTENTSION
EXTSAV__<'DMP'>			;SAVE FILES
EXTDSK__<'TXT'>			;DISK INPUT/OUTPUT
EXTMCR__<'MCR'>			;MACRO FILE EXTENSION

IFN <WAGSW&UMLSW>!PARTSW,<
DATNAM__<'FOR20 '>		;FORTRAN FILENAME (FOR OUTPT)
IPNNAM__<'FOR23 '>		;IPINS FILENAME DEFAULT
>;....
WAG,<
STRTWR__<'WIRE@ '>		;FIRST WIRE FILE -1
>;WAG
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;AC 0 FLAG BITS

;RIGHT HALF:::

ATFP__1		;EDIT INSERT IS AT THE FIRST POINT
ATLP__2		; "	"     "	 "  "  LAST POINT
TYPNEG__4	; - TYPED LAST IN EDIT INSERT
TFLG__10	;TEMPORARY FLAG
MCHG__20	;MAIN PICTURE CHANGED -- REDISPLAY IT
INLIN__40	;POINT MODE IS MAKING LINES
ZIGZAG__100	;WHICH WAY THE LINES GO FOLLOWING THE CURSOR
INMOV__200	;WE ARE MOVING SOMETHING (A POINT OR A BODY)
STBOX__400	;WE ARE DRAWING A SETBOX(NO OTHER SET COMMANDS ARE LEGAL)
MAKSET__1000		;USED IN DREAD TO MAKE SET OF APPENDED PIC
VIRGIN__2000		;USED IN DREAD TO INDICATE FIRST PIC
NEEDCL__4000		;NEED TO FIND CLOSEST AGAIN REGARDLESS OF LSTCUR
TMOVE__10000		;SPECIAL, MOVING TEXT OFFSET
BRDINH__20000		;DON'T SET BOARD TYPE WHILE SEARCHING FOR BODY IN LIBRARY
MPC,<
BTHSDS__400000		;DISPLAYING BOTH SIDES OF PC CARD
>;MPC
MD,<
LMOVE__200000		;SPECIAL, MOVING LOCATION OFFSET
>;MD
FSTLIB__400000		;TOP LEVEL LIBRARY, NAME WILL BE PUT ON LIST

;LEFT HALF
ASK__1		;TEMP FLAG IN VARIOUS ROUTINES
WFLAG__2	;		"
NOINIT__4	;SUPPRESS CALLING OF INIT MACRO ON READIN
IGNORE__10	;DOING DEFINITION OR FALSE PART OF ;F
LOCATE__20	;PUT LOCATOR LINES FROM BIG CHAR
DSPOFF__40	;DISPLAY PACKAGE IS CURRENTLY OFF SCREEN
DSPACT__100	;WE ARE CURRENTLY DISPLAYING (COMBINATION OF FLAGS)
   ;AC M FLAG BITS

;RIGHT HALF

MD,<
NBTEXT__1		;NO BODY TEXT PLEASE
NOCBOX__2		;NO BOX AROUND CONNECTOR PINS, PLEASE
>;MD
MPC,<
NDIPS__1		;USE BOX, INSTEAD OF PADS
FLIP__2			;INVERTING X
XFEED__4		;SUPPRESS DISPLAYING OF FEEDTHROUGHS
XFINGER__10		;SUPPRESS DISPLAYING OF FINGERS
>;MPC

SEXACT__10000		;EXACT MATCH IN SEARCHES
IFN LAYSW!UMLSW,<
ERRORD__20000		;SUPPRESS DISPLAY OF O_??
>;LAYSW!UMLSW
SPACES__40000		;SPACES ARE SIGNIFICANT
NLINES__100000		;NO LINES
CURSOR__200000		;USING BULLSEYE CURSOR
NPTEXT__400000		;NO POINT TEXT PLEASE


;LEFT HALF

PLOCS__1		;DISPLAY PIN NUMBERS
CLOCS__2		;DIPLAY CONNECTOR PIN LOCS!
BLOCS__4		;DISPLAY BODY LOCATIONS!
MD,<UNHIDE__10	>	;MAKE VISIBLE HIDDEN LOCS/PIN #'S, ETC.
XWINDOW__20		;NOT LIMITED TO SCREEN
MD,<RPINID__40	>	;DISPLAY REAL PINIDS (NUMBERS)
TYPREP__100
TYPNLY__200
LWINDOW__400		;WINDOW LINE SEGMENTS!
DSKFLG__1000		;USING DISK INPUT
DSKACT__2000		;DISK INPUT ACTIVE
MACACT__4000		;MACRO INPUT ACTIVE
%IDENT__10000		;PLOT BODYNAMES AND DIPNAMES ON BODIES
MD,<
PINIDS__40000		;DISPLAY DEFAULT PIN NAMES
JUNC3__100000		;DIAMONDS AT JUNCTION OF 3 LINES
DIAMONDS__200000	;PLOT DIAMONDS
>;MD
MPC,<
ROUTE,<
%ROUTE__40000
RDISP__100000		;DISPLAY BIT ARRAY!
>;ROUTE
CRDISP__200000		;DISPLAY CARD
>;MPC
LCENTER__400000		;CENTER ALL THE BLINKING STUFF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;PIN, BODY, LIBRARY, DEF AND NAMED MACRO BITS


;POINT TYPE BITS

MPC,<FRONT__400000	;PIN ON FRONT SIDE.>
ISPIN__200000		;THIS IS A PIN
MD,<FIXTXT__40000	;FIXING TEXT OFFSET
FIXRHT__20000		;WHEN FIXING MOVE LINE RIGHT
FIXCON__10000		;FIX CONNECTOR TO TEXT
DEFPIN__4000		;RESERVED FOR WD OUTPUT TO INDICATE DEFAULTED PIN NAME (BODY PINS ONLY)
CPNBTS__6000		;BITS FOR TERMINATOR RULES (CPINS ONLY)
	CPNBPS__7	;LOW ORDER BIT POS
	CPNBSZ__2	;# OF BITS
>;MD
MPC,<FEEDTH__40000	;FEED THROUGH
PLANES__34000		;PLANE CONNECTIONS
>;MPC
CPIN__1000		;THIS POINT IS ALSO A CONNECTOR PIN
FOUNDP__20		;BIT FOR FIND
;BITS 14-17 ARE USED AS MARK BITS HERE AND THERE


;BODY BITS
MD,<
L1416__1		;LEFT JUSTIFIED 14 PIN DIP IN 16 PIN SOCKET
R1416__2		;RIGHT	  "	 "  "	"   "  "  "	"
FIXLOC__4		;ALWAYS SET BODY LOC OFFSET FROM DEFINITION
FIXBLO__10		;FIX LOC CHAR OFFSET WHE LOC CHANGES
>;MD
FOUNDB__200000		;BIT FOR FIND
BTMP1__400000		;HIGH ORDER BIT IS MARK BIT FOR SET HACKS


;BODY DEF PIN BITS
MD,<
BUSSED__400000	;THIS IS A BUSSED THROUGH PIN, DON'T SHOW PIN #
;200000 AVAILABLE
FOUNDD__100000	;MARK BIT FOR FLPIN COMMAND
DPTMP1__40000	;TEMP MARK BIT
DPTMP2__20000	;ANOTHER
DEC,<
ASSL__2		;ASSERTION LOW
ASSH__1		;ASSERTION HIGH
>;DEC
DEC,<	BASSLH__BUSSED!ASSL!ASSH>
NODEC,<	BASSLH__BUSSED>
>;MD


;PIN POS FIELD DEFINITIONS
XOFFB__7		;LOW ORDER BIT OF X OFFSET
XOFFW__8		;WIDTH OF X FIELD
YOFFB__=14		;LOW ORDER BIT OF Y OFFSET
YOFFW__7		;WIDTH OF Y FIELD
POSB__=17		;LOW ORDER BIT OF POSITION NUMBER
POSW__3			;WIDTH OF POSITION FIELD


;LIBRARY NAME BLOCK BITS (RT HALF OF FIRST WORD OF SECOND BLOCK)
NEEDMR__400000		;NEED TO READ THIS LIRBARY AGAIN TO GET ALL OF DEFINITIONS
TOPLVL__200000		;THIS MARKS A LIBRARY BLOCK READ AT TOP LEVEL


;TYPE DEFINITION BITS
DTMP1__400000		;TEMPORARY MARK BIT
FOUNDL__200000		;THIS BODY HAS BEEN FOUND BY "FLNAME" OR "FLDIP"
XDISLOC__100000	;DON'T DISPLAY BODY LOC IF TRACKING DEFINITION


;MACRO BITS IN LEFT HALF OF NAMED MACRO HEADER BLOCK FIRST WORD
MSAVE__400000		;SAVE THIS MACRO IN DRW OR PC FILE
MACTMP__1		;TEMPORARY MARK BIT


;BITS IN RUNBIT WRITTEN INTO 'WD' FILE.
CABBDY__1		;"CABLE" BODY SEEN ON RUN. (MUST BE SAME AS BIT IN WL)


;PIECE OF GLASS ASSIGNMENTS
ANGLPG__1	;FOR DRAWING RIGHT ANGLES AND ALTER MODE ARROW
BIGPG__2	;FOR PUTTING OUT BIG B OR P OR S OR L
BLPG__3		;BLINKER PAGE!
MAINPG__4	;MAIN DISPLAY PAGE


;SOME RANDOM TABLE LENGTHS
MPDLEN__100
LHASHP__400	;POINT HASH TABLE (POWER OF TWO)
LHASHB__100	;BODY HASH TABLE (ALSO POWER OF TWO)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;MACROS -- GETFS,FSTRET,SCALE,SCALET,UNSCALE,ADJUST,SWITCH
MD,<PDLEN__2000>
MPC,<PDLEN__5000>
;CHECK FOR INPUT DURING DISPLAYING
DEFINE	CHECKIN
<	XCT CINST
	CAIA
	JRST CHARIN
>

;UPDATE PROGRESS THROUGH DISPLAY ROUTINES
DEFINE SOFAR
<	JSR DSPDSP
	CHECKIN
>

GDP,<
DEFINE XSOFAR
		;CMU MAGIC
<	MOVEM C,CHKSVC
	XCT CINST
	CAIA
	PUSHJ P,XCHRIN
>
>;GDP

;GET FREE STORAGE
	DEFINE GETFS (A)
<	SKIPN A,@FSTPNT
	JSR NOFST
	EXCH A,FSTPNT
>

;RETURN FREE STORAGE
	DEFINE FSTRET (A)
<	HLLI A,
	EXCH A,FSTPNT
	HRRZM A,@FSTPNT>

;CONVERT FROM INTERNAL X,Y TO III X,Y
	DEFINE SCALE (AC)
<	IMUL AC,NSCALE
MPC,<	ASH AC,-4	>
MD,<	ASH AC,-2	>
>

;CONVERT FROM INTERNAL X,Y TO P (OR PCP) X,Y
	DEFINE SCALET (AC)
<	IMUL AC,NSCALE
	ASH AC,1
>

;CONVERT FROM III X,Y TO INTERNAL X,Y
	DEFINE UNSCAL (AC)
<
IFDIF<AC><T>
<	PUSH P,T
	MOVE T,AC
>
	PUSHJ P,%UNSCAL
IFDIF<AC><T>
<	MOVE AC,T
	POP P,T
>
>

;ADD 2 HALFWORD X,Y'S (LOW ORDER BIT OFF)
	DEFINE ADJUST(OP,AC,M)
<	IFIDN <OP><SUB><TLO AC,1>
	OP AC,M
	TLZ AC,1
>

;SWITCH SIDES OF PC CARD
	DEFINE SWITCH
<	PUSHJ P,%SWITCH
>
MPC,<
	DEFINE FSWITCH
<
	MOVE T,PHASHP
	EXCH T,PHASH2
	MOVEM T,PHASHP
	SWITCH
>
>;MPC
MD,<DEFINE FSWITCH<SWITCH>>

MD,<
;HERE IS HOW WE HIDE THE PIN NUMBER OFFSET STUFF IN THE X,Y WORD

PXOFF__4000		;JUST GOBBLE 6 BITS FOR NOW
PYOFF__4000
PXMASK__PXOFF*2-1
PYMASK__PYOFF*2-1

DEFINE PXY(AC)
<	AND AC,[PXMASK,,PYMASK]
	TLO AC,1
	SUB AC,[PXOFF,,PYOFF]
	TLZ AC,1
>

DEFINE NXY(AC)
<	ROT AC,4
	ANDI AC,17
>

>;MD
                                                                                                                                                                                                                                                                                                                                                            ;MODES:

DEFINE SM(A)
<	A__%MODE
%MODE__%MODE+1
>
%MODE__0

;OUTER (DRAW) LEVEL AND SET MODE
SM	SETM
;OUTER (DRAW) LEVEL AND BODY MODE
SM	BODM
;OUTER (DRAW) LEVEL AND POINT MODE
SM	PNTM
;OUTER (DRAW) LEVEL AND LINE MODE
SM	LINM
;OUTER (DRAW) LEVEL AND POINT TEXT MODE!
SM	TXTM
;ALTER TEXT MODE
SM	ALTM
;ALTER MACRO MODE
SM	MALTM
;SPECIAL POINTER MODE (TEMPRORARY)
SM	SPM
MD,<
;BODY TEXT MODE
SM	BTXTM
;BODY TEXT ALTER MODE
SM	BTALTM
;EDIT LEVEL
SM	EDTM
;EDIT LEVEL AND INSERT MODE
SM	EDTIM
;EDIT LEVEL AND TEXT MODE
SM	EDTTM
;EDIT LEVEL AND PIN MODE
SM	EDTPM
;EDIT LEVEL AND GETTING A BODY
SM	EDTGM
;ALL EDIT MODES (EXCEPT EDTAM)
ALLEDM__1EDTM!1EDTIM!1EDTTM!1EDTPM!1EDTGM
;EDIT MODE ALTER TEXT
SM	EDTAM
>;MD

NUMODES__%MODE

;ALL ALTER MODES
ANYALT__MD,<1EDTAM!1BTALTM!>1MALTM!1ALTM

DEFINE MODISP(BITS,ADDR)
<PUSHJ P,[TRNN B,BITS
	JRST PERRET
	JRST ADDR]
>
C0__1
C1__2
C2__4
C3__10
                                                                                                                                                                                                                                                                                                                                        ;DATA IN BOTH
;BEGIN TWO PROG DATA AREAS

DEFINE NAMES<

DEC,<
NOPGP,<
SDATA	TMP1,BOTH
SDATA	TMP2,BOTH
>;NOPGP
>;DEC
SDATA	EXPER2,BOTH
SDATA	SIGCHR,BOTH
SDATA	TPTRP,BOTH
SDATA	TTPTRP,BOTH
SDATA	RUNBIT,BOTH
SDATA	LOW2UP,BOTH
SDATA	SAVER0,BOTH
SDATA	SAVERM,BOTH
SDATA	VARLST,BOTH
SDATA	WDOLST,BOTH
SDATA	FNDNUM,BOTH
SDATA	MOVED,BOTH
SDATA	HASHP,BOTH,LHASHP
SDATA	HASHP2,PC,LHASHP
SDATA	HASHB,BOTH,LHASHB		;MUST FOLLOW HASHP
SDATA	PHASH2,PC
SDATA	PHASHP,BOTH
SDATA	CLAST,BOTH
SDATA	CLOSES,BOTH
SDATA	CLOSUP,BOTH
SDATA	MDISP,BOTH
SDATA	FBNSTR,BOTH
SDATA	FBLSTR,BOTH
SDATA	FBDSTR,BOTH
SDATA	FPLSTR,BOTH
SDATA	FPTSTR,BOTH
SDATA	LSTBOD,BOTH
SDATA	LSTPNT,BOTH
SDATA	TPOINT,BOTH
SDATA	IPOINT,BOTH
SDATA	LPNTR,BOTH
SDATA	BLINKN,BOTH
SDATA	ERRP,BOTH
SDATA	SAVP,BOTH
SDATA	FBDLST,BOTH
SDATA	CORLST,BOTH
SDATA	OLDTYPE,BOTH
SDATA	NEWTYPE,BOTH
SDATA	CURPIN,BOTH
SDATA	CURDIS,BOTH
SDATA	CURREP,BOTH
SDATA	SAVEG,BOTH
SDATA	STARLOC,BOTH
SDATA	SPDISP,BOTH
SDATA	STRING,BOTH
SDATA	CRDLOC,BOTH
SDATA	BLBRT,BOTH
SDATA	REMMAC,BOTH
SDATA	PINLEV,BOTH
SDATA	BLPNTR,BOTH
SDATA	AUTOWM,BOTH
SDATA	AUTOWN,BOTH
SDATA	XGO,BOTH
SDATA	YGO,BOTH
SDATA	XDISP,BOTH
SDATA	YDISP,BOTH
SDATA	COUNT2,BOTH
SDATA	MACPNT,BOTH
SDATA	MDPNT,BOTH
SDATA	VARPNT,BOTH
SDATA	NDIG,BOTH
SDATA	PUTCHR,BOTH
SDATA	DSPPSV,BOTH
SDATA	PLTPSV,BOTH
SDATA	GTCHRX,BOTH
SDATA	CDEPPN,BOTH
SDATA	INPNT,BOTH
SDATA	FSTPNT,BOTH
SDATA	MACPDL,BOTH,MPDLEN
SDATA	PDL,BOTH,PDLEN
SDATA	NSCALE,BOTH
SDATA	MODE,BOTH
SDATA	OMODE,BOTH
SDATA	DEFBRT,BOTH
SDATA	L1,BOTH
SDATA	N1,BOTH
SDATA	N2,BOTH
SDATA	L2,BOTH
SDATA	MAXX,BOTH
SDATA	MAXY,BOTH
SDATA	MINX,BOTH
SDATA	MINY,BOTH
SDATA	CURBOD,BOTH
SDATA	CURORT,BOTH
SDATA	LINING,BOTH
SDATA	LETTER,BOTH
SDATA	NUMBER,BOTH
SDATA	NUMBR1,BOTH
SDATA	SAVEA,BOTH
SDATA	SAVEB,BOTH
SDATA	PGLASS,BOTH
SDATA	COUNT,BOTH
SDATA	BITS,BOTH
SDATA	DIFSOF,BOTH
SDATA	DY1,BOTH
SDATA	DY2,BOTH
SDATA	DY3,BOTH
SDATA	DX1,BOTH
SDATA	DX2,BOTH
SDATA	DX3,BOTH
SDATA	SETPNT,BOTH
SDATA	SETFLG,BOTH
SDATA	ENDBOX,BOTH
SDATA	BUFPTR,BOTH
SDATA	BFPTR2,BOTH
SDATA	TTPTR,BOTH
SDATA	PCHBUF,BOTH
SDATA	SETBOX,BOTH
SDATA	NEWSET,BOTH
SDATA	NEWPNT,BOTH
SDATA	CRUDLR,BOTH
SDATA	SIZ,BOTH
SDATA	BRT,BOTH
SDATA	CHRCNT,BOTH
SDATA	LSTNAM,BOTH,3
;LSTNAM IS 3 IN LENGTH AND IS FOLLOWED BY LSTPPN, SO CLRSIG CAN
;BE USED TO GET NAME INTO MACRO
SDATA	LSTPPN,BOTH
SDATA	NEWBOD,BOTH
SDATA	TYPLOC,BOTH
SDATA	THSLOC,BOTH
SDATA	BID,BOTH
SDATA	PID,BOTH
SDATA	OLDBID,BOTH
SDATA	OLDPID,BOTH
SDATA	MAXBID,BOTH
SDATA	MAXPID,BOTH
SDATA	RDVER,BOTH
SDATA	NNAMES,BOTH
SDATA	SAVEXT,BOTH
SDATA	WIRDAT,BOTH
SDATA	THEREXISTS,BOTH
SDATA	PERRSAV,BOTH
SDATA	CURSE,BOTH
SDATA	LSTCUR,BOTH
SDATA	CLXY,BOTH
SDATA	XOFF,BOTH
SDATA	YOFF,BOTH
SDATA	TOP,BOTH
SDATA	BOTTOM,BOTH
SDATA	LEFT,BOTH
SDATA	RIGHT,BOTH
SDATA	DBODPN,BOTH
SDATA	PONPNT,BOTH
SDATA	CURSET,BOTH
SDATA	TOTCNT,BOTH
SDATA	LINCNT,BOTH
SDATA	EOLCHR,BOTH
SDATA	TXTPNT,BOTH
SDATA	ALTLIN,BOTH
SDATA	MODALT,BOTH
SDATA	ALTPNT,BOTH
SDATA	TXTBYT,BOTH
SDATA	TXTCNT,BOTH
SDATA	COMREP,BOTH
SDATA	NOARG,BOTH
SDATA	ALTSTR,BOTH
SDATA	CHRALT,BOTH
SDATA	FSTART,BOTH
SDATA	FLEN,BOTH
SDATA	BEGLIN,BOTH
SDATA	NOFFST,BOTH
SDATA	NOPPNF,BOTH
ITS,<
SDATA	TVDPY,BOTH
>;ITS
IFN UMLSW!LAYSW,<
SDATA	OFFERR,BOTH
SDATA	UPINS,BOTH
>;IFN UMLSW!LAYSW
UML,<
SDATA	WIRLST,BOTH
>;UML
STAN,<
SDATA	XTHICK,BOTH
>;STAN
>;NAMES
                                                                                                                                                                                                                                                                                                                                                                                                                                  ;DATA IN ONE OR OTHER
DEFINES NAMES1<

DEFINE FLAGS
<
	FLGMAC	FALSE,BOTH,<JFCL>
	FLGMAC	TRUE,BOTH,<CAIA>
	FLGMAC	CLOSES,BOTH,<PUSHJ P,CLTEST>
	FLGMAC	RITEON,BOTH,<PUSHJ P,ROTEST>
	FLGMAC	EDGE,BOTH
	FLGMAC	AEOL,BOTH
	FLGMAC	ABOL,BOTH
	FLGMAC	FIND,BOTH
	FLGMAC	AFIND,BOTH
	FLGMAC	DSKEND,BOTH
	FLGMAC	ENDMUL,BOTH
	FLGMAC	LSTEXP,BOTH
	FLGMAC	EXPR,BOTH,<PUSHJ P,FEXPR>
>
DEFINE FLGMAC(A,B,C)
<IFIDN<C><><SDATA	A,B>
>
;GENERATE ANY DATA STATEMENTS FOR SIMPLE FLAGS
	FLAGS

PART,<
SDATA	PARNAM,D
>;PART
UML,<
SDATA	%LAST,D
SDATA	ERCODE,D
>;UML
SDATA	FPSSTR,D
SDATA	FLNSTR,D
SDATA	FLDSTR,D
SDATA	FLPSTR,D
SDATA	FLTSTR,D
SDATA	FLRSTR,D
SDATA	FBTSTR,D
SDATA	FBRSTR,D
SDATA	TYPNAM,D
SDATA	OFFCLC,D
SDATA	ERRVAR,D
SDATA	ISVERT,D
SDATA	MODLIB,D
STANFO,<
NOLAY,<
MPC,<
SDATA	GRABUF,PC
>;MPC
>;NOLAY
>;STANFO
SDATA	PONPN2,PC
SDATA	OUTSIDE,D
SDATA	SITE1,D
SDATA	SITE2,D
SDATA	TIT1,D
SDATA	TIT2,D
SDATA	TAUTHOR,D
SDATA	TREV,D
SDATA	TMODULE,D
SDATA	TVARIABLE,D
SDATA	TPREFIX,D
SDATA	TPROJ,D
SDATA	TPAGE,D
SDATA	TOF,D
SDATA	TDCODE,D
DEC,<
SDATA	DRNNAM,D,4
SDATA	CHKNAM,D,4
SDATA	ENGNAM,D,4
SDATA	TNXTHI,D
>;DEC
SDATA	DRWDAT,D
SDATA	DRWNAM,D
SDATA	DRWPPN,D
SDATA	LIBLST,D
SDATA	MAPLST,D
SDATA	LIBTMP,D
SDATA	DEPTH,D
SDATA	LIBNAM,D
SHORT,<
SDATA	SRTLST,PC
SDATA	SHRTER,PC
SDATA	SERR1,PC
SDATA	SERR2,PC
SDATA	CPLAN1,PC
SDATA	CPLAN2,PC
SDATA	PCOP,PC
SDATA	PTOP,PC
SDATA	PTOL,PC
SDATA	LTOL,PC
>;SHORT
WAG,<
SDATA	LASTWR,PC
>;WAG
SDATA	CRDNAM,PC,1,LOW
SDATA	CRDEXT,PC,1,LOW
SDATA	CRDDAT,PC,1,LOW
SDATA	CRDPPN,PC,1,LOW
SDATA	CARDHD,PC,3,LOW
SDATA	CRDBUF,PC,406,LOW
SDATA	STPSIZ,PC
SDATA	CPLANE,PC
SDATA	XUMLPN,PC
SDATA	YUMLPN,PC
SDATA	KEEPIN,D
SDATA	LOWER,D
SDATA	UPPER,D
SDATA	WIDTH,D
SDATA	EDMODS,D
SDATA	EDCURS,D
SDATA	EDSCAL,D
SDATA	EDXOFF,D
SDATA	EDYOFF,D
SDATA	CLSTPN,D
SDATA	CRPPNT,D
SDATA	BTBODY,D
SDATA	GETBOD,D
SDATA	GETORT,D
SDATA	UDLR,D
SDATA	SAVLOC,D
SDATA	PINS,D
SDATA	LINES,D
SDATA	BTEXT,D
SDATA	TYPE,D
SDATA	COPPRP,D
SDATA	BTXLST,D
SDATA	LOSEPT,D
SDATA	ODIPTYP,D
SDATA	DEFOFF,D
SDATA	DEFOF1,D
SDATA	DEFBTS,D
SDATA	UTLIST,D
SDATA	USEFLG,D
SDATA	ALLFLG,D
SDATA	BODPNT,D
SDATA	CRDLST,PC
SDATA	BARLST,PC
SDATA	CIRC,D
SDATA	ITSSCL,D
SDATA	CSCALE,D
SDATA	LSCALX,D
SDATA	LSCALY,D
STAN,<
IFE STDBIG-1,<
SDATA	LSCLX1,D
>
>;STAN
SDATA	CBOX,D
SDATA	SSCALE,D
SDATA	SHEIGHT,D
SDATA	SWIDTH,D
SDATA	MOVFLG,D
SDATA	ULNFLG,D
SDATA	MXPADN,PC
SDATA	SIDSAV,PC
SDATA	BTHBRT,PC
ROUTE,<
SDATA	ROUIDX,PC
SDATA	ARRAYA,PC,%ROW*(%YSIZ/%GRAIN)
SDATA	ARRAYB,PC,%ROW*(%YSIZ/%GRAIN)
SDATA	RCL1,PC
SDATA	RCL2,PC
SDATA	RTCNT,PC
SDATA	RCODE,PC
SDATA	ENDBYT,PC
SDATA	ENDBY2,PC
SDATA	DX,PC
SDATA	DY,PC
SDATA	XCNT,PC
SDATA	YCNT,PC
SDATA	RLIST,PC
SDATA	X1,PC
SDATA	Y1,PC
SDATA	X2,PC
SDATA	Y2,PC
SDATA	PSAV,PC
SDATA	.CNR,PC
SDATA	.FED,PC
SDATA	.BAK,PC
SDATA	.SID,PC
>;ROUTE
>;NAMES1


DEFINE SDATA(LABEL,D.PC,SIZE,SEG)
<
IFIDN<SEG><LOW><STORAGE(LOW);>STORAGE(IMPURE)
IFIDN<D.PC><D><MD,<LABEL:
	IFIDN<SIZE><><0>
	IFDIF<SIZE><><BLOCK SIZE>
>>
IFIDN<D.PC><PC><MPC,<LABEL:
	IFIDN<SIZE><><0>
	IFDIF<SIZE><><BLOCK SIZE>
>>
IFIDN<D.PC><BOTH><
LABEL:
IFIDN<SIZE><><0>
IFDIF<SIZE><><BLOCK SIZE>
>>


SDATA	PATCH1,BOTH,40		;PATCH SPACE
SDATA	DSPDSP,BOTH
	JRST @DSPDSP

ZEROBEGIN:

NAMES
NAMES1

ZEROEND__.-1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;DIP BODY DEFS (PC), BOX TABLES (D)
IFN PCSW!LAYSW,<
DEFINE BODY (NAME,NEXTBOD)
<	=NAME,,NEXTBOD
	.+1
>
DEFINE PIN  (PINID,X,Y,ENDIFZERO)
<	RADIX =10
	PINID,,IFIDN <ENDIFZERO><> <.+2>
	X/5*2,,Y/5*2
	RADIX 8
>
DEFINE DIP (Y,DECPINS,LINK)
<	NUMPINS__=DECPINS
	XWD NUMPINS,LINK
	XWD .+1+NUMPINS*2,.+1
X_=100/5*2
XC_-(((NUMPINS/2)*X-X)/=80)*=40
YC_=Y/5
;PINS
	FOR I_NUMPINS/2,(NUMPINS/2)*2-1
<	XWD I+1,.+2
	XWD X*(I-NUMPINS/2)+XC,-YC
>
	FOR I_0,NUMPINS/2-2
<	XWD -I+NUMPINS/2,.+2
	XWD X*I+XC,YC
>
	XWD 1,0
	XWD X*(NUMPINS/2-1)+XC,YC
	.+2
;APPROX BOX
	XWD X*(NUMPINS/2-1)+XC,YC
	.+2
	XWD X*(NUMPINS/2-1)+XC,-YC
	.+2
	XWD XC,-YC
	.+2
	XWD XC,YC
	0
	XWD X*(NUMPINS/2-1)+XC,YC
>;DIP
STORAGE(IMPURE)
MPC,<BODPNT:	>
	FSTBOD

STORAGE(PURE)

FSTBOD:
PIN6:	DIP(300,6,PIN8)
PIN8:	DIP(300,8,PIN14)
PIN14:	DIP(300,14,PIN16)
PIN16:	DIP(300,16,PIN18)
PIN18:	DIP(300,18,PIN20)
PIN20:	DIP(300,20,PIN22)
PIN22:	DIP(400,22,PIN24)
PIN24:	DIP(600,24,PIN28)
PIN28:	DIP(600,28,PIN40)
PIN40:	DIP(600,40,PIN64)
PIN64:	DIP(900,64,TO18.3)	; for Motorola 68000, etc.  ROB 15-Feb-81
TO18.3:	BODY (183,TO18.4)
	PIN (1,50,0)
	PIN (2,0,50)
	PIN (3,-50,0,0)
TO18.4:	BODY (184,TO5.3)
	PIN (1,50,0)
	PIN (2,0,50)
	PIN (3,-50,0)
	PIN (4,0,-50,0)
TO5.3:	BODY (53,TO5.4)
	PIN (1,100,0)
	PIN (2,0,100)
	PIN (3,-100,0,0)
TO5.4:	BODY (54,TO66.3)
	PIN (1,100,0)
	PIN (2,0,100)
	PIN (3,-100,0)
	PIN (4,0,-100,0)
TO66.3:	BODY (663,TO6631)
	PIN (1,-100,0)
	PIN (2,100,0)
	PIN (3,0,580)
	PIN (3,0,-380,0)
TO6631:	BODY (6631,.3009P)
	PIN (1,-100,0)
	PIN (2,100,0)
	PIN (3,0,-380,0)
	PIN (3,0,580)
.3009P:	BODY (30091,PIN3T)
	PIN (1,-300,0)
	PIN (2,0,-100)
	PIN (3,200,0,0)
PIN3T:	BODY (3,PIN4T)
	PIN (1,100,0)
	PIN (2,0,100)
	PIN (3,-100,0,0)
PIN4T:	BODY (4,0)
	PIN (1,50,0)
	PIN (2,0,50)
	PIN (3,-50,0)
	PIN (4,0,-50,0)
>;PCSW!LAYSW

STORAGE(PURE)
MD,<
WTAB:	(AW-=500)/5		;A
	(XW-=500)/5		;X
	(BW-=1000)/5		;B
	(CW-=1000)/5		;C
	(DW-=1000)/5		;D
	(EW-=1000)/5		;E
	(BH-=1000)/5		;VB
	(CH-=1000)/5		;VC
	(DH-=1000)/5		;VD
	(EH-=1000)/5		;VE

HTAB:	(AH-=500-LABH)/5	;A
	(XH-=500-LABX)/5	;X
	(BH-=1000-LABH)/5	;B
	(CH-=1000-LABH)/5	;C
	(DH-=1000-LABH)/5	;D
	(EH-=1000-LABH)/5	;E
	(BW-=1000-LABH)/5	;VB
	(CW-=1000-LABH)/5	;VC
	(DW-=1000-LABH)/5	;VD
	(EW-=1000-LABH)/5	;VE

BTAB:	"A"
	"X"
	"B"
	"C"
DINDEX__.-BTAB
	"D"
	"E"
HBXLEN__.-BTAB
	SETZ "B"
	SETZ "C"
	SETZ "D"
	SETZ "E"
VBXLEN__.-BTAB-HBXLEN
BOXLEN__.-BTAB
>;MD
STORAGE(PURE)
                                   COMMENT    VALID 00014 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	<DRAW>COM.FAI122, 29-JUL-75 17:37:10, EDIT BY HELLIWELL
C00007 00003	MAIN COMMAND LOOP
C00010 00004	0-9  SPC + - 
C00013 00005	A-D
C00017 00006	E-K
C00021 00007	L-Q
C00025 00008	R-V
C00028 00009	W-Z
C00030 00010	ALT BS . | & # 
C00033 00011	" ?     \ = ^Z ^K
C00036 00012	DTAB:	0
C00041 00013	DOOX:	TLNN M,DSKACT!MACACT
C00044 00014	DEFINE XARGS
C00052 ENDMK
C;
                                                                                                                                                                           ;<DRAW>COM.FAI;122, 29-JUL-75 17:37:10, EDIT BY HELLIWELL
VERSION(COM,10)

STRT:	MOVE P,[IOWD PDLEN,PDL]
	RESET
DEC,<	PUSHJ P,DECGO
VB10,<	SETZ
	SETUWP			;SET THE HIGH SEG. WRITABLE
	JFCL
>;VB10
>;DEC
	SETZM ZLOWBEGIN
	MOVE T,[XWD ZLOWBEGIN,ZLOWBEGIN+1]
	BLT T,ZLOWEND		;SEE THE CODE WE SAVE!
DEC,<	PUSHJ P,CLTIME >	;INITIALIZE TIME CELLS
LAY,<	JSR LINIT		;INIT LAYOUT STUFF>
STRTL:	SETZM ZEROBEGIN
	MOVE T,[ZEROBEGIN,,ZEROBEGIN+1]
	BLT T,ZEROEND
	MOVE P,[IOWD PDLEN,PDL]
	MOVE T,[XWD -MPDLEN,MACPDL-1]
	MOVEM T,MACPNT
MPC,<	MOVEI T,FSTBOD
	MOVEM T,BODPNT		;INITIALIZE STANDARD DIP DEFS
>;MPC
	SETOM DSKEND		;ALWAYS STARTS WITH EOF
LAY,<
MD,<	OUTSTR[ASCIZ/LAYOUT, D SIDE!
/]
>;MD
MPC,<	OUTSTR[ASCIZ/LAYOUT, PC SIDE!
/]
>;MPC
>;LAY
NOLAY,<
NOVB10,<	MOVE TT,.JBFF >
VB10,<		HLRZ TT,.JBHRL
	ADDI TT,400000
>;VB10
>;NOLAY
TWO,<	MOVEI TT,FSTBEG	>	;SYMBOLS IN LOWER, START AT END OF UPPER
LIB,<	SKIPN TT,.JBSYM		;SYMBOLS IN DIFFERENT PLACES IN OVERLAYS, MUST CHECK
	JRST [	MOVEI TT,FSTBEG	;NO SYMBOLS IS EASY
		JRST LIBFST]
	HLRE TT,TT
	MOVN TT,TT
	ADD TT,.JBSYM
	HRRZ TT,TT
LIBFST:
>;LIB
	ADDI TT,10
	TRZ TT,1
	TLZ TT,-1
	MOVEM TT,FSTPNT
NOTBL1:
NODEC,<	MOVEI T,4000(TT)	>
DEC,<
VB10,<		MOVSI T,4000(TT)	>
NOVB10,<	MOVEI T,4000(TT)	>
>;DEC
NOTWO,<	CORE T,			;GET EXACTLY 2K OF FREE STORAGE>
TWO,<	CORE2 T,	>
	JRST [	JSR NOCORE
		JRST NOTBL1]
NOTWO,<
NODEC,<	HRRZ T,.JBREL		>
DEC,<
VB10,<		HRRZ	T,.JBHRL	>
NOVB10,<	HRRZ	T,.JBREL	>
>;DEC
>;NOTWO
TWO,<	HRRZ T,.JBHRL	>
LOP1:	MOVEM TT,-2(TT)
	ADDI TT,2
	CAIG TT,(T)
	JRST LOP1
	MOVEI T,[0]
	MOVEM T,-2(TT)		;LINK END TO A 0
	PUSHJ P,ALLDEF
	PUSHJ P,DCLAIM		;GOBBLE DISPLAY IF POSSIBLE
DEC,<	PUSHJ P,LOGINI	>
	PUSHJ P,NREADY		;SET READY FLAG
	JRST MAIN

ALLDEF:
ROUTE,<
MPC,<	MOVEI T,3
	MOVEM T,RCODE	;INITIALIZE ROUTE CODE
FOR I IN (CNR,FED,BAK,SID)
<	MOVEI T,CAT(%,I)
	MOVEM T,CAT(.,I)
>
>;MPC
>;ROUTE
DEC,<
MD,<	PUSHJ	P,SETOUT	>
	PUSHJ	P,SETCLC	;DEFAULT TO CLOCATE & OUTSIDE
	PUSHJ P,CLRLC		;AND NO LOWER CASE!
	PUSHJ P,CLBOOP		;AND NO BOOPING.
GT,<	SETOM OPTFLG	>	;SET FOR OPTIMIZED DISPLAY ROUTINES
>;DEC
RSTDEF:	PUSHJ P,CLRBRD		;INITIALIZE BOARD TYPE
	MOVEI T,DBLARR
	MOVEM T,EOLCHR		;END OF LINE FOR TEXT
WAG,<	MOVE T,[STRTWR]		;FIRST WIRE FILENAME -1
	MOVEM T,LASTWR
>;WAG
MD,<	DATE T,
	HRLZM T,DRWDAT
	MSTIME T,
	IDIVI T,=1000*=60		;TO MINUTES
	HRRM T,DRWDAT
	SETZB T,DRWNAM
NODEC,<	DSKPPN T,	>
DEC,<	GETPPN T,	>
	MOVEM T,DRWPPN
>;MD
	MOVEI T,DFSCL
	MOVEM T,NSCALE
MPC,<	MOVSI SID,FRONT	;START ON FRONT SIDE
	MOVEI T,=10		;50 MIL STEPS TO START WITH
	MOVEM T,STPSIZ
>;MPC
	MOVEI T,BODM
	MOVEM T,MODE
	PUSHJ P,CLRBRT
	MOVE 0,[DFLT0]
	MOVE M,[DFLTM]
	PUSHJ P,CLCBRT
	JRST HOME		;CENTER SCREEN
                                                                                                                                                                                                                                                                                                                                                                                                                                             ;MAIN COMMAND LOOP
MLOP:	XCT T		;XCT THE DISPATCH
	TRNN INMOV	;ARE WE MOVING SOMETHING?
	JRST MAIN0
	PUSHJ P,@MDISP	;YES, MOVE IT
	MOVE TT,CLOSES
	MOVE T,MODE
	CAIE T,PNTM
	CAIN T,TXTM
	MOVEM TT,MOVED
	JRST MAIN

MAIN0:	SKIPE A,MOVED
	PUSHJ P,STOPM
	SETZM MOVED
MAIN:	MOVEM 0,SAVER0			;SAVE REGISTERS IN CASE OF REENTER
	MOVEM M,SAVERM
NODEC,<
	SKIPE AUTOSM	;AUTO-SAVING?
	SOSE AUTOSN	;YES, TIME TO SAVE?
	CAIA
	PUSHJ P,ESAVE	;DO ESAVE
>;NODEC
	SKIPE AUTOWM	; auto-writing?
	SOSE AUTOWN	;   yes, time to write?
	CAIA
	PUSHJ P,EWRITE	; yes, do EWRITE

LAY,<	SKIPN C,ODISP	;IS OTHER PROG TRYING TO TELL US SOMETHING?>
	PUSHJ P,GETCHM		;GET THE NEXT CHARACTER (IN C)
LAY,<	SETZM ODISP		;ONLY ONCE!>

	TLNN M,DSKACT!MACACT	;DON'T UPDATE CURSOR?
	SKIPN ISDPY
	JRST NOCURS
	TRNN M,CURSOR		;ARE WE CURSING?
	JRST NOCURS
	PUSH P,C
	PUSHJ P,GETPOS		;UPDATE POSITION FROM DISPLAY PROG
	TRNE INMOV		;MAY HAVE TO FIX MOVING
	PUSHJ P,@MDISP
	POP P,C

NOCURS:	LDB A,[POINT 2,C,28]	;GET CONTROL BITS
	MOVEI B,1
	LSH B,(A)		;BITS TO TEST FOR CTRL KEYS
	ANDI C,177		;CLEAR EXTRA BITS
	SKIPN T,DTAB(C)		;PICK UP TABLE ENTRY. ZERO?
	JRST ERRET		;YES, ILLEGAL CHR.
	MOVEI D,1
	LSH D,@MODE		;GET A BIT TO TEST FOR LEGAL IN THIS MODE
	CAIA
	AOBJN T,.+1
	TDNN D,(T)		;DO BITS MATCH?
	JRST .-2
	JRA T,MLOP		;YES, MATCH, PICK UP DISPATCH INSTR.

ERRET:	PUSHJ P,PERRET
	JRST MAIN

FUCKUP:
	OUTSTR[ASCIZ/PROGRAM OR DATA ERROR, GET HELLIWELL!
CALLED FROM /]
	PUSH P,T
	PUSH P,TT
	HRLO TT,-2(P)		;GET PC
FCKLOP:	SETZ T,
	LSHC T,3
	ADDI T,60
	OUTCHR T
	TRNE TT,777777
	JRST FCKLOP
	OUTSTR[ASCIZ/
/]
	POP P,TT
	POP P,T
NODEC,<	POP P,.JBOPC		;POP RETURN INTO .JBOPC
	SKIPN .JBDDT
	HALT @.JBOPC
	PUSH P,.JBDDT
	POPJ P,
>;NODEC
DEC,<	JRST TODDT	>
                                                                                                                          ;0-9  SPC + - 

.1DNUM:
	ANYALT
	-1

.2DNUM:	PUSHJ P,ALTNUM
	JRST ERRET

DEC,<
.1D1:	1PNTM!1TXTM
	ANYALT
	-1

.2D1:	PUSHJ P,LINUP
	PUSHJ P,ALTNUM
	JRST ERRET

.1D2:	1PNTM!1TXTM
	ANYALT
	-1

.2D2:	PUSHJ P,LINDWN
	PUSHJ P,ALTNUM
	JRST ERRET

.1D3:	1PNTM!1TXTM
	ANYALT
	-1

.2D3:	PUSHJ P,LINLFT
	PUSHJ P,ALTNUM
	JRST ERRET

.1D4:	1PNTM!1TXTM
	ANYALT
	-1

.2D4:	PUSHJ P,LINRT
	PUSHJ P,ALTNUM
	JRST ERRET

.1D5:	1BODM
	ANYALT
	-1

.2D5:	MODISP C1,ASSET
	PUSHJ P,ALTNUM
	JRST ERRET

.2D6:	PUSHJ	P,ALTNUM
	PUSHJ	P,MOVUP1

.2D7:	PUSHJ	P,ALTNUM
	PUSHJ	P,MOVDN1

.2D8:	PUSHJ	P,ALTNUM
	PUSHJ	P,MOVLF1

.2D9:	PUSHJ	P,ALTNUM
	PUSHJ	P,MOVRT1
>;DEC

.1DSPC:
MD,<	1EDTIM		; SPACE>
MD,<	1PNTM!1TXTM		;POINT MODE>
	1SETM		;SET MODE
MD,<	1EDTGM		;GETTING BODY MODE>
	ANYALT
	-1
.2DSPC:
MD,<	PUSHJ P,EDSPC>
MD,<	PUSHJ P,PNSPC>
	PUSHJ P,SSPACE
MD,<	PUSHJ P,GETYES	;PLANT BODY>
	PUSHJ P,FORWRD
	PUSHJ P,CLRMOV	;STOP MOVING

DEC,<
.1DCX:
MD,<	1EDTIM	>
	ANYALT
	-1

.2DCX:
MD,<	PUSHJ P,EDSPC	>
	PUSHJ P,FORWRD
	JRST ERRET
>;DEC

.1DPLS:
MD,<	1EDTIM		;+ (EDIT INSERT MODE)>
	1PNTM!1TXTM		;+ IN POINT MODE
	1SETM			;+ IN SET MODE
	ANYALT
	-1
.2DPLS:
MD,<	PUSHJ P,EDPLUS>
	PUSHJ P,PPLUS
	PUSHJ P,SPLUS
	PUSHJ P,ALTPLS
	JRST ERRET

.1DMNS:
MD,<	1EDTIM		;->
	1PNTM!1TXTM		;POINT MODE
	1SETM		;SET MODE
	ANYALT
	-1

.2DMNS:
MD,<	PUSHJ P,EDMINS>
	PUSHJ P,PNMNS
	PUSHJ P,STMNS	;END BOX
	PUSHJ P,ALTMNS	;- IN ALTER MODE
	JRST ERRET

MD,<
.1DNOT:	1PNTM!1TXTM
	-1
.2DNOT:	PUSHJ P,PNOT
	JRST ERRET
>;MD
                                                                                                                                                                                                                                                                                                               ;A-D
.1DA:	1PNTM!1TXTM
MD,<	1EDTTM
	1BTXTM
>;MD
	-1
.2DA:	XCT (A)[JRST ERRET
		PUSHJ P,PATT
		PUSHJ P,LATT
		PUSHJ P,ALTER]
MD,<	MODISP C3,EALTER
	MODISP C3,BTALTR
>;MD
	JRST ERRET

.1DB:	MD,<1BTXTM!>1SETM!1BODM
	1PNTM!1TXTM
	1LINM
	-1
.2DB:	MODISP	C3,TOP3B
	XCT (A)[JRST ERRET
MD,<		PUSHJ P,BREAKH
		PUSHJ P,BREAKV
>;MD
MPC,<		JRST ERRET
		JRST ERRET
>;MPC
		PUSHJ P,TOP3B]
	XCT (A)[JRST ERRET
	MD,<	PUSHJ P,BENDL1
		PUSHJ P,BENDL2>
	MPC,<	PUSHJ P,BENDL
		JRST ERRET>
		PUSHJ P,TOP3B]
	JRST ERRET

.1DC:	ANYALT		;SNARF OFF EDIT ALTER MODE HERE
	MD,<ALLEDM!1BTXTM!>1SETM!1BODM!1PNTM!1TXTM!1LINM
	-1
.2DC:	PUSHJ P,ALTC
	XCT(A)[JRST ERRET
		PUSHJ P,CCENTR		;CURSOR TO CENTER OF PIC
		PUSHJ P,PCENTR		;PIC CENTER TO CURSOR POS.
		PUSHJ P,HOME]		;BOTH BACK TO ZERO.
	JRST ERRET

.1DD:
MD,<	1EDTIM		;D IN EDIT INSERT
	1EDTM			;D IN EDIT MODE
	1EDTPM		;CTRL 1 IN EDIT PIN MODE
>;MD
	1BODM		;CTRL 1 OR 2 IN BODY MODE
	1PNTM!1TXTM		;CTRL 1 IN POINT MODE
	1SETM		;CTRL 1 IN SET MODE
	1LINM		;CTRL 1 IN LINE MODE
	ANYALT
MD,<	1EDTTM
	1BTXTM
>;MD
	-1
.2DD:
MD,<	PUSHJ P,EDDEL	;D IN EDIT INSERT
	PUSHJ P,EDDELE	;D IN EDIT MODE
	MODISP C1,EDPDEL
>;MD
	XCT (A)[JRST ERRET
		PUSHJ P,BODDEL
		PUSHJ P,C2BDEL
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,PNTDEL
		PUSHJ P,PN2DEL
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,SETDEL
		PUSHJ P,SETKIL
		PUSHJ P,DCOMPL]
	XCT (A)[JRST ERRET
		PUSHJ P,LINDEL	;DELETE LINE
MPC,<		PUSHJ P,LINDL2	;DELETE WIRE	>
MD,<		JRST ERRET			>
		JRST ERRET]
	PUSHJ P,DELETE		;ALTER MODE DELETE
MD,<	XCT (A)[JRST ERRET
		PUSHJ P,EDTDEL
		PUSHJ P,EDNPRP
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,BTXDEL
		PUSHJ P,BTNPRP
		JRST ERRET]
>;MD
	JRST ERRET

MD,<
.1DE:	ALLEDM	;<CTRL 1>E IN EDITOR
	1SETM!1PNTM!1TXTM!1LINM		;CTRL 12 E IN TOP MODES
	1BODM
	1BTXTM
	ANYALT
	-1

.2DE:	MODISP C1,EDITE
	MODISP C3,ENTEDC
	XCT (A)[JRST ERRET
		PUSHJ P,ENTEPN
		JRST ERRET
		PUSHJ P,ENTEDC]
	XCT (A)[JRST ERRET
		PUSHJ P,ENTBTB
		JRST ERRET
		PUSHJ P,ENTEDC]
	PUSHJ P,ELINE
	JRST ERRET
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                         ;E-K
MPC,<
.1DE:	ANYALT
ROUTE,<	1PNTM!1TXTM>
	-1
.2DE:	PUSHJ P,ELINE
ROUTE,<	XCT (A)[JRST ERRET
		PUSHJ P,RSET1
		PUSHJ P,RSET2
		PUSHJ P,DOROUTE]
>;ROUTE
	JRST ERRET
>;MPC
MD,<
.1DF:	ANYALT
	1PNTM!1TXTM
	1BODM
	1SETM
	1EDTPM
	1EDTTM
	1BTXTM
	-1

.2DF:	PUSHJ P,ALTFND		;FIND A SUBSTRING
	XCT(A)[	JRST ERRET
		PUSHJ P,FNEXTP
		PUSHJ P,FNPLOC
		PUSHJ P,FNPTXT]
	XCT(A)[	JRST ERRET
		PUSHJ P,FNEXTB
		PUSHJ P,FNBLOC
		PUSHJ P,FNBNAM]
	XCT(A)[	JRST ERRET
		PUSHJ P,STBFND
		PUSHJ P,STTFND
		JRST ERRET]
	XCT(A)[	JRST ERRET
		PUSHJ P,FIXONE
		JRST ERRET
		PUSHJ P,PALL]
	XCT (A)[JRST ERRET
		PUSHJ P,FNEXLT
		PUSHJ P,FNLPRP
		PUSHJ P,FNLTXT]
	XCT (A)[JRST ERRET
		PUSHJ P,FNEXBT
		PUSHJ P,FNBPRP
		PUSHJ P,FNBTXT]
	JRST ERRET

.1DG:	ALLEDM		;CTRL1 G IN EDIT INSERT AND EDIT MODE
	1PNTM!1TXTM
	-1
.2DG:	MODISP C1,BODGET		;GET A BODY IN THE EDITOR.
	MODISP C1,BJUMP
	JRST ERRET
>;MD
MPC,<
.1DF:	1PNTM!1TXTM
	ANYALT
	1BODM
	1SETM
	-1
.2DF:	XCT(A)[JRST ERRET
		PUSHJ P,FEED
		PUSHJ P,PLANE
		PUSHJ P,NPFEED]
	PUSHJ P,ALTFND
	XCT(A)[	JRST ERRET
		PUSHJ P,FNEXTB
		PUSHJ P,FNBLOC
		PUSHJ P,FNBNAM]
	MODISP C1,STBFND
	JRST ERRET

.1DG:	1BODM
	1PNTM!1TXTM
	-1

.2DG:	XCT (A)[JRST ERRET
		PUSHJ P,REPONE
		PUSHJ P,REPSOME
		PUSHJ P,REPALL]
	MODISP C1,BJUMP
	JRST ERRET
>;MPC

.1DH:	-1				;VARIABLE COMMANDS IN ALL MODES

.2DH:	XCT (A)[JRST ERRET
		PUSHJ P,VARNXT
		PUSHJ P,VARDEF
		PUSHJ P,VARTYP]

.1DI:
MD,<	1EDTM
	ALLEDM	;<CTRL 1>I IN EDIT MODE AND EDIT TEXT MODE
	1SETM!1PNTM!1TXTM!1BODM!1LINM!1BTXTM
>;MD
MPC,<	1SETM!1PNTM!1TXTM!1BODM!1LINM>
	ANYALT
	-1
.2DI:
MD,<	XCT(A)[	JRST ERRET
		PUSHJ P,EDINS
		PUSHJ P,EDINS2
		JRST ERRET]
	MODISP C1,EDINS
>;MD
	MODISP C2,DREAD
	PUSHJ P,INSERT			;*I IN ALTER MODE
	JRST ERRET

.1DJ:	1PNTM!1TXTM
MPC,<	1LINM	>
	1SETM
	-1

.2DJ:	PUSHJ P,PJUMP
MPC,<	XCT (A)[JRST ERRET
		PUSHJ P,LJUMP1		;JUST THIS SEGMENT
		PUSHJ P,LJUMP2		;WHOLE LINE
		JRST ERRET]
>;MPC
	MODISP C1,SETJMP
	JRST ERRET

.1DK:	1PNTM!1TXTM		;POINT MODE <CTRL 1>
MD,<	1BTXTM
	1EDTTM		;ANY CTRL IN EDIT TEXT MODE
>;MD
	1SETM		;2K IN SET MODE
	ANYALT
	-1
.2DK:	MODISP C1,PTKILL
MD,<	XCT (A)[JRST ERRET
		PUSHJ P,BTXKIL
		PUSHJ P,BTXUKL
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,EDTKIL
		PUSHJ P,BTXUKL
		JRST ERRET]
>;MD
	MODISP C2,STKILT
	PUSHJ P,KILL
	JRST ERRET
                                                                                                                  ;L-Q
.1DL:	MD,<1BTXTM!>1SETM!1PNTM!1TXTM!1BODM!1LINM
	ANYALT
	-1

.2DL:	XCT (A)[JRST ERRET
	MD,<	PUSHJ P,TTYPE
		PUSHJ P,LTYPE>
	MPC,<	JRST ERRET
		JRST ERRET>
		PUSHJ P,TOP3L]
	PUSHJ P,SLINE
	JRST ERRET


.1DM:	MD,<1EDTM!1EDTTM!1EDTPM!1BTXTM!>1SETM!1BODM!1PNTM!1TXTM
	-1
.2DM:	XCT (A)[JRST ERRET
		PUSHJ P,PBMOV
		PUSHJ P,TXTMOV
		PUSHJ P,PGRAB]
	JRST ERRET

.1DN:
MD,<	1EDTPM
	1PNTM!1TXTM>
	1BODM
MD,<	1EDTM	>
	ANYALT
	-1
.2DN:
MD,<	XCT (A)[JRST ERRET
		PUSHJ P,PNUMS
		PUSHJ P,SETORI
		PUSHJ P,XYPOFF]
	XCT (A)[JRST ERRET
		PUSHJ P,SETCPN
		PUSHJ P,PMOVEL		;MOVE LOC
		JRST ERRET]
>;MD
	XCT (A)[JRST ERRET
		PUSHJ P,BNUMS
	MD,<	PUSHJ P,BMOVEL		;MOVE LOC>
	MPC,<	JRST ERRET			>
	MD,<	PUSHJ P,SETSEC	>
	MPC,<	JRST ERRET	>	]
MD,<	MODISP C2,EMOVEL	>
	PUSHJ P,ALTN
	JRST ERRET

.1DO:	1BODM
MD,<	1EDTGM>
MPC,<	1SETM>
	-1
.2DO:	MODISP C1,BROT
MD,<	MODISP C1,GETSPC>
MPC,<	MODISP C1,SROT>
	JRST ERRET
.1DP:
MD,<	1EDTPM
	ALLEDM	;P IN EDIT MODE
>;MD
	MD,<1BTXTM!>1LINM
	1BODM	;P IN BODY MODE
	1PNTM!1TXTM
	1SETM		;CTRL1 P IN SET MODE
	-1
.2DP:
MD,<	XCT (A)[JRST ERRET
		PUSHJ P,EDITP
DEC,<		PUSHJ P,SETPOL	>
NODEC,<		JRST ERRET	>
		JFCL		]	;ALREADY IN PIN MODE, NOOP
	XCT (A)[JRST ERRET
		PUSHJ P,EDITP
		JRST ERRET
		PUSHJ P,EDPENT]
>;MD
	MODISP C3,TOP3P
	XCT (A)[JRST ERRET
		PUSHJ P,BODPLC
MPC,<		JRST ERRET	>
MD,<		PUSHJ P,BPINS	>
		PUSHJ P,TOP3P]
	XCT (A)[JRST ERRET
		PUSHJ P,PNTPLC
		JRST ERRET
		PUSHJ P,TOP3P]
	XCT (A)[JRST ERRET
		JRST ERRET
		PUSHJ P,SETCOP	;COPY SET THEN MOVE
		PUSHJ P,TOP3P]	;GO TO POINT MODE
	JRST ERRET

.1DQ:	1PNTM!1TXTM			;Z IN POINT MODE
MD,<
STANFO,<
	1EDTTM		;CTRL1 Z IN EDIT TEXT MODE
	1BTXTM
>;STANFO
	1BODM
	1EDTM
>;MD
	-1
.2DQ:
NOSTANFO,<
MD,<	XCT (A)[JRST ERRET
		JRST ERRET
		PUSHJ P,UNOFFC
		PUSHJ P,CONOFF]
>;MD
MPC,<	JRST ERRET	>
>;NOSTANFO
STANFO,<
	XCT (A)[JRST ERRET
		PUSHJ P,PNTQ
	MD,<	PUSHJ P,UNOFFC
		PUSHJ P,CONOFF	>
	MPC,<	JRST ERRET
		JRST ERRET	>]
MD,<	MODISP C1,TPNTQ
	MODISP C1,BTPNTQ
>;MD
>;STANFO
MD,<	XCT (A)[JRST ERRET
		JRST ERRET
		PUSHJ P,BLOOFF
		PUSHJ P,BLCOFF]
	MODISP C2,ELCCLR
>;MD
	JRST ERRET
                                                                                                                                                                                                                                                                                                                                              ;R-V
MD,<
.1DR:	1EDTIM		;R IN EDIT INSERT
	1EDTM		;  "   "   MODE
	1BODM
	ANYALT
	-1
.2DR:	PUSHJ P,EDCHNG
	PUSHJ P,EDCHNE
	XCT (A)[JRST ERRET
		PUSHJ P,REPONE
		PUSHJ P,REPSOME
		PUSHJ P,REPALL]
	PUSHJ P,REPLAC
	JRST ERRET
>;MD
MPC,<
.1DR:	1PNTM!1TXTM!1LINM!1SETM!1BODM
	ANYALT
	-1
.2DR:	XCT (A)[JRST ERRET
		PUSHJ P,[TRZ INLIN!INMOV
			SWITCH
			TRO MCHG!NEEDCL
			POPJ P,]
		PUSHJ P,[TRZE BTHSDS
			TRO MCHG
			POPJ P,]
		PUSHJ P,[TRON BTHSDS
			TRO MCHG
			POPJ P,]]
	PUSHJ P,REPLAC
	JRST ERRET
>;MPC
.1DS:	MD,<1BTXTM!>1TXTM!1PNTM!1SETM!1LINM
	1BODM
	ANYALT
	-1
.2DS:	MODISP	C3,TOP3S	;GO TO SET MODE
	XCT (A)[JRST ERRET
		PUSHJ P,PSWAPA
	MD,<	PUSHJ P,PSWAPB	>
	MPC,<	JRST ERRET	>
		PUSHJ P,TOP3S]
	PUSHJ P,SEARCH
	JRST ERRET
.1DT:
MD,<	1BTXTM
	ALLEDM	;CTRL 1 IN EDIT
	1BODM
>;MD
	1LINM!1SETM!1BODM
	1PNTM!1TXTM		; "   " IN POINT MODE
	-1
.2DT:
MD,<	XCT (A)[JRST ERRET
		PUSHJ P,BTXPLC
		JRST ERRET
		PUSHJ P,TOP3T]
	XCT (A)[JRST ERRET
		PUSHJ P,EDTXT
		PUSHJ P,EDTENT
		PUSHJ P,EDTENT]
	XCT (A)[JRST ERRET
		PUSHJ P,BTXPLB
		PUSHJ P,TRANSPOSE
		PUSHJ P,TOP3T]
>;MD
	MODISP C3,TOP3T
	XCT (A)[JRST ERRET
		PUSHJ P,PNTTXT
	MPC,<	JRST ERRET	>
	MD,<	PUSHJ P,PNTTX2	>
		PUSHJ P,TOP3T]
	JRST ERRET
.1DU:
MPC,<	1PNTM!1TXTM	>
	ANYALT
	-1
.2DU:
MPC,<	XCT(A)[JRST ERRET
		PUSHJ P,UNFEED
		PUSHJ P,UNPLAN
		JRST ERRET]
>;MPC
	PUSHJ P,ALTU
	JRST ERRET
.1DV:
	-1
.2DV:
LAY,<
MD,<	MODISP C3,GETPC		>
MPC,<	MODISP C3,GETD		>
>;LAY
NOLAY,<	JRST ERRET	>
                                                                                                                                                                                                                                                                                                                                                                          ;W-Z
.1DW:	MD,<1BTXTM!>1SETM!1BODM!1PNTM!1TXTM!1LINM
	-1
.2DW:	XCT(A)[JRST ERRET
		PUSHJ P,DWRITE
		PUSHJ P,WIRE
		PUSHJ P,PLOT]
	JRST ERRET
.1DX:	-1
.2DX:	PUSHJ P,DOOX

.1DY:
MD,<	ALLEDM
	1BTXTM
	1BODM
>;MD
	-1

.2DY:
MD,<	XCT (A)[JRST ERRET
		PUSHJ P,EDTPRP
		PUSHJ P,EDCPRP
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,BTXPRP
		PUSHJ P,BTCPRP
		JFCL]		;STAY IN BTXTM
	XCT (A)[JRST ERRET
		PUSHJ P,BTXPRB
		PUSHJ P,BTCPRB
		PUSHJ P,ENTBTM]
>;MD
	JRST ERRET

.1DZ:	ANYALT
	1PNTM!1TXTM			;CTRL1 Z IN POINT MODE
MD,<	1EDTTM			;CTRL1 Z IN EDIT TEXT MODE
	1BTXTM
>;MD
	-1
.2DZ:	PUSHJ P,ALTZAP			;ZAP STRING
STANFO,<XCT (A)[JRST ERRET
		PUSHJ P,PNTZ
	MD,<	PUSHJ P,UNOFFT
		PUSHJ P,PUTOFF	>
	MPC,<	JRST ERRET
		JRST ERRET	>]
>;STANFO
NOSTANFO,<
MPC,<	JRST ERRET	>
MD,<	XCT (A)[JRST ERRET
		JRST ERRET
		PUSHJ P,UNOFFT
		PUSHJ P,PUTOFF	]
>;MD
>;NOSTANFO
MD,<	XCT (A)[JRST ERRET
	STANFO,<PUSHJ P,TPNTZ>
	NOSTANFO,<JRST ERRET>
		JRST ERRET
		PUSHJ P,EDTTZ]
	XCT (A)[JRST ERRET
	STANFO,<PUSHJ P,BTPNTZ	>
	NOSTANFO,<JRST ERRET>
		JRST ERRET
		PUSHJ P,BTXTZ]
>;MD
	JRST ERRET
                                                                                                                                       ;ALT BS . | & # 
.1DALT:
MD,<	1EDTIM!1EDTTM!1EDTPM	;ALTMODE IN EDIT INSERT
	1BTXTM
>;MD
	1SETM
	1PNTM!1TXTM		;POINT MODE
MD,<	1EDTGM		;BODY GETTING MODE>
	1ALTM
	1MALTM
MD,<	1EDTAM
	1BTALTM
>;MD
	-1
.2DALT:
MD,<	PUSHJ P,EDALT	
	PUSHJ P,CLRMOV
>;MD
	PUSHJ P,SETALT
	PUSHJ P,PNALT
MD,<	PUSHJ P,GETALT		>
	PUSHJ P,ALTALT
	PUSHJ P,MALTALT
MD,<	PUSHJ P,ELTALT	
	PUSHJ P,BTXALT
>;MD
	JRST ERRET
.1DBS:
MD,<	1EDTIM		;BS>
	ANYALT
	-1
.2DBS:
MD,<	PUSHJ P,EDBS>
	PUSHJ P,BAKWRD
	JRST ERRET

.1DPER:
	1PNTM!1TXTM
	-1

.2DPER:
	XCT(A)	[
	LAY,<	PUSHJ P,PLAIN.	>
	NOLAY,<	JRST ERRET	>
		PUSHJ P,CTRL.
		PUSHJ P,META.
	ROUTE,<
	MPC,<	PUSHJ P,CTMT.	>
	MD,<
	LAY,<	PUSHJ P,CTMT.	>
	NOLAY,<	PRINTX WHAT ARE YOU DOING WITH MD, ROUTE, AND NOLAY?>
	>;MD
	>;ROUTE
	NOROUTE,<JRST ERRET	>
					]
	JRST ERRET

.1DVBR:
MPC,<	1PNTM!1TXTM	>
	-1

.2DVBR:
MPC,<	PUSHJ P,PLFEED	>	;**| IN POINT MODE
	JRST ERRET

.1DAMP:	1PNTM!1TXTM
	1BODM
	1SETM
	-1

.2DAMP:	XCT (A)[JRST ERRET		;& POINT MODE
		PUSHJ P,APPPNT
		PUSHJ P,ASSETP
		PUSHJ P,CLRCUR]
	XCT (A)[JRST ERRET		;& BODY MODE
		PUSHJ P,APPBOD
		PUSHJ P,ASSETB
		PUSHJ P,CLRCUR]
	XCT (A)[JRST ERRET		;& SET MODE
		PUSHJ P,APPSET
		PUSHJ P,SETSET
		PUSHJ P,CLRCUR]
	MODISP C3,CLRCUR		;CLEAR CURRENT SET ONLY ()

.1DSHRP:1PNTM!1TXTM
	1BODM
	1SETM
	ANYALT
	-1

.2DSHRP:XCT (A)[JRST ERRET
		PUSHJ P,XPNT
		PUSHJ P,XPNTA
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,XBOD
		PUSHJ P,XBODA
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,XSET
		PUSHJ P,XSETA
		JRST ERRET]
	PUSHJ P,SPALTN
	JRST ERRET

.1DEQV:	1BODM
	-1

.2DEQV:	MODISP C1,ASSET
	JRST ERRET
                                                                                                                                                                                                                        ;" ?     \ = ^Z ^K
.1DDBQ:	1PNTM!1TXTM
	1BODM
MD,<	1EDTM
	1EDTPM
	1EDTTM!1BTXTM
>;MD
	-1

.2DDBQ:	XCT (A)[JRST ERRET
		PUSHJ P,STOTXT
		PUSHJ P,STOCLC
		JRST ERRET]
	XCT (A)[JRST ERRET
		PUSHJ P,STONAM
		PUSHJ P,STOBLC
		PUSHJ P,STODIP]
MD,<	XCT (A)[JRST ERRET
		PUSHJ P,STFLNM
		JRST ERRET
		PUSHJ P,STFLDP]
	MODISP C2,STOBPN
	XCT (A)[JRST ERRET
		PUSHJ P,STOBTX
		PUSHJ P,STOBTP
		JRST ERRET]
>;MD
	JRST ERRET

.1DQUES:
MPC,<SHORT,<	-1-ANYALT	>>
UML,<
MD,<	-1-ANYALT-ALLEDM	>
>;UML
	-1

.2DQUES:
MPC,<SHORT,<	MODISP C0,SHWERR	;SHOW A SHORTING ERROR>>
UML,<
MD,<	MODISP C0,SHWERR	;SHOW A SINGLE UNNAMED PIN ERROR>
>;UML
	JRST ERRET

NODEC,<
.1DLBC:	1PNTM!1TXTM
	-1

.2DLBC:	PUSHJ P,LINLFT
	JRST ERRET

.1DRBC:	1PNTM!1TXTM
	-1

.2DRBC:	PUSHJ P,LINRT
	JRST ERRET

.1DUBC:	1PNTM!1TXTM
	-1

.2DUBC:	PUSHJ P,LINUP
	JRST ERRET

.1DDBC:	1PNTM!1TXTM
	-1

.2DDBC:	PUSHJ P,LINDWN
	JRST ERRET
>;NODEC

.1DBSL:	MD,<1EDTAM!1BTALTM!>1ALTM	;BACK SLASH
	-1

.2DBSL:	PUSHJ P,SETSIZ		;SET CHAR SIZE IN ALTER MODE
	PUSHJ P,MOVDN1		;CURSOR MOVE DOWN SMALL

.1DEQU:
MD,<	1EDTIM		;->
	1PNTM!1TXTM		;POINT MODE
	1SETM		;SET MODE
	-1

.2DEQU:
MD,<	PUSHJ P,EDMINS>
	PUSHJ P,PNMNS
	PUSHJ P,STMNS	;END BOX
	JRST ERRET

.1DDCR:	ANYALT
	-1

.2DDCR:	PUSHJ P,SLINE
	JRST ERRET

.1DUCR:	ANYALT
	-1

.2DUCR:	PUSHJ P,MSLINE
	JRST ERRET
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            DTAB:	0
	XWD [PUSHJ P,MAKDWN],[-1]	;
	FOR I_2,7<0
>
DEC,<	XWD	.2DBS,.1DBS	>	;^H BACKSPACE
NODEC,<	0	>
	0
	XWD [JFCL],[-1]			;LF IS NOOP
DEC,<	XWD	.2DDCR,.1DDCR	>	;^K (CURSOR UP)
NODEC,<	0	>
	FOR I_14,""-1<0
>
	XWD [PUSHJ P,MOVDN2],[-1]	; CURSOR DOWN LARGE
	XWD [PUSHJ P,MOVUP2],[-1]	; CURSOR UP LARGE
NODEC,<	XWD .2DUBC,.1DUBC		;20	^P
	XWD .2DDBC,.1DDBC		;21	^Q
	XWD .2DLBC,.1DLBC		;22	^R
	XWD .2DRBC,.1DRBC		;23	^S
>;NODEC
DEC,<	0				;20
	0				;21
	0				;22
	0				;23
>;DEC
	0				;24
	0				;25
	0
	0				;27
NODEC,<	0	>			;30
DEC,<	XWD .2DCX,.1DCX		>	;^X
	XWD [PUSHJ P,MAKRIT],[-1]	;
DEC,<	XWD .2DUCR,.1DUCR	>	;^Z (UP CURSOR)
NODEC,<	0	>			;32 
	0				;33 
	0
	0
NODEC,<	XWD .2DEQV,.1DEQV	>	;36 
DEC,<	0	>
	0
	XWD .2DSPC,.1DSPC		; SPACE
	0				;41
	XWD .2DDBQ,.1DDBQ		;DOUBLE QUOTE
	XWD .2DSHRP,.1DSHRP		;#
	0
NODEC,<	0				;%
	XWD .2DAMP,.1DAMP		;&
	0				;'
	XWD [PUSHJ P,MOVLF1],[-1]	;CURSOR LEFT SMALL
	XWD [PUSHJ P,MOVRT1],[-1]	;CURSOR RIGHT SMALL
>;NODEC
DEC,<	XWD .2DAMP,.1DAMP		;%
	XWD	[PUSHJ P,MOVUP2],[-1]	;& CURSOR UP LARGE
	XWD	[PUSHJ P,MOVDN2],[-1]	;' CURSOR DOWN LARGE
	XWD	[PUSHJ P,MOVLF2],[-1]	;CURSOR LEFT LARGE
	XWD	[PUSHJ P,MOVRT2],[-1]	;RIGHT LARGE
>;DEC
	XWD [PUSHJ P,MAKSML],[-1]	;SHRINK PIC
	XWD .2DPLS,.1DPLS		;+ (EDIT INSERT MODE)
	0				;,
	XWD .2DMNS,.1DMNS		;-
	XWD .2DPER,.1DPER		;PERIOD
	XWD [PUSHJ P,MOVUP1],[-1]	;CURSOR UP SMALL
	XWD .2DNUM,.1DNUM		;0
FOR @$ I E <12345>
<
DEC,<	XWD	.2D$I,.1D$I	>
NODEC,<	XWD .2DNUM,.1DNUM	>
>
	FOR @$ I E <6789>
<
DEC,<	XWD	.2D$I,.1DNUM	>
NODEC,<	XWD	.2DNUM,.1DNUM	>
>
	0				;:::
	XWD [PUSHJ P,ITSEM],[-1]	;;;;;;;;
NODEC,<	0
	XWD	.2DEQU,.1DEQU		;=
	0
>;NODEC
DEC,<	XWD	[PUSHJ P,MAKLFT],[-1]	;WINDOW LEFT
	XWD	.2DEQU,.1DEQU		;=
	XWD	[PUSHJ P,MAKRIT],[-1]	;WINDOW RIGHT
>;DEC
	XWD .2DQUES,.1DQUES		;?
	XWD [PUSHJ P,DSKIN],[-1]	;@
	FOR @$ I E <ABCDEFGHIJKLMNOPQRSTUVWXYZ>
<	XWD .2D$I,.1D$I
>
	XWD [PUSHJ P,MOVLF2],[-1]	;CURSOR LEFT LARGE
	XWD .2DBSL,.1DBSL		;CURSOR DOWN SMALL (SET CHAR SIZE IN ALTER MODE)
NODEC,<	XWD [PUSHJ P,MOVRT2],[-1]	>;CURSOR RIGHT LARGE
DEC,<	XWD [PUSHJ P,MAKDWN],[-1]	>;WINDOW DOWN
	XWD [PUSHJ P,MAKUP],[-1]	;^
	XWD [PUSHJ P,MAKLFT],[-1]	;_
	0				;140 `
	FOR @$ I E <ABCDEFGHIJKLMNOPQRSTUVWXYZ>
<	XWD .2D$I,.1D$I
>
	FOR I_"Z"+41,173<0
>
	0
	0
	0
	XWD .2DBS,.1DBS	;BS
	0
MD,<
ORG DTAB+NOT
	XWD .2DNOT,.1DNOT		;
>
ORG DTAB+BIGCHR
	XWD [PUSHJ P,MAKBIG],[-1]	;
ORG DTAB+VRTBAR
	XWD .2DVBR,.1DVBR		;|
ORG DTAB+ALTMOD
	XWD .2DALT,.1DALT		;ALTMODE
ORG DTAB+201
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            DOOX:	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ /
WELL?/]
	SETZ G,
	MOVEI H,G
GETCM1:	PUSHJ P,GETCOM
	JUMPE T,GETCM2
	GETFS(TT)
	MOVEM T,1(TT)
	HRRM TT,(H)
	HRLZM 0,(TT)
	MOVE H,TT
GETCM2:	CAIN C,","
	JRST GETCM1
	CAIE C,12
	JRST ERRX
	JUMPE G,CPOPJ
GETCM3:	PUSH P,G
	MOVE T,1(G)
	HLRZ TT,(G)
	TRZ TFLG
	TRNE TT,TFLG
	TRO TFLG
	PUSHJ P,SRVCOM
	POP P,A
	HRRZ G,(A)
	FSTRET A
	JUMPN G,GETCM3
	POPJ P,

SRVCOM:	JUMPE T,CPOPJ
	TLNE M,DSKACT!MACACT
	JRST NSRVPN
	TRNE TFLG
	OUTCHR["-"]
	PUSH P,T
	MOVE TT,T
	PUSHJ P,SIXPNT		;PRINT COMMAND WE ARE SERVICING
	POP P,T
NSRVPN:	MOVSI TTT,770000
	SETZ TT,		;CLEAR MASK
	TDNE T,TTT
	TDO TT,TTT
	LSH TTT,-6
	JUMPN TTT,.-3
	SETZ A,		;NO PARTIAL MATCH FOUND YET!
	MOVSI D,-TABLEN	;MAKE AOBJN POINTER
XLOP:	CAMN T,XTAB(D)
	JRST EXACT
	MOVE TTT,TT
	AND TTT,XTAB(D)
	CAMN TTT,T
	JRST [	JUMPN A,XAMBIG	;TOO MANY MATCHES?
		MOVE A,D
		JRST .+1]
	AOBJN D,XLOP
	JUMPE A,PERRET	;ANY MATCH?
	MOVE D,A	;YES, CALL IT
	TLNE M,DSKACT!MACACT
	JRST EXACT
	ANDCA TT,XTAB(D)
	LSH TT,6
	TLNN TT,770000
	JRST .-2
	PUSHJ P,SIXPNT
EXACT:	TRNN TFLG	;IS THIS A NOT
	SKIPA A,XDIS(D)	;NO
	MOVS A,XDIS(D)	;YES
	TRNN A,-1	;ANY DISPATCH FOR THIS FLAVOR?
	JRST PERRET
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
/]
	JRST (A)	;YES

XAMBIG:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ IS AMBIGUOUS!
/]
	POPJ P,

ERRX:	SKIPE B,G
	PUSHJ P,PUTFS
	JRST INNERR

GETCOM:	PUSHJ P,GETLIN
	TRO TFLG		;ASSUME NOT
	CAIN C,"-"
	JRST GETWRD
	TRZ TFLG		;NOT NOT
	SETZ T,
	MOVE A,[POINT 6,T]
	JRST ISCHRX

PNTCOM:	MOVSI A,-TABLEN
	MOVEI TTT,8
PNTCM1:	MOVE TT,XTAB(A)
	PUSHJ P,SIXPNT
	HLRZ TT,XDIS(A)
	SKIPE TT
	OUTCHR["-"]
	SOJLE TTT,[OUTSTR[ASCIZ/
/]
		MOVEI TTT,8
		JRST PNTCM2]
	OUTCHR[11]
PNTCM2:	AOBJN A,PNTCM1
	OUTSTR[ASCIZ/
/]
	POPJ P,
                                                                                                   DEFINE XARGS
<
	XMAC	HELP,PNTCOM
	XMAC	START,STRT
	XMAC	BOOP,STBOOP,CLBOOP
	XMAC	INIT,STINIT,CLINIT
	XMAC	FDIP,FNBDIP
	XMAC	EXACT,EXACTS,EXACTC
	XMAC	LOWER,SETLC,CLRLC
	XMAC	IMACRO,IMACRO
	XMAC	WMACRO,WMACRO,WMACRS
	XMAC	AMACRO,MALTER
	XMAC	SMACRO,SAVMAC,UNSAVM
	XMAC	QUIT,MQUIT
	XMAC	SPACES,SETSPC,CLRSPC
	XMAC	CENTER,SETCNT,CLRCNT
DEC,<	XMAC	TIME,STTIME,CLTIME	>
NODEC,<	XMAC	AUTOSAVE,SETSM,CLRSM	>
	XMAC	AUTOWRITE,SETWM,CLRWM
NODEC,<	XMAC	ESAVE,ESAVE	>
	XMAC	EWRITE,EWRITE
	XMAC	ELIST,EWLIST
	XMAC	EPLOT,EWPLOT
	XMAC	ENAME,CENAME,ZENAME
MD,<	XMAC	MAKEWD,MAKWIR	>
MPC,<	XMAC	MAKWPC,MAKWIR	>
	XMAC	SAVE,SAVEME
LAY,<	XMAC	RESAVE,RSAVEM		>
	XMAC	SETWRT,SWRITE
	XMAC	WRTSET,SWRITE
	XMAC	DPY,SETDPY,CLRDPY
GT,<	XMAC	OPTIMIZE,SETOPT,CLROPT
DLX,<	XMAC	DL10,SETDLX,CLRDLX	>
>;GT
	XMAC	MACRO,LMACRO
	XMAC	RMACRO,RENMAC
	XMAC	DMACRO,DELMAC,DELMCS
	XMAC	PMACRO,PMACRO
	XMAC	CLEAR,CLEAR
	XMAC	CURSOR,CURSON,CURSOFF
	XMAC	DDT,GETDDT
	XMAC	BRIGHT,ITBRT,CLRBRT
	XMAC	CURBRT,ITCBRT,CLCBRT
	XMAC	MOVE,MOVREL
	XMAC	SCALE,ITSCAL
	XMAC	SIZE,ITSIZE
	XMAC	XOFF,SETXOF
	XMAC	YOFF,SETYOF
	XMAC	TEXT,SETTXT,CLRTXT
	XMAC	WINDOW,SETWIN,CLRWIN
	XMAC	LWINDOW,SETLWN,CLRLWN
	XMAC	DELNUL,DELNUL
	XMAC	DANGLE,DANGLE
DEC,<
MD,<	XMAC	CHKPOL,POLCHK
	XMAC	POLCHK,POLCHK
>;MD
>;DEC
	XMAC	DELSET,SBLAST
	XMAC	SETCEN,CENALL
	XMAC	COUNT,DOCNT
	XMAC	DSKIN,DSKIN
	XMAC	DSKINH,DSKINH
	XMAC	IFLUSH,IFLUSH
	XMAC	DSKOUT,PUTDSK
	XMAC	CLOSE,DSKCLR
	XMAC	NEWID,NEWID
	XMAC	PINS,SETPNS,CLRPNS
	XMAC	LOCS,STBLCS,CLBLCS
	XMAC	CLOCS,STCLCS,CLCLCS
	XMAC	CPINS,STCLCS,CLCLCS
	XMAC	LINES,STLINS,CLLINS
	XMAC	LOCATE,SETLCA,CLRLCA
	XMAC	CLOCATE,SETCLC,CLRCLC
	XMAC	SETLOC,SETLOC,SETLZ
	XMAC	FLASH,LOKSIG,XFLASH
IFN LAYSW!UMLSW,<XMAC	ERROR,SETERR,CLRERR>
	XMAC	IDENTS,SIDENT,CIDENT
	XMAC	LIBPPN,STLPPN,CLLPPN
	XMAC	BOARD,GETBRD,CLRBRD
UML,<	XMAC	IWIRES,READW,RELWIR
	XMAC	LSIGNALS,LSTSIG
	XMAC	NFLASH,LOOKN
>;UML
MD,<	XMAC	LPROPS,LPROPS
	XMAC	IDEFS,DREADT
	XMAC	RDEFS,DREADR
	XMAC	IERRORS,IERRS,RELWIR
	XMAC	FIXEM,FIXEM0
	XMAC	PTEXT,STPTXT,CLPTXT
	XMAC	BTEXT,STBTXT,CLBTXT
	XMAC	TMOVE,LOCTM
	XMAC	LMOVE,LOCLM
	XMAC	TERMRULE,STTRUL,CLTRUL
	XMAC	SETPINS,BPINSA,PINZ
	XMAC	SLICE,DOSLICE
	XMAC	TSLICE,TYPSLC,CLTSLC
	XMAC	DELLIB,DELLIB
	XMAC	LOCLIB,DELLBS
	XMAC	GETLIB,DOLIB
	XMAC	TYPLIB,LIBOUT
	XMAC	LIBTYP,LIBOUT
	XMAC	MODLIB,STMLIB,CLMLIB
	XMAC	MAPLIB,SETMAP,CLRMAP
	XMAC	LIBMAP,SETMAP,CLRMAP
	XMAC	GETBOD,RDBODY
	XMAC	RENAME,BODREN
	XMAC	TYPDEL,TYPDEL
	XMAC	DELTYP,TYPDEL
	XMAC	DIAMONDS,SETDMD,CLRDMD
	XMAC	PBOX,BOXSIZ
	XMAC	SHOWBOX,SHWBOX,NSHOBX
	XMAC	PICCEN,PICCEN
	XMAC	DEFPINS,SETIDS,CLRIDS
	XMAC	RPINID,SETRID,CLRRID
	XMAC	UNHIDE,STUNHI,CLUNHI
	XMAC	HIDE,CLUNHI,STUNHI
	XMAC	FIXALL,FIXALL
	XMAC	OUTSIDE,SETOUT,CLROUT
	XMAC	TITLE,STITLE,CTITLE
	XMAC	SITE,SITE,CSITE
	XMAC	AUTHOR,AUTHOR,CAUTHOR
	XMAC	REVISION,REVISE,CREVISE
	XMAC	MODULE,MODULE,CMODULE
	XMAC	VARIABLE,VARIABLE,CVARIABLE
	XMAC	PREFIX,PREFIX,CPREFIX
	XMAC	NUMBER,SETNUM,CLRNUM
	XMAC	PROJECT,PROJECT,CPROJECT
	XMAC	PAGE,PAGEOF,CPAGEOF
DEC,<	XMAC	SHEET,PAGEOF,CPAGEOF	>
	XMAC	DCODE,DCODE,CDCODE
DEC,<	XMAC	DRAWN,SETDRN,CLRDRN
	XMAC	ENGINEER,SETENG,CLRENG
	XMAC	NEXTHI,SETNXT,CLRNXT
>;DEC
	XMAC	LTITLE,LTITLE
	XMAC	TRANSPOSE,TRANALL
	XMAC	OFFALL,OFFALL
	XMAC	OFFRIGHT,OFFRHT,NOFRHT
	XMAC	OFFLOC,OFFLOC
	XMAC	DISLOC,SETDLC,CLRDLC
	XMAC	CHANGE,SIGCHG
	XMAC	ICHANGE,ISIGCH
	XMAC	ICPINS,ICPNCH
	XMAC	UNDERLINE,UNDRLN,NUNDRL
	XMAC	CBOX,SETCBX,CLRCBX
	XMAC	IPINS,INPINS
DEC,<	XMAC	IUML,INUML	>
	XMAC	CEXCHANGE,UREST
	XMAC	MUNG,STRAIGHTEN
	XMAC	FSIGNAL,FNPSIG
	XMAC	FLNAME,FNLNAM
	XMAC	FLDIP,FNLDIP
	XMAC	FLNEXT,FNEXTL
	XMAC	FLPIN,FNLPN0
	XMAC	FLPNEXT,FNEXBP
	XMAC	RSPINI,RSPINI
>;MD
MPC,<	XMAC	WSIG,SIGPLT
	XMAC	IPAD,DREADT
	XMAC	IROUTE,DREADR
	XMAC	SETDIP,SETDIP
	XMAC	COMPONENT,STCOMP
	XMAC	SOLDER,STSOLD
	XMAC	CHANGE,CPADS
	XMAC	FEEDTHROUGH,STFEED,CLFEED
	XMAC	FINGER,STFING,CLFING
	XMAC	CDISP,STCARD,CLCARD
	XMAC	CARD,DOCARD
	XMAC	FTXT,FNPTXT
	XMAC	FCPIN,FNPLOC
	XMAC	FIND,FNEXTP
	XMAC	INNER,INNER
	XMAC	PPLOT,PPLOT
	XMAC	FLIP,STFLIP
	XMAC	MUNG,MUNG
	XMAC	UML,DOUML
	XMAC	DIPS,STDIPS,CLDIPS
	XMAC	STEP,SETSTP
	XMAC	VCC,SETPWR
	XMAC	GND,SETGND
	XMAC	POSITION,POSIT
SHORT,<	XMAC	SHORT,DOSHORT,CSHORT
	XMAC	PADDIAMETER,SETDIA
	XMAC	WIDTH,SETWID
	XMAC	SEPARATION,SETSEP
	XMAC	HOLE,SETHOL
	XMAC	CONNECTOR,SETCPN
>;SHORT
UML,<
WAG,<
	XMAC	WROUTE,WROUTE
>;WAG
>;UML
ROUTE,<
	XMAC	ROUTE,SETRTE
	XMAC	RDISP,SETRDS,CLRRDS
	XMAC	RCODE,SETRCD
	XMAC	CNR,SETCNR
	XMAC	FED,SETFED
	XMAC	BAK,SETBAK
	XMAC	SID,SETSID
>;ROUTE
STANFO,<
NOLAY,<
	XMAC	PDPY,PDPY
>;NOLAY
>;STANFO
>;MPC
STAN,<	XMAC	XTHICK,SETTHK,CLRTHK	>
>;XARGS

DEFINE XMAC(A,B,C)
<	<SIXBIT/A/>
>

XTAB:	XARGS

DEFINE XMAC(A,B,C)
<	C,,B
>

XDIS:	XARGS

TABLEN__.-XDIS

PURGE XARGS
                                                                                                                                                                                                                                                                     COMMENT    VALID 00016 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	VERSION(EDIT,5)
C00007 00003	ENTER INSERT MODE (BOTH WAYS)
C00010 00004	INSERT MODE, PLUS, MINUS, SPACE, BS
C00013 00005	D, R+, R-
C00015 00006	P, N, EXIT EDIT MODE
C00021 00007	SPREAD PIN #'S OVER SAME PIN ID'S
C00023 00008	PLACE A PIN SUBR, UPDATE LOC OFFSET IN BODIES
C00027 00009	DELETE PIN
C00030 00010	GET -- G, SPACE
C00031 00011	GET -- Y
C00036 00012	CALC PIN LOC'S AND THUS OFFSET #'S
C00041 00013	DELETE TYPE
C00043 00014	DELETE LIBRARY
C00045 00015	RSPINI	RESET PINIDS CANONICALLY FROM DEFAULT PIN NAMES
C00049 00016	
C00050 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        VERSION(EDIT,5)
;ENTER EDIT MODE, SETDIP
MD,<
ENTEPN:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ A,(A)	;POINTER TO DATA BLOCK
	HRRZ A,1(A)	;POINTER TO TYPE
	JRST ALREAD	;SKIP "TYPE BODY NAME"

ENTEDC:	MOVEI T,[ASCIZ/TYPE BODY NAME
/]
	PUSHJ P,BODYGT	;GET POINTERS TO BODY STUFF
	POPJ P,		;IF ALTMODE
	POPJ P,		;NULL
	CAIA		;NEW NAME
	JRST ALREAD	;ALREADY EXISTS
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW BODY.
/]
	GETFS (A)
	HRRZM B,(A)	;DEPOSIT (WITH 0 LIBRARY POINTER)
	MOVE B,BODPNT	;GET CURRENT BODY POINTER
	MOVEM B,1(A)	;DEPOSIT
	MOVEM A,BODPNT	;PUT THIS BODY IN CHAIN
	GETFS (B)
	HRLM B,1(A)	;DEPOSIT POINTER TO POINTER BLOCK
	GETFS(T)	;GET A DEF LOC OFFSET BLOCK (AND BITS)
	HRLZM T,(B)	;STORE
	SETZM 1(T)	;CLEAR LOC OFFSET
	SETZM (T)	;CLEAR BITS AND CHAR OFFSET POINTER
	SETZM 1(B)	;CLEAR REST OF POINTER BLOCK
ALREAD:	HLRZ T,(A)
	SKIPN MODLIB	;ALLOW MODIFICATION
	JUMPN T,NOEDIT	;CAN'T EDIT FROM LIBRARY
	MOVEM A,CURBOD	;SAVE POINTER TO CURRENT BODY
	MOVE T,XOFF
	MOVEM T,EDXOFF
	MOVE TT,YOFF
	MOVEM TT,EDYOFF
	MOVE T,CURSE
	MOVEM T,EDCURS
	MOVE T,NSCALE
	MOVEM T,EDSCAL
	PUSHJ P,HOME	;CENTER EVERYTHING
	MOVE T,MODE
	MOVEM T,EDMODS
	MOVEI T,MAINPG-1;CLEAR ALL THESE
	PUSHJ P,HYDPOG
	SOJG T,.-1
	TRO MCHG
	MOVEI T,EDTM	;GET NEW MODE (EDIT)
	JRST CHNGMD	;CHANGE MODE

NOEDIT:	OUTSTR[ASCIZ/I AM SORRY BUT YOU
CAN'T MODIFY LIBRARY BODIES!
/]
	POPJ P,

;CLEAR MARK BITS IN TYPE DEFINITION
CDFMRK:	SKIPN T,BODPNT
	POPJ P,
	MOVSI TT,DTMP1
CDFMK1:	HLRZ TTT,1(T)
	JUMPE TTT,CDFMK2
	HLRZ TTT,(TTT)
	ANDCAM TT,(TTT)	;CLEAR MARK BITS
CDFMK2:	HRRZ T,1(T)
	JUMPN T,CDFMK1
	POPJ P,

;STUFF EITHER BODY DEF NAME OR DIP TYPE NAME INTO MACRO
STFLNM:	TROA TFLG
STFLDP:	TRZ TFLG
	MOVE T,CURBOD
	JRST STODEF

SETDLC:	SKIPA B,[TLZE C,XDISLOC]	;INST TO CLEAR "DON'T DISPLAY" BIT
CLRDLC:	MOVE B,[TLON C,XDISLOC]	;INST TO SET		"
	MOVEI T,1
	LSH T,@MODE
	TDNN T,[ALLEDM!1EDTAM]
	JRST PERRET
	MOVE A,CURBOD
	HLRZ A,1(A)
	HLRZ A,(A)
	MOVE C,(A)		;GET BODY DEF BITS
	XCT B			;TURN BIT ON OR OFF AND TEST
	TLNN M,BLOCS		;CHANGED, ARE WE DISPLAYING A01
	CAIA			;NO
	TRO MCHG		;YES
	MOVEM C,(A)		;STORE BIT BACK
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                         ;ENTER INSERT MODE (BOTH WAYS)
EDINS2:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,CLSTPN
	SETZM CRPPNT		;MAKE SURE WE DON'T ADD A POINT.
	HRRZ A,(A)
	TRZ ATLP!ATFP
	MOVEI T,EDTIM
	PUSHJ P,CHNGMD
	JUMPN A,EDBS
	TRO ATLP
	JRST EDBS	;BACK UP TO THE RIGHT POINT

EDINS:	MOVEI T,EDTIM	;GET NEW MODE (EDIT INSERT)
	PUSHJ P,CHNGMD
	MOVE A,CURBOD	;GET CURRENT BODY POINTER
	HLRZ B,1(A)	;GET POINTER TO POINTER BLOCK
	ADDI B,1	;MAKE POINTER TO LINE POINTER
	MOVEM B,CLSTPN	;DEPOSIT
	HRRZ B,(B)	;GET POINTER TO FIRST LINE
	MOVEM B,CRPPNT	;DEPOSIT
	TRO ATFP!TYPNEG!MCHG	;MARK AS AT FIRST POINT, AND MAKE FIRST VECTOR INVIS.
	TRZ ATLP	;ASSUME NOT A LAST POINT YET!
	JUMPN B,EDPOS	;VIRGIN LINE LIST?
	PUSHJ P,EDROT	;YES, MAKE A FIRST POINT
	MOVEM T,1(A)
	SETZM (A)
	MOVE B,A
	HRRM B,@CLSTPN	;LINK IN
EDPOS:	SKIPN B,CRPPNT	;GET POINTER TO CURRENT POINT
	POPJ P,		;NONE
	PUSHJ P,CLEAR1	;CLEAR THESE UNTIL DISP!
	PUSHJ P,CLEAR2
	MOVE T,1(B)	;GET X,Y
	TRZE T,1
	TRO TYPNEG
	JRST SETPOS	;CENTER CURSOR THERE

EDROT:	MOVE T,CURSE	;GET CURRENT CURSOR POSITION
	TRZE TYPNEG	; - LAST?
	TRO T,1		;YES
	GETFS (A)
	POPJ P,
EDROT1:	TRZE ATFP	;TURN OFF AT-FIRST-POINT. ARE WE?
	TRO T,1		;YES, MAKE INVISIBLE
	TRO MCHG
	MOVEM T,1(A)	;DEPOSIT X,Y
	MOVE B,CLSTPN	;GET POINTER TO CURRENT "LAST" (PRECEDING) POINT
	HRRZ T,(B)	;GET LINK TO NEXT
	MOVEM T,(A)	;DEPOSIT HERE
	HRRM A,(B)	;LINK LAST ONE TO THIS ONE
	MOVEM A,CLSTPN	;MAKE THIS THE "LAST" ONE
	MOVEM T,CRPPNT	;MAKE NEXT ONE CURRENT
	MOVE A,1(T)
	TRZ A,1
	TRNE TYPNEG	;SHOULD THIS ONE BE NEGATIVE?
	TRO A,1
	MOVEM A,1(T)
	POPJ P,
                                                                                                                                                                                                                                                                                                                      ;INSERT MODE, PLUS, MINUS, SPACE, BS
EDPLUS:	PUSHJ P,EDROT
	JRST EDROT1

EDMINS:	PUSHJ P,EDROT
	TRO TYPNEG	;MAKE NEXT ONE AN INVISIBLE VECTOR
	JRST EDROT1

EDSPC:	TRNN ATLP	;AT LAST POINT?
	SKIPN B,CRPPNT	;GET POINTER TO CURRENT POINT
	POPJ P,		;NONE
	TRO MCHG
	TRZ ATFP!TYPNEG
	MOVEI T,1
	AND T,1(B)	;GET VISIBLE/INVISIBLE BIT
	IOR T,CURSE	;PUT IN CURRENT POSITION
	MOVEM T,1(B)	;DEPOSIT
	HRRZ D,(B)	;GET POINTER TO NEXT POINT
	HRRZM B,CLSTPN	;MAKE THIS POINT THE "LAST" POINT
	MOVEM D,CRPPNT	;MAKE NEXT POINT THE CURRENT POINT
	HRRZ D,(D)
	JUMPN D,EDPOS
	TRO ATLP	;AT LAST POINT NOW
	JRST EDPOS	;POSITION CURSOR

EDBS:	TRNE ATFP	;AT FIRST POINT?
	POPJ P,		;YES, DO NOTHING
	TRO MCHG
	TRZ ATLP!TYPNEG	;NO LONGER AT LAST POINT.
	MOVE A,CURBOD	;NO, GET POINTER TO BODY
	HLRZ B,1(A)	;GET POINTER TO POINTER BLOCK
	ADDI B,1	;POINT TO POINT POINTER
	MOVE C,B	;SAVE IT
	MOVE D,B	;SAVE CURRENT ONE
	HRRZ B,(B)	;GET NEXT ONE
	CAME B,CLSTPN	;ARE WE THERE?
	JRST .-3	;NO, LOOP
	CAMN C,D	;NOW AT FIRST?
	TRO ATFP!TYPNEG	;YES, SET BIT
	EXCH D,CLSTPN	;MAKE NEW ONE "LAST" ONE
	EXCH D,CRPPNT	;MAKE "LAST" ONE CURRENT ONE
	JUMPE D,EDBSOU	;IF FORMER CURRENT ONE DIDN'T EXIST, LEAVE
	MOVEI T,1
	AND T,1(D)	;GET VISIBLE/INVISIBLE BIT
	IOR T,CURSE	;GET CURRENT POSITION
	MOVEM T,1(D)	;DEPOSIT IN OLD POINT
EDBSOU:	HRRZ D,CRPPNT
	HRRZ D,(D)
	JUMPN D,EDPOS
	TRO ATLP
	JRST EDPOS	;POSITION CURSOR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;D, R+, R-
EDDELE:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE B,CURBOD
	HLRZ B,1(B)
	ADDI B,1
	MOVE C,B
	HRRZ B,(B)
	CAME B,A
	JRST .-3
	HRRZ B,(A)
	HRRM B,(C)
	FSTRET (A)
	TRO MCHG!NEEDCL
	MOVE B,CURBOD
	HLRZ B,1(B)
	HRRZ B,1(B)
	JUMPE B,CPOPJ		;IF NO POINTS LEFT AT ALL, LEAVE
	MOVEI T,1
	IORM T,1(B)	;MAKE SURE FIRST POINT IS STILL INVIS
	POPJ P,

EDDEL:	SKIPN B,CRPPNT	;GET POINTER TO CURRENT POINT
	POPJ P,		;NONE
	MOVE A,CLSTPN	;GET POINTER TO PRECEDING POINT
	HRRZ D,(B)	;GET POINTER TO NEXT POINT
	HRRM D,(A)	;REMOVE CURRENT POINT FROM CONSIDERATION
	MOVEM D,CRPPNT	;....
	FSTRET (B)
	TRO MCHG
	JUMPE D,EDBS	;IF AT END, BACK UP
	MOVEI T,1
	TRNE ATFP	;AT FIRST POINT?
	IORM T,1(D)	;YES, MAKE IT INVIS
	JRST EDPOS

EDCHNE:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE B,A
	JRST EDCHN1

EDCHNG:	HRRZ B,CRPPNT	;GET POINTER TO CURRENT POINT
	JUMPE B,PERRET	;NONE?
EDCHN1:	PUSHJ P,GETCHR	;GET CHAR
	HRRZ D,(B)	;GET POINTER TO NEXT POINT
	JUMPE D,CPOPJ 	;NONE?
	MOVE T,1(D)	;GET X,Y
	CAIN C,"+"	;WAS + TYPED?
	JRST ITPLS	;YES
	CAIE C,"-"	;WAS - TYPED?
	JRST PERRET	;NO, ERROR
ITMNS:	TROA T,1	;MAKE INVISBLE
ITPLS:	TRZ T,1		;MAKE VISIBLE
	MOVEM T,1(D)	;DEPOSIT
	TRO MCHG
	POPJ P,
                                                               ;P, N, EXIT EDIT MODE
EDPENT:	MOVEI T,EDTPM
	JRST CHNGMD

PNUMS:	PUSHJ P,GETCLS	;CURRENT PIN
	JRST PERRET
	HLRZ A,(A)
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW PIN NAME?/]
	HLRZ T,(A)
	ANDI T,BASSLH
	PUSHJ P,PSET
	JRST INNERR
	HRRM T,1(A)
	MOVE T,(A)
	TLZ T,BASSLH
	TLO T,(TT)
	MOVEM T,(A)
	TLNE M,PINIDS
	TRO MCHG
	POPJ P,

SETORI:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ A,(A)
STORI1:	TLNE M,DSKACT!MACACT
	JRST STORI2
	OUTSTR[ASCIZ/CURRENT PIN POSITION IS /]
	LDB T,[POINT POSW,1(A),POSB]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
NEW PIN POSITION # (0-7)?/]
STORI2:	PUSHJ P,READN
	CAIE C,12		;END WITH CR?
	JRST [	CAIE C,"?"
		JRST INNERR
		PUSHJ P,GETLIN
		CAIE C,12
		JRST INNERR
		TLNN M,DSKACT!MACACT
		OUTSTR[ASCIZ/
0	UP AND RIGHT		1	UP
2	UP AND LEFT		3	LEFT
4	DOWN AND LEFT		5	DOWN
6	DOWN AND RIGHT		7	RIGHT
/]
		JRST STORI1]
	CAILE T,(1POSW)-1		;LEGAL?
	JRST INNERR
	HRRZS 1(A)		;CLEAR X,Y OFFSETS
	DPB T,[POINT POSW,1(A),POSB]	;STORE HERE
	TRO MCHG
	POPJ P,

XYPOFF:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ A,(A)
	TLNE M,DSKACT!MACACT
	JRST XYPOF1
	OUTSTR[ASCIZ/CURRENT X,Y PIN OFFSET IS /]
	LDB T,[POINT XOFFW,1(A),XOFFB]
	TRNE T,1(XOFFW-1)
	ORCMI T,(1XOFFW)-1
	PUSHJ P,DECOUT
	OUTCHR[","]
	LDB T,[POINT YOFFW,1(A),YOFFB]
	TRNE T,1(YOFFW-1)
	ORCMI T,(1YOFFW)-1
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
NEW X,Y PIN OFFSET?/]
XYPOF1:	PUSHJ P,SREADN
	CAIGE T,1(YOFFW-1)
	CAMGE T,[-<1(YOFFW-1)>]
	JRST INNERR
	HRLM T,(P)		;SAVE X
	SETZ T,
	CAIN C,","
	PUSHJ P,SREADN
	CAIGE T,1(YOFFW-1)
	CAMGE T,[-<1(YOFFW-1)>]
	JRST INNERR
	CAIE C,12
	JRST INNERR		;LOSE
	DPB T,[POINT YOFFW,1(A),YOFFB]
	HLRE T,(P)
	DPB T,[POINT XOFFW,1(A),XOFFB]
	TLNE M,PINIDS		;IF SHOWING DEFAULT PINS
	TRO MCHG		;THEN REDRAW SCREEN
	POPJ P,

STOBPN:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	PUSHJ P,SETTT
	PUSH P,A
	PUSHJ P,OUTPID
	POP P,A
	JRST ITSTUF

EDALT:	TRO MCHG
	MOVEI T,EDTM
	JRST CHNGMD

EDITE:	MOVE A,CURBOD
	HLRZ A,1(A)
	JRST EDITE4

EDITE5:	PUSH P,A
	PUSHJ P,PSPRED
	POP P,A
EDITE4:	HRRZ A,(A)
	JUMPN A,EDITE5
	MOVE T,EDMODS		;GET OLD MODE BACK
	PUSHJ P,CHNGMD		;CHANGE NOW IN CASE IN EDIT INSERT MODE
	MOVE T,EDXOFF
	MOVEM T,XOFF
	MOVE T,EDYOFF
	MOVEM T,YOFF
	MOVE T,EDSCALE
	MOVEM T,NSCALE
	TRO MCHG
	MOVE T,EDCURS	;BACK TO WHERE EVER
	JRST CHANGE

EDITP:	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ /PIN NAME?/]
	SETZ T,
	PUSHJ P,PSET
	JRST INNERR
	TRO MCHG!NEEDCL
	PUSH P,TT
	PUSHJ P,PUTPIN	;MAKE PIN EVERYWHERE
	POP P,TT
	HLRZ T,(C)
	HLL T,(T)
	TLO T,(TT)
	HLLM T,(T)
	MOVE G,C
	JRST FIXPUT	;CALC INITIAL PIN OFFSET

PSET:	HRLM T,(P)
	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
	PUSHJ P,RPNAM		;GET PIN NAME INTO T
	POPJ P,
	JUMPE T,CPOPJ		;DEFAULT PIN = 0 IS ILLEGAL
	HLRZ TT,(P)
DEC,<	CAIE C,"-"		;ASSERTION AFTER PIN NAME?
	JRST NOASS
	TRZ TT,ASSL!ASSH
	PUSHJ P,GETLIN
	CAIE C,"H"+40
	CAIN C,"H"
	JRST [	TRO TT,ASSH
		JRST NOASS1]
	CAIE C,"L"
	CAIN C,"L"+40
	CAIA
	JRST NOASS
	TRO TT,ASSL
NOASS1:	PUSHJ P,GETLIN
NOASS:
>;DEC
	CAIE C,"/"
	JRST NOBUSS
	TRZ TT,BUSSED
	PUSHJ P,GETLIN
	CAIE C,"B"
	CAIN C,"B"+40
	CAIA
	JRST NOBUSS
	TRO TT,BUSSED
	PUSHJ P,GETLIN
NOBUSS:	CAIN C,12
	AOS (P)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;SPREAD PIN #'S OVER SAME PIN ID'S
PSPRED:	HLRZ A,(A)
	HRRZ A,1(A)
	PUSH P,A		;SAVE PIN NAME
	MOVEI B,DBODPN
PSPRD1:	MOVE A,CURBOD
	PUSHJ P,BODFNN
	JRST PSPRD2
	POP P,(P)
	POPJ P,

PSPRD2:	HLRZ A,(B)
	HRRZ A,(A)
	SETZ F,
PSPRD3:	HLRZ A,(A)
	HRRZ TTT,1(A)
	HRRZ T,(TTT)
	HLRZ T,(T)
	HRRZ TT,1(T)
	CAME TT,(P)		;SAME PIN NAME?
	JRST PSPRD4
	MOVE F,TTT		;SAVE THIS ONE
	MOVE TT,(T)
	TLNN TT,BUSSED		;IS IT BUSSED?
	JRST PSPRD5
PSPRD4:	HRRZ A,(A)
	JUMPN A,PSPRD3
	JUMPE F,PSPRD1
PSPRD5:	HRRZ F,1(F)		;GET PIN NAME TO SET
	HLRZ A,(B)
	HRRZ A,(A)
PSPRD6:	HLRZ A,(A)
	HRRZ TTT,1(A)
	HRRZ T,(TTT)
	HLRZ T,(T)
	HRRZ T,1(T)
	CAMN T,(P)
	HRRM F,1(TTT)
	HRRZ A,(A)
	JUMPN A,PSPRD6
	JRST PSPRD1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;PLACE A PIN SUBR, UPDATE LOC OFFSET IN BODIES
PUTPIN:	MOVE A,CURBOD	;GET POINTER TO CURRENT BODY
	GETFS (B)	;A NEW NUMBER, GET FREE STORAGE
	PUSH P,B
	HLRZ C,1(A)	;DATA BLOCK POINTER
	HRRZ D,(C)	;GET PIN POINTER
	MOVEM D,(B)	;LINK IN NEW THING
	HRRM B,(C)
	GETFS(C)
	HRLM C,(B)
	HRRZM T,1(C)
	MOVEI TT,1	;START AT 1
	MOVEI C,1	;FOR LARGEST ALSO
PTPIN1:	HRRZ T,(B)
	JUMPE T,PTPIN3
PTPIN2:	HLRZ TTT,(T)
	HRRZ TTT,(TTT)
	CAMLE TTT,C
	ADDI C,1
	CAMN TTT,TT
	AOJA TT,PTPIN1
	HRRZ T,(T)
	JUMPN T,PTPIN2
PTPIN3:	CAILE C,777777		;CAN WE ASSIGN A NEW LARGER PIN ID?
	MOVE TT,C		;YES
	HLRZ C,(B)
	HRRZM TT,(C)
	MOVE T,CURSE	;GET CURRENT POSITION
	MOVEM T,1(B)	;DEPOSIT AS POSITION OF PIN
	MOVE C,B	;HOLD POINTER TO PIN ENTRY IN TYPE
	MOVE B,DBODPN	;GET POINTER TO BODIES
BFRT:	PUSHJ P,BODFN	;FIND INSTANCES OF THIS TYPE
	JRST BFNDD	;FOUND ONE
	POP P,A		;RETURN POINTER TO TYPE BLOCK IN A
	POPJ P,		;NONE LEFT

BFNDD:	PUSH P,A	;SAVE A
	MOVE A,C	;GET POINTER TO PIN ENTRY IN TYPE
	PUSH P,(B)	;SAVE POINTER TO NEXT
	HRLI B,ISPIN	;PUT BITS IN WITH BODY POINTER
	HLRZ T,(B)
	HLRZ F,(T)	;ORIENTATION
	MOVE T,1(C)	;GET PIN X,Y
	PUSHJ P,ORIENT	;ROTATE IT
	ADJUST(ADD,T,<1(B)>)	;ADD BODY CENTER
	PUSH P,T
	PUSHJ P,PUTPNT	;CREATE THE POINT
	POP P,1(D)	;SET X,Y
	HLRZ B,(B)	;GET POINTER TO BODY DATA BLOCK
	HRRZ E,(B)	;GET PIN LINK
	HRRM E,(TTT)	;DEPOSIT IN APPROPRIATE PLACE IN POINT ENTRY
	HRRM D,(B)	;LINK NEW ONE INTO BODY
	POP P,B		;GET POINTER TO NEXT
	HRRZS B
	HLRZ TT,(A)
	HRRZ TT,1(TT)
	POP P,A
BFNDD1:	JUMPE E,BFRT
	HLRZ E,(E)
	HRRZ TTT,1(E)
	HRRZ E,(E)
	HRRZ D,(TTT)
	HLRZ D,(D)
	HRRZ D,1(D)
	CAME D,TT
	JRST BFNDD1
	HRRZ D,1(TTT)
	HRRM D,1(T)
	JRST BFRT

BODFNA:	HLRZ T,(B)	;GET POINTER TO DATA BLOCK
	HRRZ T,1(T)	;GET TYPE POINTER
	CAMN T,A	;BODY OF THIS TYPE?
	POPJ P,		;YES, RETURN IT
BODFNN:	HRRZ B,(B)	;GET NEXT
BODFN:	JUMPN B,BODFNA
	AOS (P)
	POPJ P,

UPLOFF:	MOVE A,CURBOD
	HLRZ C,1(A)
	HLRZ C,(C)
	MOVEI B,DBODPN
UPLOF2:	PUSHJ P,BODFNN
	JRST UPLOF1
	POPJ P,

UPLOF1:	HLRZ D,(B)
	HLRZ F,(D)
	HLRZ D,1(D)
	MOVE T,1(D)
	TLNN T,FIXLOC!FIXBLO	;DOES IT WANT TO BE FIXED?
	JRST UPLOF2
	HRRZ TTT,(D)
	JUMPE TTT,UPLOF2		;JUST IN CASE
	TLNN T,FIXLOC		;FIXING LOC?
	JRST UPLOF3
	MOVE T,1(C)
	PUSHJ P,ORIENT
	MOVEM T,1(TTT)
UPLOF3:	MOVE T,B
	PUSH P,A
	PUSH P,B
	PUSHJ P,OFFBLO
	POP P,B
	POP P,A
	JRST UPLOF2

ELCCLR:	TRZ INMOV
	MOVE A,CURBOD
	HLRZ A,1(A)
	HLRZ A,(A)
	HRRZ B,(A)
	JUMPE B,CPOPJ
	HLLZS (A)
	FSTRET(B)
	TLNE M,BLOCS
	TRO MCHG
	POPJ P,
   ;DELETE PIN
EDPDEL:	PUSHJ P,GETCLS	;GET POINTER TO CLOSEST PIN
	JRST PERRET
	MOVE C,A
	MOVE A,CURBOD	;GET POINTER TO CURRENT TYPE
	HLRZ D,1(A)	;GET POINTER TO DATA BLOCK
			;LET DATA BLOCK POINTER LOSE FIRST TIME
EDPDL2:	CAMN D,C	;IS THIS THE ONE THAT POINTS TO THE CLOSEST ONE?
	JRST EDPDL1	;YES
	MOVE B,D	;NO, TRY ANOTHER
	HRRZ D,(B)
	JUMPN D,EDPDL2
	PUSHJ P,FUCKUP
EDPDL1:	HRRZ D,(C)	;GET POINTER TO ONE BEYOND CLOSEST
	HRRM D,(B)	;LINK AROUND CLOSEST ONE
	MOVEI B,PONPNT	;GET ON-SCREEN POINTER
	PUSHJ P,TPINFN	;FIND INSTANCES OF THIS PIN IN THE WORLD AND REMOVE THEM
	HLRZ B,(C)
	FSTRET (B)
	FSTRET (C)	;RETURN THING TO FREE STORAGE
	TRO MCHG!NEEDCL
	POPJ P,

TPNFN1:	HLRZ D,(B)	;DATA BLOCK POINTER
	HRRZ E,1(D)	;GET POINTER TO TEXT, PIN AND BODY BLOCK
	HRRZ F,(E)	;GET POINTER TO BODY PIN BLOCK!
	CAME F,C	;SAME AS PIN WE ARE DELETING?
	JRST TPINFN	;NO, TRY ANOTHER
	PUSH P,C	;SAVE OLD PIN BLOCK POINTER
	HLRZ C,(D)	;GET BODY POINTER FROM PIN WE WANT TO DELETE
			;AND TREAT AS FIRST POINT (WILL LOSE FIRST TIME)
GOPN:	CAME C,B	;IS THIS THE POINT IN QUESTION
	JRST GOPN1	;NO
	HLRZ D,(C)	;YES, LINK IT OUT OF BODY LIST
	HRRZ D,(D)
	HRRM D,(E)
	TRO TFLG	;DELETE PINS OK!
	PUSH P,A
	PUSHJ P,DELPNT
	POP P,B		;RESTORE LAST AS CURRENT
	JRST NTPNFN

GOPN1:	HLRZ E,(C)
	HRRZ C,(E)
	JUMPN C,GOPN
	PUSHJ P,FUCKUP
NTPNFN:	POP P,C		;RESTORE OLD PIN TYPE BLOCK POINTER
TPINFN:	MOVE A,B	;SAVE LAST
	HRRZ B,(B)
	JUMPN B,TPNFN1
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;GET -- G, SPACE
BODGET:	MOVEI T,[ASCIZ/TYPE BODY NAME
/]
	PUSHJ P,BODYGT	;GET BODY NAME & POINTER
	POPJ P,		;ALTMODE
	POPJ P,		;NULL NAME
	JRST OOPS1
	CAMN A,CURBOD
	JRST [	OUTSTR[ASCIZ/SORRY YOU CAN'T "GET" THE CURRENT BODY!!!
/]
		POPJ P,]
	MOVEM A,GETBOD	;CURRENT BODY WE ARE GETTING
	SETZM GETORT	;START WITH STANDARD ORIENTATION
	TRO MCHG
	MOVEI T,EDTGM	;SET MODE
	JRST CHNGMD

GETSPC:	AOS T,GETORT
	ANDI T,7
	MOVEM T,GETORT
	TRO MCHG
	POPJ P,
                                                                                                                                                                       ;GET -- Y
GETYES:	PUSH P,CURSE
	TRO MCHG
	MOVE G,GETBOD	;NEW BODY
	MOVE A,CURBOD		;CHECK FOR EMPTY BODY AND COPY NEW LOC
	HLRZ A,1(A)
	SKIPE 1(A)
	JRST GETY1		;IF LINES OR TEXT, NO COPY
	HRRZ T,(A)
	JUMPN T,GETY1		;IF PINS, NO COPY
	HLRZ A,(A)
	SKIPE 1(A)
	JRST GETY1		;IF LOC OFFSET, NO COPY
	HRRZ T,(A)
	JUMPN T,GETY1		;IF LOC CHAR OFFSET, NO COPY
	HLRZ T,1(G)
	HLRZ T,(T)
	MOVE TTT,1(T)
	ADJUST(ADD,TTT,<(P)>)	;ADD CURSOR POS
	MOVEM TTT,1(A)		;COPY LOC OFFSET
	HRRZ TT,(T)
	JUMPE TT,GETY1		;ANY CHAR OFFSET TO COPY?
	MOVE TTT,1(TT)		;YES, GET IT
	GETFS(TT)		;NEW BLOCK FOR OUR BODY
	MOVEM TTT,1(TT)		;STORE OFFSET
	HRRM TT,(A)		;LINK IN BLOCK
	SETZM (TT)		;CLEAR UNUSED WORD
GETY1:	HLRZ G,1(G)	;DATA BLOCK LINK
	HRRZ G,(G)	;POINTER TO PINS
	JUMPE G,GNOPINS	;NONE
NEWPINS:MOVE T,1(G)	;LOC OF PIN
	MOVE F,GETORT
	PUSHJ P,ORIENT	;ORIENT IT
	ADJUST(ADD,T,<(P)>)	;ADD OFFSET
	MOVEM T,CURSE		;PUTPIN WILL LOOK HERE
	HLRZ T,(G)
	HRRZ T,1(T)		;COPY DEFAULT PIN NUMBER
	PUSHJ P,PUTPIN		;MAKE A PIN
	HLRZ T,(G)
	HLRZ T,1(T)
	MOVE TTT,F
	PUSHJ P,PINORI		;ROTATE PIN POS
	HLRZ TT,(C)
	HRLM T,1(TT)		;COPY PIN POS
	HLRZ T,(G)
	HLRZ T,(T)
	HRLM T,(TT)		;COPY BITS ALSO
	HRRZ G,(G)		;NEXT PIN
	JUMPN G,NEWPINS		;ANOTHER?
GNOPINS:MOVE A,CURBOD		;CURRENT BODY
	HLRZ A,1(A)		;LINK TO DATA BLOCK
	MOVEI A,1(A)		;POINT TO LINK FIELD
LOOPLN:	HRRZ B,(A)		;NEXT LINE IN CHAIN
	JUMPE B,LOOPL1
	MOVE A,B
	JRST LOOPLN		;FOLLOW CHAIN
LOOPL1:	MOVE G,GETBOD		;NEW BODY
	HLRZ G,1(G)		;LINK TO DATA BLOCK
	HRRZ G,1(G)		;
	JRST NXTLIN		;JUMP INTO LOOP
GMAKLN:	GETFS(TT)		;GET FREE STORAGE BLOCK FOR NEW LINE
	HRRM TT,(A)		;LINK ONTO LIST
	MOVE A,TT		;NEW END
	MOVE T,1(G)		;NEW LINE END
	LDB TT,[POINT 1,T,35]	;SAVE VIS OR INVIS
	TRZ T,1
	MOVE F,GETORT
	PUSHJ P,ORIENT		;ORIENT IT
	ADJUST(ADD,T,<(P)>)	;OFFSET IT
	DPB TT,[POINT 1,T,35]	;PUT BACK VIS OR INVIS
	MOVEM T,1(A)		;TO MEMORY
	HRRZ G,(G)		;NEXT NEW LINE
NXTLIN:	JUMPN G,GMAKLN		;DO ANOTHER?
	HLLZS (A)		;CLEAR LINK
	MOVE A,CURBOD		;CURRENT BODY
	HLRZ A,1(A)		;LINK TO ....
	HLRZ C,1(A)		;SAVE THESE 2 POINTERS.
	MOVE G,GETBOD		;NEW BODY
	HLRZ G,1(G)		;LINK TO ....
	HLRZ G,1(G)		;LINE TO BODY TEXT
	JUMPE G,GETDON		;IS THAT ALL?
GBTEXT:	HLRZ T,(G)
	HLRZ T,(T)
	JUMPE T,NPROP2		;ALWAYS COPY IF JUST TEXT
	MOVE TTT,CURBOD
	HLRZ TTT,1(TTT)
	HLRZ TTT,1(TTT)
	JUMPE TTT,NPROP2	;COPY IF NO PROPERTIES YET
	PUSHJ P,FPROPX
	JRST NPROP2		;DOESN'T EXIST, COPY
	JRST NPROP1		;EXISTS, DON'T COPY

NPROP2:	GETFS(D)		;GET A BLOCK FOR MAGIC WORDS
	MOVE T,1(G)		;X,Y
	MOVE F,GETORT
	PUSHJ P,ORIENT		;ORIENT IT
	ADJUST(ADD,T,<(P)>)	;OFFSET IT
	MOVEM T,1(D)		;SAVE IT
	HRLM D,1(A)		;LINK IT IN
	MOVEM C,(D)		;AND THE REST OF THE LIST TO IT.
	MOVE C,D		;THIS IS NOW THE REST OF THE LIST
	HLRZ T,(G)		;POINTER TO TEXT (IN STANDARD FORMAT)
	PUSHJ P,STRCOP		;COPY TEXT
	HRLM B,(C)		;LINK IN TEXT
	HLRZ T,(G)
	HLRZ T,(T)
	JUMPE T,NPROP1
	PUSHJ P,LSTCOP
	HLRZ T,(C)
	HRLM B,(T)
NPROP1:	HRRZ G,(G)		;NEXT NEW BTEXT
	JUMPN G,GBTEXT
GETDON:	POP P,CURSE	;RESTORE CURSOR POS
GETALT:	TRO MCHG
	MOVEI T,EDTM	;BACK TO EDIT MODE
	JRST CHNGMD
                                            ;CALC PIN LOC'S AND THUS OFFSET #'S
;FIX ALL BODIES
FIXALL:	SKIPN H,BODPNT
	POPJ P,
FIXAL1:	HLRZ T,(H)		;LIBRARY POINTER
	SKIPN MODLIB		;ALLOW MODIFICATION?
	SKIPN T			;SKIP THESE, CAN'T FIX THEM
	PUSHJ P,FIXSOM
	HRRZ H,1(H)
	JUMPN H,FIXAL1
	POPJ P,

;FIX ALL PIN #'S OF THIS BODY
PALL:	MOVE H,CURBOD
;CALL WITH BODY DEF POINTER IN H
FIXSOM:	HLRZ G,1(H)
	JUMPE G,CPOPJ		;QUIT IF BODY NOT IN YET!!!
	HRRZ G,(G)
	JUMPE G,CPOPJ
	PUSHJ P,CALSET
FIXSM1:	PUSHJ P,CALFIX
	HRRZ G,(G)
	JUMPN G,FIXSM1
	POPJ P,

;FIX PIN # OFFSET FOR CLOSEST PIN
FIXONE:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE G,A
FIXPUT:	MOVE H,CURBOD
	PUSHJ P,CALSET		;SET UP PIN CENTERS
;FALL INTO CALFIX
;CALL WITH BODY DEF POINTER IN H, AND PIN POINTER IN G
CALFIX:
DEC,<	HLRZ F,(G)
	HLRZ F,1(F)
	ANDI F,7
	SKIPE OUTSIDE
	ADDI F,5
>;DEC
	PUSHJ P,CALP		;FIND HIS NUMBER
NODEC,<	POPJ P,		>	;NO CAN DO
DEC,<	JFCL	>		;TRY HARDER
	SKIPE OUTSIDE		;PUTTING OUTSIDE?
	SUBI F,5		;YES, USE THIS NUMBER
DEC,<	CAMN F,[-2]
	SETZ F,
>;DEC
	ANDI F,7
	HLRZ T,(G)
	HRRZS 1(T)		;CLEAR X,Y OFFSET FIRST
	DPB F,[POINT POSW,1(T),POSB]
	TRO MCHG
	POPJ P,

;CALL WITH BODY DEF POINTER IN H, AND PIN POINTER IN G
;DX1 - AVERAGE OF ALL PIN X'S
;DY1 - 		"	  Y'S
CALP:	HLRZ T,(G)
	HLRZ T,(T)
	TRNE T,BUSSED			;IF BUSSED THROUGH, SAY CAN'T DO
	POPJ P,
	HLRZ A,1(H)
	MOVE E,1(G)
	HRRZ B,1(A)
	JUMPN B,CALP1
	POPJ P,

CALP2:	MOVE T,1(B)
	TRNE T,1		;INVIS?
	JRST CALP1		;YES, TRY ANOTHER
	XOR T,1(A)
	TLNE T,-2		;VERT?
	JRST NVERT		;YES
	TRNN T,-2		;ZERO LENGTH SEG?
	JRST CALP1		;YES, IGNORE IT
	MOVE T,E
	XOR T,1(A)
	TLNE T,-2		;PIN ON SAME LINE?
	JRST CALP1		;NO
	HLRE T,E		;GET PIN X
	CAMLE T,DX1		;COMPARE WITH CENTER OF ALL PINS
	SKIPA F,[3]		;RIGHT
	MOVEI F,7		;LEFT
	HRRE T,1(A)
	HRRE TT,E
	HRRE TTT,1(B)
	JRST DELCAL

NVERT:	TRNE T,-2		;HORZ?
	JRST CALP1		;NO
	MOVE T,E		;YES
	XOR T,1(A)
	TRNE T,-2		;PIN ON SAME LINE?
	JRST CALP1		;NO
	HRRE T,E
	CAMLE T,DY1
	SKIPA F,[5]		;UP
	MOVEI F,1		;DOWN
	HLRE T,1(A)
	HLRE TT,E
	HLRE TTT,1(B)
DELCAL:	SUB T,TTT
	SUB TT,TTT
	JUMPG TT,NNEG
	JUMPGE T,CALP1		;OFF END?
	CAML T,TT
	JRST CALP1
	JRST CPOPJ1

NNEG:	JUMPLE T,CALP1
	CAMLE T,TT
	JRST CPOPJ1
CALP1:	MOVE A,B
	HRRZ B,(A)
	JUMPN B,CALP2
	POPJ P,		;LOSE RETURN

;CALL WITH BODY DEF POINTER IN H
;RETURNS WITH:
;DX1 - (MAX+MIN)/2 OF ALL PIN X'S
;DY1 - 		"	      Y'S
CALSET:	HRLOI T,377777
	MOVEM T,DX3
	MOVEM T,DY3
	MOVSI T,400000
	MOVEM T,DX1
	MOVEM T,DY1
	HLRZ T,1(H)		;FIRST CHECK EXISTING PINS
	PUSHJ P,CALST1
	HLRZ T,1(H)
	ADDI T,1		;NOW CHECK LINES
	PUSHJ P,CALST1
	MOVE T,DX1
	ADD T,DX3
	ASH T,-1
	MOVEM T,DX1
	MOVE T,DY1
	ADD T,DY3
	ASH T,-1
	MOVEM T,DY1
	POPJ P,

CALST2:	MOVE TTT,1(T)
	HLRE TT,TTT
	CAMGE TT,DX3
	MOVEM TT,DX3
	CAMLE TT,DX1
	MOVEM TT,DX1
	HRRE TT,TTT
	CAMGE TT,DY3
	MOVEM TT,DY3
	CAMLE TT,DY1
	MOVEM TT,DY1
CALST1:	HRRZ T,(T)
	JUMPN T,CALST2
	POPJ P,
                                                                                                                                                                                                                                              ;DELETE TYPE
TYPDEL:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ALLEDM!1EDTAM]	;ANY EDIT MODE?
	JRST PERRET		;YES, ILLEGAL
	MOVEI T,[ASCIZ/TYPE BODY NAME
/]
	PUSHJ P,BODYGT
	POPJ P,		;ALTMODE
	POPJ P,		;NULL
	JRST OOPS1	;NO SUCH BODY
	TLZ WFLAG	;DON'T QUIT IF YOU FIND ONE
TYPFLU:	PUSH P,A	;SAVE TYPE POINTER
	MOVEI A,DBODPN
	JRST TYPDL1
TYPDL2:	HLRZ T,(A)
	HRRZ T,1(T)
	CAME T,(P)
	JRST TYPDL1
	TLNE WFLAG
	JRST [	POP P,A
		POPJ P,];QUIT IF WFLAG SET (WE WANT IT!)
	PUSH P,B
	PUSHJ P,BCLEAR	;DELETE BODY
	POP P,A		;RESTORE LAST AS CURRENT
TYPDL1:	MOVE B,A
	HRRZ A,(A)
	JUMPN A,TYPDL2
	SKIPE MODLIB
	JRST TCLEAR
	HLRZ T,@(P)
	JUMPE T,TCLEAR
	OUTSTR[ASCIZ/ALL INSTANCES OF THIS BODY HAVE BEEN
DELETED, BUT THE TYPE MUST REMAIN
AS IT IS PART OF A LIBRARY!
/]
	POP P,A
	POPJ P,

TCLEAR:	MOVEI A,BODPNT-1
	JRST TYPDL6
TYPDL4:	CAMN A,(P)
	JRST TYPDL5
TYPDL6:	MOVE B,A
	HRRZ A,1(A)
	JUMPN A,TYPDL4
	POP P,A
	PUSHJ P,FUCKUP
	POPJ P,		;SHOULDN'T HAPPEN.
TYPDL5:	HRRZ C,1(A)
	HRRM C,1(B)	;LINK HIM OUT
	POP P,A		;GET BACK POINTER
	JRST TYPREL	;RELEASE STORAGE
                                                                                                                                                                                         ;DELETE LIBRARY
DELLBS:	TLOA WFLAG		;SAVE USED ONES
DELLIB:	TLZ WFLAG		;DON'T SAVE THEM
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	POPJ P,			;IF HE HOLLER, LET HIM GO!
	ENTPPN
	MOVEI TT,LIBLST
	MOVE A,FILNAM
	HLLZ B,FILEXT
	MOVE C,FILPPN
	JRST LIBLP1
LIBLP2:	CAME A,1(TT)
	JRST LIBLP1
	HLRZ TTT,(TT)
	CAME C,1(TTT)
	JRST LIBLP1
	HLLZ TTT,(TTT)
	CAMN TTT,B
	JRST FNDLIB
LIBLP1:	MOVE T,TT
	HRRZ TT,(TT)
	JUMPN TT,LIBLP2
	OUTSTR[ASCIZ/SORRY, NO SUCH LIBRARY!
/]
	POPJ P,

FNDLIB: HRRZ TTT,(TT)
	HRRM TTT,(T)		;LINK THIS LIBRARY OUT
	PUSH P,TT		;SAVE POINTER
	SKIPN A,BODPNT
	JRST FNDLBE
FNDLB1:	HRRZ B,1(A)		;GET LINK AHEAD
	HLRZ T,(A)		;GET LIBRARY POINTER
	CAME T,(P)		;THIS ONE
	JRST FNDLB2		;NO
	PUSH P,B
	HRRZS (A)		;CLEAR POINTER SO WE CAN DELETE
	PUSHJ P,TYPFLU		;DELETE THIS TYPE
	POP P,B
FNDLB2:	MOVE A,B		;NEXT
	JUMPN A,FNDLB1
FNDLBE:	POP P,A
	HLRZ B,(A)
	FSTRET(A)
	FSTRET(B)
	POPJ P,
                                                                                                                                                                                                                                                                                                            ;RSPINI	RESET PINIDS CANONICALLY FROM DEFAULT PIN NAMES

RSPINI:	MOVE T,MODE
	CAIE T,EDTM		;MUST BE IN NORMAL EDIT MODE
	JRST ERRET
	MOVE A,DBODPN
	HRRZ C,CURBOD		;POINTER TO BODY DEFINITION
RSPIN2:	HLRZ B,(A)
	HRRZ B,1(B)
	CAIN B,(C)
	JRST RSPIN1		;TYPE IS IN USE
	HRRZ A,(A)		;NEXT BODY
	JUMPN A,RSPIN2		;LOOP
	HLRZ C,1(C)
	HRRZ C,(C)		;POINTER TO BEGINNING OF PIN BLOCK LIST
	MOVEI D,(C)		;SAVE IN D
	MOVEI B,0		;GET LARGEST PIN NAME VALUE IN USE IN B
RSPIN3:	HLRZ A,(C)		;POINTER TO PIN BLOCK
	HRRZ T,1(A)		;PIN NAME
	CAIGE B,(T)		;SKIP IF LE THAN BIGGEST SO FAR
	MOVEI B,(T)		;NEW BIGGEST PIN NAME
	HRRM T,(A)		;SO COPY PIN NAME TO PIN ID
	HRRZ C,(C)		;NEXT PIN LIST BLOCK
	JUMPN C,RSPIN3		;LOOP IF MORE PINS
	MOVSI TTT,BUSSED
	MOVEI C,(D)
RSPIN4:	HLRZ A,(C)		;POINTER TO PIN BLOCK
	TDNE TTT,(A)
	JRST RSPIN5		;BUSSED THROUGH PIN
RSPIN6:	HRRZ C,(C)		;NEXT PIN LIST BLOCK
	JUMPN C,RSPIN4		;LOOP IF MORE PINS
RSPIN8:	HLRZ A,(D)		;POINTER TO PIN BLOCK
	TDNE TTT,(A)
	JRST RSPIN7		;BUSSED THROUGH PIN
RSPIN9:	HRRZ D,(D)		;NEXT PIN LIST BLOCK
	JUMPN D,RSPIN8		;LOOP IF MORE PINS
	TRO MCHG		;ALL DONE
	POPJ P,

RSPIN1:	OUTSTR [ASCIZ /CAN'T CHANGE PINIDS - BODY IN USE IN DRAWING
/]
	POPJ P,

RSPIN5:	HRRZ TT,1(A)		;PIN NAME
	ADDI TT,(B)		;NEW PIN ID
	HRRM TT,(A)
	JRST RSPIN6

RSPIN7:	HRRZ TT,1(A)		;PIN NAME
	ADDI TT,(B)		;WHAT NEW PIN ID SHOULD BE
	HRRZ T,(A)		;WHAT NEW PIN ID IS
	CAIE T,(TT)
	JRST RSPIN9		;NOT EQUAL - HAVE DIDDLED THIS ONE ALREADY
	PUSH P,B
	PUSH P,D		;SEE IF THERE IS AN IDENTICAL BUSSED BIN LATER
	PUSH P,A
	HRRZ T,1(A)		;PIN NAME
	PUSH P,T
RSPINB:	HRRZ D,(D)
	JUMPE D,RSPINA		;OFF END OF LIST
	HLRZ A,(D)		;POINTER TO PIN BLOCK
	HRRZ T,1(A)		;PIN NAME
	CAMN T,(P)		;SKIP IF NOT SAME PIN NAME
	TDNN TTT,(A)
	JRST RSPINB		;NOT BUSSED THROUGH OR NOT SAME PIN NAME
	HRRZ T,(A)		;PIN ID
	ADDI T,(B)		;MAKE IT UNIQUE
	HRRM T,(A)
	LSH B,1
	JRST RSPINB

RSPINA:	SUB P,[2,,2]
	POP P,D
	POP P,B
	JRST RSPIN9
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           COMMENT    VALID 00036 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	<DRAW>POINT.FAI85, 29-JUL-75 17:40:21, EDIT BY HELLIWELL
C00006 00003	PUTPNT, ONSCR
C00008 00004	ALTMODE, SPACE, PNTPUT
C00009 00005	NOT (D)
C00011 00006	MINUS, PLUS (D)
C00014 00007	MINUS, PLUS SUBRS (D)
C00017 00008	MAKE FEEDTHROUGH(|), PLUS (PC)
C00020 00009	MINUS, FNDLNK, FRELNK (PC)
C00022 00010	PNTPLC, PN2DEL
C00025 00011	DELPNT
C00028 00012	DELPNT SUBRS
C00031 00013	DELNUL
C00036 00014	CHANGE PAD TYPES
C00039 00015	MAKE AND BREAK INNER PLANE CONNEX (PC)
C00041 00016	SET PAD TYPE, MAKE AND BREAK FEEDTHROUGHS (PC)
C00043 00017	PIN #'S, CONNECTOR AND BODY (D)
C00048 00018	SET BODY PIN #
C00051 00019	MUNGING SUBROUTINES (PC)
C00054 00020	LINE EDIT TEXT, CLRTHK, SETTHK, PNTZ
C00057 00021	POINT TEXT, POINT TEXT TO MACRO, TEXT AND CONNECTOR OFFSETS (D)
C00064 00022	OFFALL, OFFTXT, OFFCON (D)
C00073 00023	CALC HEIGHT AND LENGTH OF TEXT IN OFFSET UNITS (D)
C00076 00024	KILL TEXT (D,PC)
C00077 00025	DELETE LINE (D)
C00079 00026	LINES, SET MIDPOINT, MAKE JOG, ATTACH POINT (D)
C00081 00027	ATTACH POINT TO LINE (D)
C00084 00028	ATTACH POINT TO POINT (D)
C00089 00029	BREAK JUNCTION OF 3 OR 4 LINES (D)
C00093 00030	JUMP LINE TO OTHER SIDE OF CARD (PC)
C00096 00031	LJUMP SUBRS (PC)
C00099 00032	DELETE LINE, DELETE WIRE
C00102 00033	PUT MIDPOINT IN LINE (PC)
C00104 00034	ATTACH POINT TO POINT (PC)
C00108 00035	ATTACH POINT TO LINE (PC)
C00110 00036	
C00111 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                                                   ;<DRAW>POINT.FAI;85, 29-JUL-75 17:40:21, EDIT BY HELLIWELL
VERSION(POINT,7)
;STRAIGHTEN LINES (D) CHECK FOR COINCEDENT POINTS
MD,<
STRAIGHTEN:
	TRO MCHG!NEEDCL
	SKIPN A,PONPNT
	POPJ P,
STRTN1:	MOVE TT,1(A)	;X,Y
	PUSHJ P,PMOVX	;STRAIGHTEN X
	PUSHJ P,PMOVY	;STRAIGHTEN Y
	HRRZ A,(A)
	JUMPN A,STRTN1
	POPJ P,
>;MD

;CHECK FOR POINT COINCEDENT WITH POINT IN A
STOPM:
MPC,<	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	EQV TT,SID
	JUMPL TT,SAMSTP
	SKIPE B,PONPN2
	JRST STOPM0
	POPJ P,

SAMSTP:
>;MPC
	SKIPN B,PONPNT
	POPJ P,
STOPM0:	MOVE T,1(A)
MD,<	HRLM B,(P)
	PUSHJ P,STOPM4
	POPJ P,			;FOUND LOSER
	HLRZ A,(A)
	HLRZ A,1(A)
	MOVE C,A
DEFINE STPMAC ' (X,Y)
<	H'X'RZ A,Y(C)
	JUMPE A,STPM'X'Y
	MOVE T,1(A)
	HLRZ B,(P)
	PUSHJ P,STOPM4
	POPJ P,
STPM'X'Y:
>
FOR I IN (<L,0>,<L,1>,<R,0>,<R,1>)
<	STPMAC(I)
>
	POPJ P,

>;MD
STOPM4:	CAMN T,1(B)
	JRST STOPM3
STOPM1:	HRRZ B,(B)
	JUMPN B,STOPM4
MD,<	JRST CPOPJ1	>
MPC,<	POPJ P,	>

STOPM3:	CAMN A,B
	JRST STOPM1
	OUTSTR[ASCIZ/
YOU JUST PUT ONE POINT ON TOP OF ANOTHER,
YOU'D BETTER FIX IT!
/]
	POPJ P,			;ONLY SAY IT ONCE
                                                                                                                                                             ;PUTPNT, ONSCR
;PUTPNT:  CREATES A POINT ENTRY ...
;CALL WITH:
;		A = POINTER TO PIN # & X,Y BLOCK
;		B = BITS & BODY POINTER

PUTPNT:	SETZM HSHFLG#
PUTPN0:	GETFS (D)
	GETFS (TTT)
	HRLZM TTT,(D)	;LINK BLOCKS TOGETHER
	TRO NEEDCL	;NEED ANOTHER CLOSES
	TLNE B,ISPIN	;IS THIS GOING TO BE A PIN?
	TDZA E,E	;YES, ZERO TO CELL
	AOS E,PID	;NEW POINT ID
	HRRM E,(TTT)	;SAVE POINT ID OR 0
	HRLM B,(TTT)	;SAVE BODY POINTER OR 0
	SKIPE HSHFLG	;FAST ENTRY??
	JRST PUTPN4
	MOVE T,D
	HRLI T,PONPNT
	MOVEM T,LSTPNT	;LAST POINT STORED AND ITS LAST
	MOVE T,PONPNT
	HRRZM D,PONPNT
	HRRM T,(D)
PUTPN4:
MD,<	GETFS (E)
	SETZM (E)	;NO LINES
	SETZM 1(E)	;...
>;MD
MPC,<	SETZ E,		;NO LINE BLOCK TO START WITH	>
	HRLZM E,1(TTT)	;DEPOSIT POINTER TO ^_ BLOCK
	GETFS (T)
	HRRM T,1(TTT)	;DEPOSIT POINTER TO TEXT & BODY POINTER BLOCK
	MOVEM A,(T)	;DEPOSIT PIN POINTER
MPC,<
	TLZ B,FRONT	;CLEAR THIS BIT
	IOR B,SID	;PUT IT ON CURRENT SIDE
ROUTE,<	TLZ M,%ROUTE	;MAKE HIM ROUTE AGAIN>
>;MPC
	HLLZM B,1(T)	;DEPOSIT BITS &  0
	POPJ P,

ONSCR:	CAML T,LEFT
	CAMLE T,RIGHT
	POPJ P,
	HRRE TTT,T	;GET Y
	CAML TTT,BOTTOM
	CAMLE TTT,TOP
	POPJ P,
	AOS (P)		;DO THIS FOR SPEED
	POPJ P,
                                                                                    ;ALTMODE, SPACE, PNTPUT
PNALT:	TRZE INLIN
	TRO NEEDCL
CLRMOV:	TRZE INMOV	;TURN OFF MOVING
	TRO NEEDCL
	POPJ P,

MD,<
PNSPC:	TRNN INLIN
	JRST CLRMOV
	TRC ZIGZAG	;COMPLIMENT THE WAY THE ZIG ZAGS
	POPJ P,
>;MD
;PNTPUT
;CALL WITH
;	T	X,Y FOR NEW POINT
;RETURNS WITH
;	D	POINTER TO POINT
;	TTT	DATA BLOCK
;	T	TEXT AND BODY BLOCK
;	E	NEIGHBORS

HSHPUT:	AOSA HSHFLG#	;MAKE FAST HASH ENTRY FOR NOW
PNTPUT:	SETZM HSHFLG
	PUSH P,B	;SAVE B
	SETZB A,B
	PUSH P,T	;SAVE X,Y
	PUSHJ P,PUTPN0	;CREATE ENTRY
	POP P,1(D)	;DEPOSIT X,Y
	POP P,B
	POPJ P,
                                                                           ;NOT (D)
MD,<
PNOT:	TRNE INLIN	;CHECK DRAWING LINE
	PUSHJ P,GETCLS
	JRST PERRET	;NO
	PUSHJ P,PNOT1
	JRST PERRET
	POPJ P,

PNOT1:	MOVE B,LINING
	HLRZ C,(A)
	HLRZ C,1(C)	;_^
	HLRZ D,(B)
	HLRZ D,1(D)	;_^
	MOVE T,1(A)	;X,Y OF START POINT
	ADJUST(SUB,T,<1(B)>)	;- X,Y OF DESTINATION
	HRRE TT,T
	HLRES T
	MOVEI E,0
	MOVEI F,2
	SKIPGE T
	MOVEI E,1
	SKIPGE TT
	MOVEI F,3
	MOVMS T
	MOVMS TT
	CAMN T,TT	;45 DEGREES?
	TRNN ZIGZAG	;YES, TAKE HINT FROM ZIGZAG
	CAMLE T,TT	;HORZ OR VERT?
	MOVE F,E	;HORZ, USE HORZ DISP.
	JRST @(F)[	NRIGHT
			NLEFT
			NUP
			NDOWN]
NRIGHT:	HRRZ T,1(D)
	JUMPN T,CPOPJ	;ONE THERE ALREADY, LOSE
	HLRZ T,1(C)
	JUMPN T,CPOPJ	;ONE LEFT OF DEST., LOSE
	HRRM A,1(D)
	HRLM B,1(C)
	JRST NOUT
NLEFT:	HLRZ T,1(D)
	JUMPN T,CPOPJ
	HRRZ T,1(C)
	JUMPN T,CPOPJ
	HRLM A,1(D)
	HRRM B,1(C)
	JRST NOUT
NUP:	HRRZ T,(D)
	JUMPN T,CPOPJ
	HLRZ T,(C)
	JUMPN T,CPOPJ
	HRRM A,(D)
	HRLM B,(C)
	JRST NOUT
NDOWN:	HLRZ T,(D)
	JUMPN T,CPOPJ
	HRRZ T,(C)
	JUMPN T,CPOPJ
	HRLM A,(D)
	HRRM B,(C)
NOUT:	TRZ INLIN
	TRO MCHG!NEEDCL
	JRST CPOPJ1
                                                                                                                                                                                            ;MINUS, PLUS (D)
PNMNS:	TRNE INLIN	;CHECK DRAWING LINE
	PUSHJ P,GETCLS
	JRST PERRET
	PUSHJ P,PNMNS1	;TRY THE WAY WE ARE NOW
	TRCA ZIGZAG
	POPJ P,
	PUSHJ P,PNMNS1	;TRY THE OTHER WAY TOO
	TRCA ZIGZAG	;PUT IT BACK THE WAY WE FOUND IT
	POPJ P,
	JRST PERRET

PNMNS1:	MOVE B,LINING
	MOVE TT,1(B)
	MOVE T,1(A)	;GET ITS X,Y
	XOR TT,T
	TLNE TT,-1
	TRNN TT,-1
	JRST PNOT1	;ONLY DIFFERENT IN ONE DIMENSION, GO DO PNOT
	MOVE TT,1(B)
	SUB TT,T	;COMPUTE DIF BETWEEN POINTS
	SETZ C,
	TRNE ZIGZAG	;WHICH WAY ARE WE GOING?
	AOSA C
	MOVSS TT
	HLRZ TTT,(A)
	HLRZ TTT,1(TTT)
	ADD TTT,C
	TLNN TT,400000
	SKIPA TTT,(TTT)
	MOVS TTT,(TTT)
	TRNE TTT,-1
	POPJ P,
	MOVE TTT,LINING	;NOW CHECK POINT WE ARE COMING FROM
	HLRZ TTT,(TTT)
	HLRZ TTT,1(TTT)
	SUBI TTT,-1(C)	;OTHER DIRECTION FROM CLOSES
	TRNE TT,400000	;DITTO
	SKIPA TTT,(TTT)
	MOVS TTT,(TTT)
	TRNE TTT,-1	;LINE THERE ALREADY?
	POPJ P,		;YES, LOSE
	PUSH P,CURSE
	MOVEM T,CURSE
	PUSH P,A
	PUSHJ P,PLPNT	;MAKE A CORNER POINT
	MOVE B,LINING	;GET POINTER TO NEW OLD POINT
	POP P,D
	HLRZ TTT,(D)	;GET DATA BLOCK POINTER
	MOVE T,1(D)	;GET X,Y
	PUSHJ P,PLENT	;ENTER THE LAST LINE
	POP P,CURSE
	TRZ INLIN
	TRO NEEDCL!MCHG
	JRST CPOPJ1

PPLUS:	PUSHJ P,CLRMOV
	TRNE INLIN	;ARE WE ALREADY DRAWING A LINE?
	JRST PLPNT	;YES
	PUSHJ P,GETCLS	;NO, DRAW IT TO CLOSEST POINT?
	JRST PERRET
	MOVEM A,LINING	;...
	TRZ ZIGZAG	;START OUT THIS WAY
	TRO NEEDCL!INLIN
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;MINUS, PLUS SUBRS (D)
PLPNTF:	TRC ZIGZAG	;TRY THE OTHER WAY
PLPNT:	MOVE B,LINING	;GET POINT WE ARE COMING FROM
	MOVE T,CURSE	;GET CURSOR POSITION
	CAMN T,1(B)	;SHOULD BE DIFFERENT
	POPJ P,
	TRNN ZIGZAG	;WHICH WAY ARE WE GOING
	MOVE T,1(B)	;THE OTHER WAY
	HLL T,CURSE	;GET CURSOR X
	TRNE ZIGZAG	;WHICH WAY ARE WE GOING?
	HLL T,1(B)	;THE OTHER WAY
	CAMN T,1(B)	;THIS SHOULDN'T MATCH
	JRST PLPNTF	;TRY THE OTHER WAY
	PUSH P,T
	PUSHJ P,PNTPUT	;CREATE THE POINT
	POP P,T
PLENT:	MOVEI A,
	MOVE TT,1(B)	;GET X,Y FOR OLD POINT
	TRNE ZIGZAG	;WHICH WAY?
	JRST PLENT1	;THE OTHER WAY
	MOVEI A,1	;_ INSTEAD OF ^
	MOVSS T
	MOVSS TT	;LOOK AT X INSTEAD OF Y
PLENT1:	SUB T,TT	;GET DIRECTION OF DIFFERENCE
	MOVE TT,A
	TRNN T,400000	;WAS SIGN NEGATIVE?
	ADDI A,2	;NO, SWITCH WHICH IS LEFT & WHICH IS RIGHT
	HLRZ TT,(B)	;GET POINTER TO OLD POINT DATA BLOCK
	HLRZ TT,1(TT)	;GET POINTER TO OLD POINT _^ BLOCK
	HLRZ E,1(TTT)
	XCT (A)[HLRZ F,(TT)	;GET OLD POINTER FROM OLD
		HLRZ F,1(TT)	;SEE ROT0 FOR COMMENTS::::
		HRRZ F,(TT)
		HRRZ F,1(TT)]
	JUMPN F,PERRET		;LOSE IF LINE THERE ALREADY
	XCT (A)[HRRM B,(E)	;DEPOSIT POINTER IN NEW TO OLD
		HRRM B,1(E)
		HRLM B,(E)
		HRLM B,1(E)]
	XCT (A)[HRLM D,(TT)	;DEPOSIT POINTER IN OLD TO NEW
		HRLM D,1(TT)
		HRRM D,(TT)
		HRRM D,1(TT)]
	TRC ZIGZAG	;CHANGE THE WAY WE GO
	MOVEM D,LINING	;GO FROM NEW POINT
	MOVEM D,MOVED	;BETTER CHECK IF ON TOP OF ANOTHER POINT
	TRO MCHG
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;MAKE FEEDTHROUGH(|), PLUS (PC)
MPC,<
;SIMULATE +$1F1R+
PLFEED:	PUSHJ P,CLRMOV		;CAN'T BE MOVING
	TRNE INLIN		;IF NOT DRAWING LINE
	JRST PLFEDL
	PUSHJ P,GETCLS		;FIND CLOSEST
	JRST PERRET		;NONE
	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNE T,ISPIN!CPIN!FEEDTH
	JRST PERRET
	MOVEM A,LINING		;THE REST IS THE SAME
	TRO INLIN		;NOW IN LINE DRAWING MODE
	JRST PLFDL0

PLFEDL:	PUSHJ P,PPLUS0		;SIMULATE PLUS
	JRST PERRET		;CAN'T +
PLFDL0:	MOVE G,LINING
	PUSHJ P,RDFEED		;SIMULATE 1F
	PUSHJ P,FUCKUP		;JUST MADE POINT, CAN'T LOSE
	MOVE G,LINING
	HLRZ G,(G)
	HLRZ B,(G)		;POINTER TO OTHER SIDE
	HRRZ G,1(G)
	MOVE T,1(G)
	TLNN T,FEEDTH		;DID IT REALLY FEED THROUGH?
	JRST PERRET
	HRRZM B,LINING		;GO FROM OTHER SIDE NOW
	SWITCH			;NOW WE'RE ON THE OTHER SIDE
	POPJ P,

PPLUS:	PUSHJ P,PPLUS0
	JRST PERRET
	POPJ P,

PPLUS0:	TRNE INLIN
	JRST PLPNT
	PUSHJ P,GETCLS
	POPJ P,
	MOVEM A,LINING
	TRZ INMOV
	TRO NEEDCL!INLIN
	JRST CPOPJ1

PLPNT:	MOVE T,CURSE
	MOVE B,LINING
	CAMN T,1(B)		;WILL THIS MAKE COINCIDENT POINTS?
	POPJ P,
	PUSHJ P,PNTPUT
	GETFS(E)
	HRLM E,1(TTT)		;WILL NEED NEIGHBOR BLOCK
	SETZM 1(E)
	HRLZM B,(E)
	HLRZ T,(B)
	PUSHJ P,FRELNK
	XCT (T)[PUTAB:	HRLM D,(B)
			HRRM D,1(B)
			HRLM D,1(B)]
	MOVEM D,LINING
	MOVEM D,MOVED		;BETTER CHECK IF ON TOP OF ANOTHER POINT
	TRO MCHG
	JRST CPOPJ1		;WIN RETURN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;MINUS, FNDLNK, FRELNK (PC)
PNMNS:	TRNE INLIN
	PUSHJ P,GETCLS
	JRST PERRET
PNMNS1:	MOVE B,LINING		;ENTER HERE FROM LATTL
	HLRZ B,(B)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK		;ALREADY GOT A POINTER TO IT?
	TRZA INLIN		;NO, MAKE IT!
	JRST PERRET		;YES, SCREW HIM!
	PUSH P,A
	HLRZ T,(A)
	PUSHJ P,FRELNK
	MOVE D,LINING
	XCT (T)PUTAB
	HLRZ T,(D)
	PUSHJ P,FRELNK
	POP P,D
	XCT (T)PUTAB
	TRO MCHG!NEEDCL
	MOVEI T,ANGLPG
	JRST HYDPOG

FNDL2:	MOVEI T,2
FNDL1:	XCT (T)[GETAB:	HLRZ TT,(B)
			HRRZ TT,1(B)
			HLRZ TT,1(B)]
	CAIN TT,(A)
	JRST CPOPJ1
	SOJGE T,FNDL1
	MOVE TT,B
	HRRZ B,(B)
FNDLNK:	JUMPN B,FNDL2
	POPJ P,

FRELNK:	HLRZ B,1(T)
	JUMPN B,FRLNK1
	GETFS(B)
	SETZM 1(B)
	SETZM (B)
	HRLM B,1(T)
FRLNK1:	SETZ A,
	PUSHJ P,FNDLNK
	CAIA
	POPJ P,
	GETFS(B)
	HRRM B,(TT)
	SETZM (B)
	SETZM 1(B)
	MOVEI T,2	;USE LAST FIRST
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                              ;PNTPLC, PN2DEL
PNTPLC:	TRNE INMOV!INLIN
	JRST PERRET
	MOVE T,CURSE	;GET CURSOR POSITION
	PUSHJ P,PNTPUT	;MAKE A POINT
	MOVE T,LSTPNT	;GET NEW POINT AND PREVIOUS POINTER
	JRST SCLOSE

PN2DEL:	PUSHJ P,GETCLS
	POPJ P,
	MOVE B,CLAST
	EXCH B,A
	HLRZ C,(B)
	HLRZ C,1(C)
MD,<
	MOVE T,(C)
	MOVE TT,1(C)
	JUMPE T,[JUMPE TT,DELPNT
		TLNE TT,-1
		TRNN TT,-1
		JRST PERRET
		PUSHJ P,LMER1
		SETOM CLOSUP
		JRST DELPNT]
	TLNE T,-1
	TRNN T,-1
	JRST PERRET
	JUMPE TT,[PUSHJ P,LMER0
		SETOM CLOSUP
		JRST DELPNT]
	TLNE TT,-1
	TRNN TT,-1
	JRST PERRET
	SETOM CLOSUP
	PUSHJ P,LMER0
	PUSHJ P,LMER1
	JRST DELPNT

FOR @$ I_0,1
<
LMER$I:	HLRZ D,I(C)
	HRRZ T,I(C)
	HLRZ TT,(D)
	HLRZ TT,1(TT)
	HRRM T,I(TT)
	HLRZ TT,(T)
	HLRZ TT,1(TT)
	HRLM D,I(TT)
	POPJ P,
>
>;MD

MPC,<	JUMPE C,PERRET
	SETZM 1(P)
	SETZM 2(P)
D2LIN:	MOVEI E,2
D2LIN1:	XCT (E)DELTAB
	JUMPE D,D2LIN2
	EXCH D,1(P)		;ADVANCE THE WORLD
	EXCH D,2(P)
	JUMPN D,PERRET		;NON-ZERO IF TOO MANY
D2LIN2:	SOJGE E,D2LIN1
	HRRZ C,(C)
	JUMPN C,D2LIN
	SKIPN 2(P)		;FIND 2?
	JRST PERRET		;NO
	AOBJN P,.+1		;NOW PUSH ONE
	MOVE D,1(P)		;PICKUP THE OTHER
	PUSH P,A		;PUSH A IN ITS SPOT
	MOVE A,B		;SETUP A WITH PIN POINTER
	MOVE B,-1(P)		;AND PICKUP THE FIRST
	PUSHJ P,D2LIN4
	MOVE B,D
	MOVE D,-1(P)		;NOW THE OTHER WAY
	PUSHJ P,D2LIN4
	POP P,B			;RESTORE LAST
	POP P,(P)		;THROW AWAY THE OTHER
	EXCH A,B		;GET A AND B IN RIGHT PLACES
	SETOM CLOSUP
	JRST DELPNT		;AND DELETE

D2LIN4:	HLRZ B,(B)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK
	PUSHJ P,FUCKUP
	XCT (T)PUTAB
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                    ;DELPNT
DELPNL:	PUSHJ P,LNKSET	;SETUP A WITH LAST POINTER
	JRST DELPNT	;THEN LEAP IN

PNTDEL:	PUSHJ P,GETCLS	;GET POINTER TO CLOSEST POINT
	JRST PERRET
	MOVE B,CLAST	;ALSO LAST POINTER
	EXCH B,A	;INTO CORRECT AC'S
	TRZ TFLG	;DON'T DELETE PINS
	TRZE INMOV
	TRO NEEDCL
DELPNT:	TRO MCHG
	TRZ INMOV
	PUSH P,A	;SAVE LAST
	PUSHJ P,REMPNT	;REMOVE POINT FROM ANY SETS
	PUSHJ P,KILPNT	;KILL LINES, TEXT
	POP P,A		;RESTORE LAST
	TRNE TFLG	;DELETE PINS?
	JRST DELPOK	;YES
	TLNE F,MPC,<CPIN!>ISPIN		;IS IT A PIN?
	POPJ P,		;YES, DON'T DELETE
DELPOK:	TRO NEEDCL
	HRRZ T,(B)
	HRRM T,(A)	;LINK US OUT
MPC,<	HLR F,(B)
	HLR F,(F)	;GET BODY OR FEED THROUGH POINTER
>;MPC
	HLRZ D,(B)	;PUT THIS STUFF BACK ON FREE STORAGE...
	HRRZ E,(B)	;GET POINTER TO NEXT
	MOVE A,B	;...
	FSTRET (A)
MD,<
	HLRZ A,1(D)
	FSTRET (A)
>;MD
DPARN:	HRRZ A,1(D)
	FSTRET (D)
	HLRZ D,(A)
	TLNN F,CPIN
	JRST NTCPIN
	PUSH P,(A)	;PUSH POINTER TO CPIN BLOCK
	FSTRET (A)
	POP P,A
NTCPIN:	FSTRET (A)
	JUMPE D,NTCPN1
	PUSH P,B
	MOVE B,D
	PUSHJ P,PUTFS
	POP P,B
NTCPN1:
MPC,<	TLNN F,FEEDTH	;IS IT A FEED THROUGH?
	POPJ P,		;NO
	HLRZ A,(F)
	HRRZ A,1(A)
	MOVSI B,FEEDTH
	ANDCAB B,1(A)	;MAKE SURE HE DOESN'T TRY TO GET BACK
	HRRZ B,F
	SWITCH
	PUSHJ P,DELPNL
	SWITCH
>;MPC
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;DELPNT SUBRS
KILPNT:	PUSHJ P,KILTXT	;FLUSH TEXT
ROUTE,<MPC,<TLZ M,%ROUTE>>;MAKE HIM ROUTE AGAIN
	HLRZ  C,(B)	;GET POINTER TO DATA BLOCK
	MOVE F,1(C)
	MOVE F,1(F)	;GET BITS
	HLRZ C,1(C)	;GET POINTER TO _^ BLOCK
MD,<
	DEFINE FOO (A,B)
<	A D,B(C)
	JUMPE D,.+2
	PUSHJ P,REMLIN>
	FOO (HRRZ)
	FOO (HLRZ)
	FOO (HRRZ,1)
	FOO (HLRZ,1)
	SETZM (C)	;CLEAR _^ POINTERS
	SETZM 1(C)	;...
>;MD
MPC,<
	MOVE A,B
	JUMPE C,DELMER
	PUSH P,C
DELIN:	MOVEI E,2
DELIN1:	XCT (E)[DELTAB:	HLRZ D,(C)
			HRRZ D,1(C)
			HLRZ D,1(C)]
	JUMPE D,.+2
	PUSHJ P,REMLIN
	SOJGE E,DELIN1
	HRRZ C,(C)
	JUMPN C,DELIN
	POP P,C
DELMER:	PUSH P,B
	HLRZ B,(B)
	HRRZS 1(B)
	MOVE B,C
	JUMPE B,.+2
	PUSHJ P,PUTFS
	POP P,B
>;MPC
	HRRZ E,(B)	;GET POINTER TO NEXT POINT
	POPJ P,

MPC,<
REMLIN:	PUSH P,B
	HLRZ B,(D)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK
	CAIA
	XCT (T)[	HRRZS(B)
			HLLZS 1(B)
			HRRZS 1(B)]
	POP P,B
	SETOM CLOSUP
	POPJ P,

>;MPC


MD,<
REMLIN:	HLRZ T,(D)	;GET POINTER TO DATA BLOCK
	HLRZ T,1(T)	;GET POINTER TO _^ BLOCK
	DEFINE FOO (Y,Z,X)
<	Y TT,Z(T)
	CAMN TT,B
	X Z(T)>
	FOO (HRRZ,,HLLZS)
	FOO (HRRZ,1,HLLZS)
	FOO (HLRZ,,HRRZS)
	FOO (HLRZ,1,HRRZS)
	SETOM CLOSUP
	POPJ P,
>;MD

LNKSET:
MPC,<	HLRZ T,(B)
	HRRZ T,1(T)
	MOVE T,1(T)	;GET SIDE BITS
	EQV T,SID
	JUMPL T,LNKSTF	;WHICH SIDE IS IT ON??
	MOVEI A,PONPN2	;OTHER SIDE
	JRST LNKST1

LNKSTF:
>;MPC
	MOVEI A,PONPNT	;CURRENT SIDE
LNKST1:	HRRZ T,(A)
	CAIN T,(B)	;DOES THIS GUY POINT TO US?
	POPJ P,		;YES, RETURN
	MOVE A,T
	JUMPN A,LNKST1
	PUSHJ P,FUCKUP
	MOVE A,B	;LINK BACK TO SELF
	POPJ P,
                                                                                                                                                                                                                                                                                                                               ;DELNUL
DELNUL:	TRZE INLIN!INMOV
	TRO NEEDCL
	TRZ TFLG		;DON'T DELETE PINS!!!!!
	SETZM COUNT		;ZERO COUNT
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE Y TO MARK NULL POINTS FOR FIND,
(ELSE ALL NULL POINTS WILL BE DELETED)/]
	PUSHJ P,YORN
	POPJ P,			;ALTMODE
	JRST DELALL		;DELETE ALL
	TLO ASK
	SETZM FIND		;NONE FOUND YET
	SKIPE E,PONPNT
	PUSHJ P,ACLRP		;CLEAR FIND MARK BITS
	MOVEI B,PONPNT
	PUSHJ P,DNULL		;NOW MARK NULL POINTS
MPC,<	SKIPE E,PONPN2
	PUSHJ P,ACLRP
	MOVEI B,PONPN2
	PUSHJ P,DNULL
>;MPC
	JRST FNDCNT

DNULLA:	PUSH P,A		;SAVE LAST POINTER
	HLRZ T,(B)
	HLRZ TT,1(T)
MD,<	SKIPN (TT)
	SKIPE 1(TT)
	JRST NODEL
>;MD
MPC,<
	JUMPE TT,DLNCK1
DLINCK:	HLRZ TTT,(TT)
	JUMPN TTT,NODEL
	SKIPE 1(TT)
	JRST NODEL
	HRRZ TT,(TT)
	JUMPN TT,DLINCK
DLNCK1:
>;MPC
	HRRZ T,1(T)
	MOVE TT,1(T)
	TDNE TT,[MPC,<FEEDTH!PLANES!CPIN!>ISPIN,,MPC,<-1>]
	JRST NODEL
	HLRZ TT,(T)
	JUMPN TT,NODEL
	TLNN ASK
	JRST NOASK
	MOVSI TT,FOUNDP			;MARK POINT
	IORM TT,1(T)
	AOS FIND		;COUNT ANOTHER FOUND
	JRST NODEL

NOASK:	MOVE A,(P)			;SETUP LAST POINTER
	PUSHJ P,DELPNT
	AOS COUNT
	POP P,B
	JRST DNULL

NODEL:	POP P,B
	HRRZ B,(B)			;ADVANCE POINTER
DNULL:	MOVE A,B
	HRRZ B,(B)
	JUMPN B,DNULLA
	POPJ P,

DELALL:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[1ALTM]
	JRST PERRET
	TLZ ASK
	MOVEI B,PONPNT
	PUSHJ P,DNULL
MPC,<	MOVEI B,PONPN2
	PUSHJ P,DNULL
>;MPC
CNTOUT:	TRO NEEDCL
	TLNE M,DSKACT!MACACT
	POPJ P,
	OUTSTR[ASCIZ/
/]
	MOVE T,COUNT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ NULL POINTS DELETED!/]
	POPJ P,

DANGLE:	TRZE INLIN!INMOV
	TRO NEEDCL
	SETZM COUNT
	SETZM FIND
	SKIPE E,PONPNT
	PUSHJ P,DODANG
MPC,<	SKIPE E,PONPN2
	PUSHJ P,DODANG
>;MPC
	TLNN M,DSKACT!MACACT
	SKIPN T,COUNT
	JRST FNDCNT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ COINCIDENT POINTS OUT OF /]
	JRST FNDCNT

DODANG:	PUSH P,E
	PUSHJ P,ACLRP		;CLEAR MARK BITS
	POP P,E
DANGA:	SETO TTT,		;PREPARE COUNT
	HLRZ A,(E)
	HRRZ B,1(A)
	MOVE T,1(B)
	TDNE T,[MPC,<PLANES!CPIN!>ISPIN,,MPC,<-1>]
	JRST COINA
	TLNE T,MPC,<FEEDTH!>CPIN
	AOJG TTT,COINA
MD,<	HLRZ T,1(A)
	SKIPE (T)		;ONLY COUNT EACH DEMENSION AS ONE
	AOJG TTT,COINA
	SKIPE 1(T)
	AOJG TTT,COINA
	HLRZ T,(B)
	JUMPE T,DANGST
	AOJLE TTT,DANGST
>;MD
MPC,<	HLRZ T,(B)
	JUMPN T,COINA
	HLRZ T,1(A)
	JUMPE T,DANG1
DANG0:	MOVE TT,1(T)
	TLNE TT,-1
	AOJG TTT,COINA
	TRNE TT,-1
	AOJG TTT,COINA
	MOVE T,(T)
	TLNE T,-1
	AOJG TTT,COINA
	TRNE T,-1
	JRST DANG0
DANG1:
>;MPC
COINA:	MOVE T,1(E)
	MOVE TT,E
	JRST COINB

COINC:	CAMN T,1(TT)
	JRST DANGSC
COINB:	HRRZ TT,(TT)
	JUMPN TT,COINC
DANGB:	HRRZ E,(E)
	JUMPN E,DANGA
	POPJ P,

DANGSC:	AOS COUNT
DANGST:	AOS FIND
	MOVSI T,FOUNDP
	IORM T,1(B)
	JRST DANGB
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;CHANGE PAD TYPES
MPC,<
CPADS:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE PAD NUMBER TO CHANGE.
/]
	PUSHJ P,READNC
	MOVEM T,COUNT
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE NEW PAD NUMBER.
/]
	PUSHJ P,READNC
	MOVEM T,COUNT2
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE Y TO BE ASKED ABOUT EACH ONE/]
	PUSHJ P,YORN
	POPJ P,
	TLZA ASK
	TLO ASK
	MOVEI A,PONPNT
	PUSHJ P,CPADSD
	POPJ P,
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/DO OTHER SIDE/]
	PUSHJ P,YORN
	POPJ P,
	POPJ P,
	SWITCH
	MOVEI A,PONPNT
	PUSHJ P,CPADSD
	JFCL
	SWITCH
	POPJ P,

CPADS1:	HLRZ B,(A)
	HRRZ B,1(B)
	HRRZ T,1(B)
	CAME T,COUNT		;IS THIS ONE TO CHANGE?
	JRST CPADSD		;NO
	MOVE T,1(B)
	TLNN T,FEEDTH		;IF DRILL HOLE
	SKIPN COUNT		;OR FINDING OTHER THAN TYPE 0
	CAIA			;GO AHEAD
	JRST CPADSD
	TLNN ASK
	JRST CPADS2		;DON'T ASK
	MOVE T,1(A)
	PUSHJ P,ONSCR			;ON SCREEN
	PUSHJ P,PICSET			;NO, GET IT ON
	MOVE T,1(A)
	MOVEM T,STARLOC				;LOC TO DISPLAY
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/THIS ONE/]
	MOVEI T,UPSTAR
	MOVEM T,SPDISP
	MOVE T,[ASCID/CP/]
	MOVEM T,SPMODT
	MOVEI T,SPM				;SPECIAL POINTER MODE
	PUSHJ P,TCHNGM				;TEMPORARY CHANGE
	PUSHJ P,YORN
	JFCL
	JFCL			;IGNORE RETURN, WILL CHECK C AGAIN
	PUSHJ P,RCHNGM				;RESTORE MODE
	CAIE C,"Y"
	CAIN C,"y"
	JRST CPADS2
	CAIE C,ALTMOD
	JRST CPADSD		;JUST SKIP THIS ONE
	POPJ P,			;GIVE QUIT RETURN

CPADS2:	MOVE T,COUNT2
	HRRM T,1(B)		;STORE NEW PAD TYPE
	TRO MCHG
CPADSD:	HRRZ A,(A)
	JUMPN A,CPADS1
	JRST CPOPJ1
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                    ;MAKE AND BREAK INNER PLANE CONNEX (PC)
MPC,<
PLANE:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ A,(A)
	HLRZ B,(A)
	HRRZ A,1(A)
	HLL B,1(A)
	TLNN B,FEEDTH!ISPIN
	JRST PERRET
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ PLANE NUMBER?/]
	PUSHJ P,READNC
	ADDI T,1
	CAILE T,7
	JRST PERRET	;LOSE
UNPLN1:	TRO MCHG!NEEDCL
	DPB T,[POINT 3,1(A),6]
	TLNN B,ISPIN
	JRST CHKFED
	HRRZ TTT,(A)
	HLRZ TTT,(TTT)
	HLRZ B,(B)
	JRST PLOOP1
PLOOP2:	HLRZ B,(B)
	HRRZ TT,1(B)
	HRRZ C,(TT)
	HLRZ C,(C)
	CAMN C,TTT	;SAME PIN NUMBER?
	DPB T,[POINT 3,1(TT),6]	;YES, SET PLANE NUMBER
PLOOP1:	HRRZ B,(B)
	JUMPN B,PLOOP2
	POPJ P,

CHKFED:	TLNN B,FEEDTH
	POPJ P,
	HLRZ TT,(B)
	HRRZ TT,1(TT)
	DPB T,[POINT 3,1(TT),6]
	POPJ P,

UNPLAN:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ A,(A)
	HLRZ B,(A)
	HRRZ A,1(A)
	HLL B,1(A)	;PICK UP BITS
	TLNN B,ISPIN!FEEDTH
	JRST PERRET
	MOVEI T,0	;NO PLANE
	JRST UNPLN1
                                                                                                                                                                                                                                                                                                                                                                                               ;SET PAD TYPE, MAKE AND BREAK FEEDTHROUGHS (PC)
NPFEED:	PUSHJ P,GETCLS
	JRST PERRET
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PAD TYPE NUMBER?/]
	PUSHJ P,READNC
	HLRZ A,(A)
	HRRZ A,1(A)
	HRRM T,1(A)		;SET NEW PAD TYPE
	TRO MCHG
	POPJ P,

FEED:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE G,A
	PUSHJ P,RDFEED
	JRST PERRET
	POPJ P,

RDFEED:	HLRZ H,(G)
	HRRZ H,1(H)
	MOVE A,1(H)
	TLNE A,FEEDTH!ISPIN!CPIN
	POPJ P,
	SWITCH
	MOVE T,1(G)
	PUSHJ P,PNTPUT
	MOVE A,T
	SWITCH
	MOVSI T,FEEDTH
	IORM T,1(A)
	IORM T,1(H)
	HRRZ T,1(A)
	JUMPN T,.+3
	MOVEI T,1		;DEFAULT PAD TYPE 1
	HRRM T,1(A)
	HRRZ T,1(H)
	JUMPN T,.+3
	MOVEI T,1
	HRRM T,1(H)
	HLRZ T,(G)
	HRLM D,(T)
	HLRZ T,(D)
	HRLM G,(T)
	TRO MCHG
	JRST CPOPJ1

UNFEED:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ C,(A)
	HRRZ A,1(C)
	MOVE B,1(A)
	TLNN B,FEEDTH
	JRST PERRET
	HLR B,(C)
	HRRZS (C)
	TLZ B,FEEDTH!PLANES
	HLLZM B,1(A)
	HLRZ B,(B)
	HRRZS (B)
	HRRZ B,1(B)
	MOVE A,1(B)
	TLZ A,FEEDTH!PLANES
	HLLZM A,1(B)
	TRO MCHG!NEEDCL
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                            ;PIN #'S, CONNECTOR AND BODY (D)
MD,<SETCPN:
	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ D,(A)
	HLRZ B,(D)
	HRRZ D,1(D)
	HLL B,1(D)
	TLNE B,ISPIN
	JRST STPINN
	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
CAGAIN:	TLNN M,DSKACT!MACACT
	OUTSTR @CPCUE
	PUSHJ P,GTCONP
	JRST INNERR
	JRST [
LAY,<		CAIN C,TEXIST
		JRST [	PUSHJ P,GETLIN		;SNARF LF
			CAIE C,12
			JRST INNERR
			SKIPG T,LAYLOC		;PICK UP CLOC PASSED FROM PC PROG
			JRST [	SKIPN T
				OUTSTR[ASCIZ/NO CONNECTOR LOC PASSED FROM PC PROG!
/]
				SKIPE T
				OUTSTR[ASCIZ/TOO MANY CONNECTOR LOC'S FOUND IN PC PROG!
/]
				JRST CAGAIN]
			HRRZM T,LETTER
			JRST LNNLY]
>;LAY
		CAIE C,12
		JRST INNERR
		HRRZ B,(D)		;GET CPIN POINTER
		JUMPE B,CPOPJ
		HLLZS (D)
		FSTRET (B)
		HRLOI T,CPIN!FIXCON!CPNBTS
		ANDCAM T,1(D)			;CLEAR BITS AND BACKUP PIN NAME
		SETOM CLOSUP
		TRO MCHG
		TRNE LMOVE
		TRZN INMOV
		POPJ P,
		TRO NEEDCL
		POPJ P,]
MD,<	JFCL	>	;DON'T CARE ABOUT BRS
	CAIE C,12
	JRST INNERR
SETLET:	;ENTRY POINT TO SET LOC IN LETTER ON POINT IN A
	HLRZ D,(A)
	HRRZ D,1(D)
LNNLY:	MOVE TT,LETTER
	TLNE TT,-1
	SKIPN T,CRDLOC
	JRST NOGLBC
	XOR T,TT
	TLNE T,-1		;SAME CARD LOC OR NO GLOBAL?
	JRST [	OUTSTR[ASCIZ/SORRY, CANNOT CHANGE CARD LOCATION WHILE GLOBAL CARD LOC IS IN FORCE!
/]
		POPJ P,]
	HRRZS LETTER
NOGLBC:	HRRZ B,(D)		;GET OLD CPIN POINTER
	JUMPN B,GOTFST
	MOVSI B,CPNBTS
	ANDCAM B,1(D)
	MOVSI B,FIXCON!CPIN
	IORM B,1(D)		;MAKE IT GET FIXED INTIALLY
	HLLZS 1(D)		;CLEAR BACKUP PIN NAME
	GETFS(B)
	HRRM B,(D)
	SETZM 1(B)		;CLEAR OFFSET
	SETOM CLOSUP
GOTFST:	PUSHJ P,UBACK
	MOVE T,LETTER
	MOVEM T,(B)
	MOVE C,D
	PUSHJ P,CPNBCK		;CHECK AND SET BITS
	MOVE T,1(D)
	TRO MCHG!NEEDCL
	TLNN T,FIXCON		;CON NEED FIXING?
	POPJ P,
	JRST OFFCON

UBACK:	PUSH P,A
	MOVE A,LETTER
	PUSHJ P,QUPIN		;IS NEW PIN NAME WILD?
	JRST UBACK0
	MOVE A,(B)
	PUSHJ P,QUPIN
	JRST UBACK2
	JRST UBACK1

UBACK0:	MOVE A,(B)
	PUSHJ P,QUPIN
	JRST UBACK1		;OLD ONE NOT WILD, NO BACKUP
UBACK2:	MOVE A,(B)
	HRRM A,1(D)
UBACK1:	POP P,A
	POPJ P,

CPNBCK:	PUSH P,A
	MOVE A,T
	PUSHJ P,QUPIN
	JRST NUPIN
	DPB A,[POINT CPNBSZ,1(C),CPNBPS]	;ALWAYS SET RULE FROM LAST U PIN TYPED
NUPIN:	POP P,A
	POPJ P,
STTRUL:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ B,(A)
	HRRZ B,1(B)
	MOVE T,1(B)
	TLNN T,CPIN
	JRST PERRET
	TLNE M,DSKACT!MACACT
	JRST STTRL0
	OUTSTR[ASCIZ/CURRENT RULE NUMBER = /]
	LDB T,[POINT CPNBSZ,1(B),CPNBPS]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
STTRL0:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE RULE NUMBER (0-3)?/]
	PUSHJ P,READN
	CAIN C,12
	JRST STTRL1
	CAIE C,"?"
	JRST INNERR
	PUSHJ P,GETCHR
	CAIE C,12
	JRST INNERR
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/0	NO RULE
1	NO TERMINATION (U001-U199)
2	?? (U200-U399)
3	TERMINATED (U400-U599)
/]
	JRST STTRUL

STTRL1:	CAILE T,3
	JRST INNERR
	DPB T,[POINT CPNBSZ,1(B),CPNBPS]
	POPJ P,

CLTRUL:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ B,(A)
	HRRZ B,1(B)
	MOVE T,1(B)
	TLNN T,CPIN
	JRST PERRET
	PUSHJ P,SETTT
	LDB B,[POINT CPNBSZ,1(B),CPNBPS]
	PUSHJ P,PUTTTN
	JRST ITSTUF
                                                                                                                                  ;SET BODY PIN #
STPINN:	TLNE M,DSKACT!MACACT
	JRST STPIN0
	OUTSTR[ASCIZ/PIN NAME(/]
	OUTSTR @PINCUE
	OUTSTR[ASCIZ/)?/]
STPIN0:	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
	PUSHJ P,RPNAM
	JRST INNERR
	CAIE C,12
	JRST INNERR
STPNN1:	TLNE M,PLOCS
	TRO MCHG
	HRRZ D,(D)
	HLRZ TT,(D)
	HRRZ TT,1(TT)		;GET DEFAULT PIN NAME
	HLRZ B,(B)
	JRST STPIN1
STPIN2:	HLRZ B,(B)
	HRRZ C,1(B)
	HRRZ D,(C)
	HLRZ D,(D)
	HRRZ D,1(D)
	CAMN D,TT		;SAME PIN NAME?
	HRRM T,1(C)		;YES, STORE PIN #
STPIN1:	HRRZ B,(B)
	JUMPN B,STPIN2
	POPJ P,
>;MD

STOCLC:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ D,(A)
	HRRZ B,1(D)
	HLL B,1(B)
	PUSHJ P,SETTT			;SETUP MACRO TEXT POINTER
	PUSHJ P,STFPLC			;STUFF IN CON OR PIN SPEC
	JFCL
	JRST ITSTUF			;IF NOT CPIN, STUFF A NULL MACRO

STFPLC:	TLNE B,CPIN
	JRST STFCLC
	TLNN B,ISPIN
	POPJ P,
	HLRZ D,(D)
	HLRZ D,(D)
	HLRZ D,1(D)
	AOS (P)
	PUSH P,A
MD,<	HRRZ D,(D)
	JUMPE D,NSTFBL
	HLRZ D,(D)
>;MD
MPC,<	HRRZ T,(D)
	JUMPE T,NSTFBL
>;MPC
	MOVS A,(D)
	PUSHJ P,SLTLPN		;STUFF BODY LOCATION
NSTFBL:
MD,<	HRRZ A,1(B)
	JUMPN A,STFPL1
>;MD
	HRRZ A,(B)
	HLRZ A,(A)
MD,<	HRRZ A,1(A)
STFPL1:
>;MD
	PUSHJ P,BPINPN
	POP P,A
	POPJ P,

STFCLC:	AOS (P)
	PUSH P,A		;I AM NOT SURE IF THIS PUSH IS NEEDED!
	HRRZ A,(B)
	MOVS A,(A)
	PUSHJ P,CSLTLT		;PRINT THE BAY/RACK/SLOT/LOC/PIN
	POP P,A
	POPJ P,

BJUMP:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ B,(A)
	HRRZ C,1(B)
	MOVE C,1(C)
	TLNN C,ISPIN
	JRST PERRET
	HLRZ A,(B)
	MOVEI T,BODM
	PUSHJ P,CHNGMD		;CHANGE TO BODY MODE
	MOVE T,1(A)		;GET LOC OF BODY
	JRST CHKON
                                                                                                                                                                                                                                                                                                                                                        ;MUNGING SUBROUTINES (PC)
MPC,<
MUSH:	SKIPE A,DBODPN	;BODY POINTER
	PUSHJ P,MUSHB
	SKIPE A,PONPNT
	PUSHJ P,MUSHP
	TRO MCHG!NEEDCL
	TRNE BTHSDS	;IF ON BOTH SIDES, MUNG BOTH SIDES
	SKIPN A,PONPN2
	POPJ P,

MUSHP1:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNE T,ISPIN!CPIN
	POPJ P,
	MOVE TTT,1(A)
	PUSHJ P,MUSHIT
	MOVEM T,1(A)
	POPJ P,

MUSHP:	PUSHJ P,MUSHP1
	HRRZ A,(A)
	JUMPN A,MUSHP
	POPJ P,

MUSHB1:	HLRZ B,(A)
	HLRZ F,(B)	;GET ORIENTATION
	HRRZ B,(B)
	JUMPE B,CPOPJ	;NO PINS, NO MUSH
	MOVE TTT,1(B)
	PUSHJ P,MUSHIT	;MUSH THE PIN
	MOVE TTT,T	;SAVE NEW X,Y OF PIN
	HLRZ B,(B)
	HRRZ B,1(B)
	HRRZ B,(B)
	MOVE T,1(B)	;X,Y FROM PIN TYPE BLOCK
	ADDI F,2	;ROTATE BACK TO BODY CENTER
	ANDI F,3	;MAKE SURE WE DON'T OVERFLOW
	PUSHJ P,ORIENT
	ADJUST(ADD,T,TTT)
	MOVEM T,1(A)	;STORE AS NEW BODY X,Y
	PUSH P,A
	PUSHJ P,BODFIX
	POP P,A
	POPJ P,

MUSHB:	PUSHJ P,MUSHB1
	HRRZ A,(A)
	JUMPN A,MUSHB
	POPJ P,

MUSHIT:	HRRE T,TTT
	ASH T,-1
	IDIV T,STPSIZ
	IMUL T,STPSIZ
	ASH T,1
	HLRE TT,TTT
	ASH TT,-1
	IDIV TT,STPSIZ
	IMUL TT,STPSIZ
	ASH TT,1
	HRL T,TT
	POPJ P,

STMUSH:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG!NEEDCL
	MOVE G,A
	HLRZ G,(G)
STMSH1:	HRRZ A,1(G)
	JUMPE A,.+2
	PUSHJ P,MUSHP1
	HLRZ A,1(G)
	JUMPE A,.+2
	PUSHJ P,MUSHB1
	HRRZ G,(G)
	JUMPN G,STMSH1
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;LINE EDIT TEXT, CLRTHK, SETTHK, PNTZ
STANFO,<
LODED:	JUMPE T,CPOPJ	;DONE WHEN WE GET A ZERO
	SETZ B,
	HLRZ C,(T)	;SIZE
	JUMPE C,LODED2
	CAIN C,1	;SIZE 1?
	JRST LODED2	;YES, NO SPECIAL EFFECT
	PTWR1S	[	0
			"\"]
	JFCL
	TRZE C,400000
	PTWR1S	[	0
			"V"]
	JFCL
	ADDI C,60	;MAKE IT ASCIZ
	PTWR1S	B
	JFCL
LODED2:	ADD T,[POINT 7,1]
LODED1:	ILDB C,T
	SKIPE C		;DON'T PUT OUT <CALL>
	PTWR1S B
	JFCL		;IGNORE IF NOT SENT
	TLNE T,760000
	JRST LODED1
	HRR T,-1(T)
	TRNE T,-1
	JRST LODED1
	POPJ P,

LODPNT:	HLRZ T,(A)		;TO DATA BLOCK
	HRRZ T,1(T)		;TO TEXT BLOCK
	HLRZ T,(T)		;TO TEXT
	JUMPE T,CPOPJ		;DON'T LOAD NO TEXT!
	HRRZ T,(T)
	JRST LODED		;LOAD IT

PNTQ:	PUSHJ P,GETCLS		;CURRENT POINT
	JRST PERRET		;NONE
	PUSHJ P,LODPNT		;LOAD IT UP
ZORQ:	PUSHJ P,TXREAD		;READ IT BACK
	CAIN C,ALTMOD		;END WITH ALTMOD?
	JRST PUTFS		;JUST PUT BACK THIS STRING, NO CHANGE
	SKIPG T
	MOVEI T,STDBIG
	HRLM T,(B)
	SKIPN 1(B)
	JRST [	PUSHJ P,PUTFS	;NULL STRING, GIVE IT BACK
		JRST PTKIL1]	;AND KILL ANY EXISTING TEXT
	PUSH P,B		;SAVE STRING POINTER
	HLRZ C,(A)
	HRRZ C,1(C)
	HLRZ D,(C)
	JUMPN D,[HRRZ B,(D)
		PUSHJ P,PUTFS
		JRST GTTBLK]
	GETFS(D)
	SETZM 1(D)		;0 INITIAL OFFSET
	HRLM D,(C)		;LINK IT IN
GTTBLK:	POP P,(D)		;STORE NEW STRING POINTER
	TRO MCHG!NEEDCL
MD,<	JRST FIXEM	>	;FIX OFFSETS IF BITS ON
MPC,<	POPJ P,		>

PNTZ:	PUSHJ P,GETCLS		;CURRENT POINT
	JRST PERRET		;NONO
	PUSHJ P,LODPNT		;LOAD IT UP
	PTWRS9	[	0
			[BYTE(9)271,271,271,377,0]]	;CTRL1 999 BACKSPACE
	JRST ZORQ		;AND READ IT BACK

SETTHK:	SETOM XTHICK
	POPJ P,

CLRTHK:	SETZM XTHICK
	POPJ P,
>;STANFO
                                                                                                                                                                                                                                                                                                ;POINT TEXT, POINT TEXT TO MACRO, TEXT AND CONNECTOR OFFSETS (D)
PNTTXT:	PUSHJ P,GETCLS	;GET POINTER TO CLOSEST POINT
	JRST PERRET	;NONE
PNTTX3:	TRNE INLIN	;DRAWING LINE?
	PUSHJ P,[PUSHJ P,PLPNT	;MAKE CORNER
		MOVE T,LINING
		PUSHJ P,PNALT	;STOP LINE
		PUSHJ P,SCLOSP	;AND SET CLOSEST POINT TO LINING
		MOVE A,CLOSES
		POPJ P,]
	TLNN M,DSKACT!MACACT
	OUTSTR	[ASCIZ /TEXT?
/]
	PUSHJ P,TXREAD	;READ IN THE TEXT
	CAIN C,ALTMOD
	JRST PUTFS	;JUST GIVE BACK FREE STORAGE AND LEAVE
	HLRZ C,(A)	;GET DATA BLOCK POINTER
	HRRZ C,1(C)
	HLRZ D,(C)	;GET OLD TEXT POINTER
	SKIPN 1(B)	;NULL TEXT?
	JRST [	PUSHJ P,PUTFS	;GIVE BACK NULL STRING
		JRST PTKIL1]	;JUST KILL ORIGINAL TEXT(IF ANY)
	TRO MCHG!NEEDCL	;THIS CHANGES SCREEN
	JUMPE D,PNTTX1	;CAN'T COPY IF NO OLD
	JUMPGE T,PNTTX1	;DON'T COPY IF EXPLICIT SIZE TYPED
	HRRZ T,(D)
	HLRZ T,(T)	;GET OLD SIZE
PNTTX1:	SKIPG T		;MAKE SURE WE HAVE POSITIVE SIZE
	MOVEI T,STDBIG
	HRLM T,(B)	;STORE SIZE
	GETFS (T)
	HRRZM B,(T)
	SETZM 1(T)	;0 INITIAL OFFSET
	HRLM T,(C)	;DEPOSIT TEXT POINTER
MD,<
DEC,<	PUSH P,D	;FIND DEFAULT POLARITY IF NEEDED
	PUSH P,A
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,PERMUT	;PERMUT SIGNAL TO GET H OR L OR !
	SKIPGE POLAR	;GOT H OR L?
	JRST PNTTX4	;YES, DONE
	SKIPG POLAR	;IS IT !
	JRST NOEXCL	;NO
	MOVE A,(P)
	HLRZ A,(A)
	HRRZ A,1(A)
	HLRZ A,(A)
	HRRZ A,(A)
	ADD A,[POINT 7,1]
PNTEX1:	MOVE B,A	;REMEMBER 1 BEFORE START OF WHAT WE WANT
	PUSHJ P,GETITZ
	JRST PNTTX4	;OH WELL, I THOUGHT IT WAS THERE
	CAIE T," "
	JRST PNTEX1
PNTEX3:	PUSHJ P,GETITZ
	JRST PNTTX4
	CAIN T," "
	JRST PNTEX3
	CAIE T,"!"
	JRST PNTEX1	;GO BACK AND TRY AGAIN
	PUSHJ P,GETITZ
	SETZ T,
	JUMPN T,PNTEX1	;SHOULD BE AT END NOW
	CAIA
PNTEX4:	IDPB T,B
	TLNE B,760000
	JRST PNTEX4
	HRRZ TTT,-1(B)
	HLLZS -1(B)
	SKIPE B,TTT
	PUSHJ P,PUTFS	;RETURN REST OF STRING
	JRST PNTTX4

GETITZ:	TLNN A,760000
	JRST [	HRR A,-1(A)
		TRNN A,-1
		POPJ P,
		JRST .+1]
	ILDB T,A
	JUMPE T,GETITZ
	CAIE T,";"			;THIS IS THE COMMENT CHAR
	AOS (P)
	POPJ P,

NOEXCL:	MOVSI C,1	;CLEAR MARKING BITS FOR DEFPOL
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS
	SETZM WDOLST	;CLEAR DO LIST
	MOVE T,(P)
	MOVE H,[1,,DEFPOL]
	PUSHJ P,RECUR0	;INSERT THIS PIN IN LIST
	PUSHJ P,RECCHK	;NOW CHECK IT AND ITS CONNECTIONS FOR DEFAULT POLARITY
	JRST PNTTX4	;NONE FOUND
	MOVE B,(P)	;PTR TO POINT
	HLRZ B,(B)
	HRRZ B,1(B)
	HLRZ B,(B)
PNTTX5:	HRRZ B,(B)	;TEXT PTR
	JUMPE B,PNTTX6	;FOUND LAST BLOCK?
	MOVE C,B
	JRST PNTTX5

PNTTX7:	TLNE C,760000	;AT END OF WORD?
	JRST PNTTX8	;NO
	GETFS(D)	;YES, TACK ON A NEW BLOCK
	SETZM (D)
	SETZM 1(D)
	HRRM D,-1(C)	;LINK
	HRR C,D
PNTTX8:	ILDB D,C	;FIND FIRST NULL
	JUMPN D,PNTTX7
	POPJ P,

PNTTX6:	ADD C,[POINT 7,1]
	PUSHJ P,PNTTX7	;FIND WHERE TO PUT IN POLARITY
	MOVEI D," "
	DPB D,C		;PUT IN SEPERATOR
	PUSHJ P,PNTTX7
	MOVEI D,"H"		;ASSUME H
	TRNN A,ASSH		;H OR L?
	MOVEI D,"L"		;L
	DPB D,C
PNTTX4:	POP P,A
	POP P,D
>;DEC
>;MD
;MAYBE CHECK FOR NULL TEXT AND TEXT WITH TABS HERE
	JUMPE D,CPOPJ
	MOVE B,D	;PUT THE OLD TEXT BACK...
	JRST PUTFS	;... ON FREE STORAGE

STOTXT:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HRRZ T,1(T)
	HLRZ T,(T)
	SKIPE T
	HRRZ T,(T)
STOTXB:	PUSHJ P,SETTT
	JUMPE T,ITSTUF
	HLRZ B,(T)	;GET SIZE
	CAIN B,STDBIG	;OR STANDARD
	JRST STOTX0	;WE DON'T NEED ANYTHING IN FRONT
	PUTBYT "\"
	TRZE B,400000	;IS IT VERTICAL
	PUTBYT "V"
	PUSHJ P,PUTTTN	;AND THE SIZE
STOTX0:	ADD T,[POINT 7,1]
STOTX1:	PUSHJ P,GETTT
	JRST ITSTUF
	PUTBYT (C)
	JRST STOTX1

MD,<
;<META>T
PNTTX2:	PUSHJ P,GETCLS
	JRST PERRET
	PUSHJ P,PNTTX3
	JRST PTTOFF	;NOW GO FIX IT

;Z
PUTOFF:	PUSHJ P,GETCLS
	JRST PERRET
PTTOFF:	PUSHJ P,SETFXT
	JRST FIXEM

;Q
CONOFF:	PUSHJ P,GETCLS
	JRST PERRET
CNCOFF:	PUSHJ P,SETFXC
	JRST OFFCON	;THIS CAN'T AFFECT TEXT

SETFXT:	HLRZ T,(A)
	HRRZ T,1(T)
	HLRZ TT,(T)
	JUMPE TT,CPOPJ	;CAN'T SET IF NO TEXT
	MOVE TT,1(T)
	TLO TT,FIXTXT
	SKIPE MOVFLG
	TLOA TT,FIXRHT
	TLZ TT,FIXRHT
	MOVEM TT,1(T)
	POPJ P,

SETFXC:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLNN TT,CPIN
	POPJ P,
	TLO TT,FIXCON
	MOVEM TT,1(T)
	POPJ P,

;<META>Z
UNOFFT:	PUSHJ P,GETCLS
	JRST PERRET
CLRFXT:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVSI TT,FIXTXT!FIXRHT
	ANDCAM TT,1(T)
	POPJ P,

;<META>Q
UNOFFC:	PUSHJ P,GETCLS
	JRST PERRET
CLRFXC:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVSI TT,FIXCON
	ANDCAM TT,1(T)
	POPJ P,
                                                                                                ;OFFALL, OFFTXT, OFFCON (D)
OFFRHT:	SETOM MOVFLG
	POPJ P,

NOFRHT:	SETZM MOVFLG
	POPJ P,

OFFALL:	SKIPN A,PONPNT
	POPJ P,
OFFAL1:	PUSHJ P,SETFXT
	PUSHJ P,SETFXC
	PUSHJ P,FIXEM
	HRRZ A,(A)
	JUMPN A,OFFAL1
	POPJ P,

;ROUTINE TO RE-FIX ALL <C><M>Z POINTS
FIXEM0:	SKIPN A,PONPNT
	POPJ P,
FIXEM1:	PUSHJ P,FIXEM
	HRRZ A,(A)
	JUMPN A,FIXEM1
	POPJ P,

OFFTXT:	HLRZ C,(A)
	HRRZ D,1(C)
	HLRZ B,(D)
	JUMPE B,CPOPJ		;NO TEXT
	HLL D,1(D)		;GET BITS FOR LATER
	HLRZ T,1(C)
	TLNE D,FIXTXT		;FIXING TEXT AT ALL?
	PUSHJ P,LINSET
	POPJ P,			;TOO COMPLEX, DON'T CHANGE IT
	PUSHJ P,OFFCAL
	SKIPE ULNFLG		;POSITION SO IT GETS UNDERLINED?
	TLNE D,ISPIN		;NOT PINS WE DON'T
	JRST NOULN
	ADDI C,HMOVU-HMOVE
NOULN:	TLNE D,ISPIN		;IS THIS A PIN?
	ADDI C,HMOVP-HMOVE
	CAIG C,1		;L OR R?
	MOVE TT,TTT		;MAKE IT LOOK LIKE ONE LINE
STAN,<
	CAIE TTT,1
	JRST NOULN1
	SKIPE XTHICK
	IMULI T,CWIDTH+1
	SKIPN XTHICK
NOULN1:
>;STAN
	IMULI T,CWIDTH
	IMULI TT,CHGHT
	XCT HMOVE(C)
	XCT MOVEV(C)
	HRLM TTT,(P)		;SAVE CHAR SCALE
	IMULI TTT,CHGHT		;MAKE A LF
	SUB TT,TTT		;NORMALIZE VERTICAL
	HLRZ TTT,(P)		;GET BACK CHAR SCALE
STAN,<
	CAIE TTT,1
	JRST NOULN2
	SKIPE XTHICK
	IMULI TTT,CWIDTH+1
	SKIPN XTHICK
NOULN2:
>;STAN
	IMULI TTT,CWIDTH	;WIDTH OF CHAR
	ASH TTT,-1		;NOW 1/2
	XCT HFUDGE(C)		;POSSIBLY FUDGE X PART
	HRL TT,T
	SKIPN ISVERT		;VERTICAL TEXT?
	JRST NOFVRT
	MOVS TT,TT		;YES, MAP TO -Y,X
	TLC TT,-1
	ADD TT,[1,,0]
NOFVRT:	CAMN TT,1(B)
	POPJ P,
	EXCH TT,1(B)
	TRO MCHG
	SKIPE ISVERT
	POPJ P,			;QUIT NOW IF VERT
	TLNE D,FIXRHT		;DOES HE WANT FIX RIGHT?
	CAIE C,1		;WON'T BE 1 IF WAS PIN!!
	POPJ P,			;ALL DONE
	SUB TT,1(B)
	HLRE T,TT
	UNSCAL T
	HRLZ T,T
	ADD T,1(A)
	HLRZ TT,(A)
	HLRZ TT,1(TT)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)			;X,Y OF OTHER END!
	SUB TT,[4,,0]
	CAML T,TT
	MOVE T,TT
	MOVEM T,1(A)
	TRO NEEDCL			;MAYBE CHANGED CLOSEST
	POPJ P,


FIXEM:	PUSHJ P,OFFTXT
OFFCON:	HLRZ C,(A)
	HRRZ D,1(C)
	HLL D,1(D)
	TLNE D,FIXCON			;FIXING CON?
	TLNN D,CPIN			;CON?
	POPJ P,				;NO, QUIT NOW
	HLRZ B,(D)			;SETUP TEXT POINTER FOR LINSET
	HLRZ T,1(C)
	PUSHJ P,LINSET
	POPJ P,				;TOO COMPLEX, LEAVE IT ALONE
	HLRZ T,(D)			;GET TEXT POINTER
	PUSH P,T			;SAVE IT
	HRRZ B,(D)
	XCT CONTAB(C)
	EXCH B,(P)			;SAVE CON POINTER GET TEXT POINTER
	JUMPE B,GOTCOF			;ANY TEXT?
	PUSH P,T			;SAVE CON OFFSET
	PUSHJ P,OFFCAL			;CALC TEXT DELTAS
STAN,<
	CAIE TTT,1
	JRST OFFCN1
	SKIPE XTHICK
	IMUL T,[-CWIDTH-1]
	SKIPN XTHICK
OFFCN1:
>;STAN
	IMUL T,[-CWIDTH]
	IMULI TT,CHGHT
	IMULI TTT,CHGHT
	XCT CTOTAB(C)
	MOVE TT,1(B)
	SKIPN ISVERT
	JRST GOTTXO
	TLC TT,-1
	ADD TT,[1,,0]
	MOVS TT,TT
GOTTXO:	ADD TTT,TT
	ADD TTT,(P)
	HLRE TT,TT
	ADD T,TT
	HLRE TT,(P)
	ADD T,TT
	HRLZ T,T
	HRR T,TTT
	POP P,(P)
	SKIPN ISVERT			;VETICAL TEXT?
	JRST GOTCOF			;NO
	MOVS T,T			;YES, MAP TO -Y,X
	TLC T,-1
	ADD T,[1,,0]
GOTCOF:	POP P,B
	CAMN T,1(B)
	POPJ P,
	MOVEM T,1(B)			;SET OFFSET
	TRO MCHG
	POPJ P,

;THESE 3 TABLES MUST MATCH THE ONES FOR PINS
HMOVE:	SETZ T, 
	JFCL			;1
	ASH T,-1		;1/2
	ASH T,-1		;1/2
	ASH T,-1		;1/2

MOVEV:	ASH TT,-1		;UP 1/2
	ASH TT,-1		;UP 1/2
	JFCL			;UP 1
	SETZ TT,		;NO CHANGE
	ASH TT,-1		;UP 1/2

HFUDGE:	ADD T,TTT		;RIGHT ANOTHER HALF CHAR
	SUB T,TTT		;LEFT ANOTHER HALF CHAR
	JFCL
	JFCL
	JFCL

;THESE 3 TABLES MUST MATCH THE ONES FOR POINTS
HMOVU:	JFCL			;1
	SETZ T,
	ASH T,-1		;1/2
	ASH T,-1		;1/2
	ASH T,-1		;1/2

VMOVU:	JFCL
	JFCL
	JFCL			;UP 1
	SETZ TT,		;NO CHANGE
	ASH TT,-1		;UP 1/2

HFUDGU:	JFCL
	JFCL
	JFCL
	JFCL
	JFCL

;THESE 3 TABLE MUST MATCH THE ONE FOR POINTS
HMOVP:	JFCL			;LEFT 1
	SETZ T,
	SETZ T,
	SETZ T,			;1/2
	ASH T,-1

VMOVP:	JFCL			;UP 1
	JFCL			;UP 1
	SETZ TT,
	JFCL			;UP 1
	ASH TT,-1

HFUDGP:	SUB T,TTT		;LEFT ANOTHER HALF CHAR
	ADD T,TTT		;RIGHT ANOTHER HALF CHAR
	JFCL
	JFCL
	JFCL

CONTAB:	PUSHJ P,CONL
	PUSHJ P,CONR
	PUSHJ P,COND
	PUSHJ P,CONU
	PUSHJ P,COND

;Y/2,,-Y/2
CONL:	MOVE T,CMUL+STDBIG
	IMULI T,CHGHT
	ASH T,-1
	MOVN TTT,T
	HRLZ T,T
	HRR T,TTT
	POPJ P,

;-X-Y/2,,-Y/2
CONR:	PUSHJ P,CONCAL
	IMUL T,CMUL+STDBIG
STAN,<
IFE STDBIG-1,<
	SKIPE XTHICK
	IMULI T,CWIDTH+1
	SKIPN XTHICK
>
>;STAN
	IMULI T,CWIDTH
	MOVN T,T
	MOVN TT,CMUL+STDBIG
	IMULI TT,CHGHT
	ASH TT,-1
	ADD T,TT
	HRLZ T,T
	HRR T,TT
	POPJ P,

;-X/2,,0
COND:	PUSHJ P,CONCAL
	IMUL T,CMUL+STDBIG
STAN,<
IFE STDBIG-1,<
	SKIPE XTHICK
	IMULI T,CWIDTH+1
	SKIPN XTHICK
>
>;STAN
	IMULI T,CWIDTH
	ASH T,-1
	MOVN T,T
	HRLZ T,T
	POPJ P,

;-X/2,,-Y
CONU:	PUSHJ P,CONCAL
	IMUL T,CMUL+STDBIG
STAN,<
IFE STDBIG-1,<
	SKIPE XTHICK
	IMULI T,CWIDTH+1
	SKIPN XTHICK
>
>;STAN
	IMULI T,CWIDTH
	ASH T,-1
	MOVN T,T
	HRLZ T,T
	MOVN TT,CMUL+STDBIG
	IMULI TT,CHGHT
	HRR T,TT
	POPJ P,

CTOTAB:	PUSHJ P,CTOL
	PUSHJ P,CTOR
	ASH T,-1		;X/2,,1
	PUSHJ P,CTOU
	ASH T,-1		;X/2,,1

;X+1/2,,1/2
CTOL:	MOVE TT,CMUL+STDBIG
STAN,<
IFE STDBIG-1,<
	SKIPE XTHICK
	IMULI TT,CWIDTH+1
	SKIPN XTHICK
>
>;STAN
	IMULI TT,CWIDTH
	ASH TT,-1
	ADD T,TT
	ASH TTT,-1
	POPJ P,

;-1/2,,1/2
CTOR:	ASH TTT,-1
	MOVN T,CMUL+STDBIG
STAN,<
IFE STDBIG-1,<
	SKIPE XTHICK
	IMULI T,CWIDTH+1
	SKIPN XTHICK
>
>;STAN
	IMULI T,CWIDTH
	POPJ P,

;X/2,,-Y
CTOU:	ASH T,-1
	SUB TTT,TT
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;CALC HEIGHT AND LENGTH OF TEXT IN OFFSET UNITS (D)
OFFCAL:	HRRZ TT,(B)
	ADD TT,[POINT 7,1]
	PUSH P,[0]
	PUSH P,[1]		;AT LEAST ONE LINE
	SETZ T,
OFFCL1:	TLNN TT,760000
	JRST [	HRR TT,-1(TT)
		TRNN TT,-1
		JRST OFFCL2
		JRST .+1]
	ILDB TTT,TT
	JUMPE TTT,OFFCL1
	CAIN TTT,DBLARR		;LINE BREAK?
	JRST [	CAMGE T,-1(P)
		MOVEM T,-1(P)
		SETZ T,
		AOS (P)
		JRST OFFCL1]
	SOJA T,OFFCL1		;COUNT CHARS IN CURRENT LINE

OFFCL2:	CAMGE T,-1(P)
	MOVEM T,-1(P)
	HRRZ TTT,(B)
	HLRZ TTT,(TTT)		;CHAR SIZE
	TRZ TTT,400000		;CLEAR VERT BIT
	MOVE TTT,CMUL(TTT)	;MAKE IT SIZE ONE MULTIPLIER
	POP P,TT
	POP P,T
	IMUL TT,TTT
	IMUL T,TTT
	POPJ P,

CONCAL:	SETZM CHRCNT
	PUSH P,TT
	PUSH P,A
	PUSH P,PUTCHR
	MOVE A,[AOS CHRCNT]
	MOVEM A,PUTCHR
	MOVS A,(B)
	PUSHJ P,CSLTLP
	POP P,PUTCHR
	POP P,A
	POP P,TT
	MOVE T,CHRCNT
	POPJ P,

LINSET:	SETZ C,
	SKIPN TT,1(T)
	JRST NOLROF
	TLNE TT,-1
	TRO C,1
	TRNE TT,-1
	TRO C,2
NOLROF:	SKIPN TT,(T)
	JRST NOUDOF
	TLNE TT,-1
	TRO C,4
	TRNE TT,-1
	TRO C,10
NOUDOF:	XCT SETCTB(C)
	SETZM ISVERT		;ASSUME NO VERT TEXT
	JUMPE B,CPOPJ1		;LEAVE NOW IF NO TEXT
	HRRZ TT,(B)
	SKIPL (TT)		;VERT TEXT?
	JRST CPOPJ1		;NO
	SETOM ISVERT		;IT IS VERTICAL
	CAIN C,4		;NO CHANGE IF NO LINES
	JRST CPOPJ1
	TRCN C,2		;MAP 90 DEGREES CW
	TRC C,1
	JRST CPOPJ1

SETCTB:	MOVEI C,4
	MOVEI C,0
	MOVEI C,1
	POPJ P,
	MOVEI C,2
	POPJ P,
	POPJ P,
	POPJ P,
	MOVEI C,3
	POPJ P,
	POPJ P,
	POPJ P,
	POPJ P,
	POPJ P,
	POPJ P,
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                           ;KILL TEXT (D,PC)
PTKILL:	PUSHJ P,GETCLS	;GET POINTER TO CLOSEST POINT
	JRST PERRET	;NONE
PTKIL1:	TRNE TMOVE	;MOVING TEXT OFFSET?
	PUSHJ P,CLRMOV	;YES, CLEAR MOVING
	MOVE B,A
KILTXT:	PUSH P,B
	HLRZ T,(B)	;GET DATA BLOCK POINTER
	HRRZ T,1(T)
	HLRZ B,(T)	;GET TEXT POINTER
	JUMPE B,NKLTXT	;LEAVE IF NONE
	HRRZS (T)
	MOVSI TT,MD,<FIXTXT!FIXRHT!>FOUNDP
	ANDCAM TT,1(T)	;CLEAR FIX BITS
	TRO MCHG!NEEDCL	;CHANGES SCREEN AND BLINKING LETTER
	PUSHJ P,PUTFS
MD,<	PUSH P,A
	PUSH P,C
	PUSH P,D
	MOVE A,-3(P)
	PUSHJ P,OFFCON	;MAYBE FIX CON
	POP P,D
	POP P,C
	POP P,A
>;MD
NKLTXT:	POP P,B
	POPJ P,
                           ;DELETE LINE (D)
MD,<
LINDEL:	PUSHJ P,GETCLS		;CLOSEST LINE?
	JRST PERRET
	TRO MCHG!NEEDCL
	HLRZ D,(A)		;GET POINTER TO ^_ FOR ONE ENDPOINT
	HLRZ D,1(D)		;	"
	HLRZ B,A		;SECOND POINT
	HLRZ C,(B)		;^_
	HLRZ C,1(C)		;  "
	HRRZ B,(C)		;
	CAIN B,(A)		;THIS ONE?
	JRST [	HLLZS (C)	;CLEAR POINTER
		HRRZS (D)	;	"
		POPJ P,]
	HLRZ B,(C)		;^
	CAIN B,(A)		;THIS ONE?
	JRST [	HRRZS (C)	;CLEAR POINTER
		HLLZS (D)	;	"
		POPJ P,]
	HRRZ B,1(C)		;
	CAIN B,(A)		;THIS ONE?
	JRST [	HLLZS 1(C)	;CLEAR POINTER
		HRRZS 1(D)	;	"
		POPJ P,]
	HLRZ B,1(C)		;_
	CAIE B,(A)		;THIS ONE?
	POPJ P,
	HRRZS 1(C)		;CLEAR POINTER
	HLLZS 1(D)		;	"
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;LINES, SET MIDPOINT, MAKE JOG, ATTACH POINT (D)
DEFINE BENDIT # (CBIT)
<
BENDL#CBIT:
	PUSHJ P,GETCLS
	JRST PERRET		;NO CLOSEST LINE.
	MOVE T,CURSE		;USE CURSOR POS FOR MIDPOINT CALC
;ENTRY POINT FOR <META>A IN LINE MODE
LATTP#CBIT:
	MOVEM T,DX3		;SAVE POS TO USE
	TRO MCHG
	HLRZ C,A
	HLRZ B,(A)
	HLRZ B,1(B)
	HLRZ D,(C)
	HLRZ D,1(D)
	HRRZ E,(B)
	CAIN E,(C)
	JRST BENDY#CBIT
	HRRZ E,1(B)
	CAIN E,(C)
	JRST BENDX#CBIT
	EXCH A,C
	EXCH B,D
	HRRZ E,(B)
	CAIN E,(C)
	JRST BENDY#CBIT
	HRRZ E,1(B)
	CAIN E,(C)
	JRST BENDX#CBIT
	POPJ P,

DEFINE GARPLY $ (H1,XY,YX)
<	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	MOVE T,1(A)
	H$H1$H1 T,DX3
	PUSHJ P,PNTPUT
IFE CBIT-2,<MOVEM D,SAVP>		;REMEMBER POINT FOR HIGHER UPS!
	PUSH P,D
	MOVE T,1(D)
	HLRZ D,(D)
	HLRZ D,1(D)
	PUSH P,D
IFE CBIT-1,<
	PUSHJ P,PNTPUT
	MOVE T,D
	HLRZ TT,(T)
	HLRZ TT,1(TT)
>
	POP P,F
	POP P,E
IFN CBIT-1,<
	MOVE T,E
	MOVE TT,F
>
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	HRRM T,XY(B)
	HRLM A,XY(TT)
IFE CBIT-1,<
	HRRM E,YX(TT)
>
	HRRM C,XY(F)
IFE CBIT-1,<
	HRLM T,YX(F)
>

	HRLM E,XY(D)
	POPJ P,
>

BENDX#CBIT:
	GARPLY(L,1,0)
BENDY#CBIT:
	GARPLY(R,0,1)
>

BENDIT(1)	;MAKE DOUBLE MIDPOINT
BENDIT(2)	;MAKE SINGLE MIDPOINT
                           ;ATTACH POINT TO LINE (D)
LATT:	MOVE A,CLOSES	;IF MOVING
	TRZE INMOV	;STOP MOVING
	JRST INATT	;BUT USE THE ONE WE WERE MOVING
	SETZ A,		;FOR INLIN
	TRNE INLIN
	JRST INATT
	PUSHJ P,GETCLS
	JRST PERRET
INATT:	MOVEM A,SAVP
	MOVEI T,LINM
	PUSHJ P,TCHNGM
	PUSHJ P,GETCLS		;FIND CLOSEST LINE
	JRST [	PUSHJ P,RCHNGM
		SKIPN SAVP
		TRO INLIN!NEEDCL
		JRST PERRET]
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/THIS ONE/]
	MOVEI T,UPSTAR
	MOVEM T,SPDISP
	MOVE T,[ASCID/AL/]
	MOVEM T,SPMODT
	MOVEI T,SPM		;SPECIAL POINTER MODE
	PUSHJ P,TCHNGM
	MOVE T,IPOINT		;GET INTERSECTION POINT
	MOVEM T,STARLOC		;THIS IS LOC OF STAR
	PUSHJ P,YORN
	JFCL
	JFCL
	PUSHJ P,RCHNGM		;GET BACK OLD MODE
	CAIE C,"Y"
	CAIN C,"y"
	CAIA
	JRST [	SKIPN SAVP	;WERE WE INLIN?
		TRO INLIN!NEEDCL;YES, STAY THERE
		POPJ P,]
	SKIPE T,SAVP		;IS THIS THE INLIN GUY
	JRST GOTINT		;ALREADY GOT INTERSECTION POINT
	MOVE T,IPOINT		;PUT POINT AT PERPENDICULAR INTERSECTION POINT
	PUSHJ P,LATTP2		;MAKE MIDPOINT
	TRO INLIN		;TELL HIM ITS OK
	MOVE A,SAVP		;SETUP A FOR LINE CALLS
	PUSHJ P,PNMNS1		;TRY -
	CAIA			;LOSE
	JRST ATTDON		;THEN IT WORKED
	TRC ZIGZAG		;ELSE TRY THE OTHER WAY
	MOVE A,SAVP
	PUSHJ P,PNMNS1
	CAIA			;LOSE
	JRST ATTDON		;YES
	MOVE A,SAVP
	PUSHJ P,PNOT1		;TRY A STRAIGHT (SLANTED) LINE!
	CAIA
	JRST ATTDON
	OUTSTR[ASCIZ/SORRY, YOU'LL HAVE TO HAVE ANOTHER
TICKET TO MAKE THIS CONNECTION.
/]
	TRO INLIN!NEEDCL
	POPJ P,

ATTDON:	TRO NEEDCL!MCHG
	TRZ INMOV!INLIN
	POPJ P,

GOTINT:	MOVEM T,LINING		;SAVE ORIGINAL POINT HERE
	MOVE T,1(T)		;USE THIS AS PLACE TO MAKE NEW POINT
	PUSHJ P,LATTP2		;MAKE A MIDPOINT
	MOVE A,SAVP
	MOVE T,LINING
	HLRZ T,(T)
	HRRZ T,1(T)
	MOVE T,1(T)		;GET POINT BITS
	TLNN T,ISPIN		;CAN'T REVERSE IF LINING IS ALREADY PIN
	EXCH A,LINING		;MOVE TO LINE!
	JRST LATTP		;ATTACH TO POINT WILL DO THE REST
                                                             ;ATTACH POINT TO POINT (D)
PATT:	TRZE INMOV
	JRST [	MOVE A,CLOSES	;USE THE ONE WE WERE MOVING
		JRST PATT1]
	TRNN INLIN
	PUSHJ P,GETCLS
	JRST PERRET
PATT1:	MOVEM A,LINING
	TRO INLIN!NEEDCL
	PUSHJ P,GETCLS		;FIND CLOSEST(NOT INCLUDING CURRENT CLOSEST)
	JRST [	TRZ INLIN
		TRO NEEDCL
		JRST PERRET]	;NO, JUST ONE POINT ON SCREEN
	MOVE T,1(A)
	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TLNE TT,ISPIN
	JRST [	EXCH A,LINING	;TRY IT THE OTHER WAY
		HLRZ TT,(A)
		HRRZ TT,1(TT)
		MOVE TT,1(TT)
		TLNN TT,ISPIN
		JRST .+1
		OUTSTR[ASCIZ/SORRY, BOTH ARE PINS!
/]
		TRZ INLIN
		TRO NEEDCL
		JRST PERRET]
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/THIS ONE/]
	TRZ INLIN
	MOVEM T,STARLOC
	MOVEI T,UPSTAR
	MOVEM T,SPDISP
	MOVE T,[ASCID/AP/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM
	PUSHJ P,YORN
	JFCL
	JFCL
	TRO NEEDCL
	PUSHJ P,RCHNGM
	CAIE C,"Y"
	CAIN C,"y"
	CAIA
	POPJ P,
	TRO MCHG
LATTP:	MOVEM A,DX1
	HLRZ A,(A)
	HLRZ A,1(A)
	MOVE B,LINING
	HLRZ B,(B)
	HLRZ B,1(B)
;LEFT
	HLRZ C,(B)
	CAMN C,DX1		;POINT TO POINT WE ARE ATTACHING?
	SETZ C,			;YES, COPY POINTER ANYWAY
	JUMPE C,[HLRZ C,(A)	;COPY POINTER
		HRRZS (A)	;AND CLEAR IT
		CAMN C,LINING
		SETZ C,		;DON'T POINT HIM TO HIMSELF
		JRST .+1]
	HRLM C,(B)
	JUMPN C,[HLRZ C,(C)
		HLRZ C,1(C)
		MOVE D,LINING
		HRRM D,(C)
		JRST .+1]
;RIGHT
	HRRZ C,(B)
	CAMN C,DX1
	SETZ C,
	JUMPE C,[HRRZ C,(A)
		HLLZS (A)
		CAMN C,LINING
		SETZ C,
		JRST .+1]
	HRRM C,(B)
	JUMPN C,[HLRZ C,(C)
		HLRZ C,1(C)
		MOVE D,LINING
		HRLM D,(C)
		JRST .+1]
;DOWN
	HLRZ C,1(B)
	CAMN C,DX1
	SETZ C,
	JUMPE C,[HLRZ C,1(A)
		HRRZS 1(A)
		CAMN C,LINING
		SETZ C,
		JRST .+1]
	HRLM C,1(B)
	JUMPN C,[HLRZ C,(C)
		HLRZ C,1(C)
		MOVE D,LINING
		HRRM D,1(C)
		JRST .+1]
;UP
	HRRZ C,1(B)
	CAMN C,DX1
	SETZ C,
	JUMPE C,[HRRZ C,1(A)
		HLLZS 1(A)
		CAMN C,LINING
		SETZ C,
		JRST .+1]
	HRRM C,1(B)
	JUMPN C,[HLRZ C,(C)
		HLRZ C,1(C)
		MOVE D,LINING
		HRLM D,1(C)
		JRST .+1]
;TEXT
	MOVE B,DX1
	MOVE A,LINING
	HLRZ A,(A)
	HRRZ A,1(A)
	MOVE T,(A)
	HLRZ TT,(B)
	HRRZ TT,1(TT)
	TLNE T,-1			;ANY TEXT ON NEW?
	JRST LGTXT1
	HLRZ TTT,(TT)
	HRLM TTT,(A)			;COPY TEXT TO NEW
	HRRZS (TT)			;CLEAR FROM OLD
	MOVSI TTT,FIXTXT!FIXRHT
	ANDCAM TTT,1(A)
	AND TTT,1(TT)
	IORM TTT,1(A)
LGTXT1:	TRNE T,-1			;ANY CON OR PIN ON NEW?
	JRST LGTXT2			;YES
	MOVSI TTT,CPIN
	TDNN TTT,1(TT)			;CPIN ON OLD?
	JRST LGTXT2			;NO
	ANDCAM TTT,1(TT)		;YES, TURN OFF
	IORM TTT,1(A)			;AND TURN ON IN NEW
	HRRZ TTT,(TT)			;GET POINTER
	HRRM TTT,(A)			;STORE IN NEW
	HLLZS (TT)			;CLEAR FROM OLD
	MOVSI TTT,FIXCON!CPNBTS
	ANDCAM TTT,1(A)
	AND TTT,1(TT)
	IORM TTT,1(A)
LGTXT2:	PUSHJ P,DELPNL
	MOVE A,LINING
	SETZM LINING
	TRO NEEDCL!MCHG
	TRZ INLIN!INMOV
	MOVE TT,1(A)
	PUSHJ P,PMOVX
	JRST PMOVY
                                                                                                                                                                                                                                                                                                                                                                                                  ;BREAK JUNCTION OF 3 OR 4 LINES (D)
BREAKH:	TRZA TFLG		;ZERO INDEX FOR HORZ
BREAKV:	TRO TFLG		;20 INDEX FOR VERT
	TRNN INLIN		;CAN'T BE INLIN
	PUSHJ P,GETCLS
	JRST PERRET
	MOVE B,A
	PUSHJ P,SETBTO
	HLRZ F,F		;GET BITS
	ANDI F,17		;JUST LINE BITS
	MOVE H,D		;SAVE NEIGHBOR POINTER
	MOVE T,1(B)		;SETUP FOR LIKELY CALL ON PNTPUT
	XCT PERMIT(F)		;CHECK OK AND WHERE TO GO
	TRZE INMOV
	TRO NEEDCL
	TRO MCHG
	PUSHJ P,PNTPUT
	XCT (F)[HRRZ T,1(H)	;PICKUP RIGHT
		HRRZ T,1(H)	;PICKUP RIGHT
		HRRZ T,(H)	;PICKUP UP
		HRRZ T,(H)]	;PICKUP UP
	XCT (F)[HLLZS 1(H)	;CLEAR IT
		HLLZS 1(H)
		HLLZS (H)
		HLLZS (H)]
	XCT (F)[HRRM T,1(E)	;MAKE IT RIGHT OF NEW POINT
		HRRM T,1(E)	;	"
		HRRM T,(E)	;    "	 LEFT	   "
		HRRM T,(E)]	;	"
	HLRZ T,(T)
	HLRZ T,1(T)
	XCT (F)[HRLM D,1(T)	;MAKE NEW POINT HIS LEFT
		HRLM D,1(T)	;	"
		HRLM D,(T)	;	"	    DOWN
		HRLM D,(T)]	;	"
	XCT (F)[HRRM D,(H)	;MAKE NEW UP OF OLD
		HRLM D,(H)	;    "   DOWN   "
		HRRM D,1(H)	;    "   RIGHT  "
		HRLM D,1(H)]	;    "   LEFT	"
	XCT (F)[HRLM B,(E)	;MAKE OLD DOWN OF NEW
		HRRM B,(E)	;    "	  UP	"
		HRLM B,1(E)	;    "	  LEFT	"
		HRRM B,1(E)]	;    "	  RIGHT	"
	POPJ P,

WAY4:	TRZE INMOV		;FLAGS
	TRO NEEDCL
	TRO MCHG
	PUSHJ P,PNTPUT		;MAKE ANOTHER POINT THERE
	HRRZ T,(H)		;GET OUR RIGHT
	HRRM T,(E)		;MAKE IT NEW POINT'S RIGHT
	HRRZ TT,1(H)		;SAME WITH U
	HRRM TT,1(E)
	HLRZ T,(T)
	HLRZ T,1(T)
	HRLM D,(T)		;MAKE RIGHT POINT TO NEW POINT
	HLRZ TT,(TT)
	HLRZ TT,1(TT)
	HRLM D,1(TT)		;MAKE UP POINT TO NEW POINT
	TRNN TFLG		;NOW, CONNECT VERT OR HORZ
	JRST HRZWAY		;HORZ
	HRLM B,(E)		;VERT, STORE ORIG POINT AS NEW ONE'S DOWN
	HRRM D,(H)		;AND HIM AS OUR UP
	HLLZS 1(H)		;AND CLEAR OTHER CRUFTY POINTER
	POPJ P,

HRZWAY:	HRLM B,1(E)		;ORIG AS LEFT
	HRRM D,1(H)		;NEW AS RIGHT
	HLLZS (H)		;CLEAR UP
	POPJ P,

PERMIT:	JRST WAY4		;_   ^	CAN'T CALL IT 4WAY
	MOVEI F,0		;_  		NO UP
	MOVEI F,1		;_    ^	NO DOWN
	MOVEI F,0		;_ 		DO LIKE NO UP
	MOVEI F,2		;_    ^	NO RIGHT
	JRST PERRET		;_   
	JRST PERRET		;_     ^
	JRST PERRET		;_
	MOVEI F,3		;    ^	NO LEFT
	JRST PERRET		;   
	JRST PERRET		;     ^
	JRST PERRET		;  
	MOVEI F,2		;     ^	DO LIKE NO RIGHT
	JRST PERRET		;    
	JRST PERRET		;      ^
	JRST PERRET

>;MD
                                                                                                                                                                                                                                                                                                    ;JUMP LINE TO OTHER SIDE OF CARD (PC)
MPC,<
LJUMP1:	TLZA WFLAG		;USE WIRE LIST FLAG HERE
LJUMP2:	TLO WFLAG		;AND HERE (WHOLE LINE)
	TRZE INLIN!INMOV
	TRO NEEDCL
	PUSHJ P,GETCLS
	JRST PERRET
	PUSH P,A
	HLRZ B,A
	HRRZS A
	TRZ TYPNEG
	PUSHJ P,LSWITCH		;SWITCH THIS LINE AND IN ONE DIRECTION
	POP P,A
	TRZ TFLG
	TRNE TYPNEG
	TRO TFLG		;USE FEED THROUGH IF THERE
	PUSHJ P,LSWA
	TRO MCHG!NEEDCL
	POPJ P,

LSWA:	TLNN WFLAG		;ARE WE DOING WHOLE LINE
	POPJ P,
	HLRZ C,(A)
	HRRZ T,1(C)
	MOVE T,1(T)
	TLNE T,ISPIN!CPIN
	POPJ P,			;IMPOSSIBLE
	TRNN TFLG
	TLNN T,FEEDTH
	CAIA
	POPJ P,
	HLRZ C,1(C)
	SETZ B,			;NOW COUNT SEGMENTS FROM THIS POINT
LSWA1:	MOVEI T,2
LSWA2:	XCT (T)[HLRZ TT,(C)
		HLRZ TT,1(C)
		HRRZ TT,1(C)]
	JUMPE TT,LSWA3
	JUMPN B,CPOPJ
	MOVE B,TT
LSWA3:	SOJGE T,LSWA2
	HRRZ C,(C)
	JUMPN C,LSWA1
	JUMPE B,CPOPJ		;NO MORE SEGMENTS?
LSWITCH:PUSH P,A
	PUSH P,B
	PUSHJ P,KILSEG		;KILL SEGMENT ON THIS SIDE
	MOVE A,(P)
	MOVE B,-1(P)
	PUSHJ P,KILSEG		;BOTH DIRECTIONS
	MOVE A,-1(P)
	TRZ TFLG
	PUSHJ P,OPNT		;MAKE SURE OF POINT ON OTHER SIDE
	SETZM -1(P)		;THIS POINT WAS DELETED
	PUSH P,B		;SAVE ITS POINTER
	MOVE A,-1(P)		;AND OTHER END
	TRZE TFLG
	TRO TYPNEG
	PUSHJ P,OPNT
	SETZM -1(P)		;THIS POINT WAS DELETED
	PUSH P,B
	MOVE D,-1(P)
	PUSHJ P,MAKSEG		;NOW MAKE SEGMENT ON NEW SIDE
	POP P,D
	POP P,B
	PUSHJ P,MAKSEG		;BOTH DIRECTIONS
	POP P,A
	POP P,(P)
	JUMPN A,LSWA		;LOOP TO NEXT SEGMENT
	POPJ P,			;POINT WAS FEED THROUGH, AND WAS DELETED
                                                                                                                                                                                                                                                                                                                                                                                                                        ;LJUMP SUBRS (PC)
;CLEAR POINTER TO A FROM LIST B
KILSEG:	HLRZ B,(B)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK
	JRST KILLOS
	XCT (T)[HRRZS (B)
		HLLZS 1(B)
		HRRZS 1(B)]
	POPJ P,

KILLOS:	PUSHJ P,FUCKUP
	POPJ P,

;ADD POINTER TO A TO LIST B
MAKSEG:	HLRZ T,(B)
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	POPJ P,

;FIND POINT ON OTHER SIDE, OR MAKE ONE, AND POSSIBLY DELETE ONE ONE THIS SIDE
OPNT:	HLRZ TT,(A)
	HRRZ B,TT		;SAVE POINTER TO DATA BLOCK
	HRRZ T,1(TT)
	HLL B,1(T)
	TLNN B,FEEDTH
	JRST OPNT1
	PUSH P,(B)		;SAVE POINTER TO POINT ON OTHER SIDE
	HLRZ TT,1(TT)
	TLNN B,PLANES		;DON'T DELETE IF CONNECTED TO INNER PLANES
OPNTB:	SKIPE 1(TT)		;DON'T DELETE IF STILL HAS LINES ON IT
	JRST OPNTA
	SKIPN TT,(TT)
	JRST OPNTC
	TLNE TT,-1
	JRST OPNTA
	JRST OPNTB
OPNTC:	TLZ B,FEEDTH
	HRRZS (B)		;CLEAR POINTER TO OTHER SIDE
	HLLZM B,1(T)		;CLEAR PAD TYPE
	HLRZ T,(P)		;GET OTHER SIDE POINTER
	HLRZ T,(T)
	HRRZS (T)		;CLEAR POINTER BACK
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLZ TT,FEEDTH
	HLLZM TT,1(T)		;AND PAD TYPE AND BIT
	HRRZ B,A
	PUSHJ P,DELPNL		;DELETE ONE ON THIS SIDE
OPNTA:	POP P,B
	HLRZS B			;AND RETURN POINTER TO ONE ON OTHER SIDE
	POPJ P,

OPNT1:	TLNN B,ISPIN
	JRST OPNT2		;GUESS WE HAVE TO MAKE ONE
	HRRZ T,(T)		;HERE WE TRY TO FIND THE PIN ON THE OTHER SIDE
	HLRZ B,(B)
	HLRZ B,(B)
	HRRZ B,(B)
OPNT3:	HLRZ TT,(B)
	CAIN B,(A)
	JRST OPNT4
	HRRZ TTT,1(TT)
	HRRZ TTT,(TTT)
	CAIN TTT,(T)
	JRST CPOPJ1
OPNT4:	HRRZ B,(TT)
	JUMPN B,OPNT3
	PUSHJ P,FUCKUP
	POPJ P,

OPNT2:	TLNN B,CPIN
	JRST OPNT5
	SWITCH
	MOVE TTT,1(A)
	PUSHJ P,FIND.P		;TRY TO FIND CONNECTOR PIN ON OTHER SIDE
	SWITCH
	HRRZ B,D
	JRST CPOPJ1

OPNT5:	MOVE G,A
	PUSHJ P,RDFEED		;MAKE FEED THROUGH
	PUSHJ P,FUCKUP		;CAN'T BE IMPOSSIBLE
	HRRZ B,D
	TRO TFLG		;TELL THEM WE MADE THIS FEED THROUGH
	JRST CPOPJ1
                                                                                              ;DELETE LINE, DELETE WIRE
LINDEL:	PUSHJ P,GETCLS		;CLOSEST LINE?
	JRST PERRET
	TRO MCHG!NEEDCL
FLSHLN:	HLRZ B,A
	HLRZ B,(B)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK
	POPJ P,
	XCT (T)[CLRTAB:HRRZS (B)
		HLLZS 1(B)
		HRRZS 1(B)]
	MOVS A,A
	HLRZ B,A
	HLRZ B,(B)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK
	POPJ P,
	XCT (T)CLRTAB
	POPJ P,

;DELETE WHOLE WIRE
LINDL2:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG!NEEDCL
	PUSHJ P,FLSHLN		;FLUSH LINE
	HLRZM A,LINING		;SAVE ONE END HERE
	HLLI A,			;CLEAR LEFT HALF
	PUSHJ P,DELWIR		;DELETE THE WIRE
	SKIPN A,LINING		;NOW THIS ONE
	POPJ P,
DELWIR:	HLRZ B,(A)
	HLRZ C,1(B)		;NEIGHBORS
	JUMPE C,DELWR1
	SETZ TTT,
DELWRA:	MOVEI T,2
DELWRB:	XCT (T)[HLRZ TT,(C)
		HRRZ TT,1(C)
		HLRZ TT,1(C)]
	JUMPE TT,DELWRC
	JUMPN TTT,CPOPJ		;LEAVE IF SECOND
	MOVE TTT,TT
DELWRC:	SOJGE T,DELWRB
	HRRZ C,(C)
	JUMPN C,DELWRA
	MOVE C,TTT
DELWR1:	HRRZ T,1(B)
	MOVE TT,1(T)
	TLNN TT,FEEDTH		;FEED THROUGH?
	JRST DELWR2
	JUMPN C,CPOPJ		;2 THINGS, QUIT HERE
	HLRZ C,(B)		;FEED THROUGH POINTER
	HRRZS (B)		;UNFEED THROUGH SO WE CAN FOLLOW AFTERWARDS
	TLZ TT,FEEDTH
	MOVEM TT,1(T)
	HLRZ T,(C)
	HRRZS (T)
	HRRZ T,1(T)
	MOVSI TT,FEEDTH
	ANDCAM TT,1(T)
DELWR2:	CAMN A,LINING
	SETZM LINING		;NOTE WE DELETED THIS ONE
	PUSH P,C
	TRZ TFLG
	MOVE B,A
	PUSHJ P,DELPNL
	POP P,A
	JUMPN A,DELWIR
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;PUT MIDPOINT IN LINE (PC)
BENDL:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE T,CURSE		;WHERE TO PUT MIDPOINT
	PUSHJ P,BENDLP
	JFCL
	POPJ P,

;ENTER HERE WITH LOCATION YOU WISH MIDPOINT TO BE PLACED IN T
BENDLP:	PUSH P,A
	PUSHJ P,PNTPUT
	GETFS(E)
	SETZM (E)
	SETZM 1(E)
	HRLM E,1(TTT)
	PUSH P,D
	PUSH P,E
	HLRZ A,-2(P)
	HRRZ B,-2(P)
	HLRZ B,(B)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK
	JRST [	OUTSTR[ASCIZ/MOBY LOSSAGE AT BENDL!
/]
		POP P,(P)
		POP P,(P)
		POP P,(P)
		POPJ P,]
	TRO MCHG
	MOVE D,-1(P)
	XCT (T)PUTAB
	HLRZ B,(A)
	HLRZ B,1(B)
	HRRZ A,-2(P)
	PUSHJ P,FNDLNK
	PUSHJ P,FUCKUP		;LOSE BIG IF NOT FOUND
	MOVE D,-1(P)
	XCT (T)PUTAB
	POP P,B
	MOVE A,-1(P)
	MOVEM A,1(B)
	POP P,(P)
	MOVE T,LSTPNT
	PUSHJ P,SCLOSE
	POP P,(P)		;LOSE OLD CLOSEST
	MOVEI T,PNTM		;MUST BE IN POINT MODE FOR THIS
	PUSHJ P,CHNGMD
	PUSHJ P,DOPMOV		;START MOVING MID-POINT
	MOVEI T,BIGPG
	AOS (P)			;INDICATE SUCCESS
	JRST HYDPOG
                                                                                                                                                                                                                                                                                                                                                   ;ATTACH POINT TO POINT (PC)
PATT:	TRZE INMOV
	JRST [	MOVE A,CLOSES	;USE THE ONE WE WERE MOVING
		JRST PATT1]
	TRNN INLIN
	PUSHJ P,GETCLS
	JRST PERRET
PATT1:	MOVEM A,LINING
	TRO INLIN!NEEDCL
	PUSHJ P,GETCLS
	JRST [	TRZ INLIN
		TRO NEEDCL
		JRST PERRET]
	MOVE T,1(A)
	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TLNE TT,ISPIN!CPIN!FEEDTH
	JRST [	EXCH A,LINING	;TRY IT THE OTHER WAY
		HLRZ TT,(A)
		HRRZ TT,1(TT)
		MOVE TT,1(TT)
		TLNN TT,ISPIN!CPIN!FEEDTH
		JRST .+1
		OUTSTR[ASCIZ/SORRY, BOTH ARE PINS OR FEEDTHROUGHS!
/]
		TRZ INLIN
		TRO NEEDCL
		POPJ P,]
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
THIS ONE?/]
	TRZ INLIN
	MOVEM T,STARLOC
	MOVEI T,UPSTAR
	MOVEM T,SPDISP
	MOVE T,[ASCID/AP/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM
	PUSHJ P,YORN
	JFCL
	JFCL
	TRO NEEDCL
	PUSHJ P,RCHNGM
	CAIE C,"Y"
	CAIN C,"y"
	CAIA
	POPJ P,
PATTL:	HRLM A,LINING
	HRRZ A,LINING
	HLRZ A,(A)
	HRRZ B,1(A)
	HLRZ C,LINING
	HLRZ C,(C)
	HLRZ D,1(C)
	JUMPE D,NOMOVL
	MOVE T,D
TLOOPS:	SKIPE 1(T)		;CHECK FOR ANY NEIGHBORS TO COPY
	JRST TLOOP0
	SKIPN T,(T)
	JRST NOMOVL
	TLNN T,-1
	JRST TLOOPS
TLOOP0:	HRRZS 1(C)		;CLEAR POINTER TO LIST FROM OLD POINT
	HLRZ T,1(A)
	JUMPE T,[HRLM D,1(A)
		JRST TLOOP9]
	MOVE A,T
	HRRZ T,(T)
	JUMPN T,.-2
	HRRM D,(A)
TLOOP9:	PUSH P,B
	PUSH P,C
	MOVE C,D
	HRRZ D,LINING
	HLRZ A,LINING
TLOOP:	MOVEI TTT,2
TLOOP1:	XCT (TTT)[HLRZ B,(C)
		HRRZ B,1(C)
		HLRZ B,1(C)]
	JUMPE B,TLOOPE
	CAMN D,B			;DID THESE 2 POINT TO EACH OTHER?
	JRST [	XCT (TTT)[HRRZS (C)	;YES, FLUSH THAT SEGMENT
			HLLZS 1(C)
			HRRZS 1(C)]
		HLRZ B,(B)
		HLRZ B,1(B)
		PUSHJ P,FNDLNK
		JRST TLOOPE
		XCT (T)[HRRZS (B)
			HLLZS 1(B)
			HRRZS 1(B)]
		JRST TLOOPE]
	HLRZ B,(B)
	HLRZ B,1(B)
	PUSHJ P,FNDLNK
	CAIA
	XCT (T)PUTAB
TLOOPE:	SOJGE TTT,TLOOP1
	HRRZ C,(C)
	JUMPN C,TLOOP
	POP P,C
	POP P,B
NOMOVL:	HLRZ T,(B)
	JUMPN T,LOSTXT
	HRRZ C,1(C)
	HLRZ D,(C)
	HRRZS (C)
	HRLM D,(B)
LOSTXT:	HLRZ B,LINING
	PUSHJ P,DELPNL
	SETZM LINING
	TRO MCHG!NEEDCL
	TRZ INLIN!INMOV
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;ATTACH POINT TO LINE (PC)
LATT:	MOVE A,CLOSES
	TRZE INMOV		;STOP MOVING
	JRST INATT
	SETZM SAVP
	TRNE INLIN
	JRST INATT0
	PUSHJ P,GETCLS
	JRST PERRET
INATT:	MOVEM A,SAVP		;THIS IS POINT WE WILL ATTACH TO
	JUMPE A,INATT0
	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNE T,ISPIN!CPIN	;NOT THESE PLEASE!
	JRST PERRET
INATT0:	MOVEI T,LINM
	PUSHJ P,TCHNGM
	TRO NEEDCL
	PUSHJ P,GETCLS
	JRST [	PUSHJ P,RCHNGM
		JRST ATTERR]
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/THIS ONE/]
	MOVEI T,UPSTAR
	MOVEM T,SPDISP
	MOVE T,[ASCID/AL/]
	MOVEM T,SPMODT
	MOVEI T,SPM		;SPECIAL POINTER MODE
	PUSHJ P,TCHNGM
	MOVE T,IPOINT
	MOVEM T,STARLOC		;THIS IS LOC OF STAR
	PUSHJ P,YORN
	JFCL
	JFCL
	PUSHJ P,RCHNGM		;GET BACK OLD MODE
	SKIPN T,SAVP
	SKIPA T,IPOINT
	MOVE T,1(T)
	CAIE C,"y"
	CAIN C,"Y"
	PUSHJ P,BENDLP
	JRST ATTERR
	TRZ INMOV
	SKIPN A,SAVP
	JRST LATTL
	MOVEM A,LINING
	MOVE A,CLOSES
	EXCH A,LINING		;MOVE POINT TO LINE!
	JRST PATTL		;PATT DOES THE REST

LATTL:	MOVE A,CLOSES
	TRZ INLIN
	TRO NEEDCL
	JRST PNMNS1		;MINUS TO MIDPOINT

ATTERR:	SKIPN SAVP
	TRO INLIN!NEEDCL
	TRZ INMOV
	JRST PERRET
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             COMMENT    VALID 00011 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(BODY,5)
C00008 00003	PLACE A BODY
C00012 00004	BODY AND DIP NAME STUFF SUBRS
C00014 00005	COPY PINIDS TO PIN #'S -- TRANSPOSE -- BROT -- BODFIX
C00019 00006	GET PIN #'S FROM DIP DEF FILE
C00027 00007	SET BODY LOCATION
C00035 00008	DELETE BODY
C00038 00009	BODREN
C00040 00010	GET BODY
C00045 00011	ASSOCIATIVE BODY SET
C00048 ENDMK
C;
                                                                                                                                                                                                       VERSION(BODY,5)
;PIN SWAPPING
PSWAPA:
MD,<	TRZA TFLG
PSWAPB:	TRO TFLG		;PIN NUMBER SWAP ONLY
>;MD
	PUSHJ P,PUSHM		;SET DISPLAY MODE
	PUSHJ P,GETCLS
	JRST POPME
	TLNN M,DSKACT!MACACT
MD,<	OUTSTR[ASCIZ/FIRST PIN ID?/]	>
MPC,<	OUTSTR[ASCIZ/FIRST PIN NAME?/]	>
	PUSHJ P,READP
	JRST POPM		;ALTMODE
	JRST POPME		;ERROR
	JUMPE T,POPM		;LET HIM OUT ON 0
	MOVEM T,N1
	TLNN M,DSKACT!MACACT
MD,<	OUTSTR[ASCIZ/SECOND PIN ID?/]	>
MPC,<	OUTSTR[ASCIZ/SECOND PIN NAME?/]	>
	PUSHJ P,READP
	JRST POPM		;ALTMODE
	JRST POPME		;ERROR
	PUSHJ P,POPM
	JUMPE T,CPOPJ		;LET HIM OUT ON 0
	MOVEM T,N2
	SETZM L1
	SETZM L2
	MOVEM A,CURBOD		;STO BODY POINTER HERE FOR NOW
	HLRZ B,(A)
	JRST FNDPN2

FNDPN1:	HLRZ B,(A)
	HRRZ T,1(B)
	HRRZ T,(T)
	HLRZ T,(T)
MD,<	HRRZ T,(T)	>
	CAME T,N1
	JRST NOTN1
MPC,<	SKIPE L1
	JRST FNDPN3
>;MPC
	MOVEM A,L1
MPC,<	JRST FNDPN2

FNDPN3:	HRLM A,L1
>;MPC
	SKIPN TT,L2
	JRST FNDPN2
MPC,<	TLNE TT,-1
	TLNN TT,-1
	JRST FNDPN2
>;MPC
	JRST GOTBOT
NOTN1:	CAME T,N2
	JRST FNDPN2
MPC,<	SKIPE L2
	JRST FNDPN4
>;MPC
	MOVEM A,L2
MPC,<	JRST FNDPN2

FNDPN4:	HRLM A,L2
>;MPC
	SKIPN TT,L1
	JRST FNDPN2
MPC,<	TLNE TT,-1
	TLNN TT,-1
	JRST FNDPN2
>;MPC
	JRST GOTBOT
FNDPN2:	HRRZ A,(B)
	JUMPN A,FNDPN1
	OUTSTR[ASCIZ/CAN'T FIND BOTH PINS ON THIS BODY!
/]
	POPJ P,

GOTBOT:
MPC,<	HRRZ T,L1
	HLRZ T,(T)
	HRRZ T,1(T)
	MOVE T,1(T)
	HRRZ TT,L1
	HLRZ TT,(TT)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	EQV TT,T
	SKIPL TT		;IF NOT ON SAME SIDE
	MOVSS L1		;MAKE THEM SUCH
	PUSHJ P,SWPPIN
	MOVSS L1
	MOVSS L2
	PUSHJ P,SWPPIN
	MOVE A,CURBOD
	PUSHJ P,BODFIX		;FIX BODY PINS
	TRO MCHG!NEEDCL
	POPJ P,
>;MPC
SWPPIN:	MOVE T,L1		;FIRST POINT
	HLRZ T,(T)
	HRRZ T,1(T)
	MOVE TTT,L2		;SECOND POINT
	HLRZ TTT,(TTT)
	HRRZ TTT,1(TTT)
	HRRZ A,1(TTT)		;SECOND PIN #
	HRRZ TT,1(T)		;FIRST PIN #
MD,<	TRNE TFLG		;JUST CHANGING NUMBERS?
	JRST PNCHNG
>;MD
	HRRM A,1(T)
	HRRM TT,1(TTT)		;PIN #'S STAY WITH ID'S IN CASE BUSSED THROUGH
	HRRZ TT,(T)		;FIRST PIN TYPE POINTER AND TEXT
	HRRZ A,(TTT)		;SECOND PIN TYPE POINTER AND TEXT
	HRRM A,(T)		;EXCHANGE WITH FIRST
	HRRM TT,(TTT)		;AND USE FIRST FOR SECOND
MPC,<	POPJ P,	>
MD,<	MOVE A,CURBOD
	PUSHJ P,BODFIX		;FIX BODY PINS
	MOVE A,L1		;AND MOVE RESULTS
	MOVE TT,1(A)
	PUSHJ P,PMOVX
	PUSHJ P,PMOVY
	MOVE A,L2
	MOVE TT,1(A)
	PUSHJ P,PMOVX
	PUSHJ P,PMOVY
	TRO MCHG!NEEDCL
	POPJ P,
>;MD

MD,<
PNCHNG:	PUSH P,TT
	PUSH P,TTT
	MOVE D,T		;D GETS DATA BLOCK POINTER
	MOVE T,A		;T GETS PIN #
	MOVE B,CURBOD
	PUSHJ P,STPNN1		;SPREAD PIN# OVER NEW ID (SECOND)
	POP P,D
	POP P,T
	MOVE B,CURBOD
	TRO MCHG
	JRST STPNN1		;AND FIRST ONE
>;MD

PUSHM:	MOVE H,M		;SAVE COPY OF LH M
	HRR H,0			;AND RH 0
MD,<	TLZE M,PINIDS!PLOCS		;TURN OFF PINS
	TRO MCHG
	TLON M,RPINID
	TRO MCHG
>;MD
MPC,<	TLON M,PLOCS		;TURN ON PINS
	TRO MCHG
>;MD
	POPJ P,

POPME:	PUSHJ P,POPM
	JRST PERRET

POPM:
MD,<	TRNN H,TFLG
	TRZA TFLG
	TRO TFLG
	TLNE H,PINIDS
	TLOA M,PINIDS
	CAIA
	TRO MCHG
	TLNE H,PLOCS
	TLOA M,PLOCS
	CAIA
	TRO MCHG
	TLNN H,RPINID
	TLZA M,RPINID
>;MD
MPC,<	TLNN H,PLOCS
	TLZA M,PLOCS
>;MPC
	POPJ P,
	TRO MCHG
	POPJ P,

READP:
MD,<	PUSHJ P,READN	>
MPC,<	MOVE C,[PUSHJ P,GETLCH]
	MOVEM C,GTCHRX
	PUSHJ P,RPNAM
	JRST CPOPJ1
>;MPC
	CAIE C,12
	JRST SCARF
	MOVE B,T
	JRST CPOPJ2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ;PLACE A BODY
BODPLC:	TRNE INMOV
	JRST PERRET
MD,<	MOVEI T,[ASCIZ/TYPE BODY NAME
/]	>
	PUSHJ P,BODYGT	;GET BODY NAME & POINTER
	POPJ P,		;ALTMODE
	POPJ P,		;NULL
	JRST OOPS1	;NX
	TRZ INMOV
	MOVEM A,CURBOD	;SAVE POINTER TO TYPE
	SETZM CURORT	;ZERO ORIENTATION
	PUSHJ P,BPYES	;PLANT BODY
	MOVE T,LSTBOD
	PUSHJ P,SCLOSE
	MOVE A,CLOSES
	JRST BMOVEP	;START MOVING NEW BODY

BPYESF:	AOSA HSHFLG
BPYES:	SETZM HSHFLG
	MOVE A,CURBOD	;GET POINTER TO TYPE
	MOVEI T,BODM
	PUSHJ P,CHNGMD	;GO BACK TO BODY MODE
	TRO MCHG
	GETFS(B)
	GETFS(C)
	MOVEM B,LSTBOD		;SAVE POINTER
	HRLZM C,(B)		;DEPOSIT POINTER TO DATA BLOCK
	AOS F,BID		;GET A UNIQUE BODY ID
	SKIPE HSHFLG
	JRST BPYES1
	MOVEI D,DBODPN
	HRLM D,LSTBOD		;FOR CONSISTANCY SAKE
	MOVE D,DBODPN	;GET BODY LIST POINTER
	HRRM D,(B)	;PUT  NEW ONE IN THE LIST
	MOVEM B,DBODPN	;...
BPYES1:	MOVE T,CURSE	;GET CURSOR POSITION
	TDZ T,[1,,1]	;FOO ON INPUT!
	MOVEM T,1(B)	;DEPOSIT AS CENTER OF BODY
	GETFS(E)	;GET DIP NUMBER BLOCK
	HRLZM F,(E)
	SETZM 1(E)
	HRL A,E
	MOVEM A,1(C)	;DEPOSIT POINTER TO TYPE DEFINITION
	MOVE F,CURORT	;GET ORIENTAION
MD,<	ANDI F,7	>
MPC,<	ANDI F,3	>
	HRLZM F,(C)	;STORE ORIENTATION
MD,<
	HLRZ A,1(A)	;GET DEFINITION DATA BLOCK POINTER
	HRRZ A,(A)	;GET POINTER TO PINS
	JUMPE A,CPOPJ
	HRLI B,ISPIN
BLOPP1:	MOVE T,1(A)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,CURSE)	;TO BODY CENTER
	PUSH P,T
	PUSHJ P,PUTPNT	;CREATE THE POINT
	POP P,1(D)	;SET X,Y
BLOPP2:	HRRM D,(C)	;LINK IN WITH OTHER PINS
	MOVE C,TTT
	HRRZ A,(A)	;GET TO NEXT PIN
	JUMPN A,BLOPP1	;LOOP  IF SOME LEFT
	POPJ P,
>;MD
MPC,<
	HRRZ A,1(A)	;GET POINTER TO PINS
	PUSH P,A
	PUSHJ P,BLOPP2
	SWITCH
	POP P,A
	PUSHJ P,BLOPP2
	SWITCH
	MOVEI T,ANGLPG
	JRST HYDPOG

BLOPP2:	JUMPE A,CPOPJ	;NONE?
	HRLI B,ISPIN
BLOPP1:	MOVE T,1(A)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,CURSE)	;TO BODY CENTER
	PUSH P,T
	PUSHJ P,PUTPNT	;CREATE THE POINT
	POP P,1(D)	;SET X,Y
	HLRZ TT,(A)
	CAIE TT,1	;PIN 1?
	JRST NPIN1
	AOS 1(T)
	AOS 1(T)	;MAKE IT END UP PAD TYPE 3 (SQUARE)
NPIN1:	AOS 1(T)	;INITIALLY USE NORMAL PAD FOR PIN!
	HRRM D,(C)	;LINK IN WITH OTHER PINS
	MOVE C,TTT
	HRRZ A,(A)	;GET TO NEXT PIN
	JUMPN A,BLOPP1	;LOOP  IF SOME LEFT
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                  ;BODY AND DIP NAME STUFF SUBRS
MD,<
STODIP:	PUSHJ P,GETCLS
	JRST PERRET
	PUSHJ P,FNDDIP
	JRST [	PUSHJ P,SETTT
		JRST ITSTUF]
	HLRZ T,(T)
	JRST STODEF

STONAM:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HRRZ T,1(T)
STODEF:	HRRZ T,(T)
>;MD
MPC,<
STODIP:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HLRZ T,1(T)
	HRRZ T,1(T)		;DIP TYPE POINTER
>;MPC
	PUSHJ P,SETTT
	JUMPE T,ITSTUF
	JRST STOTX0

MPC,<
STONAM:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ D,(A)
	HRRZ D,1(D)
	PUSHJ P,SETTT
	PUSHJ P,STFNAM
	JRST ITSTUF

STFNAM:	HLRZ B,(D)
	PUSHJ P,PUTTTN
	HLRZ T,(D)
	CAIE T,2
	POPJ P,
	PUTBYT 12
	HRRZ T,1(D)
	HRRE B,1(T)
	HRRZ T,(T)
	HRRE C,1(T)
	SUB B,C
	MOVM B,B
	IMULI B,5
	ASH B,-1
	JRST PUTTTN
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;COPY PINIDS TO PIN #'S -- TRANSPOSE -- BROT -- BODFIX
MD,<
BPINS:	PUSHJ P,GETCLS
	JRST PERRET
BPINS0:	HLRZ A,(A)
	TLNE M,PLOCS
	TRO MCHG
BPINS1:	HRRZ A,(A)
	JUMPE A,CPOPJ
	HLRZ A,(A)
	HRRZ B,1(A)
	HRRZ T,(B)
	HLRZ T,(T)
	HRRZ T,1(T)		;DEFAULT PIN NAME
	HRRM T,1(B)		;USE HERE
	JRST BPINS1

BPINSA:	SKIPN C,DBODPN
	JRST PERRET
BPNSA1:	MOVE A,C
	PUSHJ P,BPINS0
	HRRZ C,(C)
	JUMPN C,BPNSA1
	POPJ P,

;CLEAR ALL DIP PIN NUMBERS
PINZ:	SKIPN A,PONPNT
	POPJ P,
	TRO MCHG
PINZ1:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLNE TT,ISPIN		;PIN?
	HLLZM TT,1(T)		;YES, FLUSH PIN #
	HRRZ A,(A)
	JUMPN A,PINZ1
	POPJ P,

;TRANSPOSE PIN NUMBERS FROM 14 PIN DIP TO 16 PIN SOCKET
;FOR "L" 12,1415	FOR "R" 11,1416
TRANSPOSE:
	PUSHJ P,GETCLS
	JRST PERRET
	PUSHJ P,GETLR
	JRST PERRET
GOTPOF:	HLRZ B,(A)
	HLRZ B,1(B)
	MOVE T,1(B)
	TLZ T,L1416!R1416
	TDO T,C
	MOVEM T,1(B)
	TRO MCHG
	POPJ P,

GETLR:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/L, R, OR <CR>?/]
	PUSHJ P,GETCHR
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
/]
	CAIE C,"L"
	JRST CKR
	MOVSI C,L1416
	JRST CPOPJ1

CKR:	CAIE C,"R"
	JRST CHKCR
	MOVSI C,R1416
	JRST CPOPJ1

CHKCR:	CAIE C,12
	POPJ P,
	SETZ C,			;LET HIM CLEAR BITS
	JRST CPOPJ1

;TRANSPOSE ALL BODIES OF A CERTAIN NAME
TRANALL:
	MOVEI T,[ASCIZ/NAME OF BODY TO TRANSPOSE?/]
	PUSHJ P,BODYGT
	POPJ P,		;ALTMODE
	POPJ P,		;NULL
	JRST OOPS1
	PUSHJ P,GETLR
	JRST PERRET
	MOVEM A,DY1	;STUFF AWAY HERE FOR NOW
	SKIPN A,DBODPN
	POPJ P,		;NOTHING TO DO
TRANA1:	HLRZ T,(A)
	HRRZ T,1(T)
	CAMN T,DY1	;SAME BODY?
	PUSHJ P,GOTPOF	;YES
	HRRZ A,(A)
	JUMPN A,TRANA1
	POPJ P,
>;MD

BROT:	TRNE INMOV
	JRST [	MOVE A,CLOSES
		JRST BROTA]
	PUSHJ P,GETCLS
	JRST PERRET
BROTA:	HLRZ B,(A)
	HLRZ T,(B)
	ADDI T,1
MD,<	ANDI T,7	>
MPC,<	ANDI T,3	>
	HRLM T,(B)	;DON'T CLOBBER OTHER HALFWORD
	TRO MCHG
MD,<	HLRZ B,1(B)
	HRRZ B,(B)
	JUMPE B,BROTB
	MOVE F,BLCROT(T)	;GET PROPER ROTATION NUMBER FROM TABLE
	MOVE T,1(B)
	PUSHJ P,ORIENT
	MOVEM T,1(B)
BROTB:
>;MD
	PUSHJ P,BODFIX
MD,<	JRST STRAIGHTEN	;GO FIX THE WORLD NOW>
MPC,<	POPJ P,>

MD,<
BLCROT:	7	;7 - 0
	1	;0 - 1
	1	;1 - 2
	1	;2 - 3
	7	;3 - 4
	1	;4 - 5
	1	;5 - 6
	1	;6 - 7
>;MD

;CALL WITH POINTER TO BODY IN A
BODFIX:	MOVE D,1(A)
	HLRZ A,(A)
	HLRZ F,(A)
	JRST BODFX1

BODFX2:	HLRZ A,(B)
	HRRZ T,1(A)
	HRRZ T,(T)
	MOVE T,1(T)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,D)
MPC,<	MOVEM T,1(B)	>
MD,<	PUSH P,A
	PUSH P,F
	MOVE A,B		;POINTER TO POINT MUST BE IN A
	PUSHJ P,PMOVRL
	POP P,F
	POP P,A
>;MD
BODFX1:	HRRZ B,(A)
	JUMPN B,BODFX2
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;GET PIN #'S FROM DIP DEF FILE
MD,<
SETSEC:	PUSHJ P,GETCLS
	JRST PERRET
	PUSHJ P,GETDEF		;GET DEFINITION FROM DIPS.DIP
	POPJ P,			;LOSE
SECAGN:	TLNE M,DSKACT!MACACT
	JRST SETSCP
	OUTSTR[ASCIZ/SECTION # (0-/]
	HLRZ T,(H)		;GET # OF SECTIONS
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/)?/]
SETSCP:	PUSHJ P,READN
	CAIN C,ALTMOD
	POPJ P,			;LET HIM OUT ON ALTMODE
	CAIE C,12
	JRST [	PUSHJ P,INNERR
		JRST SECAGN]
;ENTER HERE WITH SEC# IN T AFTER HAVING CALLED GETDEF
SETSCN:	HLRZ TT,(H)
	CAMLE T,TT
	JRST [	OUTSTR[ASCIZ/SECTION # TOO LARGE!
/]
		JRST SECAGN]
	MOVE B,T		;SAVE SEC #
	MOVE A,TYPE
	JRST SETSC4

SETSC7:	HLRZ C,(A)
	HRRZ C,1(C)
	HRRZ T,(C)		;PIN TYPE BLOCK
	HLRZ T,(T)		;PIN ID
	HRRZ T,1(T)
	CAMLE T,1(H)		;NUMBER OF PINS ON DIP
	JRST [	OUTSTR[ASCIZ/PIN ID /]
		PUSHJ P,DECOUT
		OUTSTR[ASCIZ/ TOO LARGE FOR THIS DIP!
/]
		JRST SETSC4]
	HRRZ TTT,H		;PREPARE TO SEARCH DEF LIST
	MOVE TT,T
STSC10:	HRRZ TTT,(TTT)		;DEFINITION MAKER MADE SURE THERE WERE ENOUGH PINS
	SKIPN TTT
	PUSHJ P,FUCKUP
	SOJG TT,STSC10
	MOVE TTT,1(TTT)
	JUMPE TTT,[HRRM T,1(C)
		TRO MCHG
		TLNE M,DSKACT!MACACT
		JRST SETSC4
		OUTSTR[ASCIZ/PIN ID /]
		PUSHJ P,DECOUT
		OUTSTR[ASCIZ/, NO SECTION INFO, USING AS PIN #.
/]
		JRST SETSC4]
	MOVE T,TTT
	SETZ D,
	HRRZ E,(H)
SETSC5:	ADDI D,1
	CAME T,1(E)		;SAME PIN SECT #?
	JRST SETSC6		;NO
	MOVN TTT,B		;GET NEG OF DESIRED SECTION
	MOVSI TT,400000		;GET BIT FOR SECTION 0
	LSH TT,(TTT)		;POSITION TO CORRECT SECTION
	TDNE TT,(E)		;TEST FOR THAT SECTION ON THIS PIN
	JRST [	HRRM D,1(C)	;YES, STORE THIS PIN #
		TRO MCHG	;THIS CHANGES THINGS
		JRST SETSC4]	;TRY ANOTHER PIN
SETSC6:	HRRZ E,(E)
	JUMPN E,SETSC5
	OUTSTR[ASCIZ/PIN ID /]
	HRRZ T,(C)
	HLRZ T,(T)
	HRRZ T,1(T)
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/, NOT IN THIS SECTION.
/]
SETSC4:	HLRZ A,(A)
	HRRZ A,(A)
	JUMPN A,SETSC7
	POPJ P,

SKPBDY:	PUSHJ P,SKPBD2		;SKIP PROPERTIES
SKPBD1:	PUSHJ P,SKPSOM		;SKIP REG STUFF
	PUSHJ P,WORDIN		;SKIP SECTS,,SECT PIN #
	SOJG D,SKPBD1		;SKIP THEM ALL
	JRST SETSC1

SKPBD2:	PUSHJ P,SKPSTR		;SKIP A PROPERTY NAME
	CAIA
	JRST SKPBD2
	MOVEI A,1
SKPTRE:	PUSHJ P,SKPSTR
	JRST [	SOJG A,SKPTRE
		POPJ P,]
	PUSHJ P,WORDIN		;SKIP VALUE BITS
	AOJA A,SKPTRE

SKPSOM:	PUSHJ P,WORDIN		;BITS,,PS#
	PUSHJ P,WORDIN		;HI,,LOW LOADING
	JRST WORDIN		;USE

;CALL WITH BODY POINTER IN A
;SETS UP DIP DEF TABLE, SKIP RETURNS IF ALL OK
GETDEF:	MOVEM A,TYPE		;STORE BODY POINTER HERE
	PUSHJ P,FNDDIP
	JRST [	OUTSTR[ASCIZ/SORRY, NO DIP TYPE FOR THIS BODY!
/]
		POPJ P,]
	HLRZ A,(T)
	HRRZ T,(A)
	MOVEM T,TYPNAM		;SAVE NAME
	HLRZ A,(A)		;PROPERTY NAME
	HLRZ H,(A)		;DIP DEF LIST
	JUMPN H,CPOPJ1		;DEF ALREADY IN?
	MOVE H,A		;SAVE POINTER HERE
	MOVEM P,PERRSAV		;RETURN UP FROM HERE
	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		JRST SECLEV]
	MOVEI T,IOBUF		;USE COMPILED IN BUFFER
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVE T,['DIPS  ']
	MOVEM T,FILNAM
	MOVSI T,EXTDIP
	MOVEM T,FILEXT
	SETZB T,FILDAT
NODEC,<
NOSTAN,<
	DSKPPN T,		;TRY HIS PPN FIRST
	TLOA A,400000
>;NOSTAN
>;NODEC
DIPRD2:	MOVE T,LIBPPN
	MOVEM T,FILPPN
DIPRD:	TLNE M,DSKACT!MACACT
	JRST DIPRD1
	OUTSTR [ASCIZ/READING /]
	HRRI A,FILNAM
	JSR FPRINT
	OUTSTR[ASCIZ/
/]
DIPRD1:	MOVE T,FILPPN
	LOOKUP DAT,FILNAM
	JRST [	PUSHJ P,LOOKER
NODEC,<		TLZE A,400000		;WAS THIS LIBRARY?
		JRST DIPRD2		;NO, TRY LIBRARY
>;NODEC
		OUTSTR[ASCIZ/TRY ANOTHER DIP /]
		MOVSI T,EXTDIP
		PUSHJ P,SETNAM
		JRST SECLEV
		SETZ A,
		JRST DIPRD]
DEC,<	JSR DAT,LOOKCK	>
	MOVEM T,FILPPN
	PUSHJ P,WORDIN
	MOVN TTT,TTT
	CAIE TTT,DIPVER		;CORRECT VERSION?
	JRST [	OUTSTR[ASCIZ/WRONG VERSION DIP DEFINITION FILE.
/]
		JRST SECLEV]
SETSC1:	PUSHJ P,WORDIN
	JUMPE TTT,[OUTSTR[ASCIZ/NO SUCH DIP IN DEFINITION FILE!
/]
		JRST SECLEV]
	MOVE D,TTT		;SAVE # OF PINS HERE
	PUSHJ P,RSTR
	HRLM T,(P)
	MOVE A,T
	MOVE B,TYPNAM
	PUSHJ P,TXTMAT
	JRST SKPBDY		;NOT THE SAME SKIP THIS ONE
	GETFS(T)
	HRLM T,(H)
	SETZM (T)
	MOVEM D,1(T)
	MOVE H,T
	MOVE E,H
	PUSHJ P,SKPBD2
SETSC2:	PUSHJ P,SKPSOM		;SKIP BORING STUFF
	PUSHJ P,WORDIN
	GETFS(T)
	HRRM T,(E)
	MOVE E,T
	HRRZM TTT,1(E)		;STORE SECTION PIN # HERE
	HLLZM TTT,(E)		;STORE SECTION BITS HERE
	HLLZS TT,TTT
	SUBI TT,1
	XOR TT,TTT
	JFFO TT,SETSC8		;THIS FINDS RIGHTMOST BIT FROM TTT
	JRST SETSC3		;NO BITS

SETSC8:	HLRZ TT,(H)
	CAMLE TTT,TT
	HRLM TTT,(H)		;STORE MAX SO FAR!
SETSC3:	SOJG D,SETSC2
	RELEASE DAT,		;RELEASE DEF FILE
	JRST CPOPJ1		;GIVE WIN RETURN

SECLEV:	RELEASE DAT,
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;SET BODY LOCATION
BNUMS:	PUSHJ P,GETCLS
	JRST PERRET
MD,<	HRLM A,(P) >		;SAVE BODY POINTER HERE FOR GETDEF
	HLRZ A,(A)
	HLRZ A,1(A)		;POINTER TO DIP NUMBER BLOCK
	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
	TLNN M,DSKACT!MACACT
	OUTSTR @BODCUE
	PUSHJ P,GTSLTL
	JRST INNERR
	JRST [	CAIE C,12
		JRST INNERR
MPC,<		HLLZS (A)	;CLEAR THE LOC
		TRO MCHG
		POPJ P,	]
>;MPC
MD,<		HRRZ B,(A)		;GET OLD LOC BLOCK POINTER
		JUMPE B,CPOPJ
		HLLZS (A)
		MOVSI T,FIXLOC!FIXBLO
		ANDCAM T,1(A)
		TLNE M,BLOCS
		TRO MCHG
		HLRZ A,(B)
		FSTRET (A)
		FSTRET (B)
		TRNE TMOVE!LMOVE	;IF WE WERE MOVING OFFSET,
		TRZN INMOV		;THEN STOP AND FIND CLOSEST AGAIN
		POPJ P,
		TRO NEEDCL
		POPJ P,	]
MD,<	JFCL	>		;WE DON'T CARE IF THERE WAS A BRS OR NOT
	SETO T,			;ASSUME NO SEC STUFF
	CAIE C,"-"		;SETTING SECTION #?
	JRST SECNUM
	PUSHJ P,GETLIN		;YES, GET IT
	CAIL C,"A"
	CAILE C,"Z"
	JRST [	CAIL C,"0"	;ACCEPT NUMERIC SECTIONS TOO!
		CAILE C,"9"
		JRST INNERR
		PUSHJ P,CREADN
		JRST SECNUM ]
	MOVEI T,-"A"(C)
	PUSHJ P,GETLIN
SECNUM:	MOVEM T,NUMBER		;SAVE SECTION # HERE
	MOVE T,1(A)		;GET CURRENT BITS
	TLZ T,L1416!R1416	;TURN OFF THE OLD BITS
	CAIN C,"L"		;LEFT?
	TLO T,L1416		;YES, TURN ON BIT
	CAIN C,"R"		;RIGHT?
	TLO T,R1416		;YES, TURN ON BIT
	CAIE C,"*"		;NONE?
	TLNE T,L1416!R1416	;ANY BITS CHANGED?
	PUSHJ P,[MOVEM T,1(A)	;WE GOT A CHANGE: STORE IT
		JRST GETLIN]	;AND GET NEXT CHAR
>;MD
	CAIE C,12		;NOW IT MUST BE A LF
	JRST INNERR
MD,<	MOVE TT,LETTER
	TLNE TT,-1
	SKIPN T,CRDLOC
	JRST NOGLOB
	XOR T,TT
	TLNE T,-1
	JRST [	OUTSTR[ASCIZ/SORRY, CAN'T CHANGE CARD LOC WHILE GLOBAL CARD LOC IS IN FORCE!
/]
		JRST CHKSCN]	;GO CHECK SECTION ANYWAY
	HRRZS LETTER
NOGLOB:
>;MD
	MOVE T,LETTER
MPC,<	HRRM T,(A)		;STORE IT>
MD,<	HRRZ B,(A)
	JUMPN B,GTNMBK		;DO WE HAVE A BLOCK ALREADY?
	GETFS(B)
	GETFS(TT)
	HRLZM TT,(B)
	SETZM 1(TT)
	HRRM B,(A)		;LINK IN
DEC,<	MOVSI TT,FIXBLO
	IORM TT,1(A)
>;DEC
	HLRZ TT,(P)		;BODY POINTER
	HLRZ TT,(TT)		;BODY DATA BLOCK
	HLRZ F,(TT)		;ORIENTATION
	HRRZ TT,1(TT)		;TYPE POINTER
	PUSH P,T
	PUSHJ P,STLCOF
	POP P,T
GTNMBK:	HLRZ B,(B)
	MOVEM T,(B)
	HLRZ T,(P)		;SETUP T FOR OFFBLO
	PUSHJ P,OFFBLO		;CHECK FOR RECALC CHAR OFFSET
>;MD
	TLNE M,BLOCS
	TRO MCHG
MPC,<	POPJ P,	>
MD,<
CHKSCN:	SKIPGE NUMBER		;ANY SECTION #?
	POPJ P,
	HLRZ A,(P)		;GET BODY POINTER
	PUSHJ P,GETDEF
	POPJ P,			;LOSE
	MOVE T,NUMBER
	JRST SETSCN		;TRY TO SET SECTION!

OFFLOC:	SKIPN H,DBODPN
	POPJ P,
OFFLC1:	HLRZ A,(H)
	HRRZ TT,1(A)		;TYPE POINTER
	HLRZ F,(A)		;ORIENTATION
	HLRZ A,1(A)		;SECOND DATA BLOCK
	HRRZ B,(A)		;LOC BLOCK POINTER
	JUMPE B,OFFLC2		;ANY?
	PUSHJ P,STLCOF		;YES, SET TO FOLLOW DEFINITION
	MOVE T,H
	PUSHJ P,OFFBLO
OFFLC2:	HRRZ H,(H)
	JUMPN H,OFFLC1
	TLNE M,BLOCS
	TRO MCHG
	POPJ P,

;RESET LOCATION OFFSET OF CLOSEST BODY TO DEFAULT
BLCOFF:	PUSHJ P,GETCLS
	JRST PERRET
	HRLM A,(P)		;SAVE BODY HERE FOR OFFBLO
	HLRZ A,(A)
	HRRZ TT,1(A)		;TYPE POINTER
	HLRZ F,(A)		;ORIENTATION
	HLRZ A,1(A)		;SECOND DATA BLOCK
	HRRZ B,(A)		;LOC BLOCK POINTER
	JUMPE B,CPOPJ		;LEAVE IF NONE
	TLNE M,BLOCS
	TRO MCHG
	PUSHJ P,STLCOF		;SET OFFSET
	HLRZ T,(P)
	JRST OFFBLO

;CALL WITH -- TT:TYPE POINTER  A:BODY BIT BLOCK  B:LOC BLOCK F:BODY ORIENTATION
STLCOF:	HLRZ TT,1(TT)		;TYPE DATA BLOCK
	HLRZ TT,(TT)		;OFFSET BLOCK
	MOVE T,1(TT)		;DEFAULT OFFSET FROM DEF
	PUSHJ P,ORIENT		;ROTATE IT
	MOVEM T,1(B)		;SET IT
	MOVSI T,FIXLOC		;CONTINUE FIXING LOC OFFSET
	IORM T,1(A)
	POPJ P,
>;MD

STOBLC:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ D,(A)
	PUSHJ P,SETTT
	HLRZ D,1(D)
MD,<	HRRZ D,(D)
	JUMPE D,ITSTUF
	HLRZ D,(D)
>;MD
MPC,<	HRRZ T,(D)
	JUMPE T,ITSTUF
>;MPC
	PUSHJ P,STFBLC
	JRST ITSTUF

STFBLC:	PUSH P,A
	MOVS A,(D)
	PUSHJ P,SLTLPN
	POP P,A
	POPJ P,

MD,<
;RESET LOCATION OFFSET OF CLOSEST BODY TO DEFAULT
BLOOFF:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE T,A
	HLRZ A,(A)
	HLRZ A,1(A)		;SECOND DATA BLOCK
	HRRZ B,(A)		;LOC BLOCK POINTER
	JUMPE B,CPOPJ		;LEAVE IF NONE
	MOVSI TT,FIXBLO
	IORM TT,1(A)
;CALL WITH T:POINTER TO BODY
OFFBLO:	HLRZ A,(T)
	HLRZ A,1(A)
	HRRZ B,(A)
	HLRZ B,(B)
	HLL T,1(A)
	TLNN T,FIXBLO
	POPJ P,			;NOT BEING FIXED
	TLNE M,BLOCS
	TRO MCHG
	TLNN T,FIXLOC		;DON'T FOLLOW BODY DEF OFFSET UNLESS FOLLOWING BODY DEF LOC
	JRST OFFBL1
	HLRZ T,(T)
	HRRZ T,1(T)
	HLRZ T,1(T)
	HLRZ T,(T)
	HRRZ T,(T)
	JUMPE T,OFFBL1		;CHAR OFFSET IN DEF?
	MOVE T,1(T)		;YES, USE IT
	MOVEM T,1(B)
	POPJ P,

OFFBL1:	SETZM CHRCNT
	PUSH P,PUTCHR
	MOVE TTT,[AOS CHRCNT]
	MOVEM TTT,PUTCHR
	MOVS A,(B)
	PUSHJ P,SLTLPN
	POP P,PUTCHR
	MOVN A,CHRCNT
	IMULI A,CWIDTH
	IMUL A,CMUL+STDBIG
	ASH A,-1
	HRLZM A,1(B)		;X PART OF OFFSET
	MOVNI A,CHGHT
	IMUL A,CMUL+STDBIG
	ASH A,-1
	HRRM A,1(B)		;Y PART
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                         ;DELETE BODY
C2BDEL:	SETOM PINLEV
	PUSHJ P,GETCLS
	POPJ P,
	MOVE B,CLAST
	TRO NEEDCL
	JRST BCLR1

BODDEL:	PUSHJ P,GETCLS	;ANY TO DELETE?
	JRST PERRET	;NO
	MOVE B,CLAST
	TRO NEEDCL
BCLEAR:	SETZM PINLEV
BCLR1:	PUSH P,B	;SAVE LAST
	TRZE INMOV	;TURN OFF MOVING
	TRO NEEDCL
ROUTE,<MPC,<TLZ M,%ROUTE>>;MAKE HIM ROUTE AGAIN
	PUSHJ P,REMBOD	;REMOVE BODY FROM ANY SETS
	TRO TFLG!MCHG	;DELETE PINS
	PUSH P,A	;SAVE THIS
	HLRZ B,(A)
	HRRZ B,(B)
	SKIPN PINLEV	;LEAVING PINS AS POINTS?
	JRST BODDLD	;NO, DELETING
	JRST BODDL1

BODDL2:	HLRZ A,(B)
	HRRZ B,(A)
	AOS T,PID
	MOVEM T,(A)	;GET A PIN ID
	HRRZ T,1(A)
	HRLOI TT,MPC,<PLANES!>ISPIN
	ANDCAM TT,1(T)	;CLEAR ISPIN AND PADTYPE OR PIN#
	HLLZS (T)	;CLEAR TYPE BLOCK POINTER
BODDL1:	JUMPN B,BODDL2
BODDLE:	POP P,A		;HERE WE GIVE BACK THE BODY
	HRRZ F,(A)	;GET POINTER TO NEXT BODY
	POP P,B		;RESTORE LAST POINTER
	HRRM F,(B)	;LINK AROUND
	HLRZ B,(A)	;GET DATA BLOCK POINTER
	HLRZ C,1(B)	;BID BLOCK
	FSTRET (A)
	FSTRET (B)
MD,<	HRRZ D,(C)	;GET LOC POINTER(IF ANY)
	JUMPE D,NOLXY
	HLRZ B,(D)
	FSTRET (B)
	FSTRET (D)
NOLXY:	PUSHJ P,PRPRET
>;MD
	FSTRET (C)
	POPJ P,

BODDLD:	MOVEI B,PONPNT
	PUSHJ P,BODDLP	;DELETE ALL PINS WHICH POINT TO THIS BODY
MPC,<	MOVEI B,PONPN2
	PUSHJ P,BODDLP
>;MPC
	JRST BODDLE	;NOW GIVE BACK BODY

BODDLQ:	HLRZ T,(B)
	HLRZ T,(T)	;BODY POINTER
	CAME T,-1(P)	;THIS IS WHERE BODY POINTER WAS STORED
	JRST BODDLP	;TRY ANOTHER
	PUSH P,A	;SAVE LAST POINTER
	TRO TFLG	;ALLOW DELETE PIN
	PUSHJ P,DELPNT	;DELETE (CURRENT AND LAST ALREADY SETUP)
	POP P,B
BODDLP:	MOVE A,B	;SAVE LAST
	HRRZ B,(B)
	JUMPN B,BODDLQ
	POPJ P,

;CALL TO RETURN PROPERTY/TEXT LIST,
;3RD BODY CELL IN C

PRPRET:	HRRZ A,1(C)
	JUMPE A,CPOPJ
PRPR1:	HLRZ B,(A)
	JUMPE B,PRPR2
	HLRZ D,(B)
	PUSHJ P,PUTFS
	SKIPE B,D
	PUSHJ P,PUTFS
PRPR2:	HRRZ A,(A)
	JUMPN A,PRPR1
	HRRZ B,1(C)
	HLLZS 1(C)
	JRST PUTFS
             ;BODREN
MD,<
BODREN:	MOVEI T,[ASCIZ/TYPE BODY NAME.
/]
	PUSHJ P,BODYGT
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	JRST OOPS1		;NX
	SKIPE MODLIB		;ALLOW MODIFICATION?
	JRST RENOK
	HLRZ T,(A)
	JUMPE T,RENOK
	OUTSTR[ASCIZ/CAN'T RENAME LIBRARY BODY!
/]
	POPJ P,

RENOK:	MOVEI T,[ASCIZ/TYPE NEW BODY NAME.
/]
	PUSH P,A
	PUSHJ P,BODYGT
	JRST RENOKB		;ALTMODE
	JRST RENOKB		;NULL
	JRST RENOKA		;NX
	OUTSTR[ASCIZ/NAME ALREADY IN USE!!!
/]
RENOKB:	POP P,(P)
	POPJ P,

RENOKA:	POP P,C
	MOVE D,B
	HRRZ B,(C)
	HLRZ T,(B)		;COPY DIPTYPE POINTER
	HRLM T,(D)
	PUSHJ P,PUTFS
	HRRM D,(C)
	TLNE M,%IDENT		;DISPLAYING NAMES?
	TRO MCHG		;YES, REFRESH
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;GET BODY
BODYGT:	TLNN M,DSKACT!MACACT
	OUTSTR (T)
	SETZ A,		;IN CASE NO NAME
	PUSHJ P,TREADU	;READ IN THE TEXT FOR THE BODY NAME
	POPJ P,		;ALTMODE
	JRST CPOPJ1	;NULL STRING
	AOS (P)
	AOS (P)		;AT LEAST 2 SKIPS
	MOVEI A,BODPNT-1;GET POINTER TO THE STRING OF BODIES
	JRST BLOP2

BLOP1:	PUSH P,A	;SAVE A
	PUSH P,B	;SAVE B
	HRRZ A,(A)	;GET POINTER TO STRING
	PUSHJ P,TXTMAT	;CHECK FOR TEXT MATCH
	JRST BLOP3	;NO MATCH
	POP P,B		;MATCH, RESTORE B
	POP P,A		;RESTORE A
	PUSHJ P,PUTFS	;RETURN STRING
	HLRZ T,1(A)
	JUMPE T,BDYGET	;GET BODY FROM LIBRARY IF NOT ALL IN
	HRRZ A,A	;CLEAR PREVIOUS LINK
	JRST CPOPJ1	;FOUND

BLOP3:	POP P,B		;YES, MATCH, RESTORE B
	POP P,A		;RESTORE A, THE POINTER TO THE FOUND BODY
BLOP2:	HRL A,A
	HRR A,1(A)	;GO TO NEXT BODY
	TRNE A,-1
	JRST BLOP1	;LOOP IF ANY LEFT TO COMPARE WITH
	POPJ P,		;ELSE LEAVE
>;MD
MPC,<
BODYGT:	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ /NO. OF PINS?
/]
	SETZ A,		;THIS IS "NO" ANSWER
	PUSHJ P,READN	;READ IN THE TEXT FOR THE BODY NAME
	CAIN C,ALTMOD
	POPJ P,
	JUMPE T,[	CAIN C,12		;JUST BLANK?
			JRST CPOPJ1		;LET HIM OUT
			CAIN C,"R"
			MOVEI T,=400/5
			CAIN C,"C"
			MOVEI T,=300/5
			CAIN C,"T"
			MOVEI T,3
			PUSHJ P,GETLIN
			CAIE C,12
			JRST INNERR
			JUMPE T,INNERR
			CAIE T,3		;3 PIN DIP?
			JRST IS2PIN		;NO, 2 PIN AND WE HAVE SEPERATION
			JRST BLOP0]
	CAIE C,12
	JRST INNERR
	CAIN T,2	;2 PIN DIP?
	JRST ASKWID
BLOP0:	MOVE A,BODPNT	;GET POINTER TO THE STRING OF BODIES
	AOS (P)
	AOS (P)
BLOP1:	JUMPE A,CPOPJ	;DOESN'T EXIST
	HLRZ TT,(A)
	CAIN TT,(T)
	JRST CPOPJ1	;EXISTS
	HRRZ A,(A)
	JRST BLOP1

ASKWID:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PIN SEPERATION IN MILS (DIVISIBLE BY 10)?/]
	PUSHJ P,READNC
	IDIVI T,=10
	JUMPE T,INNERR
	JUMPN TT,INNERR
	ASH T,1
IS2PIN:	AOS (P)
	AOS (P)
	AOS (P)		;ALWAYS EXISTS
G2PIN:	SKIPN A,BODPNT
	JRST MAKE2D
B2LOP:	HLRZ TT,(A)
	CAIE TT,2
	JRST B2LOP1
	HRRZ TT,1(A)
	HRRE TT,1(TT)
	CAIN TT,(T)
	POPJ P,
B2LOP1:	HRRZ A,(A)
	JUMPN A,B2LOP
MAKE2D:	GETFS(A)
	MOVSI TT,2
	HRR TT,BODPNT
	MOVEM TT,(A)
	MOVEM A,BODPNT
	GETFS(TT)
	HRRZM T,1(TT)
	HRRZM TT,1(A)
	GETFS(TTT)
	HRLI TTT,1
	MOVEM TTT,(TT)
	MOVSI TT,2
	MOVEM TT,(TTT)
	MOVN T,T
	HRRZM T,1(TTT)
	POPJ P,

;SET DIP TYPE
SETDIP:	PUSHJ P,GETCLS
	JRST PERRET
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE DIP TYPE
/]
	PUSHJ P,TREADU
	POPJ P,			;ALTMODE
	SETZ B,			;NULL
	TLNE M,%IDENT
	TRO MCHG
	HLRZ T,(A)
	HLRZ T,1(T)
	MOVE TT,B
	HRRZ B,1(T)		;PICK UP OLD
	HRRM TT,1(T)		;STORE NEW
	JUMPN B,PUTFS
	POPJ P,
>;MPC

OOPS1:	OUTSTR[ASCIZ/NO SUCH BODY, CHARLY
/]
MD,<	JRST PUTFS	;PUT NON-EX NAME BACK IN FREE STORAGE	>
MPC,<	POPJ P,							>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;ASSOCIATIVE BODY SET
ASSET:	PUSHJ P,GETCLS
	JRST PERRET
	TRZE INMOV
	TRO NEEDCL
	GETFS(T)		;MAKE A NEW SET
	HRLZM A,1(T)		;STARTING WITH THIS BODY
	SETZM (T)
	GETFS(TT)
	HRLM T,(TT)
	SETZM 1(TT)
	EXCH TT,SETPNT
	HRRM TT,@SETPNT
	MOVE H,T
	HLRZ A,(A)
	JRST ASSET1

ASSET2:	HLRZ A,(A)
	HLRZ B,1(A)
MD,<	HLRZ C,(B)
	PUSHJ P,ASSPUT
	HRRZ C,(B)
	PUSHJ P,ASSPUT
	HLRZ C,1(B)
	PUSHJ P,ASSPUT
	HRRZ C,1(B)
	PUSHJ P,ASSPUT
>;MD
MPC,<	JUMPE B,ASSET1
ASSET3:	MOVEI D,2
ASSET4:	XCT (D)[HLRZ C,(B)
		HRRZ C,1(B)
		HLRZ C,1(B)]
	PUSHJ P,ASSPUT
	SOJGE D,ASSET4
	HRRZ B,(B)
	JUMPN B,ASSET3
>;MPC
ASSET1:	HRRZ A,(A)
	JUMPN A,ASSET2
	MOVEI T,SETM
	PUSHJ P,CHNGMD		;GO INTO SET MODE
	MOVE A,SETPNT
	PUSHJ P,RECNTR		;CALC CENTER
	MOVE A,SETPNT
	MOVE T,1(A)		;LOC OF CENTER
	JRST CHKON

ASSPUT:	JUMPE C,CPOPJ
	HLRZ T,(C)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNE T,MPC,<CPIN!>ISPIN
	POPJ P,
	MOVE T,H
ASSPT1:	HRRZ TT,1(T)
	JUMPE TT,ASSPT2
	CAMN TT,C
	POPJ P,			;ALREADY IN, SKIP IT
	MOVE TT,T
	HRRZ T,(T)
	JUMPN T,ASSPT1
	GETFS(T)
	HRRM T,(TT)
	SETZM (T)
	SETZM 1(T)
ASSPT2:	HRRM C,1(T)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 COMMENT    VALID 00007 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(BTEXT,2)
C00007 00003	EDIT MODE TEXT AND PROPERTY PLACEMENT
C00014 00004	PRINT ALL PROPERTIES FOR THIS BODY OR BODY DEF
C00017 00005	LINE EDIT TEXT
C00019 00006	TEXT, KILL
C00024 00007	ALL NEW BODY/BODY DEF PROPERTY/TEXT ROUTINES.
C00034 ENDMK
C;
                                                                                                                                                                                                                                                                                                   VERSION(BTEXT,2)
MD,<
;BODY TEXT MODE TEXT AND PROPERTY PLACEMENT
ENTBTB:	MOVE A,BTBODY
	HLRZ A,(A)
	HRRZ A,1(A)
	JRST ALREAD		;ENTER EDITOR ON THIS BODY

ENTBTM:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,BTBODY
	MOVEI T,BTXTM
	JRST CHNGMD

BTXPLB:	PUSHJ P,GETCLS
	JRST PERRET
	CAIA
BTXPLC:	MOVE A,BTBODY
	SETZM BTEXT
	PUSHJ P,BTXPUT
	JFCL
	HRRZ TT,(E)
	HLRZ T,(TT)
	JUMPN T,CPOPJ
	MOVEI T,STDBIG
	HRLM T,(TT)
	POPJ P,

BTXPRB:	PUSHJ P,GETCLS
	JRST PERRET
	CAIA
BTXPRP:	MOVE A,BTBODY
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PROPERTY NAME?
/]
	PUSHJ P,TREADU
	POPJ P,
	POPJ P,
	MOVE T,B
	PUSHJ P,BFPROP
	JRST BTXPNW
	TROA TFLG		;REMEMBER FOUND IN BODY DEF
	TRZ TFLG		;REMEMBER FOUND IN BODY
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/OLD PROPERTY, NEW TEXT?
/]
BTXPR1:	MOVE E,T		;SAVE POINTER TO BLOCK
	PUSHJ P,TXREAD
	CAIE C,ALTMOD
	SKIPN 1(B)
	JRST PUTFS
	PUSH P,TT
	PUSH P,T
	TRNE TFLG		;DID WE FIND IN BODY OR BODY DEF?
	PUSHJ P,COPLTP		;COPY TEXT AND PROPERTIES INTO INDIRECT LIST
	POP P,T
	MOVE A,E		;IF COPLTP CALLED, E SET TO INDIRECT POINTER BLOCK
	HLRZ E,(A)
	JUMPN E,BTXPR2
	HRRZ TT,1(A)
	GETFS(E)
	HRLM E,(A)
	MOVE TTT,1(TT)
	MOVEM TTT,1(A)
	HLRZ TT,(TT)
	MOVE TTT,1(TT)
	MOVEM TTT,1(E)
	PUSH P,B
	PUSH P,T
	HLRZ T,(TT)		;GET PROPERTY NAME
	PUSHJ P,LSTCOP
	HRLZM B,(E)
	POP P,T
	POP P,B
	SKIPGE T
	MOVEI T,STDBIG
BTXPR2:	TRO MCHG!NEEDCL
	HRRZ TT,(E)
	SKIPGE T
	HLRZ T,(TT)
	HRLM T,(B)
	HRRM B,(E)
	SKIPE B,TT
	PUSHJ P,PUTFS
	HLRZ TT,(E)
	HLRZ B,(TT)
	HRRZS (TT)
	SKIPE B
	PUSHJ P,PUTFS		;GIVE BACK DIP DEF LIST
	POP P,TT
	MOVE T,1(A)
	TRNN T,1
	POPJ P,			;NO AUTO OFFSET
	JRST EDTCEN		;GO CENTER IT

BTXPNW:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW PROPERTY, /]
	MOVEM T,BTEXT
	PUSHJ P,BTXPUT
	SKIPA B,BTEXT		;LOSE, MUST GIVE BACK PROPERTY NAME
	POPJ P,			;WIN, RETURN
	JRST PUTFS

;CALL WITH BODY POINTER IN A
BTXPUT:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TEXT?
/]
	PUSHJ P,TXREAD
	CAIE C,ALTMOD
	SKIPN 1(B)
	JRST PUTFS
	TRO MCHG!NEEDCL
	GETFS(C)
	PUSH P,T
	MOVE T,CURSE
	ADJUST(SUB,T,<1(A)>)
	PUSH P,F
	HLRZ E,(A)
	HLRZ F,(E)
	MOVE F,UNROT(F)
	PUSHJ P,ORIENT
	POP P,F
	TRO T,1			;AUTO OFFSET INITIALLY
	MOVEM T,1(C)
	HLRZ E,1(E)
	PUSH P,TT
	HRRZ TT,1(E)
	SKIPN TT
	PUSHJ P,COPLTP		;COPY BODY DEF TEXT/PROPERTIES INTO INDIRECT LIST
	POP P,TT
	POP P,T
	HRRZ D,1(E)
	HRRM C,1(E)
	HRRM D,(C)
	JRST BTXIN8

BTCPRB:	PUSHJ P,GETCLS
	JRST PERRET
	CAIA
BTCPRP:	MOVE A,BTBODY
	HLRZ TTT,(A)
	HLRZ TTT,1(TTT)
	HRRZ TTT,1(TTT)
	JUMPE TTT,BTCPR1
	PUSHJ P,BFCPRP
	POPJ P,
	TRZ TFLG		;FOUND IN BODY
BTCPR2:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW TEXT?
/]
	JRST BTXPR1

BTCPR1:	HLRZ TTT,(A)
	HRRZ TTT,1(TTT)
	HLRZ TTT,1(TTT)
	HLRZ TTT,1(TTT)
	PUSHJ P,BFCPRP
	POPJ P,
	TRO TFLG
	JRST BTCPR2
                                                                                                                                                                                                                                                                                                                                                                                      ;EDIT MODE TEXT AND PROPERTY PLACEMENT
EDTXT:	SETZM BTEXT
	PUSHJ P,EDTPUT
	POPJ P,			;DON'T DIDLE SIZE IF NO CHANGE
	HRRZ TT,(E)
	HLRZ T,(TT)
	JUMPN T,CPOPJ		;ZERO SIZE?
	MOVEI T,STDBIG		;YES, NOT ALLOWED, USE STANDARD
	HRLM T,(TT)
	POPJ P,

EDTPRP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PROPERTY NAME?
/]
	PUSHJ P,TREADU
	POPJ P,
	POPJ P,
	MOVE T,B
	MOVE A,CURBOD
	PUSHJ P,FPROP
	JRST EDTPNW
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/OLD PROPERTY, NEW TEXT?
/]
EDTPR1:	MOVE A,T
	PUSHJ P,TXREAD
	CAIE C,ALTMOD
	SKIPN 1(B)
	JRST PUTFS
	PUSH P,TT
	TRO MCHG!NEEDCL
	HLRZ E,(A)
	HRRZ TT,(E)
	SKIPGE T
	HLRZ T,(TT)		;IF NO SIZE TYPED, COPY OLD
	HRLM T,(B)
	HRRM B,(E)
	MOVE B,TT
	PUSHJ P,PUTFS
	HLRZ TT,(E)
	HLRZ B,(TT)
	HRRZS (TT)
	SKIPE B
	PUSHJ P,PUTFS
	POP P,TT
	MOVE T,1(A)
	TRNN T,1		;AUTO OFFSET?
	POPJ P,			;NO
	JRST EDTCEN

EDTPNW:	MOVEM T,BTEXT
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW PROPERTY, /]
	PUSHJ P,EDTPUT
	SKIPA B,BTEXT		;HE QUIT, GIVE BACK STRING
	POPJ P,			;ALL OK
	JRST PUTFS

EDTPUT:	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ /TEXT?
/]
	PUSHJ P,TXREAD	;READ TEXT
	CAIE C,ALTMOD	;IF ALTMODE TYPED,
	SKIPN 1(B)	;OR NULL TEXT
	JRST PUTFS	;JUST RETURN FREE STORAGE
	TRO MCHG!NEEDCL
	MOVE A,CURBOD	;GET POINTER TO CURRENT BODY
	HLRZ A,1(A)	;GET POINTER TO DATA BLOCK
	GETFS (C)
	SKIPN D,DBODPN
	JRST BTXIN9	;NO BODIES TO INSERT INTO
BTXINS:	HLRZ E,(D)
	HRRZ TTT,1(E)
	CAME TTT,CURBOD	;THIS BODY OF OUR TYPE?
	JRST BTXIN1	;NO
	HLRZ E,1(E)	;YES
	HRL E,1(E)	;GET CURRENT POINTER
	TLNN E,-1	;IS THERE ONE
	JRST BTXIN1	;NO, DON'T HAVE TO ADD TO IT
	SKIPN BTEXT	;IS THIS A PROPERTY?
	JRST BTXIN2	;NO, INSERT INDIRECT POINTER
	PUSH P,T
	MOVE T,BTEXT	;NAME OF PROPERTY
	HLRZ TTT,E	;BODY PROPERTY LIST
	PUSHJ P,FPROPX	;SEE IF BODY ALREADY HAS THIS PROPERTY
	JRST [	POP P,T
		JRST BTXIN2]	;BODY DOESN'T HAVE IT, ADD IT
	POP P,T
	JRST BTXIN1	;BODY ALREADY HAS ONE, DON'T ADD IT

BTXIN2:	GETFS(TTT)
	HRRZM C,1(TTT)
	HLRZM E,(TTT)
	HRRM TTT,1(E)
BTXIN1:	HRRZ D,(D)	;NEXT BODY
	JUMPN D,BTXINS
BTXIN9:	MOVE D,CURSE	;GET CURRENT POSITION
	TRO D,1		;SET AUTO OFFSET BIT
	TLZ D,1		;CLEAR MARK BIT
	MOVEM D,1(C)	;DEPOSIT AS X,Y
	HLRZ D,1(A)	;GET TEXT POINTER
	MOVEM D,(C)	;LINK IN NEW BLOCK...
	HRLM C,1(A)	;...
BTXIN8:	GETFS (E)
	HRLM E,(C)	;DEPOSIT POINTER TO TEXT DATA BLOCK
	HRRZM B,(E)	;DEPOSIT POINTER TO TEXT
	SKIPGE T	;IF NO SIZE TYPED,
	MOVEI T,STDBIG	;USE STANDARD
	HRLM T,(B)	;DEPOSIT CHR SIZE IN FIRST BLOCK OF TEXT
	MOVE T,BTEXT	;GET PROPERTY NAME
	HRLM T,(E)	;AND SAVE
	AOS (P)		;SKIP TO INDICATE SUCCESS, AND FALL INTO EDTCEN
EDTCEN:	TRO MCHG
	HRRZ T,(E)
	HLRZ T,(T)
	SKIPN T
	MOVEI T,STDBIG
	PUSH P,T
	ANDI T,377777	;REMOVE VERT BIT
	HLRZ TTT,TT	;GET # LINES-1
	ANDI TT,-1	;GET # CHARS
	IMUL TT,CMUL(T)
	IMULI TT,CWIDTH
	ASH TT,-1	;ONLY HALF FOR OFFSET
	MOVNS TT
	HRLM TT,1(E)	;X PART
	SUBI TTT,1
	IMUL TTT,CMUL(T)
	IMULI TTT,CHGHT
	ASH TTT,-1
	HRRM TTT,1(E)	;Y OF CONSTANT OFFSET
	POP P,T
	TRNN T,400000	;VERT?
	POPJ P,
	MOVEI F,1	;YES 90 DEGREES CCW
	MOVE T,1(E)
	PUSHJ P,ORIENT
	MOVEM T,1(E)
	POPJ P,

BTXTZ:
EDTTZ:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEI T,1
	IORM T,1(A)		;TURN ON AUTO OFFSET BIT
EDTTZA:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[1EDTTM!1BTXTM]
	TRNN TMOVE
	JRST EDTTZ2
	CAME A,CLOSES
	JRST EDTTZ2
	TRZE INMOV
	TRO NEEDCL
EDTTZ2:	HLRZ E,(A)
	HRRZ T,(E)
	ADD T,[POINT 7,1]
	SETZB TT,TTT
EDTTZ1:	PUSHJ P,GETTT
	JRST [	CAILE TTT,(TT)
		HRR TT,TTT
		JRST EDTCEN]
	CAIE C,""
	AOJA TTT,EDTTZ1
	ADD TT,[1,,0]
	CAILE TTT,(TT)
	HRR TT,TTT
	SETZ TTT,
	JRST EDTTZ1

;$$Y IN EDIT MODES
EDCPRP:	MOVE TTT,CURBOD
	HLRZ TTT,1(TTT)
	HLRZ TTT,1(TTT)
	PUSHJ P,BFCPRP
	POPJ P,
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW TEXT?
/]
	JRST EDTPR1

EDTENT:	MOVEI T,EDTTM
	JRST CHNGMD

STOBTP:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HLRZ T,(T)
	PUSHJ P,SETTT
	JUMPE T,ITSTUF
	JRST STOTX0

STOBTX:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HRRZ T,(T)
	JRST STOTXB		;CALL ROUTINE FOR POINT TEXT
                                                                                                                                                                                                                                                                                                                                                                                                                             ;PRINT ALL PROPERTIES FOR THIS BODY OR BODY DEF
LPROPS:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ALLEDM!1EDTAM]
	JRST EDTLPR
	TDNE T,[1BTXTM]
	JRST [	MOVE A,BTBODY
		JRST BTXLPR]
	TDNN T,[1BODM]
	JRST PERRET
	PUSHJ P,GETCLS
	JRST PERRET
BTXLPR:	MOVE H,A
	HLRZ G,(H)
	HLRZ G,1(G)
	HRRZ G,1(G)
	JUMPE G,[OUTSTR[ASCIZ/
NO LOCAL BODY PROPERTIES.
/]
		JRST BTSLPE]
	OUTSTR[ASCIZ/
LOCAL BODY PROPERTIES:
* INDICATES PROPERTY FROM BODY DEF.
/]
	PUSHJ P,LPROPL	;LIST PROPERTY LIST
BTSLPE:	HLRZ H,(H)
	HRRZ H,1(H)
	CAIA
EDTLPR:	MOVE H,CURBOD		;LIST BODY DEF PROPERTIES
	OUTSTR[ASCIZ/
BODY NAME: /]
	HRRZ T,(H)		;BODY NAME
	PUSHJ P,OUTTXT
	HLRZ G,1(H)
	HLRZ G,1(G)
	JUMPE G,[OUTSTR[ASCIZ/
NO BODY DEFINITION PROPERTIES.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
BODY DEFINITION PROPERTIES:
/]
LPROPL:	OUTSTR[ASCIZ/! INDICATES INVISIBLE PROPERTY.
/]
LPROP0:	MOVEI C," "		;ASSUME LOCAL
	HLRZ B,(G)
	JUMPN B,LPROP1
	MOVEI C,"*"		;INDIRECT
	HRRZ B,1(G)
	HLRZ B,(B)
LPROP1:	HLRZ T,(B)		;PROPERTY NAME
	JUMPE T,LPROP2		;SKIP TEXT
	OUTCHR C
	HRRZ A,(B)
	HLRZ A,(A)
	SKIPN A
	OUTCHR["!"]
	SKIPE A
	OUTCHR[" "]
	PUSHJ P,OUTTXT		;TYPE PROPERTY NAME
	OUTCHR[":"]
	HRRZ T,(B)
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/
/]
LPROP2:	HRRZ G,(G)
	JUMPN G,LPROP0
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;LINE EDIT TEXT
STANFO,<
LODTPN:	HLRZ T,(A)	;POINTER TO REL VEC WORD
	HRRZ T,(T)	;POINTER TO STRING
	PUSHJ P,LODED	;LOAD IT
	POPJ P,

TPNTQ:	PUSHJ P,TPNTQA
	POPJ P,
	JRST EDTDL1

BTPNTQ:	PUSHJ P,TPNTQA
	POPJ P,
	JRST BTXDL0

TPNTQA:	PUSHJ P,GETCLS
	JRST PERRET		;NONE
	PUSHJ P,LODTPN
	JRST TPNTZ1

TPNTZ:	PUSHJ P,TPNTZA
	POPJ P,
	JRST EDTDL1

BTPNTZ:	PUSHJ P,TPNTZA
	POPJ P,
	JRST BTXDL0

TPNTZA:	PUSHJ P,GETCLS
	JRST PERRET
	PUSHJ P,LODTPN	;LOAD IT
	PTWRS9	[0
		[BYTE(9)271,271,271,377,0]]	;CTRL1 999 BACKSPACE
TPNTZ1:	PUSHJ P,TXREAD	;READ TEXT BACK
	CAIN C,ALTMOD
	JRST PUTFS	;NO CHANGE
	SKIPN 1(B)
	JRST [	PUSHJ P,PUTFS
		JRST CPOPJ1]
	HLRZ E,(A)
	HLRZ TT,(E)
	JUMPN TT,ZSIZOK
	SKIPN T
	MOVEI T,STDBIG		;IF TEXT ONLY, MUST HAVE SIZE
ZSIZOK:	SKIPGE T
	MOVEI T,STDBIG	;NO SIZE, USE STANDARD
	HRLM T,(B)	;STO SIZE
	HRRZ T,(E)
	HRRM B,(E)
	MOVE B,T
	PUSHJ P,PUTFS
	TRO MCHG
	MOVE T,1(E)
	TRNN T,1		;AUTO OFFSET?
	POPJ P,			;NO
	JRST EDTCEN		;TT STILL SETUP FROM TXREAD
>;STANFO
                                                                                                                                                                                                                                                     ;TEXT, KILL

;KILL (STOP DISPLAYING)
EDTKIL:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG!NEEDCL
	TRZ INMOV
	HLRZ T,(A)
	HLRZ TT,(T)
	JUMPE TT,EDTDL1
	HRRZ T,(T)
	HRRZS (T)		;0 CHAR SIZE = NO DISPLAY
	POPJ P,

;DELETE
EDTDEL:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG!NEEDCL
	TRZ INMOV
EDTDL1:	MOVEI B,DBODPN
FBT1:	PUSHJ P,FBTPTR
	JRST EDTDL2
	HRRZ T,(D)
	HRRM T,(C)
	FSTRET(D)
	JRST FBT1

EDTDL2:	HLRZ C,(A)
	HLRZ C,(C)
	JUMPE C,EDTDL3
	HLRZ B,(C)
	SKIPE B
	PUSHJ P,PUTFS
	MOVE B,C
	PUSHJ P,PUTFS
EDTDL3:	MOVE C,CURBOD	;GET POINTER TO TYPE
	HLRZ C,1(C)	;GET POINTER TO POINTER BLOCK
	HLRZ B,1(C)	;GET POINTER TO TEXT
	CAMN B,A	;IS IT THE FIRST ONE?
	JRST EDTKP1	;YES
EDTKP2:	MOVE C,B
	HRRZ B,(C)	;NO, GET POINTER TO NEXT
	CAME B,A	;IS THIS IT?
	JRST EDTKP2	;LOOP
	HRRZ TT,(B)	;GET POINTER TO NEXT
	HRRM TT,(C)	;DEPOSIT POINTER AROUND STUFF TO BE DELETED
	MOVSS (B)	;PREPARE TO PUT IT BACK ON FREE STORAGE
	JRST PUTFS

EDTKP1:	HRRZ TT,(B)	;GET POINTER TO NEXT
	HRLM TT,1(C)	;DEPOSIT POINTER AROUND
	MOVSS (B)	;PREPARE TO PUT IT BACK ON FREE STORAGE
	JRST PUTFS

BTXKIL:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG!NEEDCL
	TRZ INMOV
	HLRZ T,(A)
	HLRZ TT,(T)
	JUMPE TT,BTXDL0
	HRRZ T,(T)
	HRRZS (T)
	POPJ P,

BTXUKL:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HRRZ T,(T)
	HLRZ TT,(T)		;GET SIZE
	JUMPN TT,[TLNN M,DSKACT!MACACT
		OUTSTR[ASCIZ/ALREADY VISIBLE.
/]
		POPJ P,]
	MOVEI TT,STDBIG		;SET SIZE TO STANDARD
	HRLM TT,(T)
	POPJ P,			;THIS SHOULDN'T CHANGE PICTURE

BTXDEL:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG!NEEDCL
BTXDL0:	HRL A,CLAST
BTXDL1:	HLRZ C,(A)
	HLRZ T,(C)
	JUMPE T,BTXDL2		;IF ONLY TEXT, JUST FLUSH IT
	PUSH P,A
	MOVE A,BTBODY
	HLRZ A,(A)
	HRRZ A,1(A)
	PUSHJ P,FPROP0		;LOOK FOR THIS PROPERTY IN BODY DEF
	JRST [	POP P,A
		JRST BTXDL2]	;NOT IN DEF, JUST DELETE
	POP P,A
	MOVEM T,1(A)		;STORE INDIRECT POINTER TO IT
	HRRZS (A)		;AND CLEAR POINTER
	JRST BTXDL3		;GIVE BACK AND CHECK FOR EMPTY LIST

BTXDL2:	HLRZ B,A
	HRRZ T,(A)
	HRRM T,(B)		;LINK US OUT
	FSTRET(A)
BTXDL3:	HLRZ A,(C)
	JUMPE A,BTXDL5
	HLRZ B,(A)
	SKIPE B
	PUSHJ P,PUTFS
	MOVE B,A
	PUSHJ P,PUTFS
BTXDL5:	MOVE B,C
	PUSHJ P,PUTFS
	MOVE A,BTBODY
	HLRZ A,(A)
	HLRZ A,1(A)
	HRRZ B,1(A)
	JUMPE B,CPOPJ		;LEAVE IF NONE NOW
BTXDL4:	HLRZ T,(B)
	JUMPN T,CPOPJ		;LEAVE IF NON INDIRECT POINTER STILL IN LIST
	HRRZ B,(B)
	JUMPN B,BTXDL4		;CHECK THEM ALL
	HRRZ B,1(A)
	HLLZS 1(A)
	JRST PUTFS		;GIVE BACK INDIRECT LIST

;$$D DELETE PROPERTY NAME
BTNPRP:
EDNPRP:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HLRZ B,(T)
	JUMPE B,PERRET		;NO PROPERTY NAME, LOSE
	HRRZS T,(T)
	HLRZ TT,(T)
	JUMPN TT,PUTFS
	MOVEI TT,STDBIG
	HRLM TT,(T)
	JRST PUTFS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;ALL NEW BODY/BODY DEF PROPERTY/TEXT ROUTINES.

;FPROP - FIND BODY DEF PROPERTY
;STRING PROPERTY NAME IN T (RETURNED TO FS IF FOUND)
;BODY DEF POINTER IN A
;SKIP RETURNS WITH PROPERTY BLOCK POINTER IN T

FPROP:	PUSHJ P,FPROP0
	POPJ P,
	PUSH P,T
	EXCH B,TTT
	PUSHJ P,PUTFS
	MOVE B,TTT
	POP P,T
	JRST CPOPJ1

;FPROPX - FIND PROPERTY NAME IN LIST SUPPLIED
;BODY OR BODY DEF PROPERTY LIST POINTER IN TTT
;STRING PROPERTY NAME IN T
;SKIP RESTURNS WITH PROPERTY BLOCK IN T (TTT NOW CONTAINS STRING POINTER)

FPROP0:	HLRZ TTT,1(A)
	HLRZ TTT,1(TTT)
	JUMPE TTT,CPOPJ
FPROPX:	PUSH P,A
	PUSH P,B
	PUSH P,T
FPROP1:	HLRZ B,(TTT)
	JUMPN B,FPROP3
	HRRZ B,1(TTT)
	HLRZ B,(B)
FPROP3:	HLRZ B,(B)
	JUMPE B,FPROP2
	MOVE A,(P)
	PUSHJ P,TXTMAT
	JRST FPROP2
	POP P,T
	POP P,B
	POP P,A
	EXCH T,TTT
	JRST CPOPJ1

FPROP2:	HRRZ TTT,(TTT)
	JUMPN TTT,FPROP1
	POP P,T
	POP P,B
	POP P,A
	POPJ P,

;FNDDIP - FIND DIP TYPE
;BODY POINTER IN A
;SKIP RETURNS WITH DIPTYPE BLOCK POINTER IN T

FNDDIP:	MOVEI TT,[ASCIZ/DIPTYPE/]
	PUSHJ P,ASCCOP
	PUSHJ P,BFPROP
	JRST [	PUSH P,B
		MOVE B,T
		PUSHJ P,PUTFS
		POP P,B
		POPJ P,]
	JRST CPOPJ1		;FOUND IN BODY DEF
	HLRZ TT,(T)		;FOUND IN BODY, CHECK FOR INDIRECT
	JUMPN TT,CPOPJ1
	HRRZ T,1(T)
	JRST CPOPJ1

;BFPROP - FIND PROPERTY FOR BODY
;BODY POINTER IN A
;STRING PROPERTY NAME IN T
;SKIP RETURNS WITH PROPERTY BLOCK POINTER IN T
;SKIPS 1 IF FOUND IN BODY DEF (NO INDIRECT LIST IN BODY)
;SKIPS 2 IF FOUND IN BODY (INDIRECT OR DIRECT)
;PROPERTY NAME STRING IS RETURNED TO FS IF FOUND

BFPROP:	HLRZ TTT,(A)
	HLRZ TTT,1(TTT)
	PUSH P,A
	HRRZ TTT,1(TTT)
	JUMPE TTT,BFPRP4
	PUSH P,B
	PUSH P,T
BFPRP2:	HLRZ B,(TTT)
	JUMPN B,BFPRP3
	HRRZ B,1(TTT)
	HLRZ B,(B)
BFPRP3:	HLRZ B,(B)
	JUMPE B,BFPRP1
	MOVE A,(P)
	PUSHJ P,TXTMAT
	JRST BFPRP1
	POP P,B
	PUSHJ P,PUTFS
	POP P,B
	POP P,A
	MOVE T,TTT
	JRST CPOPJ2

BFPRP1:	HRRZ TTT,(TTT)
	JUMPN TTT,BFPRP2
	POP P,T
	POP P,B
	POP P,A
	POPJ P,

BFPRP4:	HLRZ A,(A)
	HRRZ A,1(A)
	PUSHJ P,FPROP		;LOOK IN BODY DEF
	JRST [	POP P,A		;NOT FOUND
		POPJ P,]
	POP P,A
	JRST CPOPJ1

;BFCPRP - FIND BODY OR BODY DEF PROPERTY BY CLOSEST MATCH NAME
;POINTER TO PROPERTY LIST IN TTT
;RETURNS PROPERTY BLOCK OR INDIRECT POINTER IN T

BFCPRP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PROPERTY NAME (ENOUGH TO UNIQUELY SPECIFY IT)?
/]
	JUMPE TTT,[PUSHJ P,SCARF
		POPJ P,
		JRST NXPROP]
	PUSHJ P,TREADU
	POPJ P,
	JRST NXPROP
	PUSH P,A
	PUSH P,B
	TRZ TFLG		;NO MATCHS YET
EDCPR2:	HLRZ A,(TTT)
	JUMPN A,EDCPR4
	HRRZ A,1(TTT)
	HLRZ A,(A)
EDCPR4:	HLRZ A,(A)
	JUMPE A,EDCPR3
	MOVE B,(P)
	ADD A,[POINT 7,1]
	ADD B,[POINT 7,1]
EDCPR5:	PUSHJ P,BTGETB		;GET A MATCH CHARACTER
	JRST EDCPR6		;MATCH
	PUSHJ P,BTGETA		;GET A PROPERTY NAME CHARACTER
	JRST EDCPR3		;NO MATCH
	CAMN T,TT		;MATCH?
	JRST EDCPR5		;YES, LOOP
	JRST EDCPR3		;NO MATCH

EDCPR6:	MOVEM TTT,BTEXT		;SAVE MATCH HERE
	PUSHJ P,BTGETA		;GET ONE MORE CHAR OF PROPERTY NAME
	 JRST EXPRP1		;EXACT MATCH, WIN NOW
	TROE TFLG		;FLAG ONE FOUND, CHECK FOR MORE THAN ONE
	JRST AMBIGP		;AMBIGUOUS PROPERTY
EDCPR3:	HRRZ TTT,(TTT)
	JUMPN TTT,EDCPR2
	JRST EXPROP

EXPRP1:	TRO TFLG
EXPROP:	POP P,B
	PUSHJ P,PUTFS
	POP P,A
	MOVE T,BTEXT		;GET MATCH (IF ANY)
	TRNE TFLG		;WAS THERE A MATCH?
	JRST EDCPR7		;YES, PRINT NAME AND RETURN IT
NXPROP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SORRY, NO SUCH PROPERTY.
/]
	POPJ P,

EDCPR7:	TLNE M,DSKACT!MACACT
	JRST CPOPJ1
	PUSH P,T
	HLRZ TT,(T)
	JUMPN TT,EDCPR8
	HRRZ TT,1(T)
	HLRZ TT,(TT)
EDCPR8:	HLRZ T,(TT)
	PUSHJ P,OUTTCR
	POP P,T
	JRST CPOPJ1

AMBIGP:	POP P,B
	PUSHJ P,PUTFS
	POP P,A
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SORRY, AMBIGUOUS PROPERTY NAME.
/]
	POPJ P,

BTGETA:	TLNN A,760000
	JRST [	HRR A,-1(A)
		TRNN A,-1
		POPJ P,
		JRST .+1]
	ILDB T,A
	JUMPE T,CPOPJ
	JRST CPOPJ1

BTGETB:	TLNN B,760000
	JRST [	HRR B,-1(B)
		TRNN B,-1
		POPJ P,
		JRST .+1]
	ILDB TT,B
	JUMPE TT,CPOPJ
	JRST CPOPJ1

;MPROP - MAKE A PROPERTY BLOCK
;STRING PROPERTY NAME IN T
;BODY DEF POINTER IN A
;NEW BLOCK RETURNED IN T WITH NO VALUE STRING YET

MPROP:	GETFS(TT)
	MOVEI TTT,1
	MOVEM TTT,1(TT)		;INITIALIZE TO AUTO OFFSET
	GETFS(TTT)
	HRLM TTT,(TT)
	SETZM 1(TTT)
	HRLZM T,(TTT)
	HLRZ T,1(A)
	HLRZ TTT,1(T)
	HRRM TTT,(TT)
	HRLM TT,1(T)
	MOVE T,TT
	POPJ P,

;FBTPTR - FIND INSTANCE OF PROPERTY/TEXT INDIRECT POINTER GIVEN IN A
;LAST BODY FOUND IN B
;BODY DEF PROPERTY/TEXT BLOCK POINTER IN C
;SKIP RETURNS WITH NEW BODY IN B
;	POINTER TO INDIRECT BLOCK IN D, PREVIOUS IN C

FBTPT1:	HLRZ D,(B)
	HRRZ T,1(D)		;POINTER TO TYPE
	CAME T,CURBOD
	JRST FBTPTR
	HLRZ D,1(D)
	ADDI D,1		;ADDR OF PNTR TO BODY TEXT LIST
	JRST FBTPT3

FBTPT2:	HLRZ T,(D)		;SEE WHICH FORM IT IS.
	JUMPN T,FBTPT3		;IGNORE LOCAL BODY TEXT
	HRRZ T,1(D)		;SEE IF THIS USE OF THE TEXT FROM THE TYPE IS
	CAMN T,A		;THE ONE WE ARE LOOKING FOR.
	JRST CPOPJ1
FBTPT3:	MOVE C,D
	HRRZ D,(D)		;POINTER TO ENTRY ON BODY TEXT LIST
	JUMPN D,FBTPT2
FBTPTR:	HRRZ B,(B)
	JUMPN B,FBTPT1
	POPJ P,

;COPLTP - MAKE INDIRECT LIST TO BODY DEF TEXT/PROPERTIES
;BODY POINTER IN A
;IF E POINTS TO BODY DEF PROPERTY, IT IS CHANGED TO POINT TO INDIRECT BLOCK

COPLTP:	HLRZ T,(A)
	HRRZ TT,1(T)
	HLRZ TT,1(TT)
	HLRZ TT,1(TT)
	JUMPE TT,CPOPJ		;LEAVE IF NO BODY DEF LIST TO COPY
	HLRZ T,1(T)
	ADDI T,1		;POINT T TO NEW LISTHEAD
CPLTP1:	GETFS(TTT)
	HRRM TTT,(T)		;LINK IN INDIRECT BLOCK
	MOVE T,TTT		;GET NEW END OF LIST
	SETZM (TTT)		;CLEAR LINK OUT
	HRRZM TT,1(TTT)		;PUT IN INDIRECT POINTER
	CAMN E,TT		;DOES E POINT TO IT?
	MOVE E,TTT		;YES, POINT E TO INDIRECT BLOCK
	HRRZ TT,(TT)
	JUMPN TT,CPLTP1
	POPJ P,

;ASCCOP - MAKE INTERNAL FORMAT STRING FROM ASCIZ STRING
;ASCIZ STRING POINTER IN TT
;RETURNS INTERNAL FORMAT STRING POINTER IN T

ASCCOP:	GETFS(T)
	HRLM T,(P)
	JRST ASCCP2

ASCCP1:	GETFS(TTT)
	HRRZM TTT,(T)
	MOVE T,TTT
ASCCP2:	MOVE TTT,(TT)
	MOVEM TTT,1(T)
	TRNN TTT,376
	JRST ASCCP3
	SKIPE 1(TT)
	AOJA TT,ASCCP1
ASCCP3:	SETZM (T)
	HLRZ T,(P)
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                          COMMENT    VALID 00020 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	VERSION(SET,2)
C00005 00003	SROT, STTFND, STBFND
C00008 00004	STMNS:	TRZN STBOX		DRAWING A BOX?
C00010 00005	END NEW SET
C00012 00006	KILL ALL SETS -- CALLED FROM CLEAR
C00014 00007	DELETE CONTENTS OF CLOSEST SET
C00018 00008	APPEND STUFF TO "CURRENT" SET
C00022 00009	REMOVE POINT FROM CURRENT SET
C00025 00010	WRITE CLOSEST SET INTO FILE
C00026 00011	ASSOCIATIVE SET
C00030 00012	REMPNT, REMBOD, INBOX
C00035 00013	MD,<
C00039 00014	NOW COPY STUFF ONTO NEW POINTS AND BODIES
C00043 00015	DEFINE MAKSEG $ (LOSE,INDEX,GET,PUT)
C00044 00016	MPC,<
C00047 00017		MOVE H,NEWSET		NEW SET IN H
C00049 00018	COPPNT:	MOVEM C,NEWPNT		STORE NEW POINT POINTER HERE
C00053 00019	COPSDN:	GETFS(A)		POINTER BLOCK FOR SET
C00054 00020	STRCOP:	GETFS (B)		RETURN POINTER IN B
C00056 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                              VERSION(SET,2)
STRTBX:	GETFS(B)		;GET FIRST BLOCK FOR BOX
	EXCH B,SETBOX		;POINT TO IT
	JUMPE B,.+2
	PUSHJ P,PUTFS		;GIVE BACK OLD LIST
	MOVE T,CURSE		;GET CURSOR POSITION
	MOVE A,SETBOX
	MOVEM T,1(A)		;SAVE HERE
	SETZM (A)		;CLEAR LINK
	MOVEM A,ENDBOX		;POINTER TO END OF BOX
	TRO STBOX		;NOW WE ARE DRAWING A BOX
	TRZ ZIGZAG		;ZIG THIS WAY FIRST
	MOVEI T,BIGPG		;FLUSH BIG PHRAMUSES
	JRST HYDPOG

SETALT:	TRZE INMOV		;TURN OFF MOVING
	TRO NEEDCL
	TRZN STBOX		;ARE WE DOING A BOX?
	POPJ P,			;NO
	SKIPE B,SETBOX
	PUSHJ P,PUTFS
	SETZM SETBOX
	TRO NEEDCL
	MOVEI T,ANGLPG
	JRST HYDPOG

SPLUS:	TRZE INMOV
	TRO NEEDCL
	TRNN STBOX		;ARE WE DRAWING A SET BOX
	JRST STRTBX		;NO
	MOVE T,CURSE
FINBOX:	MOVE A,ENDBOX
	CAMN T,1(A)	;ON TOP OF THE PREVIOS CORNER>
	POPJ P,		;YES, IGNORE EXTRA "+"
	TRNE ZIGZAG	;UP THEN OVER?
	HLL T,1(A)	;USE X OF END POINT
	TRCN ZIGZAG	;OVER THEN UP?
	HRR T,1(A)	;USE Y OF END POINT
	GETFS(B)	;GET A BLOCK FOR END
	MOVEM T,1(B)
	SETZM (B)
	MOVEM B,(A)
	MOVEM B,ENDBOX
	POPJ P,

SSPACE:	TRNE STBOX		;DRAWING A BOX?
	TRC ZIGZAG		;YES, COMPLIMENT SENSE OF ZIG
	TRZE INMOV		;MOVING?
	TRO NEEDCL		;YES, FIND CLOSEST AGAIN
	POPJ P,			;NO, JUST RETURN
                                                               ;SROT, STTFND, STBFND
MPC,<
SROT:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG
	PUSH P,A
	PUSH P,1(A)	;CENTER OF SET
	HLRZ A,(A)	;POINTER TO SET LIST
SROT1:	HRRZ B,1(A)	;GET A POINT
	JUMPE B,NOROTP	;NONE
	MOVE T,1(B)	;LOC OF POINT
	ADJUST(SUB,T,<(P)>)	;OFFSET FROM CENTER OF SET
	XCT XTB1+1
	XCT XTB2+1
	XCT XTB3+1
	TLZ T,1
	ADJUST(ADD,T,<(P)>)	;PUT BACK OFFSET
	MOVEM T,1(B)	;PUT BACK X,Y
NOROTP:	HLRZ B,1(A)	;BODY
	JUMPE B,NOROTB	;NONE
	MOVE T,1(B)
	ADJUST(SUB,T,<(P)>)
	XCT XTB1+1
	XCT XTB2+1
	XCT XTB3+1
	TLZ T,1
	ADJUST(ADD,T,<(P)>)
	MOVEM T,1(B)
	HLRZ B,(B)
	HLRZ T,(B)		;PICK UP ROTATION
	ADDI T,1		;90 DEGREES LEFT
	ANDI T,3		;ONLY 4 STATES
	HRLM T,(B)		;AND PUT BACK
	PUSH P,A
	HLRZ A,1(A)		;GET POINTER TO BODY AGAIN
	PUSHJ P,BODFIX		;FIX POINTS
	POP P,A
NOROTB:	HRRZ A,(A)
	JUMPN A,SROT1
	POP P,(P)	;DON'T NEED TO REMEMBER WHERE SET IS ANY MORE
	POP P,A
;	JRST FEDFIX	;FIX FEED THROUGH'S

FEDFIX:	HLRZ A,(A)
FEDFX1:	HRRZ B,1(A)
	JUMPE B,FEDFX2
	HLRZ T,(B)
	HRRZ TT,1(T)
	MOVE TT,1(TT)	;GET BITS
	TLNN TT,FEEDTH	;FEED THROUGH?
	JRST FEDFX2	;NO
	HLRZ T,(T)	;GET ITS POINTER
	MOVE TT,1(B)	;COPY X,Y
	MOVEM TT,1(T)
FEDFX2:	HRRZ A,(A)
	JUMPN A,FEDFX1
	POPJ P,
>;MPC

STBFND:
STTFND:	OUTSTR[ASCIZ/NOT YET BOSS!
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           STMNS:	TRZN STBOX		;DRAWING A BOX?
	POPJ P,
	MOVE T,SETBOX
	MOVE T,1(T)		;X,Y OF START OF BOX
	PUSHJ P,FINBOX		;FINISH BOX AT END
	MOVE T,SETBOX
	MOVE T,1(T)
	PUSHJ P,FINBOX		;IT TAKES TWO
	MOVEI A,CLOSES		;START SET HERE
	SETZB H,CLOSES		;COLLECT SET IN CLOSES, X IN H
	SETZB F,E		;COLLECT Y IN F
	SKIPE B,PONPNT		;ON SCREEN POINTS
	PUSHJ P,CHKPNT
MPC,<
	TRNN BTHSDS
	JRST ONESID		;ONE SIDED SET
	SKIPE B,PONPN2
	PUSHJ P,CHKPNT
ONESID:
>;MPC
	JRST ENDPNT

CHKPNT:	HLRZ T,(B)	;PONTER TO DATA BLOCK
	HRRZ T,1(T)	;POINTER TO TEXT AND BODY(IF ANY)
	MOVE T,1(T)	;POINTER TO BODY
	TLNE T,MPC,<CPIN!>ISPIN
	JRST NOTINP	;IT'S A PIN IT GOES WITH THE BODY
	MOVE T,1(B)	;USE X,Y OF POINT
	PUSHJ P,INBOX	;IS IT IN SET
	JRST NOTINP	;NO
	GETFS(T)		;GET A BLOCK FOR POINT
	HRRZM B,1(T)		;PUT POINT IN SET
	SETZM (T)		;CLEAR LINK
	HRRZM T,(A)		;LINK ONTO END OF SET
	MOVE A,T		;NEW END
	HRRE T,1(B)
	ADD F,T
	HLRE T,1(B)
	ADD H,T
	ADDI E,1
NOTINP:	HRRZ B,(B)		;NEXT POINT
	JUMPN B,CHKPNT		;CHECK IT
	POPJ P,
                                                                                                                                                                                                                                                   ;END NEW SET
ENDPNT:	MOVEI A,CLOSES		;BACK TO THE BEGINNING
	MOVEI B,DBODPN		;NOW CHECK BODIES
	JRST NOTINB
CHKBOD:	MOVE T,1(B)		;LOC OF BODY
	PUSHJ P,INBOX		;IN BOX?
	JRST NOTINB		;NO
	HRRZ T,(A)		;NEED ANOTHER BLOCK?
	JUMPN T,NONEED		;NO
	GETFS(T)
	SETZM (T)
	SETZM 1(T)
	HRRZM T,(A)		;LINK ON END
NONEED:	HRRZ A,T		;NEW END
	HRLM B,1(A)		;PUT BODY IN SET
	HRRE T,1(B)
	ADD F,T
	HLRE T,1(B)
	ADD H,T
	ADDI E,1
NOTINB:	HRRZ B,(B)
	JUMPN B,CHKBOD
	SKIPE B,SETBOX
	PUSHJ P,PUTFS		;DON'T NEED BOX ANY MORE
	SETZM SETBOX
	MOVEI T,ANGLPG
	PUSHJ P,HYDPOG		;OR DRAWING OF IT
	SKIPN A,CLOSES		;DID WE MAKE A SET?
	POPJ P,			;NO
	GETFS(B)
	HRLZM A,(B)		;GIVE NEW SET A LIST POINTER AND X,Y
	MOVE A,SETPNT
	MOVEM B,SETPNT
	HRRM A,(B)		;LINK IN NEW SET
	MOVE T,F
	IDIV T,E		;AVERAGE OF Y VALUES
MD,<	TRZ T,1			;CLEAR LOW ORDER BIT
	HRRM T,1(B)
	MOVE T,H
	IDIV T,E		;AVERAGE OF X VALUES
	TRZ T,1			;CLEAR LOW ORDER BIT
>;MD
MPC,<
	ASH T,-1
	IDIV T,STPSIZ
	IMUL T,STPSIZ
	ASH T,1
	HRRM T,1(B)
	MOVE T,H
	IDIV T,E		;AVERAGE OF X VALUES
	ASH T,-1
	IDIV T,STPSIZ
	IMUL T,STPSIZ
	ASH T,1
>;MPC
	HRLM T,1(B)
	MOVE T,B
	JRST SCLOSP		;SET AS CLOSEST AND MOVE THERE
                                                                           ;KILL ALL SETS -- CALLED FROM CLEAR
SBLAST:	TRZ STBOX!INMOV
	TRO NEEDCL
SBLST1:	MOVEI B,SETPNT
	SKIPN A,SETPNT
	POPJ P,			;ALL GONE, DONE
	PUSHJ P,SCLEAR
	JRST SBLST1

;KILL ALL TEXT IN CLOSEST SET
STKILT:	TRNN STBOX
	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ A,(A)
STKIL1:	HLRZ D,1(A)		;BODY
	JUMPE D,STKIL4
	HLRZ D,(D)
	JRST STKIL2
STKIL3:	HLRZ D,(D)
	HRRZ C,1(D)
	HLRZ B,(C)
	JUMPE B,STKIL2
	HRRZS (C)
	TRO MCHG
	PUSHJ P,PUTFS
STKIL2:	HRRZ D,(D)
	JUMPN D,STKIL3
STKIL4:	HRRZ C,1(A)
	JUMPE C,NSTPNT
	HLRZ C,(C)
	HRRZ C,1(C)
	HLRZ B,(C)
	JUMPE B,NSTPNT
	HRRZS (C)
	TRO MCHG
	PUSHJ P,PUTFS
NSTPNT:	HRRZ A,(A)
	JUMPN A,STKIL1
	POPJ P,

;FLUSH THIS SET (LEAVE CONTENTS ALONE)
SETDEL:	TRNN STBOX	;DRAWING A BOX OR MOVEING
	PUSHJ P,GETCLS
	JRST PERRET
	TRZ INMOV
	TRO NEEDCL
	MOVE B,CLAST
SCLEAR:	HRRZ T,(A)
	HRRM T,(B)	;LINK SET OUT
	HLRZS (A)	;LINK UP SET FOR DELETION
	MOVE B,A
	PUSHJ P,PUTFS	;GIVE BACK SET
	CAME A,CURSET
	POPJ P,
	SETZM CURSET
	TRO MCHG
	POPJ P,
                                                                                                                                                                                                                                                                          ;DELETE CONTENTS OF CLOSEST SET
SETKIL:	TRNN STBOX		;MOVING OR DRAWING BOX?
	PUSHJ P,GETCLS
	JRST PERRET		;YES
	TRZ INMOV
	TRO MCHG!NEEDCL
	PUSH P,CLAST
	PUSH P,A		;SAVE SET POINTER FOR DELETION
	MOVE D,[ANDCAM C,1(T)]
	PUSHJ P,STBITA
	MOVE D,[IORM C,1(T)]
	MOVE A,(P)
	PUSHJ P,STBITB
	POP P,A			;THIS SET
	POP P,B			;AND LAST
	PUSHJ P,SCLEAR		;NOW FLUSH SET
	JRST DOSDEL		;NOW DELETE ALL MARKED POINTS AND BODIES

;DELETE COMPLIMENT OF SET
DCOMPL:	TRNN STBOX
	PUSHJ P,GETCLS
	JRST PERRET
	MOVE B,CLAST
	HRRZ C,(A)
	HRRM C,(B)
	PUSH P,A
	MOVE D,[IORM C,1(T)]
	PUSHJ P,STBITA		;MARK ALL POINTS AND BODIES
	MOVE A,(P)
	MOVE D,[ANDCAM C,1(T)]
	PUSHJ P,STBITB		;NOW UNMARK OUR SET
	PUSHJ P,SBLST1		;FLUSH ALL OTHER SETS
	PUSHJ P,DOSDEL
	SETZM LSTNAM		;DISABLE 
LAY,<	SETZM SAVNAM	>
	PUSHJ P,FILEUP		;UPDATE ON SCREEN
	TRO MCHG
	POP P,SETPNT		;THIS IS NOW ONLY SET
	HLLZS @SETPNT		;CLEAR ITS NEXT POINTE
	POPJ P,

DOSDEL:	MOVEI B,PONPNT
	PUSHJ P,PNTSET
MPC,<	MOVEI B,PONPN2
	PUSHJ P,PNTSET
>;MPC
	MOVEI A,DBODPN
	JRST BODSET

BODST1:	HLRZ T,(A)
	HLRZ T,1(T)
	MOVE T,1(T)
	TLNN T,BTMP1		;NEED TO BE DELETED?
	JRST BODSET
	PUSH P,B		;SAVE POINTER TO LAST
	PUSHJ P,BCLEAR		;YES
	POP P,A
BODSET:	MOVE B,A
	HRRZ A,(A)
	JUMPN A,BODST1
	POPJ P,

PNTST1:	HLRZ T,(B)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNN T,MPC,<CPIN!>ISPIN	;THESE GO WITH BODY
	TLNN T,1
	JRST PNTSET		;TRY NEXT
	PUSH P,A		;SAVE LAST
	PUSHJ P,DELPNT
	POP P,B			;BACK UP TO LAST SO FORWARD GET NEW POINT
PNTSET:	MOVE A,B
	HRRZ B,(B)
	JUMPN B,PNTST1
	POPJ P,

STBITA:	MOVSI C,1
	SKIPE A,PONPNT
	PUSHJ P,PNTBST
MPC,<	SKIPE A,PONPN2
	PUSHJ P,PNTBST
>;MPC
	SKIPN A,DBODPN
	POPJ P,
	MOVSI C,BTMP1
BODBST:	HLRZ T,(A)
	HLRZ T,1(T)
	XCT D
	HRRZ A,(A)
	JUMPN A,BODBST
	POPJ P,

PNTBST:	HLRZ T,(A)
	HRRZ T,1(T)
	XCT D
	HRRZ A,(A)
	JUMPN A,PNTBST
	POPJ P,

STBITB:	MOVSI C,1
	PUSH P,A
	HLRZ A,(A)
SETBT1:	HRRZ T,1(A)
	JUMPE T,SETBT2
	HLRZ T,(T)
	HRRZ T,1(T)
	XCT D
SETBT2:	HRRZ A,(A)
	JUMPN A,SETBT1
	POP P,A
	MOVSI C,BTMP1
	HLRZ A,(A)
SETBT3:	HLRZ T,1(A)
	JUMPE T,SETBT4
	HLRZ T,(T)
	HLRZ T,1(T)
	XCT D
SETBT4:	HRRZ A,(A)
	JUMPN A,SETBT3
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                    ;APPEND STUFF TO "CURRENT" SET

;APPEND BODY TO CURRENT SET
APPBOD:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE B,A
	SETZ E,
	PUSHJ P,APPPB
RECNTC:	SKIPA A,CURSET
RECNTR:	CAMN A,CURSET
	TRO MCHG		;MUST UPDATE CURSET
	HRLM A,(P)
	TRO NEEDCL		;MAY CHANGE CLOSEST
	SETZ TT,
	SETZB B,C
	HLRZ A,(A)
RCNTR1:	HRRZ D,1(A)
	PUSHJ P,ADCNTR
	HLRZ D,1(A)
	PUSHJ P,ADCNTR
	HRRZ A,(A)
	JUMPN A,RCNTR1
	JUMPE TT,CPOPJ
	HLRZ A,(P)
	IDIV C,TT
MD,<	TRZ C,1			;CLEAR LOW ORDER BIT
	HRRM C,1(A)
	IDIV B,TT
	TRZ B,1
>;MD
MPC,<
	ASH C,-1
	IDIV C,STPSIZ
	IMUL C,STPSIZ
	ASH C,1
	HRRM C,1(A)
	IDIV B,TT
	ASH B,-1
	IDIV B,STPSIZ
	IMUL B,STPSIZ
	ASH B,1
>;MPC
	HRLM B,1(A)
	POPJ P,

ADCNTR:	JUMPE D,CPOPJ
	HRRE T,1(D)
	ADD C,T
	HLRE T,1(D)
	ADD B,T
	AOJA TT,CPOPJ

CENALL:	SKIPN A,SETPNT
	POPJ P,
CENAL1:	HRLM A,(P)
	PUSHJ P,RECNTR
	HLRZ A,(P)
	HRRZ A,(A)
	JUMPN A,CENAL1
	POPJ P,

;APPEND POINT TO CURRENT SET
APPPNT:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE B,A
	HLRZ T,(B)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNE T,MPC,<CPIN!>ISPIN
	JRST PERRET
	MOVEI E,1
	PUSHJ P,APPPB
	JRST RECNTC

APPPB:	SKIPN A,CURSET		;AND A CURRENT SET?
	JRST [	GETFS (A)
		GETFS (T)
		HRLM T,(A)
		SETZM 1(A)
		SETZM (T)
		SETZM 1(T)
		EXCH A,SETPNT
		HRRM A,@SETPNT
		MOVE A,SETPNT
		MOVEM A,CURSET
		JRST .+1]
	HLRZ A,(A)
	SETZ C,			;THIS WILL POINT TO A PLACE TO PUT HIM
APPPN1:	XCT (E)[HLRZ T,1(A)
		HRRZ T,1(A)]
	CAMN T,B		;ALREADY IN SET?
	POPJ P,			;YES, NOOP
	SKIPN T
	MOVE C,A
	MOVE D,A
	HRRZ A,(A)
	JUMPN A,APPPN1
	JUMPN C,APPPN2
	GETFS(C)
	HRRM C,(D)
	SETZM (C)
	SETZM 1(C)
APPPN2:	XCT (E)[HRLM B,1(C)
		HRRM B,1(C)]
	POPJ P,

;MAKE CLOSEST SET THE CURRENT SET
SETSET:	PUSHJ P,GETCLS
	JRST PERRET
	TRO MCHG
	MOVEM A,CURSET
	POPJ P,

;APPEND CLOSEST SET TO CURRENT SET
APPSET:	SKIPN CURSET		;AND CURRENT ONE?
	JRST SETSET		;NO, DO <META>&
	PUSHJ P,GETCLS		;CLOSEST SET?
	JRST PERRET
	CAMN A,CURSET		;APPENDING TO HIMSELF?
	POPJ P,			;YES, NOOP
	MOVEI E,1		;START WITH POINTS
APPST1:	MOVE F,A
	HLRZ F,(F)
APPST2:	XCT (E)[HLRZ B,1(F)
		HRRZ B,1(F)]
	JUMPE B,APPSKP
	PUSH P,A
	PUSHJ P,APPPB
	POP P,A
APPSKP:	HRRZ F,(F)
	JUMPN F,APPST2
	SOJGE E,APPST1		;LOOP FOR BODIES
	JRST RECNTC		;NOW RE-CENTER SET
                                                                                                                                                                                                                                                                                                  ;REMOVE POINT FROM CURRENT SET
XPNT:	SKIPE B,CURSET
	PUSHJ P,GETCLS
	JRST PERRET
	EXCH A,B
	MOVEI E,1
	PUSHJ P,XPNBD
	JRST RECNTC

;REMOVE BODY FROM CURRENT SET
XBOD:	SKIPE B,CURSET
	PUSHJ P,GETCLS
	JRST PERRET
	EXCH A,B
	SETZ E,
	PUSHJ P,XPNBD
	JRST RECNTC

XPNBD:	HLRZ A,(A)
XPNBD1:	XCT (E)[HLRZ T,1(A)
		HRRZ T,1(A)]
	CAMN T,B
	XCT (E)[HRRZS 1(A)
		HLLZS 1(A)]
	HRRZ A,(A)
	JUMPN A,XPNBD1
	POPJ P,

;REMOVE MEMBERS OF CLOSEST SET FROM CURRENT SET
XSET:	TRNN STBOX
	SKIPN C,CURSET
	JRST PERRET
	MOVEI E,1
	PUSHJ P,GETCLS
	JRST PERRET
	CAMN C,CLOSES
	JRST PERRET
	TRZ INMOV
	EXCH C,A
XSET2:	PUSH P,C
	HLRZ C,(C)
XSET1:	XCT (E)[HLRZ B,1(C)
		HRRZ B,1(C)]
	JUMPE B,.+3
	MOVE A,CURSET
	PUSHJ P,XPNBD
	HRRZ C,(C)
	JUMPN C,XSET1
	POP P,C
	SOJGE E,XSET2
	JRST RECNTC

;CLEAR CURRENT SET
CLRCUR:	SETZM CURSET
	TRO MCHG		;MUST CHANGE WHOLE THING
	POPJ P,

;REMOVE POINT FROM ALL SETS
XPNTA:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE B,A
	PUSHJ P,REMPNT
	JRST ALCNTR

;REMOVE BODY FROM ALL SETS
XBODA:	PUSHJ P,GETCLS
	JRST PERRET
	PUSHJ P,REMBOD
	JRST ALCNTR

;REMOVE MEMBERS OF THIS SET FROM ALL SETS
;AND DELETE SET
XSETA:	TRNN STBOX
	PUSHJ P,GETCLS
	JRST PERRET
	TRZ INMOV
	TRO NEEDCL
	PUSH P,CLAST
	PUSH P,A
	HLRZ A,(A)
XSETA1:	PUSH P,A
	HLRZ A,1(A)
	JUMPE A,.+2
	PUSHJ P,REMBOD
	MOVE A,(P)
	HRRZ B,1(A)
	JUMPE B,.+2
	PUSHJ P,REMPNT
	POP P,A
	HRRZ A,(A)
	JUMPN A,XSETA1
	POP P,A
	POP P,B
	PUSHJ P,SCLEAR
ALCNTR:	SKIPN E,SETPNT
	POPJ P,
ALCNT1:	MOVE A,E
	PUSHJ P,RECNTR
	HRRZ E,(E)
	JUMPN E,ALCNT1
	POPJ P,

SETJMP:	SKIPN T,CURSET
	JRST PERRET
	TRZ STBOX!INMOV
	JRST SCLOSP
                                                                                                                                                                                                                                                            ;WRITE CLOSEST SET INTO FILE
SWRITE:	MOVE T,MODE
	TRNN STBOX		;NOT DRAWING BOX, AND
	CAIE T,SETM		;SET MODE ONLY
	JRST PERRET
	PUSHJ P,GETCLS
	JRST PERRET
	PUSH P,A		;SAVE SET POINTER
	MOVE D,[ANDCAM C,1(T)]	;FIRST CLEAR ALL MARK BITS
	PUSHJ P,STBITA
	MOVE A,(P)		;GET SET POINTER
	MOVE D,[IORM C,1(T)]	;NOW MARK THIS SET
	PUSHJ P,STBITB
	POP P,SETFLG		;SETUP FLAG TO THIS SET
	JRST DWRITS		;AND WRITE FILE
                                                                                                                                                                                                                         ;ASSOCIATIVE SET
ASSETP:	PUSHJ P,GETCLS
	JRST PERRET
	TRZ INMOV!INLIN
	PUSHJ P,ASSCLR
	PUSHJ P,ASSPTP
ASSFIN:	MOVEI T,SETM
	PUSHJ P,CHNGMD		;GO INTO SET MODE
	MOVE A,SETPNT
	PUSHJ P,RECNTR		;CALC CENTER
	MOVE A,SETPNT
	MOVE T,1(A)		;LOC OF CENTER
	JRST CHKON

ASSPTP:	HLRZ B,(A)
	HRRZ C,1(B)
	MOVE D,1(C)
	TLOE D,1
	POPJ P,
	MOVEM D,1(C)
	PUSH P,B		;SAVE DATA BLOCK POINTER
	TLNN D,MPC,<CPIN!>ISPIN	;THESE DON'T GO INTO SET
	PUSHJ P,ASPUTP
MPC,<	TRNE BTHSDS		;ONLY IN BOTH SIDES MODE
	TLNN D,FEEDTH
	JRST NOFOLF
	HLRZ A,(B)		;FOLLOW FEEDTHROUGH
	PUSHJ P,ASSPTP
	JRST NOBODF

NOFOLF:
>;MPC
	TLNN D,ISPIN
	JRST NOBODF
	HLRZ A,(B)		;BODY POINTER
	PUSHJ P,ASSPTB
NOBODF:
MD,<	MOVE B,(P)		;PICKUP DATA BLOCK POINTER AGAIN
	HLRZ B,1(B)
	MOVEM B,(P)
	HLRZ A,(B)
	SKIPE A
	PUSHJ P,ASSPTP
	HRRZ A,@(P)
	SKIPE A
	PUSHJ P,ASSPTP
	AOS (P)
	HLRZ A,@(P)
	SKIPE A
	PUSHJ P,ASSPTP
	POP P,A
	HRRZ A,(A)
	JUMPN A,ASSPTP
	POPJ P,
>;MD
MPC,<	POP P,B			;PICKUP DATA BLOCK POINTER AGAIN
	HLRZ B,1(B)
	JUMPE B,CPOPJ
ASSL1:	MOVEI C,2
ASSL2:	XCT (C)[HLRZ A,(B)
		HRRZ A,1(B)
		HLRZ A,1(B)]
	JUMPE A,ASSL3
	HRLM C,B
	PUSH P,B
	PUSHJ P,ASSPTP
	POP P,B
	HLRZ C,B
ASSL3:	SOJGE C,ASSL2
	HRRZ B,(B)
	JUMPN B,ASSL2
	POPJ P,
>;MPC

ASSETB:	PUSHJ P,GETCLS
	JRST PERRET
	TRZ INMOV
	PUSHJ P,ASSCLR
	PUSHJ P,ASSPTB
	JRST ASSFIN

ASSPTB:	HLRZ B,(A)
	HLRZ C,1(B)
	MOVE T,1(C)
	TLOE T,BTMP1		;DONE ALREADY?
	POPJ P,
	MOVEM T,1(C)
	PUSHJ P,ASPUTB
	JRST ASSBP1

ASSBP2:	HLRZ B,(A)
MPC,<	TRNE BTHSDS		;DOING BOTH SIDES?
	JRST ASSBTH		;YES
	HRRZ T,1(B)
	MOVE T,1(T)
	EQV T,SID
	JUMPGE T,ASSBP1		;JUMP IF ON OTHER SIDE
ASSBTH:
>;MPC
	PUSH P,B
	PUSHJ P,ASSPTP
	POP P,B
ASSBP1:	HRRZ A,(B)
	JUMPN A,ASSBP2
	POPJ P,

ASPUTP:	MOVE T,H
ASPTP1:	HRRZ TT,1(T)
	JUMPE TT,ASPTP2
	MOVE TT,T
	HRRZ T,(T)
	JUMPN T,ASPTP1
	GETFS(T)
	HRRM T,(TT)
	SETZM (T)
	SETZM 1(T)
ASPTP2:	HRRM A,1(T)
	POPJ P,

ASPUTB:	MOVE T,H
ASPTB1:	HLRZ TT,1(T)
	JUMPE TT,ASPTB2
	MOVE TT,T
	HRRZ T,(T)
	JUMPN T,ASPTB1
	GETFS(T)
	HRRM T,(TT)
	SETZM (T)
	SETZM 1(T)
ASPTB2:	HRLM A,1(T)
	POPJ P,

ASSCLR:	PUSH P,A
	MOVE D,[ANDCAM C,1(T)]
	PUSHJ P,STBITA
	POP P,A
	GETFS(T)
	SETZM 1(T)
	EXCH T,SETPNT
	GETFS(H)
	HRL T,H
	MOVEM T,@SETPNT
	SETZM (H)
	SETZM 1(H)
	POPJ P,
                                                                                                                                                                                                                                           ;REMPNT, REMBOD, INBOX
REMPNT:
	CAMN B,MOVED		;DON'T CHECK LATER IF GOING AWAY
	SETZM MOVED
UML,<	MOVEI D,WIRLST
	JRST ISWL

ISWL1:	HRRZ C,1(D)
ISWL3:	HLRZ T,(C)
	CAMN T,B
	HRRZS (C)
	HRRZ C,(C)
	JUMPN C,ISWL3
ISWL:	HRRZ D,(D)
	JUMPN D,ISWL1
>;UML
	MOVEI D,BLPNTR
	JRST ISBL

ISBL1:	HRRZ T,1(D)
	CAME B,T
	JRST ISBL
	HRRZ T,(D)
	HRRM T,(C)
	FSTRET(D)
	MOVE D,C
ISBL:	MOVE C,D
	HRRZ D,(D)
	JUMPN D,ISBL1
MPC,<
ROUTE,<	CAMN B,RCL1
	SETZM RCL1
	CAMN B,RCL2
	SETZM RCL2
>;ROUTE
>;MPC
SHORT,<	MOVEI D,SHRTER
	JRST SHRTR1

SHRTR2:	HLRZ A,(D)
	HRRZ T,1(D)
	CAMN T,B
	JRST SHRTR3
	HLRZ T,1(D)
	CAMN T,B
	JRST SHRTR3
	HRRZ T,1(A)
	CAMN T,B
	JRST SHRTR3
	HLRZ T,1(A)
	CAME T,B
	JRST SHRTR1
SHRTR3:	FSTRET(A)
	HRRZ T,(D)
	HRRM T,(C)
	FSTRET(D)
	MOVE D,C
SHRTR1:	MOVE C,D
	HRRZ D,(D)
	JUMPN D,SHRTR2
	HLRZ T,SERR1
	HRRZ D,SERR1
	CAME T,B
	CAMN D,B
	JRST SHRTR4
	HLRZ T,SERR2
	HRRZ D,SERR2
	CAME T,B
	CAMN D,B
	JRST SHRTR4
	JRST SHRTR5

SHRTR4:	SETZM SERR1
	SETZM SERR2
SHRTR5:
>;SHORT
	SKIPN C,SETPNT
	POPJ P,
REMP1:	HLRZ D,(C)		;GO DOWN SET
REMP2:	HRRZ E,1(D)		;A POINT
	CAMN E,B		;IS THIS IT?
	HLLZS 1(D)		;YES, CLEAR POINTER
	HRRZ D,(D)		;NEXT MEMBERS
	JUMPN D,REMP2
	HRRZ C,(C)		;NEXT SET
	JUMPN C,REMP1
	POPJ P,

REMBOD:	SKIPN C,SETPNT
	POPJ P,
REMB1:	HLRZ B,(C)		;GO DOWN SET......
REMB2:	HLRZ D,1(B)		;A BODY
	CAMN D,A		;IS THIS IT
	HRRZS 1(B)		;CLEAR POINTER
	HRRZ B,(B)
	JUMPN B,REMB2
	HRRZ C,(C)
	JUMPN C,REMB1
	POPJ P,

INBOX:	MOVE C,SETBOX
	SETZ G,
INBOX1:	HRRZ TT,(C)
	JUMPE TT,INDONE		;FINI
	HLLZ TT,1(TT)		;X,Y OF NEXT POINT
	HLLZ TTT,1(C)		;X,Y OF THIS POINT
	HLLZ D,T		;GET X PART OF T
	CAMN TT,TTT		;SAME X VALUES FOR LINE?
	JRST CKVERT		;YES, SPECIAL CHECK
	CAMG TT,TTT		;WHICH IS GREATER?
	EXCH TT,TTT		;REVERSE
	CAML D,TTT		;NOT IN RANGE?
	CAML D,TT		;	"
	JRST VERT		;DOESN'T MAKE IT
	HRRE TT,1(C)		;Y ONLY
	HRRE D,T		;Y OF POINT IN QUESTION
	CAMN TT,D		;IF ON LINE, IMMEDIATE WIN!
	JRST CPOPJ1
	CAML TT,D		;CHECK IF Y VALUE OF LINE IS GREATER THAN THAT OF POINT
	ADDI G,1		;ANOTHER CROSSING
	JRST VERT

VERT:	HRRZ C,(C)
	JRST INBOX1

CKVERT:	CAME D,TT		;POINT ALSO ON VERTICAL LINE?
	JRST VERT		;NO, SKIP IT
	HRRZ TT,(C)
	HRRE TTT,1(TT)		;GET Y VALUES
	HRRE TT,1(C)		;	"
	HRRE D,T		;Y PART OF T
	CAMG TT,TTT		;WHICH IS GREATER?
	EXCH TT,TTT		;REVERSE
	CAMG D,TT
	CAMGE D,TTT
	JRST VERT		;NOT ON LINE, IGNORE
	JRST CPOPJ1		;IMMEDIATE WIN IF ON VERT LINE

INDONE:	TRNE G,1		;ODD NUMBER OF CROSSINGS?
	AOS(P)			;YES, SKIP RETURN, IT WAS IN THE BOX
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  MD,<
SETCOP:	TRNN STBOX		;ARE WE MOVING OR DRAWING A BOX?
	PUSHJ P,GETCLS		;CURRENT SET
	JRST PERRET		;NOT NOW BROTHER
	TRZ INMOV
	MOVE G,A
	MOVEI T,BIGPG
	PUSHJ P,HYDPOG
	PUSH P,CURSET
	MOVEM A,CURSET
	PUSH P,CURSE
	MOVE T,CURSE
	ADJUST(SUB,T,<1(G)>)	;GET OFFSET TO NEW SET
	MOVEM T,NOFFST		;REMEMBER IT
	MOVE T,PID
	MOVEM T,OLDPID
	MOVE T,BID
	MOVEM T,OLDBID
	HLRZ G,(G)		;START OF OLD SET
	SETZM NEWSET		;COLLECT NEW SET HERE
	MOVEI H,NEWSET		;POINTER TO END OF NEW SET
BODNEW:	GETFS(T)		;NEW BLOCK FOR NEW SET
	SETZM (T)
	SETZM 1(T)		;CLEAR IT
	HRRM T,(H)		;LINK IT IN
	MOVE H,T		;POINT TO IT
	HLRZ B,1(G)		;BODY OF THIS BLOCK
	JUMPE B,NNWBOD		;NONE HERE
	MOVE C,1(B)		;LOC
	ADJUST(ADD,C,NOFFST)	;ADD OFFSET
	MOVEM C,CURSE		;WHERE TO PUT NEW BODY
	HLRZ B,(B)		;POINTER TO POINTERS
	HRRZ C,1(B)		;POINTER TO TYPE
	MOVEM C,CURBOD		;SAVE HERE FOR BPYES
	HLRZ C,1(B)
	PUSH P,C		;SAVE  POINTER TO BID, BITS
	HLRZ C,(B)		;ORIENTATION
	MOVEM C,CURORT		;SAVE HERE FOR BPYES
	PUSHJ P,BPYES		;PLANT THE BODY
	MOVE T,DBODPN		;NEWEST BODY
	HRLM T,1(H)		;TO NEW SET
	HLRZ T,(T)
	HLRZ T,1(T)
	POP P,A			;OLD BODY POINTER TO BID, BITS
	HLRZ C,(A)		;OLD BID
	ADD C,OLDBID		;NEW BODY ID
	HRLM C,(T)		;STUFF IT
	MOVE B,[L1416!R1416!FIXLOC!FIXBLO,,0]
	AND B,1(A)		;GET THESE OLD BITS
	IORM B,1(T)		;COPY TO NEW
	HRRZ B,(A)		;GET OLD LOC POINTER
	JUMPE B,NCPLOC		;SKIP IF NONE
	GETFS(C)
	MOVE TTT,1(B)
	MOVEM TTT,1(C)
	HRRM C,(T)
	GETFS(TTT)
	HRLZM TTT,(C)
	HLRZ B,(B)
	MOVE C,(B)
	MOVEM C,(TTT)
	MOVE C,1(B)
	MOVEM C,1(TTT)
NCPLOC:	HRRZ A,1(A)		;OLD BODY TEXT/PROPERTY LIST
	JUMPE A,NNWBOD
	MOVEI C,1(T)
BDNEW2:	GETFS(T)
	MOVE TTT,1(A)
	MOVEM TTT,1(T)
	HRRM T,(C)
	MOVE C,T
	SETZM (C)
	HLRZ T,(A)
	JUMPE T,BDNEW3
	PUSHJ P,STRCOP
	HRLM B,(C)
	HLRZ T,(A)
	HLRZ T,(T)
	JUMPE T,BDNEW3
	PUSHJ P,LSTCOP
	HLRZ T,(C)
	HRLM B,(T)
BDNEW3:	HRRZ A,(A)
	JUMPN A,BDNEW2
NNWBOD:	HRRZ B,1(G)		;POINT FIELD
	JUMPE B,NNWPNT		;NONE
	HLRZ TTT,(B)
	HRRZ TTT,(TTT)		;OLD POINT ID
	PUSH P,TTT
	MOVE T,1(B)		;LOC
	ADJUST(ADD,T,NOFFST)	;OFFSET
	PUSHJ P,PNTPUT		;MAKE A POINT(ALWAYS)
	HRRM D,1(H)		;PUT IN NEW SET
	HLRZ T,(D)
	POP P,TTT
	ADD TTT,OLDPID		;NEW POINT ID
	HRRM TTT,(T)		;STUFF IT
NNWPNT:	HRRZ G,(G)		;NEXT SET BLOCK
	JUMPN G,BODNEW		;LOOP
                                                                                                                                                                                                                                                         ;NOW COPY STUFF ONTO NEW POINTS AND BODIES
	MOVE G,CURSET
	HLRZ G,(G)		;POINTER TO SET
	MOVE H,NEWSET		;AND NEW ONE
BODPNS:	HLRZ A,1(G)		;OLD BODY
	JUMPE A,NTPINS
;********************BODY ***********************
	HLRZ A,(A)
	JRST PINDON		;GO DOWN PIN LIST
NXTPIN:	HLRZ A,(A)
	HRRZ B,1(A)
	MOVE T,B		;SAVE POINTER TO TEXT AND BIT BLOCK
	HRRZ B,(B)		;POINTER TO PIN ENTRY IN TYPE (COMMON)
	HLRZ C,1(H)		;NEW BODY
	HLRZ C,(C)
	JRST NEWPN1
PINNUM:	MOVEM C,NEWPNT
	HLRZ C,(C)
	HRRZ D,1(C)		;POINTER TO TEXT, PIN, AND BODY POINTERS
	HRRZ E,(D)		;POINTER TO PIN ENTRY (COMMON)
	CAMN E,B		;IS THIS THE ONE
	JRST THSPIN		;YES
NEWPN1:
	HRRZ C,(C)
	JUMPN C,PINNUM		;LOOP
	JRST PINDON		;OOPS!
THSPIN:	PUSHJ P,PCOPY		;COPY TEXT AND TEXT BITS
NNWTXT:
	HRRZ T,1(A)		;COPY PIN #
	HRRZ T,1(T)
	HRRM T,1(D)
	HLRZ T,1(A)		;^_ POINTER FOR OLD PIN
	MOVEM T,CRUDLR
	HLRZ T,1(C)		;^_ POINTER FOR NEW PIN
	MOVEM T,UDLR
	PUSHJ P,SEGCOP		;MAKE SEGMENTS (USE POINTER IN NEWPNT)
PINDON:
	HRRZ A,(A)
	JUMPN A,NXTPIN		;NEXT PIN OF THIS BODY
NTPINS:	HRRZ A,1(G)		;OLD POINT
	JUMPE A,NNOPNT		;NO POINT HERE
;********************* PIN ********************
	HRRZ C,1(H)		;NEW POINT
	MOVEM C,NEWPNT
	HLRZ A,(A)
	HLRZ C,(C)		;POINTERS TO POINTERS
	HLRZ T,1(A)
	MOVEM T,CRUDLR
	HLRZ T,1(C)
	MOVEM T,UDLR
	HRRZ T,1(A)
	HRRZ D,1(C)
	MOVE TT,1(T)
	TLNN TT,CPIN		;CONNECTOR PIN HERE?
	JRST NOCCPN		;NO
	HRRZ TT,(T)
	GETFS (TTT)
	MOVE B,(TT)
	MOVEM B,(TTT)
	MOVE B,1(TT)
	MOVEM B,1(TTT)
	HRRM TTT,(D)		;STO NEW CPIN BLOCK
	MOVSI TTT,CPIN!FIXCON
	AND TTT,1(T)		;PICKUP FIXCON BIT AS WELL AS CPIN
	IORM TTT,1(D)		;AND MARK IT
NOCCPN:	PUSHJ P,PCOPY		;COPY TEXT AND TEXT BITS
NNOTXT:	PUSHJ P,SEGCOP		;MAKE SEGMENTS
NNOPNT:	HRRZ H,(H)
	HRRZ G,(G)		;NEXT OF NEW AND OLD
	JUMPN G,BODPNS		;NEXT BLOCK
;END FINISH UP
	GETFS(A)		;NEW BLOCK
	MOVE B,SETPNT		;LINK HIM IN
	HRL B,NEWSET		;POINT TO SET
	MOVEM B,(A)		;TO NEW BLOCK
	MOVEM A,SETPNT		;DONE
	MOVE T,A
	HRLI T,SETPNT
	PUSHJ P,SCLOSE
	POP P,CURSE		;RESTORE CURSOR POSITION
	POP P,CURSET
	MOVE T,CURSE
	MOVEM T,1(A)		;PUT SET AT CURSOR
	MOVEI T,SETM
	PUSHJ P,CHNGMD
	PUSHJ P,DOSMOV
	TRO MCHG		;START MOVING AND MARK AS CHANGED
	MOVE T,OLDBID
	MOVEM T,BID
	MOVE T,OLDPID
	MOVEM T,PID
	JRST REEID		;SPREAD NEW ID'S OVER RANGE OLDBID-
                                                                                                                                                                                                                                  DEFINE MAKSEG $ (LOSE,INDEX,GET,PUT)
	<H$GET$RZ T,@UDLR		;ONE THERE ALREADY?
	JUMPN T,LOSE		;YES
	H$GET$RZ	T,@CRUDLR
	JUMPE	T,LOSE
	MOVEI	TTT,(T)
	PUSHJ	P,GETID			;GET POINT ID IN TTT
	PUSHJ	P,FNDID			;FIND BY ID (ALWAYS WORKS RIGHT)
	JRST	LOSE
	H$PUT$RZ T,INDEX(E)
	JUMPN T,LOSE			;ONE AT DESTINATION ALREADY?
	HR$GET$M D,@UDLR
	MOVE	D,NEWPNT
	HR$PUT$M D,INDEX(E)
>

SEGCOP:	MAKSEG(NODOWN,0,L,R)
NODOWN:	MAKSEG(NOUP,0,R,L)
NOUP:	AOS CRUDLR
	AOS UDLR
	MAKSEG(NOLEFT,1,L,R)
NOLEFT:	MAKSEG(CPOPJ,1,R,L)
	POPJ P,

>;MD
                                                                                                  MPC,<
SETCOP:	TRNN STBOX		;ARE WE MOVING OR DRAWING A BOX?
	PUSHJ P,GETCLS		;CURRENT
	JRST PERRET		;NOT NOW BROTHER
	TRO MCHG
	TRZ INMOV
	MOVEI T,BIGPG
	PUSHJ P,HYDPOG
	PUSH P,CURSET
	MOVEM A,CURSET
	PUSH P,SID		;SAVE WHICH SIDE WE ARE ON
	PUSH P,CURSE		;SAVE CURSOR POSITION
	MOVE T,PID
	MOVEM T,OLDPID
	MOVE T,BID
	MOVEM T,OLDBID
	MOVE T,CURSE
	ADJUST(SUB,T,<1(A)>)
	MOVEM T,NOFFST		;OFFSET FOR NEW SET
	SETZM NEWSET		;COLLECT NEW SET HERE
	MOVEI G,NEWSET
	HLRZ A,(A)
BODNEW:	PUSH P,A
	GETFS (B)
	HRRM B,(G)
	SETZM (B)
	SETZM 1(B)
	HRRZ G,B
	HLRZ B,1(A)		;POINTER TO BODY FIELD OF THIS SET
	JUMPE B,NNWBOD		;NONE
	MOVE C,1(B)		;LOC
	ADJUST(ADD,C,NOFFST)	;ADD OFFSET
	MOVEM C,CURSE		;SAVE HERE
	HLRZ B,(B)		;POINTER TO POINTERS
	HRRZ C,1(B)		;POINTER TO TYPE
	HLRZ TTT,1(B)
	HLRZ TTT,(TTT)		;GET BID
	PUSH P,TTT
	MOVEM C,CURBOD		;SAVE HERE
	HLRZ C,(B)		;ORIENTATION
	MOVEM C,CURORT		;SAVE HERE
	PUSHJ P,BPYES		;MAKE A BODY THERE
	MOVE C,DBODPN		;THIS POINTS TO NEW BODY
	HRLM C,1(G)		;PUT IN NEW SET
	POP P,TTT		;OLD BODY ID
	ADD TTT,OLDBID		;NEW BODY ID
	HLRZ T,(C)
	HLRZ T,1(T)
	HRLM TTT,(T)
NNWBOD:	MOVE A,(P)		;SET POINTER
	HRRZ B,1(A)		;POINT FROM OLD SET
	JUMPE B,NNWPNT		;MAYBE NONE
	HLRZ T,(B)
	HRRZ TTT,(T)
	PUSH P,TTT		;SAVE POINT ID
	HRRZ T,1(T)
	MOVE T,1(T)
	EQV T,SID
	JUMPL T,PNTNEW		;RIGHT SIDE?
	SWITCH			;NO
PNTNEW:	MOVE T,1(B)		;GET LOC OF OLD POINT
	ADJUST(ADD,T,NOFFST)	;NEW POS
	PUSHJ P,PNTPUT		;MAKE THE NEW POINT
	HRRM D,1(G)		;STORE NEW POINT IN NEW SET
	HLRZ T,(D)
	POP P,TTT
	ADD TTT,OLDPID		;NEW POINT ID
	HRRM TTT,(T)
NNWPNT:	POP P,A
	HRRZ A,(A)
	JUMPN A,BODNEW
                                                                                                                                                                                                                                                                 	MOVE H,NEWSET		;NEW SET IN H
	MOVE G,CURSET
	HLRZ G,(G)		;OLD IN G
SEGCP1:	HLRZ A,1(G)		;BODY
	JUMPE A,SEGCP2		;ANY?
	HLRZ B,(A)
	JRST SEGCP3
SEGCP4:	HLRZ B,(A)
	HRRZ T,1(B)
	HLL T,1(T)
	HRR T,(T)
	HLR T,(T)		;XWD BITS,PIN#
	HLRZ C,1(H)		;NEW BODY
	HLRZ D,(C)		;POINTER BLOCK
	JRST SEGCP5
SEGCP6:	HLRZ D,(C)
	HRRZ TT,1(D)
	MOVE TTT,1(TT)
	EQV TTT,T
	JUMPGE TTT,SEGCP5
	HRRZ TT,(TT)
	HLRZ TT,(TT)
	CAIE TT,(T)		;SAME PIN #
	JRST SEGCP5		;NO
	PUSH P,B		;SAVE LINK
	PUSHJ P,COPPNT		;COPY POINT STUFF
	POP P,B
	JRST SEGCP3
SEGCP5:	HRRZ C,(D)
	JUMPN C,SEGCP6
SEGCP3:	HRRZ A,(B)
	JUMPN A,SEGCP4
SEGCP2:	HRRZ A,1(G)		;POINT FROM OLD SET
	JUMPE A,SEGCP7		;NO POINT
	HRRZ C,1(H)		;AND FROM NEW ONE
	PUSHJ P,COPPNT		;DO POINT STUFF
SEGCP7:	HRRZ H,(H)
	HRRZ G,(G)
	JUMPN G,SEGCP1
	JRST COPSDN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        COPPNT:	MOVEM C,NEWPNT		;STORE NEW POINT POINTER HERE
	HLRZ T,(A)
	HRRZ T,1(T)
	HLRZ TT,(C)
	HRL A,TT		;GRAB DATA BLOCK POINTER OF NEWPNT AND STUFF IT AWAY
	HRRZ TT,1(TT)
	MOVE TTT,[PLANES,,-1]	;COPY PLANES AND PAD TYPE!
	ANDCAM TTT,1(TT)	;CLEAR IN NEW POINT
	AND TTT,1(T)		;GET FROM OLD
	IORB TTT,1(TT)		;SET IN NEW (AND GET FRONT BIT)
	EQV TTT,SID
	JUMPL TTT,COPSID	;RIGHT SIDE?
	PUSH P,T
	SWITCH			;NO, CHANGE
	POP P,T
COPSID:	HLRZ T,(T)		;TEXT POINTER
	JUMPE T,NNOTXT
	PUSHJ P,STRCOP
	HLRZ T,(C)
	HRRZ T,1(T)
	HRLM B,(T)		;STORE NEW TEXT POINTER
NNOTXT:	HLRZ F,(A)
	HLRZ F,1(F)		;NEIGHBOR POINTER
	PUSH P,H		;SAVE H
	JUMPE F,NOSEGS		;NONE AT ALL?
	PUSH P,A		;AND A AND NEIGHBOR POINTER
SEGCOP:	MOVEI H,2
NNTXT1:	XCT (H)[HLRZ T,(F)
		HRRZ T,1(F)
		HLRZ T,1(F)]
	JUMPE T,NOSEG
	MOVEI TTT,(T)
	PUSHJ P,GETID			;GETID INTO TTT
	PUSHJ P,FNDID
	JRST NOSEG
	MOVE B,E
	MOVE A,NEWPNT
	PUSHJ P,FNDLNK		;ALREADY THERE?
	CAIA			;NO, LETS MAKE ONE
	JRST NOSEG		;YES, DON'T MAKE 2 LINES
	HLRZ T,(P)		;GET NEIGHBOR POINTER FROM STACK
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	MOVE T,TTT
	PUSHJ P,FRELNK
	MOVE D,NEWPNT
	XCT (T)PUTAB
NOSEG:	SOJGE H,NNTXT1
	HRRZ F,(F)
	JUMPN F,SEGCOP
	POP P,A			;GET BACK SOURCE POINT
NOSEGS:	HLRZ T,(A)
	HLRZ TTT,(T)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNN T,FEEDTH		;FEED THROUGH HERE?
	JRST NNPFED		;NO
	SWITCH			;GET TO OTHER SIDE
	PUSHJ P,GETID		;ID OF OTHER POINT(POINTER ALREADY IN TTT)
	PUSHJ P,FNDID		;FIND NEW POINT
	JRST NOFEDY		;NOT YET, CLEAR PLANE BITS, NO ONE ON OTHER SIDE
	MOVE TT,1(T)
	TLNE TT,FEEDTH!CPIN!ISPIN;IS IT FED THROUGH?
	JRST NOFEDX		;YES, DONE ALREADY
	HRR TT,NEWPNT
	HRLM TT,(TTT)
	TLO TT,FEEDTH
	HLLM TT,1(T)
	HLRZ TT,(TT)
	HRLM D,(TT)
	HRRZ TT,1(TT)
	MOVE TTT,1(TT)
	TLO TTT,FEEDTH
	HLLM TTT,1(TT)
NOFEDX:	SWITCH
NNPFED:	POP P,H
	POPJ P,

NOFEDY:	SWITCH
	POP P,H
	MOVE T,NEWPNT
	HLRZ T,(T)
	HRRZ T,1(T)
	MOVSI TT,PLANES
	ANDCAM TT,1(T)		;CLEAR PLANE CONNECTIONS IF NOT FED THROUGH YET!
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                COPSDN:	GETFS(A)		;POINTER BLOCK FOR SET
	MOVE B,SETPNT		;LINK HIM IN
	HRL B,NEWSET		;POINT TO SET
	MOVEM B,(A)		;TO NEW BLOCK
	MOVEM A,SETPNT		;DONE
	MOVE T,A
	HRLI T,SETPNT
	PUSHJ P,SCLOSE
	POP P,CURSE		;RESTORE CURSOR POSITION
	MOVE T,CURSE
	MOVEM T,1(A)		;NEW SET CENTER
	MOVEI T,SETM
	PUSHJ P,CHNGMD		;BACK TO SET MODE
	PUSHJ P,DOSMOV
	TRO MCHG		;AND NOW MOVE IT(THIS CHANGES PIC).
	MOVE T,OLDPID
	MOVEM T,PID
	MOVE T,OLDBID
	MOVEM T,BID
	PUSHJ P,REEID		;SPREAD NEW ID'S OVER RANGE OLDBID-
	POP P,T
	POP P,CURSET
	EQV T,SID
	JUMPL T,CPOPJ
	SWITCH
	POPJ P,
>;MPC
                                            STRCOP:	GETFS (B)		;RETURN POINTER IN B
	MOVE TT,1(T)		;GET OFFSET
	MOVEM TT,1(B)
	HRRZ T,(T)
	HLL TT,(T)		;SIZE
	GETFS(TTT)		;GET A BLOCK FOR IT
	MOVEM TTT,(B)		;LINK IN
	HLLZM TT,(TTT)
	MOVE TT,1(T)
	MOVEM TT,1(TTT)		;SAVE FIRST WORD OF TEXT
LPTXTC:	HRRZ T,(T)		;NEXT BLOCK
	JUMPE T,[	HLLZS(TTT)	;CLEAR LINK
			POPJ P,]
LSTCP1:	GETFS(TT)		;ANOTHER BLOCK
	HRRM TT,(TTT)		;LINK IT IN
	MOVE TTT,TT
	MOVE TT,1(T)
	MOVEM TT,1(TTT)
	JRST LPTXTC		;LOOP

LSTCOP:	SETZ B,
	MOVEI TTT,B
	JRST LSTCP1

MD,<
PCOPY:	HLRZ TT,(T)
	JUMPE TT,CPOPJ		;DON'T BOTHER IF NO TEXT
	MOVSI TTT,FIXTXT!FIXRHT
	AND TTT,1(T)		;GET BITS FROM OLD
	IORM TTT,1(D)		;STORE IN NEW
	HLRZ T,(T)
	PUSHJ P,STRCOP
	HRLM B,(D)		;STORE NEW TEXT IN NEW POINT
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 COMMENT    VALID 00009 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(ALT,3)
C00005 00003	LEAVE ALTER MODE
C00010 00004	GETONE, FORWRD, BAKWRD, SEARCH
C00014 00005	END OF LINE SEARCHES
C00016 00006	DELETE:	TRZN TYPNEG
C00020 00007	ALTN:	PUSHJ P,ALTNS
C00024 00008	REPLAC:	PUSHJ P,DELETE		<->nD, THEN INSERT
C00026 00009	HERE WE SEARCH FOR A SUBSTRING OF THE CURRENT STRING
C00029 ENDMK
C;
                                                                                                                                                                                                                         VERSION(ALT,3)
;ENTER ALTER MODE -- POINT, EDIT, MACRO
MD,<
BTALTR:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,REMMAC
	MOVE T,CLAST
	HRLM T,REMMAC	;SAVE LAST ALSO
	HLRZ A,(A)
	MOVEI T,BTALTM
	JRST EALT0

EALTER:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,REMMAC		;REMEMBER THE ONE WE ARE WORKING ON
	HLRZ A,(A)
	MOVEI T,EDTAM	;ENTER THIS MODE SO WE LEAVE PROPERLY
	JRST EALT0
>;MD

ALTER:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,ALTPNT		;FOR PTKIL1
	HLRZ A,(A)
	HRRZ B,1(A)
	HLRZ A,(B)
	JUMPN A,EALT1
	GETFS (A)
	SETZM 1(A)		;GIVE HIM SOMETHING TO EDIT ANYWAY
	HRLM A,(B)		;IT SHOULD NEVER GET SEEN IF IT STAYS NULL
	GETFS(C)
	SETZM 1(C)
	HRRZM C,(A)
	MOVSI T,STDBIG
	MOVEM T,(C)		;SIZE ONE
EALT1:	MOVEI T,ALTM
EALT0:	HRRZ A,(A)	;JUST TEXT PLEASE
	MOVEM A,TXTPNT
	SETZM ALTLIN
	MOVE TT,MODE
	MOVEM TT,MODALT
	PUSHJ P,CHNGMD
	TRO MCHG
	SETOM LPNTR
	JRST TXTSET		;INITIALIZE POINTERS!

MALTER:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ANYALT]
	JRST PERRET
	PUSHJ P,ITGET		;GET MACRO
	JRST NXMAC		;NONE
	MOVEM E,REMMAC
	MOVE T,MODE
	MOVEM T,MODALT
	SETZM ALTLIN
	MOVEI T,CRCHR
	MOVEM T,EOLCHR
	MOVEI T,MALTM
	PUSHJ P,CHNGMD
	TRO MCHG
	SETOM LPNTR
	MOVE T,B		;SAVE BYTE POINTER
	PUSHJ P,SETTT7		;SETUP FOR TEXT STRING
	MOVEM A,TXTPNT
MALT1:	PUSHJ P,GETTT
	JRST TXTSET
	TRZE C,200
	PUTBYT AMCTL
	TRZE C,400
	PUTBYT AMMTA
IFN ALTCHR-ALTMOD,<
	CAIN C,ALTMOD
	MOVEI C,ALTCHR
>;IFN ALTCHR-ALTMOD
	CAIN C,12
	MOVEI C,CRCHR		;USE THIS AS LF FOR NOW
	PUTBYT (C)
	JRST MALT1
                                                                                                                                                                                                                                                                                                                                                                                                                  ;LEAVE ALTER MODE
MD,<
BTXALT:	PUSHJ P,EBTALT
	POPJ P,
	JRST BTXDL1		;A SETUP WITH LAST,,CLOSEST

ELTALT:	PUSHJ P,EBTALT
	POPJ P,
	JRST EDTDL1

EBTALT:	MOVE T,MODALT
	PUSHJ P,CHNGMD
	TRO MCHG
	SETOM LPNTR
	MOVE B,TXTPNT
	MOVE A,REMMAC		;GET THE ONE WE WERE WORKING ON
	SKIPN 1(B)		;DID TEXT GO AWAY?
	JRST CPOPJ1		;YES, TELL HIGHER UPS TO KILL IT
	PUSHJ P,EALT2
	MOVE T,1(A)
	TRNN T,1		;AUTO OFFSET?
	POPJ P,			;NO
	JRST EDTTZA		;YES, RECALCULATE OFFSET
>;MD

MALTALT:MOVE B,REMMAC
	HLRZ B,1(B)
	PUSHJ P,PUTFS		;GIVE OLD COPY OF MACRO BACK
	MOVE T,TXTPNT
	ADD T,[POINT 7,1]
	PUSHJ P,SETTT
	SETZ D,
MALTC1:	PUSHJ P,GETTT
	JRST MALTC2
	CAIN C,AMMTA
	JRST [	TRO D,400
		JRST MALTC1]
	CAIN C,AMCTL
	JRST [	TRO D,200
		JRST MALTC1]
	CAIN C,CRCHR
	JRST [	MOVEI C,12
		JRST ISLF]	;DON'T ALLOW CTRLMETA ON LF
IFN ALTCHR-ALTMOD,<
	CAIN C,ALTCHR
	MOVEI C,ALTMOD
>;IFN ALTCHR-ALTMOD
	TRO C,(D)
ISLF:	PUTBYT (C)
	SETZ D,
	JRST MALTC1

MALTC2:	MOVE E,REMMAC
	HRLM A,1(E)
	HRROS (A)		;MARK AS PERMANENT
MQUIT1:	MOVE B,TXTPNT
	PUSHJ P,PUTFS
	TRO MCHG
	MOVEI T,DBLARR
	MOVEM T,EOLCHR		;RESTORE END OF LINE CHARACTER
	MOVE T,MODALT
	JRST CHNGMD

MQUIT:	MOVE T,MODE
	CAIN T,MALTM		;CAN'T IF NOT DOING ANYTHING
	JRST MQUIT1
	JRST PERRET

ALTALT:	MOVE T,MODALT		;GET BACK OLD MODE
	PUSHJ P,CHNGMD
	TRO MCHG
	MOVE B,TXTPNT		;GET TEXT POINTER
	MOVE A,ALTPNT
	SKIPN 1(B)		;DID IT GET CLEARED ENTIRELY?
	JRST PTKIL1		;KILL IT THE USUAL WAY
MD,<	PUSHJ P,FIXEM		;FIX TEXT AND CON OFFSET (IF BITS ON)>
EALT2:	MOVE B,TXTPNT
EALT3:	MOVE T,B
	HRRZ B,(B)
	JUMPE B,CPOPJ
	SKIPE 1(B)		;NULLS?
	JRST EALT3
	HLLZS (T)
	JRST PUTFS		;FLUSH THEM

SETSIZ:	TRZE TYPNEG
	JRST MSORRY
	PUSHJ P,READSZ		;READ SIZE ARG (RETURNS IN T)
	JRST INNERR		;IF ERROR, JUST SAY SO
	PUSHJ P,GETLIN		;GET LF
	CAIE C,12
	JRST INNERR
MPC,<	JUMPE T,INNERR	>
MD,<	JUMPN T,NOZERO
	MOVEI TT,1
	LSH TT,@MODE
	TDNN TT,[1EDTAM!1BTALTM]
	JRST INNERR
	MOVE TT,REMMAC
	HLRZ TT,(TT)
	HLRZ TT,(TT)
	JUMPE TT,INNERR		;ZERO NOT ALLOWED UNLESS PROPERTY
NOZERO:
>;MD
	HRLM T,@TXTPNT		;STORE IN TEXT HEADER
	JRST COMCLR

ALTMNS:	SKIPE NOARG		;HAS HE ALREADY STARTED A NUMBER?
	TROE TYPNEG		;NO, ARE WE ALREADY - ?
	JRST PERRET		;YES, ERROR
	POPJ P,

ALTNUM:	SETZM NOARG		;INDICATE ARG SPECIFIED
	MOVE T,COMREP
	IMULI T,=10
	ADDI T,-60(C)
	MOVEM T,COMREP
	POPJ P,

TXTSET:	MOVE T,TXTPNT
	ADD T,[<POINT 7,1,6>]
	MOVEM T,TXTBYT		;INITIALIZE BYTE POINTER TO FIRST CHAR
	MOVEI T,1
	MOVEM T,TXTCNT		;AND FIRST CHAR OF TEXT
	TRO ATFP
	TRZ ATLP		;ASSUME NOT AT LAST POINT YET
	LDB T,TXTBYT
	JUMPN T,COMCLR		;WE WERE RIGHT
	TRO ATLP		;FLAG AT LAST POINT
COMCLR:	SETZM COMREP		;CLEAR REPEAT COUNT
	SETOM NOARG		;FLAG NO ARGUMENT YET
	TRZ TYPNEG		;NOT - YET
	SETZM AEOL
	SETZM ABOL
	TRNE ATLP
	SETOM AEOL
	TRNE ATFP
	SETOM ABOL
	POPJ P,

MSORRY:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SORRY, MINUS NOT IMPLEMENTED FOR THIS COMMAND.
/]
	JRST COMCLR
                                                                                                                                                                                                    ;GETONE, FORWRD, BAKWRD, SEARCH
GETONE:	TRNE ATLP
	POPJ P,			;DIRECT RETURN IF AT LAST POINT ALREADY
	TRZ ATFP		;GUESS WE'RE NOT AT THE FIRST POINT ANY MORE
	AOS TXTCNT		;MOVING FORWARD AT LEAST ONE
	MOVE T,TXTBYT
	TLNE T,760000		;END OF WORD YET?
	JRST SAMWRD		;YES
	HRR T,-1(T)
	TRNE T,-1
	JRST SAMWRD
	GETFS(TT)
	MOVE T,TXTBYT
	HRRM TT,-1(T)
	SETZM 1(TT)
	SETZM (TT)
	HRR T,TT
SAMWRD:	ILDB C,T		;GET CHAR (MAY BE 0)
	MOVEM T,TXTBYT
	JUMPN C,CPOPJ1		;SKIP RETURN IF AT END NOW
	TRO ATLP		;NOT REALLY AT LAST POINT
	POPJ P,

FORWRD:	TRZE TYPNEG
	JRST BAKWRD
	TRNE ATLP		;AT LAST CHR
	JRST COMCLR		;YES, LEAVE
	SKIPN COMREP		;ANY ARGUMENT?
	AOS COMREP		;NO, USE ONE
FORLOP:	SOSL COMREP
	PUSHJ P,GETONE		;GET NEXT CHAR
	JRST COMCLR
	JRST FORLOP

BAKONE:	PUSH P,COMREP
	SETZM COMREP
	PUSHJ P,BAKWRD
	POP P,COMREP
	POPJ P,

BAKWRD:	TRZE TYPNEG
	JRST FORWRD
	TRNE ATFP		;AT FIRST POINT?
	JRST COMCLR		;YES, LEAVE
	SKIPN T,COMREP
	MOVEI T,1
	SUB T,TXTCNT		;WHERE TO BACK UP TO, COUNTING FROM FRONT
	PUSH P,T
	PUSHJ P,TXTSET		;GET BACK TO FRONT
	POP P,T
	ADDI T,1		;ACCOUNT FOR BEING AT FIRST ONE ALREADY
	MOVNM T,COMREP
	JRST FORLOP		;FORLOP WILL QUIT IF AT FRONT ALREADY

SEARCH:	TRZE TYPNEG
	JRST NSEARC
	PUSHJ P,SEARC0
	JRST COMCLR
	PUSHJ P,GETONE
	JRST COMCLR
	JRST COMCLR

SEARC0:	SKIPN COMREP
	AOS COMREP
	PUSHJ P,GETCHR
SEARCL:	SETZM AFIND
	PUSH P,C		;SAVE CHAR TO SEARCH FOR
	LDB C,TXTBYT	;START WITH CURRENT CHAR
	JRST SEARC5

SEARC1:	SOSG COMREP
	JRST SEARC3
SEARC2:	PUSHJ P,GETONE
	JRST SEARC4		;AT END, LEAVE
SEARC5:	CAME C,(P)		;IS THIS ONE?
	JRST SEARC2		;GET ANOTHER
	JRST SEARC1		;LOOP FOR COUNT

SEARC3:	AOS -1(P)
	SETOM AFIND
SEARC4:	POP P,(P)
	POPJ P,

NSEARC:	PUSHJ P,NSEAR0
	JRST COMCLR
	JRST COMCLR


NSEAR0:	SKIPN COMREP
	AOS COMREP
	PUSHJ P,GETCHR
NSEARL:	SETZM AFIND
	PUSH P,C		;SAVE CHAR TO SEARCH FOR
NSEAR1:	SOSGE COMREP
	JRST SEARC3
NSEAR2:	TRNE ATFP		;DONE IF AT FIRST POINT
	JRST SEARC4
	PUSHJ P,BAKONE
	LDB C,TXTBYT
	CAME C,(P)
	JRST NSEAR2
	JRST NSEAR1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;END OF LINE SEARCHES
ELINE:	TRO TFLG
	TRNN TYPNEG
	AOS COMREP		;FOR FORWARD, ADD 1
	JRST SLINE1

MSLINE:	TRC TYPNEG
SLINE:	TRZ TFLG
	TRNE TYPNEG		;IF - SEARCH
	JRST [	SKIPE NOARG	;IF NO ARG,
		AOS COMREP	;THEN - = -1
		AOS COMREP	;THEN ADD 1 TO COUNT
		JRST SLINE1]	;AND PROCESS
	SKIPN NOARG		;IF ARG,
	SKIPE COMREP		;AND IT IS 0
	JRST SLINE1
	TRO TYPNEG		;THEN BACKWARDS 1 EOL
SLINE1:	SKIPN COMREP
	AOS COMREP
	MOVE C,EOLCHR		;THIS IS ALWAYS THE SEARCH CHARACTER
	TRZE TYPNEG
	JRST NSLINE
	PUSHJ P,SEARCL
	JRST COMCLR
NSLIN1:	TRNN TFLG		;IF "E", LEAVE BEFORE CHAR
	PUSHJ P,GETONE
	JRST COMCLR
	JRST COMCLR

NSLINE:	PUSHJ P,NSEARL
	JRST COMCLR
	JRST NSLIN1

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           DELETE:	TRZN TYPNEG
	JRST DELET0
	TRNE ATFP
	JRST COMCLR
	SKIPN T,COMREP
	MOVEI T,1
	ADDI T,1
	CAMLE T,TXTCNT		;IS THERE ENOUGH THERE TO DELETE?
	MOVE T,TXTCNT		;NO, DELETE JUST WHATS THERE
	SUBI T,1
	MOVEM T,COMREP
	PUSH P,COMREP
	PUSHJ P,BAKWRD
	POP P,COMREP
DELET0:	TRNE ATLP
	JRST COMCLR
	SKIPN COMREP
	AOS COMREP
	PUSH P,TXTCNT
	PUSH P,TXTBYT
	MOVE A,TXTBYT
	ADD A,[070000,,0]
	SOS COMREP		;GET WILL DO ONE
	PUSHJ P,FORLOP		;SKIP OVER CHARS WE WANT TO DELETE
DELET1:	PUSHJ P,GETONE
	JFCL
	TLNN A,760000		;END OF WORD?
	HRR A,-1(A)		;YES, FOLLOW LINK (CAN'T LOSE).
	IDPB C,A		;DEPOSIT CHAR
	JUMPN C,DELET1		;LOOP IF NOT AT END (C=0)
	TRO MCHG
	SETOM LPNTR
	POP P,TXTBYT
	POP P,TXTCNT
	SOSN 1(P)		;TEST TXTCNT FOR 1
	TRO ATFP		;AND SET ATFP IF ON
	CAME A,TXTBYT		;DID WE PUT A 0 IN THE CURRENT BYTE?
	TRZ ATLP		;NO, FLUSH ATLP
	TLNE A,760000		;END OF WORD?
	IDPB C,A		;ANOTHER 0
	TLNE A,760000		;END OF WORD YET?
	JRST .-2
	HRRZ B,-1(A)		;GET FORWARD LINK
	HLLZS -1(A)
	JRST PUTFS		;AND RETURN THE REST

KILL:	TRZE TYPNEG
	JRST NKILL
	PUSH P,0		;SAVE FIRST-LAST BITS
	PUSH P,TXTCNT
	PUSH P,TXTBYT
	PUSHJ P,SEARC0		;FIND CHAR IN QUESTION
	JRST [	SUB P,[3,,3]
		JRST COMCLR]
	POP P,TXTBYT
	POP P,T			;GET BACK ORIGINAL COUNT
	EXCH T,TXTCNT		;PUT THIS BACK NOW IN CASE AT END
	POP P,TT		;GET BACK BITS
	TRZ ATLP!ATFP		;CLEAR THESE
	ANDI TT,ATLP!ATFP
	TRO (TT)
	SUB T,TXTCNT
	ADDI T,1		;KILL THROUGH CHARACTER WE FOUND.
	MOVEM T,COMREP		;THIS IS HOW MANY TO DELETE
	JRST DELETE

NKILL:	PUSH P,TXTCNT
	PUSHJ P,NSEAR0		;FIND CHAR IN QUESTION
	JRST [	POP P,(P)
		JRST COMCLR]
	POP P,T
	SUB T,TXTCNT
	MOVEM T,COMREP		;THIS IS HOW MANY TO DELETE
	JRST DELETE

ALTC:	TRZE TYPNEG
	TROA TFLG
	TRZ TFLG
	SKIPN COMREP
	AOS COMREP
ALTC1:	PUSHJ P,GETCHR		;GET REPLACEMENT CHAR
	CAIE C,12
	CAIN C,ALTMOD		;DIS-ALLOW STUPIDNESS
	JRST ALTC3
	TRNN TFLG
	JRST ALTC4
	TRNE ATFP
	JRST ALTC2
	PUSH P,C
	PUSHJ P,BAKONE
	POP P,C
	JRST ALTC5

ALTC4:	TRNE ATLP
	JRST ALTC2
ALTC5:	DPB C,TXTBYT
	TRO MCHG
	SETOM LPNTR
ALTC3:	TRNN TFLG
	PUSHJ P,GETONE		;MOVE FORWARD ONE
	JFCL			;IF AT END, JUST GOBBLE REST OF CHARS
ALTC2:	SOSLE COMREP
	JRST ALTC1
	JRST COMCLR
                                                                                                                                                                                                                                                                                                                                 ALTN:	PUSHJ P,ALTNS
	JRST COMCLR
	TRNE TFLG
	POPJ P,			;ALREADY AT FRONT IF -N
ALTNA:	PUSHJ P,GETONE
	JRST COMCLR
	CAIL C,"0"
	CAILE C,"9"
	JRST COMCLR
	JRST ALTNA

SPALTN:	PUSHJ P,ALTNS
	JRST COMCLR		;DIDN'T FIND IT
	PUSHJ P,COMCLR
	PUSHJ P,SETTT		;SETUP OUTPUT STRING
SPALT1:	PUTBYT (C)
	PUSHJ P,GETONE
	JRST SPALT2
	CAIL C,"0"
	CAILE C,"9"
	CAIA
	JRST SPALT1
SPALT2:	TRNE TFLG
	PUSHJ P,BAKDIG		;BACK UP TO FRONT IF -#
	JRST ITSTUF

ALTPLS:	PUSHJ P,SREADN
	CAIE C,12
	JRST INNERR
	MOVE D,T
	PUSHJ P,ALTNS
	JRST COMCLR
	SETZ B,
ALTPL1:	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	JRST ALTPL2
	IMULI B,=10
	ADDI B,-"0"(C)
	PUSH P,B
	PUSHJ P,DELETE
	POP P,B
	JRST ALTPL1

ALTPL2:	ADD B,D			;NOW ADD ARGUMENT
	PUSHJ P,SETTT7		;PREPARE TO MAKE STRING
	PUSHJ P,PUTTTN		;MAKE NUMBER BACK INTO STRING
	MOVE B,A		;PUT WHERE INSERT WILL FIND IT
	PUSHJ P,ALTPL3		;AND INSERT NEW DIGIT STRING
	TRNE TFLG
	PUSHJ P,BAKDIG
	JRST COMCLR

ALTU:	PUSHJ P,ALTNS
	JRST COMCLR
ALTU1:	PUSHJ P,DELETE
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"		;ALL DIGITS DELETED?
	POPJ P,			;YES
	JRST ALTU1

ALTNS:	SETZM AFIND
	SKIPN COMREP
	AOS COMREP
	TRZE TYPNEG
	JRST NALTNS
	TRZ TFLG
	TRNE ATLP
	POPJ P,
	LDB C,TXTBYT		;IN CASE AT FRONT
	TRNE ATFP
	JRST ALTN2		;YES, ASSUME CAN BE START OF DIGIT STRING
	PUSHJ P,BAKONE		;BACK UP ONE
	LDB C,TXTBYT		;GET CHAR WE NOW POINT AT
ALTN1:	CAIL C,"0"
	CAILE C,"9"
	JRST ALTN3		;FOUND NON-DIGIT
ALTN4:	PUSHJ P,GETONE
	POPJ P,
	JRST ALTN1

ALTN3:	PUSHJ P,GETONE		;GET ANOTHER
	POPJ P,
ALTN2:	CAIL C,"0"
	CAILE C,"9"		;GET TO DIGIT YET?
	JRST ALTN3		;NO
	SOSLE COMREP		;YES, HAVE WE FOUND ENOUGH?
	JRST ALTN4		;NO
	SETOM AFIND
	JRST CPOPJ1		;YES

NALTNS:	TRO TFLG
	TRNE ATLP
	JRST NALTN1		;CAN BE START OF DIGIT STRING IF END
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	JRST NALTN1		;IF THIS CHAR NOT DIGIT, CAN ALSO BE START
	PUSHJ P,BAKDIG
NALTN1:	TRNE ATFP
	POPJ P,			;NOT FOUND
	PUSHJ P,BAKONE
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	JRST NALTN1
	PUSHJ P,BAKDIG		;BACKUP OVER DIGIT STRING
	SOSLE COMREP
	JRST NALTN1		;NOT ENOUGH YET, LOOP BACK
	SETOM AFIND
	JRST CPOPJ1		;FOUND IT

BAKDIG:	TRNE ATFP
	POPJ P,			;IF AT FRONT, THEN DONE
	PUSHJ P,BAKONE
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	CAIA
	JRST BAKDIG		;KEEP GOING
	PUSHJ P,GETONE		;POINT BACK AT FIRST DIGIT
	JFCL			;CAN'T HAPPEN
	POPJ P,
                                                                                                                                           REPLAC:	PUSHJ P,DELETE		;<->nD, THEN INSERT
INSERT:	TRZE TYPNEG
	JRST MSORRY
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/INSERT TEXT_/]
	PUSHJ P,TREADC
	POPJ P,
	POPJ P,
ALTPL3:	TRO MCHG
	SETOM LPNTR
	TRZ ATLP		;THERE IS AT LEAST ONE MORE CHAR COMING!
	MOVE T,TXTBYT
	GETFS(TT)
	MOVE TTT,(T)
	MOVEM TTT,1(TT)
	HRRZ TTT,-1(T)		;GET LINK
	HRRM B,-1(T)
	HRRM TTT,(TT)
	PUSH P,TT		;SAVE END PIECE
	MOVEI TT,1
	MOVEI C,177		;AS GOOD A THING AS ANY
	ADD T,[070000,,0]
	IDPB C,T
	TLNE T,760000
	AOJA TT,.-2
	MOVEM TT,COMREP		;SET AS DELETE COUNT
	PUSH P,TT
	PUSHJ P,DELETE
INS2:	PUSHJ P,GETONE
	CAIA
	JRST INS2		;LOOP UNTIL END OF TEXT
	TRZ ATLP
	POP P,T
	EXCH T,(P)		;EXCHANGE COUNT FOR REST OF TEXT
	MOVE TT,TXTBYT
	HRRM T,-1(TT)
	MOVNI T,1
	MOVEI C,177
	ADD TT,[070000,,0]
	IDPB C,TT
	TLNE TT,760000
	SOJA T,.-2
INS3:	SUBI T,5
	POP P,(P)
	ADD T,1(P)		;ADD # WE SUBTRACTED BEFORE
	MOVNM T,COMREP		;# TO DELETE
	JRST DELETE
                                                                                                                                                                                                                                                                                                                                  ;HERE WE SEARCH FOR A SUBSTRING OF THE CURRENT STRING
ALTZAP:	SETOM CHRALT		;FLAG DELETE
	CAIA
ALTFND:	SETZM CHRALT		;FLAG NO DELETE
	TRZE TYPNEG
	JRST MSORRY
	TLNN M,DSKACT!MACACT
	SKIPN A			;WANT PROMPT?
	CAIA
	OUTSTR[ASCIZ/TYPE SEARCH STRING.
/]
	PUSHJ P,TREADC
	JRST COMCLR		;ALTMODE
	JRST [
MD,<
		SKIPE B,FPTSTR	;YES, USE TEXT SEARCH STRING
		JRST .+1
>;MD
		JRST PERRET]	;NO STRINGS AT ALL, ERROR
	MOVEM B,ALTSTR	;SAVE POINTER HERE
	PUSHJ P,ADZERO	;MAKE SURE THERE IS A ZERO ON THE END
	SKIPN COMREP
	AOS COMREP
	SETZM AFIND		;NOTHING FOUND YET
	TRNE ATLP	;AT END?
	JRST ALTFN2
	MOVE A,TXTBYT	;BACK UP ONE INITIALLY
	ADD A,[160000,,0]
	SETOM BEGLIN	;START AT FRONT
	TRNN ATFP	;IS IT TRUE?
	SETZM BEGLIN	;NOT AT FIRST CHAR
	SETOM FSTART
ALTFN1:	PUSHJ P,MATCH	;TRY TO MATCH THEM
	JRST ALTFN2	;NO MATCH
	SOSLE COMREP	;DONE?
	JRST ALTFN1	;NO, TRY AGAIN
ALTFN2:	MOVE T,FSTART	;COUNT TO START
	MOVEM T,COMREP
	JUMPE T,.+2	;MAY ALREADY BE THERE
	PUSHJ P,FORWRD	;MOVE TO THERE
	MOVE B,ALTSTR
MD,<	CAME B,FPTSTR	;WAS THIS THE TEXT SEARCH STRING?	>
	PUSHJ P,PUTFS	;NO, GIVE BACK FREE STORAGE
	SKIPE T,FLEN		;NON-ZERO STRING FOUND?
	TRNE ATLP		;YES, AT END?
	JRST COMCLR		;LOSE
	MOVEM T,COMREP		;THIS IS HOW MANY TO DO
	SETOM AFIND		;FLAG SOMETHING FOUND
	SKIPN CHRALT		;NON-ZERO MEANS DELETE
	JRST FORWRD		;ELSE JUST MOVE TO END
	JRST DELETE

ADZERO:	MOVE T,B
	HRRZ B,(B)
	JUMPN B,.-2
	MOVE TT,1(T)
	TRNN TT,376
	POPJ P,
	GETFS (TT)
	SETZM 1(TT)
	SETZM (TT)
	HRRM TT,(T)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                           COMMENT    VALID 00007 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(FIND,1)
C00006 00003	ADDLST SUBR
C00012 00004	HERE WE FIND THE NEXT INSTANCE OF WHATEVER
C00017 00005	CLEAR BITS
C00019 00006	FIND TABLES
C00021 00007	MATCH
C00029 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                             VERSION(FIND,1)
;TXTLST SETUP, FIND NEXT
;HERE WE DEFINE THE INDICES FOR WHAT TO FIND

DEFINE %FBLST
<
%FBVAL(BNAM,BODY NAME)	;FIND BODY BY NAME (OR # OF PINS PC)
%FBVAL(BLOC,BODY LOCATION)	;FIND BODY BY LOC
%FBVAL(BDIP,DIP TYPE NAME)	;FIND BODY BY DIP NAME
%FBVAL(PLOC,CONNECTOR OR DIP PIN LOCATION)	;FIND POINT BY LOC (CPIN)
%FBVAL(PTXT,TEXT)		;FIND POINT BY TEXT
MD,<
%FBVAL(PSIG,SIGNAL NAME)	;FIND SIGNAL NAME
%FBVAL(LNAM,LIBRARY BODY NAME)	;FIND LIBRARY BODIES
%FBVAL(LDIP,LIBRARY BODY DIP TYPE NAME)	;FIND LIBRARY BODIES BY DIP TYPE
%FBVAL(LPIN,LIBRARY BODY DEFAULT PIN LOCATION)
%FBVAL(LTXT,LIBRARY BODY TEXT)
%FBVAL(LPRP,LIBRARY BODY PROPERTY NAME)
%FBVAL(BTXT,BODY TEXT)
%FBVAL(BPRP,BODY PROPERTY NAME)
>;MD
>

;GENERATE INDICES
DEFINE %FBVAL $ (A,B)
<	%F$A__%FBIND
	%FBIND__%FBIND+1
>

%FBIND__0
%FBLST


DEFINE %FBVAL $ (A,B)
<FN$A:	JSP H,FNDALL
>

FINDTB:
	%FBLST

DEFINE %FBVAL (A,B)
<	[ASCIZ/B/]
>

%PROMPT:%FBLST

MD,<
FNLPN0:	MOVEI T,1
	LSH T,@MODE
	TDNN T,[1EDTPM]		;MUST BE IN CORRECT MODE BEFORE DISPATCHING THROUGH NORMAL ENTRY
	JRST PERRET
	JRST FNLPIN
>;MD

FNDALL:	MOVEI H,-FINDTB-1(H)		;GENERATE INDEX
	TLNE M,DSKACT!MACACT
	JRST NPRMPT
	OUTSTR[ASCIZ/
/]
	OUTSTR @%PROMPT(H)
	OUTSTR[ASCIZ/ SEARCH STRING?/]
NPRMPT:	PUSHJ P,GETLIN
	CAIN C,12
	JRST [	SKIPN @FSTRTB(H)	;HE WANTS OLD, IS THERE ONE?
		JRST PERRET
		JRST DOFND]
	GETFS(B)
	MOVE A,B
	ADD A,[POINT 7,1]
	SETZM (B)
	SETZM 1(B)
	MOVE D,C		;SAVE OTHER CHAR
	MOVEI C,BELCHR		;GET BEGIN LINE CHAR
	XCT DLMTAB(H)		;STUFF IN DELIMITER IF NEEDED
	MOVE C,D
FNREAD:	CAIN C,ALTMOD
	JRST PUTFS		;ALTMODE, FLUSH STRING
	PUSHJ P,FNPUT
	PUSHJ P,GETLIN
	CAIE C,12
	JRST FNREAD
	MOVEI C,BELCHR
	XCT DLMTAB(H)		;CHECK FOR ANOTHER
	SETZ C,
	PUSHJ P,FNPUT		;PUT ZERO AT END
	EXCH B,@FSTRTB(H)	;REPLACE OLD WITH NEW
	PUSHJ P,PUTFS		;GIVE BACK OLD STRING
DOFND:	SETZM FIND
	SKIPE E,@LSTTAB(H)
	PUSHJ P,ADDLST
MPC,<	SKIPE E,@LSTTB2(H)
	PUSHJ P,ADDLST
>;MPC
FNDCNT:	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,PTFNDN
	SETOM FIND
	TLNE M,DSKACT!MACACT
	POPJ P,
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ ITEMS FOUND!
/]
	POPJ P,

PTFNDN:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NO MATCHES FOUND!
/]
	POPJ P,

FNPUT:	TLNE A,760000
	JRST FNPUT1
	GETFS(T)
	HRRM T,-1(A)
	HRR A,T
	SETZM (T)
	SETZM 1(T)
FNPUT1:	IDPB C,A
	POPJ P,
                                                                                                                                                        ;ADDLST SUBR
ADDLST:	PUSH P,E
	PUSHJ P,@ADDCLR(H)	;CLEAR BITS FIRST
	POP P,E
ADDISP:	JRST @ATHING(H)

MD,<
ADPSIG:	MOVE A,FPSSTR
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
ADPSG1:	HLRZ F,(E)
	HRRZ F,1(F)
	HLRZ A,(F)
	JUMPE A,ADPSG2
	HRRZ A,(A)
	ADD A,[POINT 7,1]
	MOVEI B,SIGTAB
	PUSHJ P,SIGMAT
	JRST ADPSG2
	JFCL
	AOS FIND
	MOVSI T,FOUNDP
	IORM T,1(F)
ADPSG2:	HRRZ E,(E)
	JUMPN E,ADPSG1
	POPJ P,
>;MD

ADPTXT:	HLRZ F,(E)
	HRRZ F,1(F)
	HLRZ A,(F)
	JUMPE A,ADTXTX
	HRRZ A,(A)		;ACTUAL TEXT POINTER
	HRRZS (P)		;CLEAR THING TO RETURN
ADTXTT:	MOVE T,@FSTRTB(H)	;SEARCH STRING
	PUSHJ P,MATCHS
	JRST ADTXTE		;NO MATCH
	AOS FIND
	MOVSI T,FOUNDP
	IORM T,1(F)		;TURN BIT ON IN BITS
ADTXTE:	HLRZ B,(P)
	SKIPE B
	PUSHJ P,PUTFS		;GIVE BACK TEMP STRING
ADTXTX:	HRRZ E,(E)		;NEXT POINT OR BODY
	JUMPN E,ADDISP		;GO BACK TO CORRECT ROUTINE
	POPJ P,

ADPLOC:	HLRZ D,(E)
	HRRZ F,1(D)
	MOVE B,F
	HLL B,1(B)
	PUSHJ P,SETTT7		;SETUP TO MAKE STRING
	HRLM A,(P)		;SAVE POINTER TO TEMP STRING
	PUSHJ P,STFPLC		;USE STUFF ROUTINE IN POINT
	JRST ADTXTE		;GIVE BACK STRING AND LOOP
	JRST ADTXTT		;DO COMPARE

MD,<
ADBDIP:
ADBNAM:	HLRZ F,(E)
	HRRZS (P)		;NOTHING TO GIVE BACK
	CAIN H,%FBDIP
	JRST [	MOVE A,E
		PUSHJ P,FNDDIP
		JRST ADTXTE
		HLRZ A,(T)
		HRRZ A,(A)
		JRST ADBNM0]
	HRRZ A,1(F)		;TYPE POINTER
	HRRZ A,(A)
ADBNM0:
>;MD
MPC,<
ADBDIP:	HLRZ F,(E)
	HLRZ A,1(F)
	HRRZ A,1(A)		;DIP TYPE NAME
	JUMPE A,ADTXTE		;IF ANY
>;MPC
ADBNM1:	MOVE T,@FSTRTB(H)
	PUSHJ P,MATCHS
	JRST ADTXTE
	HLRZ F,1(F)
	MOVSI T,FOUNDB
	IORM T,1(F)
	AOS FIND
	JRST ADTXTE

ADBLOC:	PUSHJ P,SETTT7
	HRLM A,(P)
	HLRZ F,(E)
	HLRZ D,1(F)
MD,<	HRRZ D,(D)
	JUMPE D,ADBNM1
	HLRZ D,(D)
>;MD
MPC,<	HRRZ T,(D)
	JUMPE T,ADBNM1
>;MPC
	PUSHJ P,STFBLC
	JRST ADBNM1

MPC,<
ADBNAM:	HLRZ F,(E)
	HRRZ D,1(F)
	PUSHJ P,SETTT7
	HRLM A,(P)
	PUSHJ P,STFNAM		;MAKE # OF PINS STRING (ALSO SEPERATION IF 2 PINS)
	JRST ADBNM1
>;MPC

MD,<
ADLDIP:
ADLNAM:	HLRZ T,(E)
	JUMPN T,ADLNME		;SKIP LIBRARY BODIES SINCE THEY MAY NOT BE READ IN
	CAIN H,%FLDIP
	JRST [	MOVE A,E
		MOVEI TT,[ASCIZ/DIPTYPE/]
		PUSHJ P,ASCCOP
		PUSHJ P,FPROP
		JRST [	MOVE B,T
			PUSHJ P,PUTFS
			JRST ADLNME]
		HLRZ A,(T)
		HRRZ A,(A)		;GET VALUE STRING
		JRST ADLNM1]
	HRRZ A,(E)		;GET BODY NAME
ADLNM1:	JUMPE A,ADLNME		;UNLESS NONE
	MOVE T,@FSTRTB(H)	;GET SEARCH STRING
	PUSHJ P,MATCHS		;COMPARE
	JRST ADLNME		;NO MATCH
	HLRZ F,1(E)
	HLRZ F,(F)		;POINTER TO BITS WORD
	MOVSI T,FOUNDL
	IORM T,(F)		;MARK FOUND BODY DEF
	AOS FIND		;AND COUNT IT
ADLNME:	HRRZ E,1(E)		;LOOK AT ALL OF THEM
	JUMPN E,ADLNAM
	POPJ P,

ADLPIN:	HLRZ E,1(E)
	JRST ADLPN1

ADLPN2:	HLRZ T,(E)
	PUSHJ P,SETTT
	HRLI TT,(<POINT 7,0>)
	MOVEM TT,TTPTR
	HRLM A,(P)
	PUSHJ P,OUTPID
	MOVE T,@FSTRTB(H)
	HLRZ A,(P)		;CLOBBERED BY OUTPID
	PUSHJ P,MATCHS
	JRST ADLPN3
	HLRZ F,(E)
	MOVSI T,FOUNDD
	IORM T,(F)
	AOS FIND
ADLPN3:	HLRZ B,(P)
	PUSHJ P,PUTFS
ADLPN1:	HRRZ E,(E)
	JUMPN E,ADLPN2
	POPJ P,

ADBPRP:
ADBTXT:	HLRZ E,(E)
	HLRZ E,1(E)
	HRRZ E,1(E)
	JRST ADBLPT

ADLPRP:
ADLTXT:	HLRZ E,1(E)
	HLRZ E,1(E)
ADBLPT:	JUMPE E,CPOPJ
ADLTX1:	HLRZ A,(E)
	JUMPE A,ADLTX2		;JUMP IF THIS IS INDIRECT BLOCK
	CAIE H,%FBPRP
	CAIN H,%FLPRP
	JRST [	HLRZ A,(A)
		JUMPE A,ADLTX2
		JRST ADLTX3]
	HRRZ A,(A)
	HLRZ T,(A)
	TLNN M,%IDENT
	JUMPE T,ADLTX2
ADLTX3:	MOVE T,@FSTRTB(H)
	PUSHJ P,MATCHS
	JRST ADLTX2
	MOVSI T,1
	IORM T,1(E)		;MARK THIS ONE FOUND
	AOS FIND
ADLTX2:	HRRZ E,(E)
	JUMPN E,ADLTX1
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                              ;HERE WE FIND THE NEXT INSTANCE OF WHATEVER
FNEXTP:
MPC,<	MOVEI T,1
	LSH T,@MODE
	TDNN T,[1PNTM!1TXTM]
	JRST PERRET
>;MPC
	SETZB F,FIND		;NOTHING FOUND YET
	SKIPE A,PONPNT
	PUSHJ P,FNNXTP
	SKIPE F
	JRST IFNDP
MPC,<	SKIPE A,PONPN2
	PUSHJ P,FNNXTP
	SKIPE F
	JRST IFNDP
>;MPC
NOFNDA:	TLNN M,DSKACT!MACACT
	JRST PERRET
	POPJ P,

IFNDP:
MPC,<	HLRZ T,(F)
	HRRZ T,1(T)
	MOVE T,1(T)
	EQV T,SID
	JUMPL T,NOSIDC
	SWITCH
	TRO MCHG!NEEDCL
NOSIDC:
>;MPC
	TRZ INMOV!INLIN
	HLRZ T,(F)
	HRRZ T,1(T)
	MOVSI TT,FOUNDP
	ANDCAM TT,1(T)
IFNDBA:	SETOM FIND
	MOVE T,F
	JRST SCLOSP		;SET AS CLOSEST, AND MOVE THERE

FNEXTB:	SETZB F,FIND
	SKIPN A,DBODPN
	JRST NOFNDA
FNNXTB:	HLRZ T,(A)
	HLRZ T,1(T)
	MOVE T,1(T)
	TLNN T,FOUNDB
	JRST FNXTB2
	MOVE F,A
	TLNE M,DSKACT!MACACT
	JRST IFNDB		;WIN IMMEDIATELY IF IN DSKIN OR MACRO
	MOVE T,1(A)
	PUSHJ P,ONSCR
	CAIA
	JRST IFNDB
FNXTB2:	HRRZ A,(A)
	JUMPN A,FNNXTB
	JUMPE F,NOFNDA
IFNDB:	TRZ INMOV!INLIN
	HLRZ T,(F)
	HLRZ T,1(T)
	MOVSI TT,FOUNDB
	ANDCAM TT,1(T)
	JRST IFNDBA

FNNXTP:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNN T,FOUNDP
	JRST FNXTP1
	MOVE F,A
	TLNE M,DSKACT!MACACT
	JRST CPOPJ1		;WIN IMMEDIATELY IF IN DSKIN OR MACRO
	MOVE T,1(A)
	PUSHJ P,ONSCR
	CAIA
	JRST CPOPJ1
FNXTP1:	HRRZ A,(A)
	JUMPN A,FNNXTP
	POPJ P,

MD,<
FNEXTL:	MOVEI T,1
	LSH T,@MODE		;GET CURRENT MODE AS BIT
	TDNN T,[1BTXTM!1SETM!1PNTM!1TXTM!1LINM!1BODM]
	JRST PERRET		;CAN'T GET TO EDIT MODE FROM HERE
	SKIPN A,BODPNT
	JRST NOFNDA
FNNXTL:	HLRZ T,1(A)
	JUMPE T,FNXTL2		;GET NEXT IF NO DEF HERE
	HLRZ T,(T)
	MOVE TT,(T)		;BODY DEF BITS
	TLZE TT,FOUNDL		;BIT ON?
	JRST FNXTL1		;YES, STORE BACK WITH BIT OFF
FNXTL2:	HRRZ A,1(A)
	JUMPN A,FNNXTL
	JRST NOFNDA

FNXTL1:	MOVEM TT,(T)
	SETOM FIND
	JRST ALREAD		;EDIT BODY IN A

FNEXBP:	MOVEI T,1
	LSH T,@MODE
	TDNN T,[1EDTPM]
	JRST PERRET
	SETZB F,FIND
	MOVE A,CURBOD
	HLRZ A,1(A)
	JRST FNXBP1

FNXBP2:	HLRZ T,(A)
	HLRZ T,(T)
	TRNN T,FOUNDD
	JRST FNXBP1
	MOVE F,A
	TLNE M,DSKACT!MACACT
	JRST FNXBP3
	MOVE T,1(A)
	PUSHJ P,ONSCR
	CAIA
	JRST FNXBP3
FNXBP1:	HRRZ A,(A)
	JUMPN A,FNXBP2
	JUMPE F,NOFNDA
FNXBP3:	TRZ INMOV
	HLRZ T,(F)
	MOVSI TT,FOUNDD
	ANDCAM TT,(T)
	JRST IFNDBA

FNEXBT:	MOVE A,BTBODY
	MOVEM A,CLXY		;SAVE BODY POINTER HERE
	HLRZ A,(A)
	HLRZ A,1(A)
	HRRZ A,1(A)
	JRST FNEXLB

FNEXLT:	MOVE A,CURBOD
	SETZM CLXY
	HLRZ A,1(A)
	HLRZ A,1(A)
FNEXLB:	SETZB F,FIND
	JUMPE A,NOFNDA
FNXBT1:	MOVE T,1(A)
	TLNN T,1		;MARKED?
	JRST FNXBT2		;NO
	HLRZ TT,(A)
	HRRZ TT,(TT)
	HLRZ TT,(TT)
	TLNN M,%IDENT
	JUMPE TT,FNXBT2		;ONLY VISIBLE ONES
	MOVE F,A
	TLNN M,DSKACT!MACACT
	JRST FNXBT3
	MOVE T,1(A)
	TDZ T,[1,,1]
	SKIPN TT,CLXY
	JRST FNXBT4
	PUSH P,F
	HLRZ F,(TT)
	HLRZ F,(F)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TT)>)
FNXBT4:	PUSHJ P,ONSCR
	CAIA
	JRST FNXBT3
FNXBT2:	HRRZ A,(A)
	JUMPN A,FNXBT1
	JUMPE F,NOFNDA
FNXBT3:	TRZ INMOV
	MOVSI TT,1
	ANDCAM TT,1(F)		;CLEAR MARK BIT
	JRST IFNDBA
>;MD
                                                                                                                                                                                              ;CLEAR BITS
ACLRP:	HLRZ T,(E)
	HRRZ T,1(T)
	MOVSI TT,FOUNDP
	ANDCAM TT,1(T)
	HRRZ E,(E)
	JUMPN E,ACLRP
	POPJ P,

ACLRB:	HLRZ T,(E)
	HLRZ T,1(T)
	MOVSI TT,FOUNDB
	ANDCAM TT,1(T)
	HRRZ E,(E)
	JUMPN E,ACLRB
	POPJ P,

MD,<
ACLRL:	HLRZ T,1(E)
	JUMPE T,ACLRL1
	HLRZ T,(T)
	MOVSI TT,FOUNDL
	ANDCAM TT,(T)
ACLRL1:	HRRZ E,1(E)
	JUMPN E,ACLRL
	POPJ P,

ACLRLP:	HLRZ E,1(E)
	MOVSI TT,FOUNDD
	JRST ACLLP2

ACLLP1:	HLRZ T,(E)
	ANDCAM TT,(T)
ACLLP2:	HRRZ E,(E)
	JUMPN E,ACLLP1
	POPJ P,

ACLRBT:	HLRZ E,(E)
	HLRZ E,1(E)
	HRRZ E,1(E)
	JRST ACLRLB

ACLRLT:	HLRZ E,1(E)
	HLRZ E,1(E)
ACLRLB:	JUMPE E,CPOPJ
	MOVSI TT,1
ACLBT1:	ANDCAM TT,1(E)
	HRRZ E,(E)
	JUMPN E,ACLBT1
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;FIND TABLES
DLMTAB:	JFCL
	PUSHJ P,FNPUT
	JFCL
	PUSHJ P,FNPUT
	JFCL
MD,<	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
	JFCL
>;MD

LSTTAB:	DBODPN
	DBODPN
	DBODPN
	PONPNT
	PONPNT
MD,<	PONPNT
	BODPNT
	BODPNT
	CURBOD
	CURBOD
	CURBOD
	BTBODY
	BTBODY
>;MD
FSTRTB:	FBNSTR
	FBLSTR
	FBDSTR
	FPLSTR
	FPTSTR
MD,<	FPSSTR
	FLNSTR
	FLDSTR
	FLPSTR
	FLTSTR
	FLRSTR
	FBTSTR
	FBRSTR
>;MD
MPC,<
LSTTB2:	[0]
	[0]
	[0]
	PONPN2
	PONPN2
>;MPC

ADDCLR:	ACLRB
	ACLRB
	ACLRB
	ACLRP
	ACLRP
MD,<	ACLRP
	ACLRL
	ACLRL
	ACLRLP
	ACLRLT
	ACLRLT
	ACLRBT
	ACLRBT
>;MD

DEFINE %FBVAL $ (A)
<	AD$A
>

ATHING:
	%FBLST
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;MATCH
MATCHS:	MOVEM T,ALTSTR			;SAVE SEARCH STRING
	SETOM BEGLIN
	ADD A,[POINT 7,1]		;WILL ILDB TO FIRST CHR
	JRST MATCHZ

MATCH:	TLNN A,760000
	JRST [	HRR A,-1(A)
		TRNN A,-1
		POPJ P,
		JRST .+1]
	IBP A				;ADVANCE PAST LAST MATCH
MATCHZ:	AOS FSTART
	SKIPN BEGLIN			;AT BEGINNING?
	JRST MATCH1			;NO, NO BEGIN LINE CHECK
NODEC,<	TRNE M,SEXACT			;EXACT MATCH?
	JRST MATCH0			;YES, NO SPECIAL CHECK
	MOVE TTT,A
	ILDB T,TTT			;GET FIRST 2 CHARS
	ILDB TT,TTT
	CAIE T,NOT
	JRST [	CAIN T,TILDA
		CAIE TT,NOT
		JRST MATCH0
		JRST MATCHX]
	CAIE TT,TILDA
	JRST MATCH0
MATCHX:	MOVE A,TTT			;SKIP THESE CHARS
	AOS FSTART
	AOS FSTART
>;NODEC
MATCH0:	MOVE C,ALTSTR
	LDB C,[POINT 7,1(C),6]		;GET FIRST CHAR
	CAIN C,BELCHR			;BEGIN LINE CHAR?
	JRST MATCHB			;TRY TO MATCH BEGINNING
MATCH1:	SETZM FLEN			;NO CHARS MATCHED YET
	MOVE B,ALTSTR
	ADD B,[POINT 7,1]
	TRNE M,SPACES
	JRST DOMAT
	MOVE T,A
NOMAT:	TLNN T,760000
	JRST [	HRR T,-1(T)
		TRNN T,-1
		JRST DOMAT		;NO MORE
		JRST .+1]
	ILDB TT,T
	CAIE TT,DBLARR
	CAIN TT," "
	JRST [	MOVE A,T		;DON'T START ON SPACE
		AOS FSTART		;COUNT A CHAR SKIPPED
		JRST NOMAT]		;TRY FOR ANOTHER
DOMAT:	PUSH P,A			;SAVE FOR BACKUP
	PUSHJ P,TRYMAT			;CALL MATCH SUBR
	JRST [	POP P,A
		JRST CPOPJ1]		;MATCHED
	POP P,A
	SETZM BEGLIN			;NO LONGER BEGINNING OF STRING
	SETZM FLEN			;USE THIS TO COUNT FSTART
	PUSHJ P,GETA			;MOVE FORWARD IN STRING
	JFCL				;TO GET COUNT
	MOVE T,FLEN			;THIS IS HOW MANY REAL CHARS WE MOVED
	ADDM T,FSTART			;OVER TO GET TO NEXT LOGICAL ONE
	JUMPN C,MATCH1			;GO ON IF NOT EOL
	POPJ P,				;EOL, NO MATCH, FSTART IS COUNT TO END

MATCHB:	MOVE B,ALTSTR
	ADD B,[POINT 7,1,6]		;SKIP FIRST CHAR
	SETZM FLEN
	PUSHJ P,TRYMAT			;TRY TO MATCH REST
	AOS (P)				;MATCH
	POPJ P,				;NO MATCH

TRYMAT:	PUSHJ P,GETB
	POPJ P,
	CAIN D,INFCHR			;ANY # OF NEXT CHAR
	JRST INFCHK
	PUSHJ P,MATCHD
	JRST TRYMAT			;MATCH, TRY SOME MORE
	JRST CPOPJ1			;NO MATCH

MATCHA:	PUSHJ P,GETB			;GET A CHAR FROM MATCH STRING
	POPJ P,				;END OF MATCH STRING, THIS IS MATCH
MATCHD:	CAIN D,BELCHR			;END OF LINE CHAR?
	JRST EOLCHK
	CAIN D,NFCHR			;NOT CHAR?
	JRST NOTCHK
	CAIN D,ANYCHR			;ANY CHAR?
	JRST ANYCHK
	CAIN D,QUOCHR			;QUOTE NEXT CHAR
	JRST QUOCHK
	CAIN D,LETCHR		;LETTER?
	JRST LETCHK
	CAIN D,DIGCHR		;DIGIT?
	JRST DIGCHK
	CAIN D,ALFCHR		;ALPHANUMERIC?
	JRST ALFCHK
MATCHC:	PUSHJ P,GETA
	JRST CPOPJ1			;EOL, NO MATCH
	CAME C,D
	AOS (P)				;NO MATCH
	POPJ P,

LETCHK:	PUSHJ P,GETA
	JRST CPOPJ1
LETCK1:	CAIL C,"A"
	CAILE C,"z"
	JRST CPOPJ1
	CAIGE C,"a"
	CAIG C,"Z"
	POPJ P,
	JRST CPOPJ1

DIGCHK:	PUSHJ P,GETA
	JRST CPOPJ1
DIGCK1:	CAIL C,"0"
	CAILE C,"9"
	AOS (P)
	POPJ P,

ALFCHK:	PUSHJ P,GETA
	JRST CPOPJ1
	PUSHJ P,DIGCK1		;CHECK FOR DIGIT
	POPJ P,			;MATCH
	JRST LETCK1		;NO, TRY LETTER

EOLCHK:	PUSHJ P,GETA
	POPJ P,				;EOL, OK
	JRST CPOPJ1			;NO MATCH

NOTCHK:	PUSHJ P,MATCHA			;TRY THE FOLLOWING MATCH
					;NOTE: WE DISALLOW 
	AOS (P)				;MATCH, NO MATCH
	POPJ P,

ANYCHK:	PUSHJ P,GETA
	AOS (P)				;EOL, NO MATCH
	POPJ P,

QUOCHK:	PUSHJ P,GETB
	POPJ P,				;EOL, MATCH
	JRST MATCHC			;SKIP SPECIAL CHECK

INFCHK:	PUSH P,B			;SAVE MATCH STRING POINTER FOR BACKUP
INFCK1:	PUSHJ P,MATCHA			;TRY NEXT CHAR
	CAIA				;MATCH
	JRST [	POP P,(P)		;NO MATCH POSSIBLE
		JRST CPOPJ1]
	PUSH P,A			;SAVE BOTH STRING POINTER
	PUSH P,FLEN			;AND SUBSTR LENGTH
	PUSHJ P,TRYMAT			;TRY TO MATCH THE REST
	JRST [	POP P,(P)
		POP P,(P)
		POP P,(P)
		POPJ P,]		;PERFECT MATCH
	POP P,FLEN
	POP P,A				;BACKUP THESE POINTERS
	MOVE B,(P)
	JRST INFCK1			;TRY A FURTHER MATCH ON STRING

GETA:	AOS FLEN			;COUNT A CHAR SCARFED
	TLNN A,760000			;STRING OUT?
	JRST [	TRNE A,-1
		HRR A,-1(A)
		TRNE A,-1
		JRST .+1
		SETZ C,
		POPJ P,]
	ILDB C,A
	JUMPE C,CPOPJ			;NULL IS EOL
	TRNE M,SPACES
	JRST GETA1
	CAIE C,DBLARR
	CAIN C," "
	JRST GETA
GETA1:	TRNE M,SEXACT
	JRST CPOPJ1
	CAIN C,DBLARR
	JRST [	MOVEI C," "
		JRST CPOPJ1]
NODEC,<	CAIN C,TILDA
	JRST [	MOVEI C,NOT
		JRST CPOPJ1]
>;NODEC
	CAIL C,"a"
	CAILE C,"z"
	JRST CPOPJ1
	SUBI C,40
	JRST CPOPJ1

GETB:	TLNN B,760000
	HRR B,-1(B)
	ILDB D,B
	JUMPE D,CPOPJ			;NULL IS EOL
	TRNE M,SPACES
	JRST GETB1
	CAIE D,DBLARR
	CAIN D," "
	JRST GETB
GETB1:	TRNE M,SEXACT
	JRST CPOPJ1
	CAIN D,DBLARR
	JRST [	MOVEI D," "
		JRST CPOPJ1]
NODEC,<	CAIN D,TILDA
	JRST [	MOVEI D,NOT
		JRST CPOPJ1]
>;NODEC
	CAIL C,"a"
	CAILE C,"z"
	JRST CPOPJ1
	SUBI C,40
	JRST CPOPJ1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          COMMENT    VALID 00008 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(REP,1)
C00008 00003	SAMEDN:	MOVE G,NEWTYP
C00010 00004	REPLACE BY GEOMETRIC OVERLAY
C00012 00005	GEOMETIC OVERLAY FOR DIFF NUMBER OF PINS
C00015 00006	MAP BY DEFAULT PIN NAMES
C00020 00007	REPONE:	PUSHJ P,GETCLS
C00023 00008	REPIT:	PUSH P,G
C00029 ENDMK
C;
                                                                                                                                                                                                                                                                                        VERSION(REP,1)
REPLST:	SKIPE B,CORLST
	PUSHJ P,PUTFS
	SETZM CORLST
	MOVEI G,CORLST	;POINT TO IT
	MOVE A,OLDTYP
MD,<	HLRZ A,1(A)	>
MPC,<	ADDI A,1	>
	JRST CORPIN

CORNXT:	GETFS(T)
	SETZM 1(T)
	HRRM T,(G)	;LINK NEW BLOCK
	MOVE G,T
	HRLZM A,(G)	;SAVE TYPE PIN POINTER
CORPIN:	HRRZ A,(A)
	JUMPN A,CORNXT
	POPJ P,

REPSET:	MOVEM A,OLDTYP
MD,<	MOVEI T,[ASCIZ/TYPE NEW BODY NAME
/]
>;MD
	PUSHJ P,BODYGT
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	JRST OOPS1		;NX
	MOVEM A,NEWTYP
REPST1:	PUSHJ P,REPLST		;INTIALIZE CORLST
MD,<	MOVE T,[ASCID/BR/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM
	MOVEI T,UPREP
	MOVEM T,SPDISP
	PUSHJ P,PUSHM		;SET PIN IDS ON
	PUSH P,H
	PUSHJ P,REPAGN
	CAIA
	AOS -1(P)
	POP P,H
	PUSHJ P,POPM		;RESTORE STATE OF PIN IDS
	JRST RCHNGM		;RESTORE OLD MODE
>;MD
REPAGN:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/REPLACEMENT MODE (H FOR HELP)?/]
MD,<	SETZM KEEPIN		;CLEAR KEEP PINS FLAG
	SETZM COPPRP
>;MD
MAINTP:	PUSHJ P,GETCHR
	CAIL C,"A"+40
	CAILE C,"Z"+40
	CAIA
	SUBI C,40
	CAIE C,12
	TLNE M,DSKACT!MACACT
	CAIA
	OUTSTR[ASCIZ/
/]
	CAIE C,"H"
	CAIN C,"?"
	JRST [	TLNN M,DSKACT!MACACT
MD,<		OUTSTR[ASCIZ/CHAR	MODE
E	EXACT MATCH BY DEFAULT PIN NAME
N	CLOSEST MATCH BY DEFAULT PIN NAME
L	EXACT GEOMETRIC OVERLAY
C	CLOSEST GEOMETRIC OVERLAY
<CR>	ASK ABOUT EACH PIN
<ALT>	ABORT
M	MAINTAIN PIN NAMES (PRECEEDS OTHER COMMANDS)
P	COPY BODY TEXT AND PROPERTIES
/]
>;MD
MPC,<		OUTSTR[ASCIZ/CHAR	MODE
N	MATCH BY PIN #
L	EXACT GEOMETRIC OVERLAY
C	CLOSEST GEOMETRIC OVERLAY
<CR>	ASK ABOUT EACH PIN
<ALT>	ABORT
/]
>;MPC
		JRST MAINTP]
MD,<	CAIN C,"M"
	JRST [	SETOM KEEPIN
		TLNN M,DSKACT!MACACT
		OUTSTR[ASCIZ/MAINTAINING PIN NAMES./]
		JRST MAINTP]
	CAIN C,"P"
	JRST [	SETOM COPPRP
		TLNN M,DSKACT!MACACT
		OUTSTR[ASCIZ/COPYING PROPERTIES AND TEXT./]
		JRST MAINTP]
>;MD
	CAIN C,ALTMOD
	POPJ P,
MPC,<	CAIN C,"N"
	JRST SAME
>;MPC
MD,<	CAIN C,"N"
	JRST CNMAT
	CAIN C,"E"
	JRST ENMAT
>;MD
	CAIN C,"L"
	JRST REPLOC
	CAIN C,"C"
	JRST REPCLS		;MORE FORGIVING THAN L
	CAIE C,12
	JRST [	PUSHJ P,PERRET
		JRST REPAGN]
	MOVEI G,CORLST
	TLNN M,DSKACT!MACACT
MD,<	OUTSTR[ASCIZ/TYPE CORRESPONDENCE FOR PIN ID'S.
/]
>;MD
MPC,<	OUTSTR[ASCIZ/TYPE CORRESPONDENCE FOR PIN NAMES.
/]
>;MPC
	JRST GETIN

GETPIN:	TLNE M,DSKACT!MACACT
	JRST NOTALK
MD,<	OUTSTR[ASCIZ/OLD PIN ID /]	>
MPC,<	OUTSTR[ASCIZ/OLD PIN NAME /]	>
	HLRZ T,(G)
	HLRZ T,(T)
MD,<	HRRZ T,(T)
	PUSHJ P,DECOUT		;PRINT PIN ID
>;MD
MPC,<	MOVSI A,(T)
	PUSH P,PUTCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,PINPLS
	POP P,PUTCHR
>;MPC
	OUTSTR[ASCIZ/=/]
NOTALK:
MPC,<	MOVE C,[PUSHJ P,GETLCH]
	MOVEM C,GTCHRX
	PUSHJ P,RPNAM
	CAIA
>;MPC
MD,<	PUSHJ P,READN	>
	CAIE C,12
	JRST [	PUSHJ P,SCARF
		JRST REPST1
		JRST GETPIN]
	SETZ A,
	JUMPE T,NEWOK
	MOVEI A,CORLST
	JRST CHKNUM

CHKNXT:	HLRZ TT,1(A)
	CAMN TT,T
	JRST [	TLNN M,DSKACT!MACACT
		OUTSTR[ASCIZ/ALREADY USED!
/]
		JRST GETPIN]
CHKNUM:	HRRZ A,(A)
	JUMPN A,CHKNXT
	MOVE A,NEWTYP
MD,<	HLRZ A,1(A)	>
MPC,<	ADDI A,1	>
	JRST NEWCHK

NEWNXT:	HLRZ TT,(A)
MD,<	HRRZ TT,(TT)	>
	CAMN TT,T
	JRST NEWOK
NEWCHK:	HRRZ A,(A)
	JUMPN A,NEWNXT
	TLNN DSKACT!MACACT
	OUTSTR[ASCIZ/NO SUCH PIN IN NEW TYPE!
/]
	JRST GETPIN

NEWOK:	HRLM T,1(G)
	HRRM A,1(G)	;SAVE PIN ID AND POINTER TO BLOCK IN TYPE
GETIN:	MOVE H,G
	HRRZ G,(G)
	JUMPN G,GETPIN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      SAMEDN:	MOVE G,NEWTYP
MD,<	HLRZ G,1(G)	>
MPC,<	ADDI G,1	>
	JRST REPNW1

REPNEW:	GETFS(T)
	HRRZM G,1(T)
	EXCH T,CORLST
	HRRZM T,@CORLST
REPNW1:	HRRZ G,(G)
	JUMPE G,CPOPJ1
	MOVEI A,CORLST
	HLRZ T,(G)
MD,<	HRRZ T,(T)	>
	JRST REPNW2

REPNW3:	HLRZ TT,1(A)
	CAMN TT,T
	JRST REPNW1
REPNW2:	HRRZ A,(A)
	JUMPN A,REPNW3
	JRST REPNEW

MPC,<
SAME:	SKIPN G,CORLST	;RUN DOWN CORLST
	JRST SAMEDN
SAME4:	MOVE A,NEWTYP
	ADDI A,1
	HLRZ T,(G)	;OLD PIN ID
	HLRZ T,(T)
	JRST SAME1

SAME2:	HLRZ TT,(A)
	CAME T,TT
	JRST SAME1
	HRRZM A,1(G)	;STUFF IN NEW PIN ID AND POINTER
	HRLM T,1(G)
SAME3:	HRRZ G,(G)
	JUMPE G,SAMEDN
	JRST SAME4

SAME1:	HRRZ A,(A)
	JUMPN A,SAME2
	JRST SAME3
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;REPLACE BY GEOMETRIC OVERLAY

REPCL1:PUSHJ P,REPLST		;INITIALIZE CORLST
MD,<	SETOM KEEPIN		;MAKE SURE WE KEEP PINS>
REPLOC:				;OFFSET CRAP GOES HERE
	PUSHJ P,REPCL4
	JRST RPLERR
	JRST SAMEDN

RPLERR:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
SORRY, NO EXACT GEOMETRIC OVERLAY POSSIBLE.
/]
	JRST REPST1

FCLONE:	SETZM CURPIN		;NO CLOSEST YET!
	HRLOI T,77777		;LARGE NUMBER
	MOVEM T,CURDIS		;CURRENT CLOSEST DISTANCE
REPL3:	SKIPE 1(G)		;HAVE WE FOUND THIS ONE YET?
	JRST REPL2		;YES, SKIP IT
	HLRZ T,(G)		;POINTER TO OLD PIN TYPE BLOCK
	MOVE T,1(T)		;OLD PIN LOC
	ADJUST(SUB,T,<1(A)>)
	HLRE TT,T
	HRRES T
	IMUL T,T
	IMUL TT,TT
	ADD T,TT		;SQUARE OF DISTANCE
	CAML T,CURDIS		;SMALLER?
	JRST REPL2		;NO
	MOVEM T,CURDIS		;UPDATE
	MOVEM G,CURPIN
REPL2:	HRRZ G,(G)		;ANOTHER MEMBER OF CORLST
	JUMPN G,REPL3
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;GEOMETIC OVERLAY FOR DIFF NUMBER OF PINS
%MAX__20	;MAX SEPARATION BETWEEN PINS IN ORDER TO MATCH!

REPCLS:
				;OFFSET STUFF GOES HERE
	PUSHJ P,REPCL4
	JFCL			;THIS VERSION DOESN'T CARE
	JRST SAMEDN

REPCL4:	SKIPN CORLST
	POPJ P,
	MOVE A,NEWTYP
MD,<	HLRZ A,1(A)
	HRRZ A,(A)
>;MD
MPC,<	HRRZ A,1(A)	>
	JUMPE A,CPOPJ
	HRLOI B,77777
	SETZ H,			;NONE FOUND YET
REPCL2:
MPC,<	HLL A,(A)	>	;GET PIN ID ALSO
MD,<	HLRZ T,(A)
	HRL A,(T)		;PIN ID ALSO
>;MD
	TRZ TFLG
	MOVE G,CORLST		;GET CORLST
REPCL5:	CAMN A,1(G)		;IS IT MAPPED YET?
	JRST REPCL3		;YES, TRY ANOTHER
	HRRZ G,(G)
	JUMPN G,REPCL5
	TRO TFLG		;FLAG UN-MAPPED NEW PIN SEEN
	MOVE G,CORLST		;NOT USED YET, CHECK DISTANCE
	PUSHJ P,FCLONE		;FIND ONE
	SKIPN CURPIN		;DID WE FIND ONE
	POPJ P,			;NO, RAN OUT OF CORLST I GUESS
	CAMG B,CURDIS		;IS IT CLOSEST YET?
	JRST REPCL3		;NO
	MOVE B,CURDIS
	MOVE H,CURPIN		;SAVE CLOSEST YET
	HRL H,A			;SAVE BOTH POINTERS
REPCL3:	HRRZ A,(A)
	JUMPN A,REPCL2		;LOOP THROUGH ALL
	JUMPE H,REPCL6
	CAILE B,%MAX*%MAX	;TO FAR APART?
	POPJ P,
	HLRZ A,H		;GET POINTER TO NEW PIN
MPC,<	HLL A,(A)	>	;AND PIN ID
MD,<	HLRZ T,(A)
	HRL A,(T)		;PIN ID
>;MD
	MOVEM A,1(H)		;AND SAVE HERE
	JRST REPCL4		;LOOP UNTIL ALL ASSIGNED

REPCL6:	TRNE TFLG		;ALL NEW PINS MAPPED?
	POPJ P,			;NO, LOSE RETURN
	MOVE H,CORLST
REPCL7:	SKIPN 1(H)		;THIS OLD PIN MAPPED?
	POPJ P,			;NO, LOSE
	HRRZ H,(H)
	JUMPN H,REPCL7
	JRST CPOPJ1		;ALL OLD PINS MAPPED, WIN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;MAP BY DEFAULT PIN NAMES
MD,<
CNMAT:	PUSHJ P,DONMAT
	JFCL
	JRST SAMEDN

ENMAT:	PUSHJ P,DONMAT
	JRST ENERR
	JRST SAMEDN

ENERR:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SORRY, NO EXACT PIN MATCH POSSIBLE.
/]
	JRST REPST1

DONMAT:	SKIPN CORLST
	POPJ P,
	TRZ TFLG!ATLP
	MOVE A,NEWTYP
	HLRZ A,1(A)
	HRRZ A,(A)
	JUMPE A,CPOPJ
	MOVSI TT,DPTMP1!DPTMP2
DONMT0:	HLRZ T,(A)
	ANDCAM TT,(T)
	HRRZ A,(A)
	JUMPN A,DONMT0
	MOVE A,NEWTYP
	HLRZ A,1(A)
	HRRZ A,(A)
DONMT1:	SETZM CURPIN
	HLRZ TT,(A)
	HLRZ T,(TT)
	TRNE T,DPTMP1
	JRST DONMT6
	ANDI T,BASSLH
	HRL T,1(TT)
	HRRZ B,(A)
	JUMPE B,DONMT3
	TRZ ATFP
DONMT2:	HLRZ TT,(B)
	HLRZ TTT,(TT)
	ANDI TTT,BASSLH
	HRL TTT,1(TT)
	CAMN TTT,T
	JRST [	TRO ATFP
		MOVSI TTT,DPTMP1!DPTMP2
		IORM TTT,(TT)
		JRST .+1]
	HRRZ B,(B)
	JUMPN B,DONMT2
	TRNE ATFP
	JRST DONMTE
DONMT3:	MOVE G,CORLST
DONMT4:	HLRZ TT,(G)
	HLRZ TT,(TT)
	HLRZ TTT,(TT)
	ANDI TTT,BASSLH
	HRL TTT,1(TT)
	CAME TTT,T
	JRST DONMT5
	SKIPE CURPIN
	JRST DONMTE
	MOVEM G,CURPIN
DONMT5:	HRRZ G,(G)
	JUMPN G,DONMT4
	SKIPN G,CURPIN
	JRST [	TRO ATLP
		JRST DONMT6]
	HLRZ T,(A)
	HRL A,(T)
	MOVEM A,1(G)
	JRST DONMTW

DONMTE:	TRO TFLG
	PUSHJ P,DONMRK
DONMTW:	HLRZ T,(A)
	MOVSI TT,DPTMP1
	IORM TT,(T)
DONMT6:	HRRZ A,(A)
	JUMPN A,DONMT1
	TRNN ATLP		;ANY UNMAPPED NEW PINS?
	JRST REPCL6		;NO, CHECK OLD PINS
	MOVE A,NEWTYP
	HLRZ A,1(A)
	HRRZ A,(A)
DONMA1:	SETZM CURPIN
	HLRZ TT,(A)
	HLRZ T,(TT)
	TRNE T,DPTMP2!DPTMP1
	JRST DONMA6
NODEC,<	HRRZ T,1(TT)	>
DEC,<	HLRZ T,(TT)
	ANDI T,BUSSED
	HRL T,1(TT)
>;DEC
	HRRZ B,(A)
	JUMPE B,DONMA3
	TRZ ATFP
DONMA2:	HLRZ TT,(B)
NODEC,<	HRRZ TTT,1(TT)	>
DEC,<	HLRZ TTT,(TT)
	ANDI TTT,BUSSED
	HRL TTT,1(TT)
>;DEC
	CAMN TTT,T
	JRST [	HLRZ TTT,(TT)
		TRNE TTT,DPTMP1
		JRST .+1
		TRO ATFP
		MOVSI TTT,DPTMP2
		IORM TTT,(TT)
		JRST .+1]
	HRRZ B,(B)
	JUMPN B,DONMA2
	TRNE ATFP
	JRST DONMAE
DONMA3:	MOVE G,CORLST
DONMA4:	SKIPE 1(G)
	JRST DONMA5
	HLRZ TT,(G)
	HLRZ TT,(TT)
NODEC,<	HRRZ TTT,1(TT)	>
DEC,<	HLRZ TTT,(TT)
	ANDI TTT,BUSSED
	HRL TTT,1(TT)
>;DEC
	CAME TTT,T
	JRST DONMA5
	SKIPE CURPIN
	JRST DONMA6
	MOVEM G,CURPIN
DONMA5:	HRRZ G,(G)
	JUMPN G,DONMA4
	SKIPN G,CURPIN
	JRST DONMAF
	HLRZ T,(A)
	HRL A,(T)
	MOVEM A,1(G)
	JRST DONMA6

DONMAE:	PUSHJ P,DONMRK
DONMAF:	TRO TFLG
DONMA6:	HRRZ A,(A)
	JUMPN A,DONMA1
	JRST REPCL6

DONMRK:	MOVE B,NEWTYP
	HLRZ B,1(B)
	HRRZ B,(B)
	MOVSI TT,DPTMP2
	HLRZ T,(A)
	HRRZ T,1(T)
	MOVEM T,CURPIN
DONMR1:	HLRZ TTT,(B)
	HRRZ T,1(TTT)
	CAMN T,CURPIN
	IORM TT,(TTT)
	HRRZ B,(B)
	JUMPN B,DONMR1
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        REPONE:	PUSHJ P,GETCLS
	POPJ P,
	PUSH P,A
	HLRZ A,(A)
	HRRZ A,1(A)
	PUSHJ P,REPSET		;SET UP CORRESPONDENCE
	JRST [	POP P,(P)
		JRST CLRREP]
	POP P,G
	PUSHJ P,REPIT
	TRO MCHG
	JRST CLRREP
IFN 0,<	PUSHJ P,CLRREP
MD,<	JRST STRAIGHTEN	>
MPC,<	POPJ P,		>
>;IFN 0

REPALL:
MD,<	MOVEI T,[ASCIZ/TYPE OLD BODY NAME
/]
>;MD
	PUSHJ P,BODYGT
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	JRST OOPS1		;NX
	PUSHJ P,REPSET
	JRST CLRREP
REPLOP:MOVEI G,DBODPN
	JRST REPLP1
REPLP2:	HLRZ A,(G)
	HRRZ B,1(A)
	CAMN B,OLDTYP	;DOES THIS BODY HAVE THE RIGHT TYPE?
	PUSHJ P,REPIT
REPLP1:	HRRZ G,(G)
	JUMPN G,REPLP2
	TRO MCHG
	JRST CLRREP
IFN 0,<	PUSHJ P,CLRREP
MD,<	JRST STRAIGHTEN	>
MPC,<	POPJ P,		>
>;IFN 0

REPSOME:
MD,<	MOVEI T,[ASCIZ/TYPE OLD BODY NAME
/]
>;MD
	PUSHJ P,BODYGT
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	JRST OOPS1		;NX
	PUSHJ P,REPSET
	JRST CLRREP		;LET HIM OUT
	MOVEI T,UPSTAR		;WHERE TO GO IN UPCLOS
	MOVEM T,SPDISP
	MOVE T,[ASCID/BR/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM		;GET INTO SPECIAL POINTER MODE
	MOVEI G,DBODPN
	MOVEM G,CURREP
REPSPC:	MOVE G,CURREP
	HRRZ G,(G)
	JUMPE G,REPALT
	MOVEM G,CURREP
	HLRZ A,(G)
	HRRZ A,1(A)
	CAME A,OLDTYP
	JRST REPSPC		;KEEP LOOKING
	MOVEI T,BIGPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	PUSHJ P,SETBRT
	MOVE T,1(G)		;LOC OF BOD.
	TLNE M,DSKACT!MACACT
	JRST ISON		;NO, ALL BODIES ARE ON
	PUSHJ P,ONSCR		;IS IT ON SCREEN?
	PUSHJ P,PICSET		;NO, GET IT ON
ISON:	MOVEM T,STARLOC
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
THIS ONE/]
	PUSHJ P,YORN
	JRST REPALT
	JRST REPSPC
	MOVE G,CURREP
	PUSHJ P,REPIT
	TRO MCHG
IFN 0,<MD,<	PUSHJ P,STRAIGHTEN	>>
	JRST REPSPC

REPALT:	PUSHJ P,RCHNGM		;RESTORE OLD MODE
CLRREP:	SKIPE B,CORLST
	PUSHJ P,PUTFS
	SETZM CORLST
	POPJ P,
                                                                                                                                                REPIT:	PUSH P,G
	HLRZ G,(G)
	MOVE T,NEWTYP
	HRRM T,1(G)		;NEW TYPE POINTER FOR BODY
MD,<	CAMN T,OLDTYP		;DON'T COPY PROPERTIES IF SAME BODY
	JRST REPITP
	MOVE T,(P)
	PUSHJ P,OFFBLO		;FIX CHAR OFFSET IF BIT ON
	HLRZ A,1(G)
	MOVE T,1(A)
	TLNN T,FIXLOC
	JRST NFXBLC
	HRRZ B,(A)
	JUMPE B,NFXBLC		;JUST IN CASE
	HLRZ F,(G)
	HRRZ TT,1(G)
	PUSHJ P,STLCOF
NFXBLC:	HLRZ C,1(G)
	SKIPN COPPRP
	JRST [	PUSHJ P,PRPRET
		JRST REPITP]
	HRRZ D,1(C)		;GET OLD PROPERTY LIST
	JUMPE D,REPITP		;NOTHING TO DO IF NO LOCAL PROPS
	HLLZS 1(C)		;CLEAR POINTER TO IT
	MOVE A,(P)		;GET BODY POINTER
	PUSHJ P,COPLTP		;COPY BODY DEF TEXT/PROPERTIES INTO INDIRECT LIST
	HLRZ A,(A)
	HLRZ A,1(A)		;POINT TO TEXT/PROPERTY LIST HEADER BLOCK
PRPCP1:	MOVE C,D
	HRRZ D,(D)
	HLRZ T,(C)
	JUMPE T,[FSTRET(C)	;JUST INDIRECT POINTER, DELETE
		JRST PRPCP2]
	HLRZ T,(T)		;GET PROPERTY NAME
	JUMPE T,PRPCP3		;IF NONE, COPY TEXT
	HRRZ TTT,1(A)
	SKIPE TTT		;NOT FOUND IF NO PROPS IN NEW BODY
	PUSHJ P,FPROPX		;LOOK FOR THIS PROPERTY IN BODY DEF
	JRST PRPCP3		;NOT FOUND, INSERT NEW PROPERTY
	HLRZ TTT,(T)
	JUMPN TTT,PRPCP4	;BUG CHECK FOR DUPLICATE PROPERTY ON BODY
	HLRZ TTT,(C)		;GET POINTER TO REST OF NEW PROPERTY
	HRLM TTT,(T)		;STORE INTO INDIRECT BLOCK
	MOVE TTT,1(C)		;GET X,Y
	MOVEM TTT,1(T)		;STORE IT ALSO
	FSTRET(C)		;GIVE BACK OLD BLOCK
	JRST PRPCP2

PRPCP3:	HRRZ TTT,1(A)		;LINK THIS PROPERTY
	HRRM TTT,(C)		;INTO BODY LIST
	HRRM C,1(A)
	JRST PRPCP2

PRPCP4:	MOVSS T,(C)
	HLRZ B,(T)
	HLRZ B,(B)		;CHECK FOR DIP DEF LIST
	SKIPE B
	PUSHJ P,PUTFS
	HRRZ B,(C)
	HLRZ B,(B)
	PUSHJ P,PUTFS		;RETURN PROPERTY NAME
	MOVE B,C
	PUSHJ P,PUTFS		;AND THE REST
PRPCP2:	JUMPN D,PRPCP1		;LOOP IF MORE
REPITP:
>;MD
MPC,<	SWITCH
	PUSHJ P,REPIT1		;DO BACK SIDE FIRST
	HRRZ G,(P)
	HLRZ G,(G)
	SWITCH
>;MPC
	PUSHJ P,REPIT1		;DO IT
	HRRZ A,(P)		;BODY POINTER
	PUSHJ P,BODFIX		;FIX ALL THE PINS ON IT!
	POP P,G			;RESTORE BODY POINTER
	POPJ P,

REPIT2:	HRRZ T,1(A)
	JUMPE T,REPDEL
	HRRM T,(B)	;NEW TYPE PIN POINTER
MD,<	SKIPN KEEPIN	;KEEPING PIN #'S?
	HLLZS 1(B)	;NO, FLUSH THEM
>;MD
	MOVE B,-1(P)
	HLRZ F,(B)
	HLRZ F,(F)
	MOVE T,1(T)	;X,Y FROM PIN TYPE BLOCK
	PUSHJ P,ORIENT	;ORIENT IT
	ADJUST(ADD,T,<1(B)>)
	MOVE A,SAVEG
MD,<	PUSH P,G
	PUSHJ P,PMOVRL	;MOVE TO NEW POS!
	POP P,G
>;MD
REPIT1:	MOVE H,G
	HRRZ G,(G)
REPDL4:	JUMPE G,REPMAK
	MOVEM G,SAVEG
	HLRZ G,(G)
	HRRZ B,1(G)
MPC,<	MOVE TT,1(B)		;BITS
	EQV TT,SID
	JUMPGE TT,REPIT1	;SAME SIDE?
>;MPC
	HRRZ T,(B)
	MOVEI A,CORLST
	JRST REPIT3

REPIT4:	HLRZ TT,(A)
	CAMN TT,T		;SAME TYPE POINTER?
	JRST REPIT2
REPIT3:	HRRZ A,(A)
	JUMPN A,REPIT4
	OUTSTR[ASCIZ/POINT NOT FOUND AT REPIT4!!
/]
	PUSHJ P,FUCKUP
	JRST REPIT1		;THIS SHOULDN'T HAVE HAPPENED

REPMAK:	MOVEI G,CORLST
	JRST REPMK1

REPMK2:	HLRZ A,(G)
	JUMPN A,REPMK1		;NOT A NEW PIN?
	HRRZ A,1(G)		;PIN ID & X,Y BLOCK
	MOVE B,-1(P)		;BODY POINTER
	HRLI B,ISPIN		;PIN
	HLRZ TT,(B)
	HLLZ TT,(TT)		;ORI AND X,Y BLOCK
	PUSHJ P,PUTPNT		;MAKE IT
MPC,<	HLRZ TT,(A)		;PIN #
	CAIE TT,1		;FOR PIN 1
	JRST XPIN1
	AOS 1(T)
	AOS 1(T)
XPIN1:	AOS 1(T)
>;MPC
	HRRM D,(H)		;LINK INTO PIN LIST
	MOVE H,TTT
REPMK1:	HRRZ G,(G)
	JUMPN G,REPMK2
	POPJ P,

REPDEL:	HRRZ G,(G)
	HRRM G,(H)	;LINK THIS PIN OUT
	TRO TFLG	;DELETE PINS
	PUSH P,H
	PUSH P,G
	MOVE B,SAVEG
	PUSHJ P,DELPNL
	POP P,G
	POP P,H
	JRST REPDL4
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     COMMENT    VALID 00016 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(CLOSE,1)
C00006 00003	FNDLIN:	SETZM CLOSES	CLEAR CLOSEST POINTER
C00010 00004	LRSLAN:	HLRE T,CURSE
C00012 00005	SQRT:	FINDS THE SQUARE ROOT OF THE INTEGER IN T.  USES TT AND TTT
C00014 00006	FNDSET, FNDBOD, FNDPNT, EDTFND, EDPFND, EDIFND
C00016 00007	CLFNDA:	HRRZ B,(F)
C00020 00008	UPCLOS
C00023 00009	.UPPNT
C00025 00010	.UPSET
C00027 00011	.UPLIN
C00028 00012	LINES, BOXES, BODY
C00029 00013	UPREP
C00030 00014	ANGLE (LINE OR SETBOX)
C00032 00015	SETBOX
C00033 00016	ARROW
C00036 ENDMK
C;
                                     VERSION(CLOSE,1)
GETCLS:	TRNE STBOX
	POPJ P,
	MOVE A,CURSE
	EXCH A,LSTCUR		;SET CURRENT CURSOR POS AS LAST FOUND!
	TRZN NEEDCL
	CAME A,CURSE		;MOVED SINCE LAST FIND?
	JRST GETCL1
	JRST GETCL2		;NO
GETCL1:	PUSHJ P,PUSHIT
	PUSHJ P,FNDCLS
	PUSHJ P,POPIT
	SETOM CLOSUP
GETCL2:	SKIPN A,CLOSES
	POPJ P,
	JRST CPOPJ1

SCLOSP:	PUSHJ P,SCLOSL
	MOVE T,1(T)
	TDZ T,[1,,1]		;CLEAR THESE BITS
MD,<	MOVE TTT,MODE
	CAIE TTT,BTXTM
	JRST SCLSP1
	MOVE TTT,BTBODY
	PUSH P,F
	HLRZ F,(TTT)
	HLRZ F,(F)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TTT)>)
SCLSP1:
>;MD
	MOVEM T,LSTCUR		;THIS IS NOW CURSOR POS OF LAST CLOSEST
	JRST CHKON

SCLOSL:	PUSH P,TT
	MOVE TT,MODE
	XCT CLOSLT(TT)
SCLOS1:	HRL T,TT
	HRRZ TT,(TT)
	CAIN TT,(T)
	JRST SCLOSX
	JUMPN TT,SCLOS1
	POP P,TT
	PUSHJ P,FUCKUP
	POPJ P,

CLOSLT:	MOVEI TT,SETPNT	;S
	MOVEI TT,DBODPN	;B
MD,<	MOVEI TT,PONPNT	>	;P
MPC,<	PUSHJ P,PONSID	>	;P
	PUSHJ P,FUCKUP	;L
MD,<	MOVEI TT,PONPNT	>	;T
MPC,<	PUSHJ P,PONSID	>	;T
	PUSHJ P,FUCKUP	;A
	PUSHJ P,FUCKUP	;MA
	PUSHJ P,FUCKUP	;SP
MD,<	PUSHJ P,BTLAST	;BT
	PUSHJ P,FUCKUP	;BTA
	PUSHJ P,FUCKUP	;E
	PUSHJ P,FUCKUP	;EI
	JRST SCLOSX	;ET  DOESN'T USE CLAST
	JRST SCLOSX	;EP	"
	PUSHJ P,FUCKUP	;EG
	PUSHJ P,FUCKUP	;EA
>;MD
REPEAT NUMODES+<CLOSLT-.>,<PUSHJ P,FUCKUP>

MD,<
BTLAST:	MOVE TT,BTBODY
	HLRZ TT,(TT)
	HLRZ TT,1(TT)
	ADDI TT,1
	POPJ P,			;RETURN POINTER TO LIST HEAD
>;MD

MPC,<
PONSID:	HLRZ TT,(T)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	EQV TT,SID
	SKIPL TT		;ON CURRENT SIDE?
	SKIPA TT,[PONPN2]	;NO
	MOVEI TT,PONPNT		;YES
	POPJ P,
>;MPC

SCLOSX:	POP P,TT
SCLOSE:	HRRZM T,CLOSES
	HLRZM T,CLAST
	PUSH P,T
	MOVE T,CURSE
	MOVEM T,LSTCUR			;NOTE LAST PLACE WE SET CLOSEST
	POP P,T
	SETOM CLOSUP
	TRZ NEEDCL			;IF SETTING CLOSEST, DON'T NEED NEW ONE
	POPJ P,

FNDCLS:	TRNE INMOV
	POPJ P,			;DON'T GAFROTZ CLOSES
	MOVE T,MODE
	JRST @FNDTAB(T)

FNDTAB:	FNDSET		;S
	FNDBOD		;B
	FNDPNT		;P
	FNDLIN		;L
	FNDPNT		;T
	NOFNDS		;A
	NOFNDS		;MA
	CPOPJ		;SP
MD,<	BTXFND		;BT
	NOFNDS		;BTA
	EDIFND		;E
	NOFNDS		;EI
	EDTFND		;ET
	EDPFND		;EP
>
REPEAT NUMODES+<FNDTAB-.>,<NOFNDS
>

NOFNDS:	SETZM CLOSES	;NO CLOSEST ANYTHING
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                        FNDLIN:	SETZM CLOSES	;CLEAR CLOSEST POINTER
	PUSHJ P,CLSLIN	;FIND CLOSEST LINE
	MOVEM A,CLOSES	;SAVE AS CLOSEST LINE (DON'T USE CLAST HERE)
	POPJ P,

CLSLIN:	SETZ A,		;NO CLOSEST YET
	SKIPN B,PONPNT	;NO POINTS?
	POPJ P,
	MOVSI T,177777	;FAR ENOUGH
	MOVEM T,DIFSOF
FLLOP:	HLRZ C,(B)	;GET POINTER TO DATA BLOCK
	HLRZ D,1(C)	;GET POINTER TO ^_ BLOCK
MD,<
	HRRZ E,(D)	;GET POINTER
	JUMPE E,.+2	;NONE?
	PUSHJ P,ISCLLN	;SEE IF CLOSER
	HRRZ E,1(D)	;GET ANOTHER POINTER
	JUMPE E,.+2	;NONE?
	PUSHJ P,ISCLLN	;SEE IF CLOSER
>;MD
MPC,<
	JUMPE D,FLLOP2
FLLOP1:	HLRZ E,(D)
	JUMPE E,.+2
	PUSHJ P,ISCLLN
	HRRZ E,1(D)
	JUMPE E,.+2
	PUSHJ P,ISCLLN
	HLRZ E,1(D)
	JUMPE E,.+2
	PUSHJ P,ISCLLN
	HRRZ D,(D)
	JUMPN D,FLLOP1
FLLOP2:
>;MPC
	HRRZ B,(B)	;GO TO NEXT POINT
	JUMPN B,FLLOP
	POPJ P,

ISCLLN:	MOVE C,1(B)	;GET X,Y OF FIRST POINT
MPC,<	CAMGE C,1(E)	;DO SEGMENT ONCE ONLY
	POPJ P,
>;MPC
	MOVE F,1(E)	;GET X,Y OF SECOND POINT
	MOVE TTT,CURSE	;GET CURSOR X,Y
	MOVE T,F
	XOR T,C		;GET DIFFERENCE
	TLNN T,-1	;LEFT HALF ZERO?
	JRST [TRNN T,-1	;YES, RIGHT HALF ZERO TOO?
		POPJ P,	;YES
		MOVEI TT,1 ;NO, LEFT HALF ONLY, ZERO. VERT. LINE
		HRRZM TTT,TPOINT
		HLLM F,TPOINT
		JRST LRTCON]
	TRNE T,-1	;RIGHT HALF ZERO?
	JRST LRSLAN	;NO, SLANTY LINE
	MOVEI TT,2	;YES, HORIZ. LINE
	HLLZM TTT,TPOINT
	HRRM F,TPOINT
	MOVSS F
	MOVSS C		;SWAP HALVES
	MOVSS TTT
LRTCON:	HLRE T,C	;GET THE PART THAT'S THE SAME (X OR Y)
	HRRES F
	HRRES C
	HRRE G,TTT
MD,<	CAME F,G	;WELL IF PHIL SAYS SO!
	CAMN C,G	;EITHER END SAME AS CURSOR?
	POPJ P,		;YES, CAN'T BE CLOSE
>;MD
	CAML F,G	;GREATER THAN ONE BUT LESS THAN THE OTHER?
	JRST [CAMG C,G
		JRST ISPOSS
		POPJ P,];NO, NOT CLOSE
	CAMG C,G
	POPJ P,		;NO, NOT CLOSE
ISPOSS:	HLRES TTT	;GET OTHER THING
	SUB TTT,T	;GET DIFFERENCE
	IMUL TTT,TTT	;SQUARE IT
	CAML TTT,DIFSOF	;DISTANCE SMALLER?
	POPJ P,		;NO
ITCLSS:	TLNE M,XWINDOW!MACACT!DSKACT
	JRST ITCLSX
	MOVE T,TPOINT	;TAKE INTERSECTION POINT
	PUSH P,TTT
	PUSHJ P,ONSCR
	JRST [	POP P,(P)
		POPJ P,]	;NOT ON
	POP P,TTT
ITCLSX:	MOVEM TTT,DIFSOF;YES, DEPOSIT NEW DISTANCE
	MOVE A,B	;GET POINTERS
	HRL A,E
	MOVE T,TPOINT
	TDZ T,[1,,1]
	MOVEM T,IPOINT
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                 LRSLAN:	HLRE T,CURSE
	MOVEM T,DX1		;STORE HERE TERMPORARILY
	HRRE T,CURSE
	PUSHJ P,CALINE		;RETURN LENGTH IN TTT
	POPJ P,			;OFF ONE END OR OTHER
	DIV TT,L2		;DO FINAL CALC
	MOVM TTT,TT
	CAML TTT,DIFSOF
	POPJ P,
	CAML T,L2
	JRST [	MOVE T,1(E)
		MOVEM T,TPOINT
		JRST ITCLSS]
	PUSH P,TTT
	DIV T,L2		;CALC SCALE
	HRRE TTT,1(B)
	HRRE TT,1(E)
	SUB TT,TTT
	MULM T,TT
	ADD TT,TTT
	MOVEM TT,TPOINT
	HLRE TTT,1(B)
	HLRE TT,1(E)
	SUB TT,TTT
	MULM T,TT
	ADD TT,TTT
	HRLM TT,TPOINT
	POP P,TTT
	JRST ITCLSS

CALINE:	HRRE TT,1(B)
	SUB T,TT
	MOVEM T,DY1
	HRRE T,1(E)
	SUB T,TT
	MOVEM T,DY3
	HLRE TT,1(B)
	MOVE T,DX1
	SUB T,TT
	MOVEM T,DX1
	HLRE T,1(E)
	SUB T,TT
	MOVEM T,DX3
	MOVE T,DX3
	IMUL T,DX3
	MOVE TT,DY3
	IMUL TT,DY3
	ADD T,TT
	MOVEM T,L2
	MOVE T,DX1
	IMUL T,DX3
	MOVE TT,DY1
	IMUL TT,DY3
	ADD T,TT
	JUMPLE T,CPOPJ		;NEGATIVE MEANS OFF ONE END
	MOVMS T
	CAML T,L2
	POPJ P,
	MOVE TT,DX1		;INSIDE LINE, CALC LENGTH
	IMUL TT,DY3
	MOVE TTT,DX3
	IMUL TTT,DY1
	SUB TT,TTT
	MUL TT,TT		;PRODUCE DOUBLE LENGTH RESULT
	JRST CPOPJ1
                                                                                                                                                                                                       ;SQRT:	FINDS THE SQUARE ROOT OF THE INTEGER IN T.  USES TT AND TTT
SQRT:	JFFO T,.+2	;FIND THE HIGH ORDER BIT
	POPJ P,		;ZERO?
	SUBI TT,=37
	MOVNS TT
	LSH TT,-1
	MOVEI TTT,1
	LSH TTT,-1(TT)	;MAKE WORD WITH HALF AS MANY LOW ORDER BITS
	SETOM SQRFLG	;TURN ON TEMP (COUNT) FLAG
SLOP1:	MOVE TT,TTT	;GET APROXIMATE SQRT
	IDIVM T,TT	;DIVIDE IT INTO THE SQUARE
	ADD TT,TTT	;ADD APROX.
	ASH TT,-1	;DIVIDE BY 2. THIS IS THE NEW APPROX.
	MOVE TTT,TT	;GET APPROX.
	IDIVM T,TTT	;DIVIDE IT INTO THE SQUARE
	ADD TTT,TT	;ADD APPROX.
	ASH TTT,-1	;DIVIDE BY 2. THIS IS THE NEW APPROX.
	AOSG SQRFLG	;GONE THROUGH TWICE?
	JRST SLOP1	;NO
	MOVE T,TTT
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;FNDSET, FNDBOD, FNDPNT, EDTFND, EDPFND, EDIFND
FNDSET:	MOVEI F,SETPNT	;GET SET POINTER
	JRST CLFNDA	;FIND CLOSEST SET.

FNDBOD:	MOVEI F,DBODPN	;GET POINTER TO LIST OF BODIES
	JRST CLFNDA	;FIND BODY WHICH IS CLOSEST TO CURSOR

FNDPNT:	MOVEI F,PONPNT	;GET POINTER TO POINTS WHICH ARE ON THE SCREEN
	JRST CLFNDA	;FIND POINT WHICH IS CLOSEST OT CURSOR

MD,<
BTXFND:	MOVE F,BTBODY
	HLRZ F,(F)
	HLRZ F,1(F)
	ADDI F,1
	JRST CLFNDA

EDTFND:	MOVE A,CURBOD	;GET POINTER TO CURRENT BODY (TYPE) DEFINITION
	HLRZ C,1(A)	;GET DATA BLOCK POINTER
	HLRZ B,1(C)	;GET TEXT POINTER
	JRST CLFND	;FIND PIECE OF TEXT CLOSEST TO CURSOR

EDIFND:	MOVE A,CURBOD
	HLRZ C,1(A)
	HRRZ B,1(C)
	JRST CLFND	;FIND CLOSEST POINT IN LINES

EDPFND:	MOVE A,CURBOD	;GET POINTER TO CURRENTLY-BEING-EDITED TYPE DEF.
	HLRZ F,1(A)	;GET POINTER TO DATA BLOCK
	JRST CLFNDA
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                               CLFNDA:	HRRZ B,(F)
CLFND:	HRLOI TT,177777	;MAKE A LARGE NUMBER(LARGE ENOUGH)
	MOVE E,TT
	SETZB A,CLOSES	;CLEAR CLOSEST POINTERS
	JUMPE B,CPOPJ
CLOP1:	MOVE T,1(B)	;GET X,Y WORD
	TDZ T,[1,,1]
	TRNE INLIN	;DRAWING A LINE?
	CAME B,LINING	;YES, IS THIS THE POINT FROM WHICH WE ARE DRAWING?
	CAIA
	JRST CLOP2	;YES, IGNORE IT
	MOVE D,MODE
	CAIE D,TXTM
	JRST NOTXTM	;NOT TEXT MODE
	HLRZ D,(B)
	HRRZ D,1(D)
	HLRZ D,(D)
	JUMPE D,CLOP2
NOTXTM:
MD,<	MOVEI D,1
	LSH D,@MODE
	TDNN D,[1EDTTM!1BTXTM]
	JRST NOETXM
	TDNN D,[1BTXTM]
	JRST NADJBT
	MOVE TTT,BTBODY
	PUSH P,F
	HLRZ F,(TTT)
	HLRZ F,(F)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TTT)>)	;CALC SCREEN POS OF TEXT
NADJBT:	HLRZ D,(B)
	JUMPE D,CLOP2		;DON'T FIND INDIRECT POINTERS
	HRRZ D,(D)
	HLRZ D,(D)
	TLNN M,%IDENT
	JUMPE D,CLOP2
NOETXM:
>;MD
	MOVEM T,CLXY	;SAVE X,Y HERE
	SUB T,CURSE	;SUBTRACT CURSOR POSITION
	MOVMS T		;GET ABS OF DIFFERENCE
	CAMLE T,TT	;THIS ONE SMALLER X DISTANCE?
	JRST CLOP2	;YES, THINK ABOUT IT MORE
TRYIT:	MOVE T,1(B)
	CAMN T,1(A)
	JUMPN A,CKCOIN	;IF ALREADY HAVE CLOSEST AT SAME PLACE, CHECK
	TLNE M,DSKACT!MACACT!XWINDOW
	JRST WINX	;NO TEST IF NO WINDOW
	MOVE T,CLXY
	PUSHJ P,ONSCR
	JRST CLOP2
WINX:	HLRE T,CLXY	;GET X OF POINT
	HLRE D,CURSE	;GET X OF CURSOR
	SUB T,D		;GET DIFF.
	MOVMS T		;ABS VAL.
	HRRE D,CLXY	;GET Y OF POINT
	SUB D,CURSE	;SUBTRACT CURSOR (Y IN RIGHT HALF)
	HRRES D		;GET Y PART
	MOVMS D		;ABS. VAL.
	IMUL D,D	;Y^2
	IMUL T,T	;X^2
	ADD T,D		;X^2+Y^2
	CAMLE T,E	;SMALLER OR EQUAL DISTANCE?
	JRST CLOP2	;NO
	MOVE A,B	;YES, SHORTEST SO FAR. HOLD POINTER TO IT
	HRL A,F		;ALSO LAST POINTER
	MOVE E,T	;REPLACE COMPARE WITH NEW ONE
	PUSHJ P,SQRT	;GET SQRT OF DISTANCE
	ADDI T,20	;SAFETY FACTOR
	MOVS TT,T	;REPLACE THE Y-PART COMPARE WITH THE DISTANCE
CLOP2:	MOVE F,B
	HRRZ B,(B)	;NO, GO TO NEXT
	JUMPN B,CLOP1	;LOOP IF MORE TO LOOK AT
	HRRZM A,CLOSES	;DEPOSIT POINTER TO CLOSEST
	HLRZM A,CLAST	;ALSO LAST
	POPJ P,

CKCOIN:	MOVEI TTT,1
	LSH TTT,@MODE
	TDNN TTT,[1PNTM!1TXTM]
	JRST WINX		;ONLY CHECK POINTS
	HLRZ TTT,(A)
	HRRZ TTT,1(TTT)
	MOVE TTT,1(TTT)
	TLNE TTT,MPC,<CPIN!>ISPIN	;DON'T FIND PIN IF COINCEDENT
	JRST WINX			;CONTINUE CHECK
	JRST CLOP2			;LOSE IMMEDIATELY
                                                                                                                                                                                                                                                                                                                      ;UPCLOS
UPCLOS:	TLNE DSPACT	;DISPLAYING AT ALL?
	TRNE INMOV!STBOX;DOING ANYTHING OBVIOUSLY WRONG?
	POPJ P,		;YES, DON'T INDICATE CLOSEST
	SKIPN CLOSUP		;NEED TO UPDATE CLOSES DISPLAY?
	POPJ P,			;NO
	SETZM CLOSUP
	MOVE T,MODE
	SKIPE A,CLOSES
	JRST @UPTAB(T)
UPNONE:	MOVEI T,BIGPG
	JRST HYDPOG

UPTAB:	.UPSET		;S
	.UPBOD		;B
	.UPPNT		;P
	.UPLIN		;L
	.UPPNT		;T
	UPNONE		;A
	UPNONE		;MA
	UPNONE		;SP
MD,<	.UPBTX		;BT
	UPNONE		;BTA
	.UPED		;E
	UPNONE		;EI
	.UPED		;ET
	.UPEDP		;EP
>
REPEAT NUMODES+<UPTAB-.>,<UPNONE
>

SPSETUP:
	SKIPA T,[ANGLPG]
.SETUP:	MOVEI T,BIGPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	JRST SETBRT

.UPVCT:	MOVE T,1(A)	;X,Y OF THING
.UPT:	TDZ T,[1,,1]
	PUSHJ P,ONSCR	;ON SCREEN?
	POPJ P,
	PUSHJ P,VHLINE	;MAKE CROSS HAIRS (MAYBE)
	PUSHJ P,BIGAIV	;PUT IN VECTOR TO THERE
	JRST CPOPJ1

MD,<
.UPEDP:	PUSHJ P,.SETUP
	MOVE T,1(A)
	PUSHJ P,.UPT
	JRST UPNONE
	MOVEI T,"*"+"*"+1
	PUSHJ P,TXTDPB
	JRST BLINKO

.UPBTX:	PUSHJ P,.SETUP
	MOVE TT,BTBODY
	MOVE T,1(A)
	PUSH P,F
	HLRZ F,(TT)
	HLRZ F,(F)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TT)>)
	PUSHJ P,.UPT
	JRST UPNONE
	HLRZ T,(A)
	HLRZ T,(T)
	SKIPE T			;SKIP IF NOT PROPERTY
	SKIPA T,[ASCID/BTP/]
	MOVE T,[ASCID/BT/]
	PUSHJ P,TXTDPB
	JRST BLINKO
>;MD

MD,<
.UPED:	SKIPA T,[ASCID/*/]
>;MD
.UPBOD:	MOVEI T,"B"+"B"+1
	PUSH P,T
	PUSHJ P,.SETUP
	PUSHJ P,.UPVCT
	JRST [	POP P,(P)
		JRST UPNONE]
	POP P,T
	PUSHJ P,TXTDPB
	JRST BLINKO	;OUTPUT IT

SETBRT:
MPC,<	TRNE BTHSDS
	SKIPA T,BTHBRT	;ALWAYS USE 7 IF BOTH SIDES ARE ON
>;MPC
	MOVE T,DEFBRT	;GET CURRENT BRIGHTNESS
	ADDI T,1
	JRST DPYBRT
                                                                                                                                                                                                                                                                                           ;.UPPNT
.UPPNT:	PUSHJ P,.SETUP
	PUSHJ P,.UPVCT
	JRST UPNONE
	MOVSI T,(<ASCII/*/>)
	TRNE INLIN	;DRAWING A LINE?
	JRST GTPNTC	;YES, JUST STAR
	MOVSI T,(<ASCII/P/>)
	HLRZ B,(A)	;GET DATA BLOCK POINTER
	HRRZ B,1(B)
	HLRZ TT,(B)	;GET TEXT POINTER
	JUMPE TT,NOTEX	;ANY TEXT?
	MOVSI T,(<ASCII/T/>)
	HRRZ TT,(TT)	;GET SIZE BLOCK
	HLRZ TTT,(TT)
	TRNE TTT,400000
	TLO T,(<BYTE(7),"V">)
NOTEX:	MOVE TT,1(B)
	TLNE TT,ISPIN	;IS THIS POINT A PIN
	TRO T,"A"+"A"	;YES, TACK ON AN A
	TLNE TT,CPIN	;CONNECTOR PIN?
	TRO T,"C"+"C"	;TACK ON A "C"
	HLRZ TTT,(A)
	HLRZ TTT,1(TTT)
MD,<	SKIPN (TTT)
	SKIPE 1(TTT)	;ANY LINES ATTACHED HERE?
	TRO T,"L"10
>;MD
MPC,<
	JUMPE TTT,UPPNTA
UPPNTB:	SKIPE 1(TTT)
	JRST UPPNTC
	SKIPN TTT,(TTT)
	JRST UPPNTA
	TLNN TTT,-1
	JRST UPPNTB
UPPNTC:	TRO T,"L"10
UPPNTA:	LDB TTT,[POINT 3,TT,6]
	IOR T,(TTT)[	0
			"G"17
			"1"17
			"2"17
			"3"17
			0
			0
			0	]
>;MPC
GTPNTC:	TRO T,1		;MAKE IT ASCID
	PUSHJ P,TXTDPB
	JRST BLINKO	;OUTPUT THE THING
                                                                                                                                                                                                                                                                                ;.UPSET
.UPSET:	PUSHJ P,.SETUP
	PUSHJ P,.UPVCT
	SKIPA T,[1]		;FLASH THE ONES ON SCREEN ANY WAY
	MOVEI T,"S"+"S"+1	;ASCID S
	PUSHJ P,DCLSET
	JRST BLINKO		;AND BLINK IT

DCLSET:	PUSHJ P,TXTDPB
	HLRZ A,(A)	;POINTER TO THIS SET
STPNTR:	HRRZ TT,1(A)	;POINTER TO FIRST POINT IN SET
	JUMPE TT,SNOPNT	;NO POINT?
	MOVE T,1(TT)
	PUSHJ P,ONSCR
	JRST SNOPNT
MPC,<
	HLRZ T,(TT)
	HRRZ T,1(T)
	MOVE T,1(T)
	EQV T,SID	;ON THIS SIDE?
	TLNN T,FRONT
	TRNE BTHSDS	;OR BOTH SIDES ON?
	CAIA
	JRST SNOPNT	;NO
>;MPC
	MOVE T,1(TT)
	PUSHJ P,BIGAIV
	MOVEI T,"P"+"P"+1	;ASCID P
	PUSHJ P,TXTDPB
SNOPNT:	HLRZ T,1(A)		;POINTER TO FIRST BODY IN SET
	JUMPE T,SNOBOD		;NO BODY?
	MOVE T,1(T)		;X,Y
	PUSHJ P,BIGAIV
	MOVEI T,"B"+"B"+1	;ASCID B
	PUSHJ P,TXTDPB
SNOBOD:	HRRZ A,(A)		;NEXT WORD OF SET
	JUMPN A,STPNTR
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ;.UPLIN
.UPLIN:	PUSHJ P,.SETUP
	MOVE T,IPOINT
	PUSHJ P,ONSCR
	JRST [	MOVEI T,BIGPG
		JRST HYDPOG]
	PUSHJ P,VHLINE	;MAKE CROSS HAIRS (MAYBE)
	PUSHJ P,BIGAIV 	;PUT IN VECTOR TO THERE
	MOVEI T,"L"1+1	;ASCID L
	PUSHJ P,TXTDPB
	JRST BLINKO
                                                                                                                                                                                                                                                                                                                                                                                                        ;LINES, BOXES, BODY
DOSLPB:	MOVE T,MODE
	JRST @SLPBTB(T)

SLPBTB:	DRWBOX		;S
	NOSLPB		;B
	DOANGL		;P
	NOSLPB		;L
	DOANGL		;T
	ARROW		;A
	ARROW		;MA
	DOSPM		;SP
MD,<
	NOSLPB		;BT
	ARROW		;BTA
	NOSLPB		;E
	NOSLPB		;EI
	NOSLPB		;ET
	NOSLPB		;EP
	NOSLPB		;EG
	ARROW		;EA
>;MD
REPEAT NUMODES+<SLPBTB-.>,<NOSLPB
>

NOSLPB:	MOVEI T,ANGLPG
	JRST HYDPOG
DOSPM:	JRST @SPDISP

UPSTAR:
;	PUSHJ P,SPSETUP
	PUSHJ P,DOANGL
	MOVE T,STARLOC
	PUSHJ P,.UPT
	JRST UPNONE
	MOVEI T,"*"+"*"+1
	PUSHJ P,TXTDPB
	JRST BLINKO
                                                                                                      ;UPREP
UPREP:	TRZ MCHG		;NOOP THE MAIN DISPLAY
	MOVEI T,CPOPJ
	MOVEM T,DSPDSP
	PUSHJ P,NOSLPB
	MOVEI T,MAINPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	PUSHJ P,SETBRT
	SETZ F,
	MOVE A,OLDTYP
	MOVEI D,0
	UNSCAL(D)
	ADD D,YOFF
	MOVE T,[(3*%LEFT+%RIGHT)/4]
	UNSCAL(T)
	ADD T,XOFF
	HRL D,T
	PUSHJ P,PUTBDL
	MOVE T,[(3*%RIGHT+%LEFT)/4]
	UNSCAL(T)
	ADD T,XOFF
	HRL D,T
	MOVE A,NEWTYP
	PUSHJ P,PUTBDL
	JRST MAINOU
                                                                                                                                                                                                                       ;ANGLE (LINE OR SETBOX)
DOANGL:	TRNE INLIN	;ARE WE IN A LINE?
	SKIPN LINING	;REALLY????
	JRST NOSLPB	;NO
	MOVEI T,ANGLPG
	MOVEM T,PGLASS	;YES, USE PIECE OF GLASS 1
	PUSHJ P,DPYSET	;SET UP BUFFER
	PUSHJ P,SETBRT
	MOVE A,LINING	;GET POINTER TO CURRENT POINT WE ARE DRAWING FROM
	MOVE T,1(A)	;GET X,Y
	PUSHJ P,AIVECT	;DRAW INVIS. TO IT
MD,<	MOVE T,CURSE	;GET CURSOR POSITION
	TRNN ZIGZAG	;OTHER WAY?
	MOVE T,1(A)	;YES, GET POINT
	HLL T,CURSE	;GET CURSOR X
	TRNE ZIGZAG	;OTHER WAY?
	HLL T,1(A)	;NO, GET POINT X
	PUSHJ P,AVECT	;DRAW LINE TO IT
>;MD
	MOVE T,CURSE	;GET CURSOR POSITION
	PUSHJ P,AVECT	;DRAW LINE TO IT
	JRST BLINKO	;OUTPUT POG
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;SETBOX
DRWBOX:	TRNN STBOX
	JRST NOSLPB
	MOVEI T,ANGLPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	MOVE A,SETBOX
	MOVE T,1(A)
	PUSHJ P,AIVECT
	JRST NXTDRW
NXTDR1:	MOVE T,1(A)
	PUSHJ P,AVECT
NXTDRW:	HRRZ A,(A)
	JUMPN A,NXTDR1
	MOVE A,ENDBOX
	MOVE T,CURSE	;GET CURSOR POSITION
	TRNN ZIGZAG	;OTHER WAY?
	MOVE T,1(A)	;YES, GET POINT
	HLL T,CURSE	;GET CURSOR X
	TRNE ZIGZAG	;OTHER WAY?
	HLL T,1(A)	;NO, GET POINT X
	PUSHJ P,AVECT	;DRAW LINE TO IT
	MOVE T,CURSE	;GET CURSOR POSITION
	PUSHJ P,AVECT	;DRAW LINE TO IT
	JRST BLINKO
                                                                                                      ;ARROW
ARROW:	MOVE T,TXTCNT
	CAMN T,LPNTR
	POPJ P,
	MOVEM T,LPNTR
	MOVN T,ALTLIN
	MOVEM T,LINCNT		;INITIALIZE TO - NUMBER OF LINES WE HAVE MOVED UP
	SETZM CHRCNT
	MOVE T,TXTPNT
	ADD T,[POINT 7,1]
	MOVE TTT,TXTCNT
	MOVEM TTT,TOTCNT
ARROW1:	TLNN T,760000
	JRST [	HRR T,-1(T)
		TRNE T,-1
		JRST .+1
		JRST ARROW2]
	ILDB TT,T
	JUMPE TT,ARROW1
	SOSG TOTCNT
	JRST ARROW2
	AOS TTT,CHRCNT
	CAIL TTT,MAXLIN			;FORCED CRLF?
	JRST ARROW3			;YES
	CAMN TT,EOLCHR			;END OF LINE CHARACTER?
	JRST ARROW3
	JRST ARROW1

ARROW3:	SETZM CHRCNT
	AOS LINCNT
	JRST ARROW1

ARROW2:	MOVEI T,ANGLPG
	SKIPL TT,LINCNT		;IS TEXT ON SCREEN?
	CAILE TT,MAXPAG		;CHECK TOP ALSO
	JRST HYDPOG		;NO, HIDE CURSOR
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	MOVEI TT,106
	TDO TT,BSOR
	MOVN T,LINCNT
	IMUL T,CMUL+ACHRSZ
	IMULI T,CHGHT
IFN AYPOS,<	ADD T,[AYPOS]	>
	DPB T,[POINT 11,TT,21]		;Y PART
	MOVN T,CMUL+ACHRSZ
	IMULI T,CWIDTH
IFN AXPOS,<ADD T,[AXPOS]>
	DPB T,[POINT 11,TT,10]	;X PART
	PUSH P,TT
	TRO TT,40
	PUSHJ P,INSOU2			;DEPOSIT
	MOVE TT,CHRCNT
	IMUL TT,CMUL+ACHRSZ
	IMULI TT,CWIDTH
IFN AXPOS,<ADD TT,[AXPOS]>
	DPB TT,[POINT 11,(P),10]
	MOVE TT,(P)
	PUSHJ P,INSOUT			;STUFF IT
	POP P,TT
	LDB T,[POINT 11,TT,21]
	MOVE TTT,CMUL+ACHRSZ
	IMULI TTT,CHGHT
	ASH TTT,-2
	ADD T,TTT
	DPB T,[POINT 11,TT,21]
	PUSHJ P,INSOUT
	JRST DPYOUT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     COMMENT    VALID 00010 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(MOVE,1)
C00004 00003	MOVE POINT
C00012 00004	MOVE TEXT OFFSET, CPIN OFFSET
C00015 00005	MOVE BODY AND BODY LOC
C00017 00006	EDIT MOVES
C00021 00007	MOVE SET
C00024 00008	MICRO MOVEMENT COMMANDS
C00028 00009	MOVE ALONG LINES
C00032 00010	
C00033 ENDMK
C;
                                                                                                                                                                                                                                                                                         VERSION(MOVE,1)
;START MOVING
PBMOV:	TRZA TFLG
PGRAB:	TRO TFLG
	TRNE INMOV
	JRST PERRET
MD,<	TDZ [TMOVE,,LMOVE]	>
MPC,<	TLZ TMOVE		>
	MOVE T,MODE
	HRRZ T,STRTMV(T)
	JRST (T)

TXTMOV:	TRNE INMOV
	JRST PERRET
MD,<	TRZ LMOVE	>
	TLO TMOVE
	MOVE T,MODE
	HLRZ T,STRTMV(T)
	JRST (T)

STRTMV:	PERRET,,SMOVE	;SET MODE
	PERRET,,BMOVE	;BODY MODE
	PMOVET,,PMOVE	;POINT MODE
	PERRET,,PERRET	;LINE MODE
	PMOVET,,PMOVE	;TEXT MODE
	PERRET,,PERRET	;ALTER MODE
	PERRET,,PERRET	;MACRO ALTER MODE
	PERRET,,PERRET	;SPECIAL POINTER MODE
MD,<	ETMOVT,,ETMOVE	;BODY TEXT MODE
	PERRET,,PERRET	;BODY TEXT ALTER MODE
	PERRET,,EDINS2	;EDIT MODE (MAKE IT SAME AS <BETA>I)
	PERRET,,PERRET	;EDIT INSERT MODE
	ETMOVT,,ETMOVE	;EDIT TEXT MODE
	PERRET,,EPMOVE	;EDIT PIN MODE
	PERRET,,PERRET	;EDIT GET MODE
	PERRET,,PERRET	;EDIT ALTER MODE
>;MD
REPEAT NUMODES-(STRTMV-.),<PERRET,,PERRET>

DOMOVE:	TRZ TFLG
DOMOVG:	MOVEM TT,MDISP
	TRO INMOV
	TRNN TFLG		;DON'T MOVE CURSOR IN GRAB MODE
	PUSHJ P,SETPOS
	MOVEI T,BIGPG
	JRST HYDPOG
                                                                                                                                                                                                                                                  ;MOVE POINT
DOPMOV:	MOVE A,CLOSES
	TDZ [TMOVE,,MD,<LMOVE!>TFLG!INMOV]
	JRST PMOVE1

PMOVE:	PUSHJ P,GETCLS
	JRST PERRET
PMOVE1:	MOVE T,1(A)
	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TLNE TT,MPC,<CPIN!>ISPIN
 	JRST [	TRNN TFLG
 		JRST SETPOS
 		POPJ P,]
	JSP TT,DOMOVG
;MOVE SUBR
	MOVE A,CLOSES	;GET POINT POINTER
	MOVE T,CURSE	;GET CURSOR POSITION
	CAMN T,1(A)
	POPJ P,
ROUTE,<MPC,<TLZ M,%ROUTE>>;MAKE HIM ROUTE AGAIN
MPC,<
	MOVEM T,1(A)	;NEW X,Y
	HLRZ A,(A)
	HLRZ B,(A)	;GET FEED THROUGH POINTER(IF ANY)
	HRRZ A,1(A)
	MOVE A,1(A)
	TLNE A,FEEDTH
	MOVEM T,1(B)	;STORE ALSO IN FEEDTHROUGH
	TRO MCHG
	POPJ P,
>;MPC
MD,<	TRO MCHG
PMOVIT:	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TLNE TT,ISPIN	;BODY PIN?
	POPJ P,		;YES, DOESN'T MOVE
PMOVRL:	MOVE TT,T	;HOLD X,Y
	XOR T,1(A)	;COMPARE WITH OLD X,Y
	JUMPE T,CPOPJ	;LEAVE IF NO CHANGE AT ALL
	MOVEM TT,1(A)	;STORE NEW X,Y
	TRNE T,-1	;DID Y CHANGE?
	PUSHJ P,PMOVY	;YES
	TLNE T,-1	;DID X CHANGE?
	PUSHJ P,PMOVX	;YES
;HERE WE CHECK TO SEE IF A SEGMENT LEAVING THIS POINT NEEDS
;TO CHANGE SENSE (HORZ TO VERT OR VERT TO HORZ).
	MOVEI F,3		;4 CASES (F IS TABLE INDEX)
	PUSH P,A		;SAVE OUR POINT
	HLRZ A,(A)
	HLRZ A,1(A)		;POINT TO PIN'S NEIGHBOR BLOCK
HVFLP1:	XCT SEGTAB(F)		;GET THE POINTER FOR SEGMENT WE WANT TO CHECK
	JUMPE T,HVFLP2		;SKIP IT IF NONE
	HLRZ TT,(T)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TLNN TT,ISPIN		;PINS ONLY
	JRST HVFLP2
	MOVE TT,1(T)		;GET IT'S X,Y
	MOVE TTT,(P)
	MOVE TTT,1(TTT)		;GET ORIGINAL POINT'S X,Y
	ADJUST(SUB,TT,TTT)	;GET DELTAS
	PUSH P,TT		;SAVE THEM
	HLRE TTT,TT		;SEPERATE X AND Y
	HRRE TT,TT
	MOVM TTT,TTT		;GET MAGNITUDES ONLY
	MOVM TT,TT
	XCT HVMAG(F)		;SEE IF PAST DIAGONAL
	JRST HVFLP3		;NO
	POP P,TT		;GET BACK SIGNED DELTAS
	TRNE F,1		;DO WE WANT X OR Y DELTA
	MOVS TT,TT		;WE WANT Y DELTA
	SETCM TTT,F		;COMPLEMENT LOW ORDER BIT (CHANGE HORZ TO VERT)
	ANDI TTT,1		;ASSUME POSITIVE
	JUMPGE TT,.+2
	TRO TTT,2		;WELL IT WAS NEGATIVE
	PUSH P,T		;SAVE THIS POINT ALSO
	HLRZ T,(T)
	HLRZ T,1(T)		;POINT TO IT'S NEIGHBOR BLOCK
	XCT HVNEWT(TTT)		;GET POINTER WE WANT TO USE
	JUMPN TT,HVFLP3		;SKIP IF ALREADY IN USE
	XCT HVNEWA(TTT)		;CHECK BOTH ENDS
	JUMPN TT,HVFLP3		;MUST BOTH BE FREE
	MOVE TT,-1(P)		;GET ORIGINAL POINT
	XCT HVSTOT(TTT)		;STORE IT IN NEW POSITION
	MOVE TT,(P)		;GET OTHER POINT
	XCT HVSTOA(TTT)		;STORE IT ALSO
	XCT HVCLRA(F)		;CLEAR OLD POINTER
	XCT HVCLRT(F)		;AT BOTH ENDS
HVFLP3:	POP P,(P)		;FIX STACK
HVFLP2:	SOJGE F,HVFLP1
	POP P,(P)		;FIX STACK
	POPJ P,

	DEFINE FOO $ (HINST,LOCHW,XY,YX)
<	TRO NEEDCL	;MOVING, MAY NEED NEW CLOSEST
	HLRZ F,(A)	;GET DATA BLOCK POINTER
	HLRZ F,1(F)	;GET _^ BLOCK POINTER
	PUSH P,A	;SAVE A
	PUSH P,T	;SAVE T
	HRRZ A,XY(F)	;GET A _ OR ^
	MOVE T,TT	;GET NEW Y OR X
	HINST T,1(A)	;GET OLD X OR Y (HLL OR HRR)
	PUSH P,TT	;SAVE TT
	JUMPE A,.+2
	PUSHJ P,PMOVIT	;MOVE THE POINT & FRIENDS
	MOVE T,(P)	;GET NEW Y OR X
	MOVE A,-2(P)	;GET A
	HLRZ F,(A)	;GET DATA BLOCK POINTER
	HLRZ F,1(F)	;GET _^ BLOCK POINTER
	HLRZ A,XY(F)	;GET A _ OR ^
	HINST T,1(A)	;GET OLD X OR Y (HLL OR HRR)
	JUMPE A,.+2
	PUSHJ P,PMOVIT	;MOVE THE POINT & FRIENDS
MOV$LOCHW$0:
	MOVE A,-2(P)
	H$LOCHW$RE T,1(A)	;THIS X OR Y
	HLRZ A,(A)
	HLRZ A,1(A)		;^_
	HRRZ F,YX(A)		;^ OR 
	JUMPE F,MOV$LOCHW$1
	H$LOCHW$RE TT,1(F)
	CAMG T,TT
	JRST MOV$LOCHW$1
	HLRZ F,(F)
	HLRZ F,1(F)
	MOVSS TT,YX(A)
	MOVSS TTT,YX(F)
	HLRM TTT,YX(A)
	HRLM TT,YX(F)
	TRNN TT,-1
	JRST .+4
	HLRZ F,(TT)
	HLRZ F,1(F)
	HLRM TT,YX(F)
	MOVSS TTT,TTT
	TRNN TTT,-1
	JRST MOV$LOCHW$0
	HLRZ F,(TTT)
	HLRZ F,1(F)
	HLLM TTT,YX(F)
	JRST MOV$LOCHW$0
MOV$LOCHW$1:
	HLRZ F,YX(A)
	JUMPE F,MOV$LOCHW$2
	H$LOCHW$RE TT,1(F)
	CAML T,TT
	JRST MOV$LOCHW$2
	HLRZ F,(F)
	HLRZ F,1(F)
	MOVSS TT,YX(F)
	MOVSS TTT,YX(A)
	HLRM TTT,YX(F)
	HRLM TT,YX(A)
	TRNN TT,-1
	JRST .+4
	HLRZ F,(TT)
	HLRZ F,1(F)
	HLRM TT,YX(F)
	MOVS TTT,TTT
	TRNN TTT,-1
	JRST MOV$LOCHW$0
	HLRZ F,(TTT)
	HLRZ F,1(F)
	HLLM TTT,YX(F)
	JRST MOV$LOCHW$0

MOV$LOCHW$2:
	POP P,TT
	POP P,T
	POP P,A
	POPJ P,
>

PMOVY:	FOO (HLL,R,1,0)
PMOVX:	FOO (HRR,L,0,1)

SEGTAB:	HRRZ T,(A)
	HRRZ T,1(A)
	HLRZ T,(A)
	HLRZ T,1(A)

HVMAG:	CAMG TTT,TT
	CAMG TT,TTT
	CAMG TTT,TT
	CAMG TT,TTT

HVNEWT:	HLRZ TT,(T)
	HLRZ TT,1(T)
	HRRZ TT,(T)
	HRRZ TT,1(T)

HVNEWA:	HRRZ TT,(A)
	HRRZ TT,1(A)
	HLRZ TT,(A)
	HLRZ TT,1(A)

HVSTOT:	HRLM TT,(T)
	HRLM TT,1(T)
	HRRM TT,(T)
	HRRM TT,1(T)

HVSTOA:	HRRM TT,(A)
	HRRM TT,1(A)
	HRLM TT,(A)
	HRLM TT,1(A)

HVCLRT:	HRRZS (T)
	HRRZS 1(T)
	HLLZS (T)
	HLLZS 1(T)

HVCLRA:	HLLZS (A)
	HLLZS 1(A)
	HRRZS (A)
	HRRZS 1(A)
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;MOVE TEXT OFFSET, CPIN OFFSET
MD,<
PMOVEL:	TRNE INMOV
	JRST PERRET
	TRO LMOVE		;MOVE CPIN OFFSET
	TLZ TMOVE
>;MD
PMOVET:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE T,1(A)
	HLRZ A,(A)
	HRRZ A,1(A)
MD,<	TRNN LMOVE
	JRST PMOVT1
	MOVE TT,1(A)
	TLNN TT,CPIN
	JRST PERRET
	TLZ TT,FIXCON		;TURN OFF FIXCON WHEN HE MOVES IT
	MOVEM TT,1(A)		;AND STORE BACK
	HRRZ A,(A)
	JRST PMOVL1

PMOVT1:	MOVSI TT,FIXTXT!FIXRHT	;TURN THESE OFF WHEN HE MOVES TEXT OFFSET
	ANDCAM TT,1(A)
	HLRZ A,(A)
	JUMPE A,PERRET
PMOVL1:	PUSHJ P,TOFSET
>;MD
MPC,<	HLRZ A,(A)	;TEXT POINTER
	JUMPE A,PERRET
	ADJUST(ADD,T,<1(A)>)
>;MPC
	JSP TT,DOMOVE
	MOVE A,CLOSES
	MOVE TT,1(A)
	HLRZ A,(A)
	HRRZ A,1(A)
MD,<	TRNE LMOVE
	JRST [	HRRZ A,(A)	;USE CPIN POINTER IF LMOVE
		JRST TOFMOV]
	HLRZ A,(A)
	PUSHJ P,TOFMOV
	CAMN T,1(A)
	POPJ P,
	MOVE A,CLOSES
	JRST OFFCON		;FIX CON (NOT IF NO MOVE)
>;MD
MPC,<	HLRZ A,(A)	>

TOFMOV:	MOVE T,CURSE
	TLO T,1
	SUB T,TT
	TLZ T,1
MD,<	HLRE TT,T
	HRRE T,T
	SCALE T
	SCALE TT
	HRL T,TT
>;MD
	CAMN T,1(A)
	POPJ P,
	EXCH T,1(A)
	TRO MCHG
	POPJ P,

MD,<
TOFSET:	HLRE TT,1(A)	;CONSTANT OFFSET
	UNSCAL TT
	MOVE TTT,TT
	HRRE TT,1(A)
	UNSCAL TT
	HRL TT,TTT	;UNSCALED OFFSET
	TLZ TT,1
	ADD T,TT	;CURSOR POS
	TDZ T,[1,,1]
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;MOVE BODY AND BODY LOC
BMOVE:	PUSHJ P,GETCLS
	JRST PERRET
BMOVEP:	MOVE T,1(A)
	JSP TT,DOMOVG
;MOVE SUBR
	MOVE A,CLOSES	;GET POINTER TO CLOSEST BODY
	MOVE T,CURSE	;GET CURRENT CURSOR POSITION
	CAMN T,1(A)
	POPJ P,
ROUTE,<MPC,<TLZ M,%ROUTE>>;MAKE HIM ROUTE AGAIN
	MOVEM T,1(A)	;SET BODY POS
	TRO MCHG
	JRST BODFIX	;AND FIX PINS

MD,<
BMOVEL:	TRNN INMOV
	PUSHJ P,GETCLS
	JRST PERRET
	MOVE T,1(A)
	HLRZ A,(A)
	HLRZ A,1(A)
	MOVSI TT,FIXLOC
	ANDCAM TT,1(A)		;TURN OFF AUTO POSITION BIT
	HRRZ A,(A)
	JUMPE A,PERRET
	MOVE TT,1(A)
	ADJUST(ADD,T,TT)
	TLNE M,BLOCS
	TRO MCHG		;REDISPLAY IN CASE WE TURNED THIS LOC ON
	TRO LMOVE
	TLZ TMOVE
	JSP TT,DOMOVE
;MOVE SUBR
	MOVE A,CLOSES
	MOVE T,CURSE
	ADJUST(SUB,T,<1(A)>)	;CALC OFFSET FROM BODY
	HLRZ A,(A)
	HLRZ A,1(A)
	HRRZ A,(A)
	CAMN T,1(A)
	POPJ P,
	MOVEM T,1(A)		;STO IN LOC BLOCK
	TRO MCHG
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                    ;EDIT MOVES
MD,<
EPMOVE:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE T,1(A)
	JSP TT,DOMOVG
;MOVE SUBR
	MOVE A,CLOSES	;GET POINTER TO CLOSEST PIN
	MOVE T,CURSE	;GET CURRENT CURSOR POSITION
	CAMN T,1(A)
	POPJ P,
	MOVEM T,1(A)
	TRO MCHG
	SKIPN A,PONPNT
	POPJ P,
EDPFIX:	HLRZ C,(A)	;POINTER TO DATA BLOCK
	HRRZ D,1(C)	;POINTER TO TEXT AND BODY POINTER
	HRRZ B,(D)	;POINTER TO PIN DSCR IN TYPE
	CAME B,CLOSES	;IS THIS ONE OF OUR PINS
	JRST NOFIX	;NO
	HLRZ E,(C)	;POINTER TO BODY
	MOVE T,1(B)	;GET PIN X,Y
	HLRZ F,(E)	;DATA BLOCK POINTER OF BODY
	HLRZ F,(F)	;ORIENTATION
	PUSHJ P,ORIENT	;ORIENT IT
	ADJUST(ADD,T,<1(E)>)
	PUSHJ P,PMOVRL	;AND MOVE IT
NOFIX:	HRRZ A,(A)
	JUMPN A,EDPFIX	;NEXT
	POPJ P,

ETMOVE:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE T,1(A)
	MOVE TT,MODE
	CAIE TT,BTXTM
	JRST NBTXT0
	MOVE TT,BTBODY
	PUSH P,F
	HLRZ F,(TT)
	HLRZ F,(F)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TT)>)
NBTXT0:	JSP TT,DOMOVG
;MOVE SUBR
	MOVE A,CLOSES	;GET POINTER TO CLOSEST TEXT
	MOVE T,CURSE	;GET CURSOR POSITION
	MOVE TT,MODE
	CAIE TT,BTXTM	;BODY TEXT MODE?
	JRST NBTXT1
	MOVE TT,BTBODY
	ADJUST(SUB,T,<1(TT)>)
	PUSH P,F
	HLRZ F,(TT)
	HLRZ F,(F)
	MOVE F,UNROT(F)
	PUSHJ P,ORIENT
	POP P,F
NBTXT1:	MOVE TT,1(A)
	TDZ TT,[1,,1]
	TDZ T,[1,,1]
	CAMN T,TT
	POPJ P,
	XOR TT,1(A)	;GET STATE OF AUTO OFFSET BIT AND MARK BIT
	IOR T,TT	;AND MOVE TO NEW X,Y
	MOVEM T,1(A)	;DEPOSIT AS NEW X,Y OF TEXT
	TRO MCHG
	POPJ P,

ETMOVT:	PUSHJ P,GETCLS
	JRST PERRET
	MOVE T,1(A)
	TRZ T,1
	MOVEM T,1(A)		;CLEAR AUTO OFFSET BIT
	TLZ T,1			;AND MARK BIT
	MOVE TT,MODE
	CAIE TT,BTXTM
	JRST NBTXT2
	MOVE TT,BTBODY
	PUSH P,F
	HLRZ F,(TT)
	HLRZ F,(F)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TT)>)
NBTXT2:	HLRZ A,(A)
	PUSHJ P,TOFSET
	JSP TT,DOMOVE
;MOVE SUBR
	MOVE A,CLOSES
	MOVE TT,1(A)
	TDZ TT,[1,,1]
	HLRZ A,(A)
	MOVE T,MODE
	CAIE T,BTXTM
	JRST TOFMOV
	MOVE TTT,BTBODY
	MOVE T,TT
	PUSH P,F
	HLRZ F,(TTT)
	HLRZ F,(F)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TTT)>)
	MOVE TT,T
	JRST TOFMOV

EMOVEL:	TRNE INMOV
	JRST PERRET
	MOVE A,CURBOD
	HLRZ A,1(A)
	HLRZ A,(A)
	MOVE T,1(A)		;DEFAULT OFFSET
	TRO LMOVE
	TLZ TMOVE
;MOVE SUBR
	JSP TT,DOMOVE
	MOVE A,CURBOD
	HLRZ A,1(A)
	HLRZ A,(A)
	MOVE T,CURSE
	CAMN T,1(A)
	POPJ P,
	MOVEM T,1(A)	;NEW DEF OFFSET
	TRO MCHG
	JRST UPLOFF		;UPDATE OFFSET FOR ALL INSTANCES WITH FIXLOC ON
>;MD
                                                                                                                                                                  ;MOVE SET
DOSMOV:	MOVE A,CLOSES
	TDZ [TMOVE,,MD,<LMOVE!>TFLG!INMOV]
	JRST SMOVE1

SMOVE:	TRNN STBOX		;ARE WE MOVING ALREADY OR DRAWING A BOX
	PUSHJ P,GETCLS		;CURRENT SET
	JRST PERRET		;NONE
SMOVE1:	MOVE T,1(A)		;LOC OF CENTER
	JSP TT,DOMOVG
;MOVE SUBR
	MOVE A,CLOSES			;CURRENT SET
ROUTE,<MPC,<TLZ M,%ROUTE>>		;MAKE HIM ROUTE AGAIN
	MOVE T,CURSE			;CURRENT CURSOR POSITION
	ADJUST(SUB,T,<1(A)>)		;GET DIFFERENCE
	JUMPE T,CPOPJ			;RETURN IF HE DIDN'T MOVE
	MOVE TT,CURSE
	MOVEM TT,1(A)			;NEW SET LOC.
	HLRZ A,(A)			;POINT TO FIRSTSET MEMBERS
	JUMPE A,CPOPJ
	TRO MCHG			;PIC WILL CHANGE
MMSET1:	HRRZ B,1(A)			;POINT
	JUMPE B,NOPNTM			;NO POINT HERE
	MOVE TT,T
	ADJUST(ADD,TT,<1(B)>)		;NEW LOC
	MOVEM TT,1(B)			;SAVE
NOPNTM:	HLRZ B,1(A)			;BODY
	JUMPE B,NOBODM			;NO BODY HERE
	MOVE TT,T
	ADJUST(ADD,TT,<1(B)>)		;NEW LOC
	MOVEM TT,1(B)			;SAVE
	PUSH P,A
	MOVE A,B
	PUSH P,T
	PUSHJ P,BODFIX
	POP P,T
	POP P,A
NOBODM:	HRRZ A,(A)			;NEXT MEMBERS
	JUMPN A,MMSET1
	MOVE A,CLOSES			;FIX FEED THROUGHS
MPC,<	JRST FEDFIX	>;MPC
MD,<	HLRZ G,(A)
FIXPNT:	HRRZ A,1(G)			;GET A POINT POINTER
	JUMPE A,FXNOPT			;NO POINT HERE
	MOVE TT,1(A)			;X,Y
	PUSHJ P,PMOVY			;MOVE VERTICAL ONES
	PUSHJ P,PMOVX			;MOVE HORIZONTAL ONES
FXNOPT:	HLRZ A,1(G)			;BODY IN SET
	JUMPE A,FXNPNS			;NONE
	JRST FIXPN1
FIXPIN:	PUSH P,A
	MOVE TT,1(A)
	PUSHJ P,PMOVX
	PUSHJ P,PMOVY
	POP P,A
FIXPN1:	HLRZ A,(A)
	HRRZ A,(A)		;NEXT PIN OF BODY
	JUMPN A,FIXPIN
FXNPNS:	HRRZ G,(G)			;NEXT SET MEMBERS
	JUMPN G,FIXPNT			;AND LOOP
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                         ;MICRO MOVEMENT COMMANDS
MD,<
LOCTM:	MOVEI T,1
	LSH T,@MODE
	TDNN T,[1TXTM!1PNTM!1EDTTM!1BTXTM]
	JRST PERRET
	TLO TMOVE		;MOVE T OFFSET
	TDNN T,[1EDTTM!1BTXTM]
	JRST MICLOC
	TRZ INLIN!INMOV
	PUSHJ P,GETCLS
	JRST PERRET
	MOVEI T,1
	ANDCAM T,1(A)
	HLRZ B,(A)
	JRST LOCMTY

LOCLM:	MOVEI T,1
	LSH T,@MODE
	TDNN T,[1TXTM!1PNTM]
	JRST PERRET
	TLZ TMOVE
MICLOC:	TRZ INLIN!INMOV
	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ B,(A)
	HRRZ B,1(B)
	TLNN TMOVE		;IF LAST MOVE WAS CLOC
	JRST LOCM0
	MOVSI TTT,FIXTXT!FIXRHT
	ANDCAM TTT,1(B)		;TURN THESE OFF HERE
	HLRZ B,(B)
	JUMPE B,PERRET
	JRST LOCMTY

LOCM0:	MOVE TTT,1(B)
	TLNN TTT,CPIN
	JRST PERRET
	TLZ TTT,FIXCON
	MOVEM TTT,1(B)
	HRRZ B,(B)		;DO IT
LOCMTY:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/USE CURSOR MOVE COMMANDS TO MOVE OFFSET.
/]
	TRO INMOV			;TURN ON MOVING SO BIG LETTERS GO AWAY
LOCM:	PUSHJ P,GETCHR
	LDB D,[POINT 2,C,28]
	ANDI C,177
	MOVSI TTT,-MICLEN
LOCM1:	CAME C,MICCHR(TTT)
	AOBJN TTT,.-1
	SETZB T,TT
	XCT MICTAB(TTT)
	ASH T,(D)		;SHIFT BY BITS BEING HELD DOWN
	ASH TT,(D)
	HRRE TTT,1(B)
	ADD TT,TTT
	HLRE TTT,1(B)
	ADD T,TTT
	HRL TT,T
	CAMN TT,1(B)
	JRST LOCM
	MOVEM TT,1(B)		;STO Y
	TRO MCHG		;CHANGES PIC
	JRST LOCM

LOCMDN:	TRZ INMOV		;DONE, TURN OFF MOVING
	POPJ P,			;AND LEAVE

NODEC,<
MICCHR:	")"			;RIGHT SMALL
	"("			;LEFT SMALL
	"/"			;UP SMALL
	"\"			;DOWN SMALL
	"]"			;RIGHT BIG
	"["			;LEFT BIG
	""			;UP BIG
	""			;DOWN BIG
	12			;NOOP
	ALTMOD			;LEAVE
	40			;LEAVE
MICLEN__.-MICCHR
>;NODEC
DEC,<
MICCHR:	"9"	;RS
	"8"	;LS
	"6"	;US
	"7"	;DS
	")"	;RB
	"("	;LB
	"&"	;UB
	"'"	;DB
	12		;NOOP
	ALTMOD		;LEAVE
	40		;LEAVE
MICLEN__.-MICCHR
>;DEC
MICTAB:	MOVEI T,1		;RS
	MOVNI T,1		;LS
	MOVEI TT,1		;US
	MOVNI TT,1		;DS
	MOVEI T,10		;RB
	MOVNI T,10		;LB
	MOVEI TT,10		;UB
	MOVNI TT,10		;DB
	JRST LOCM		;NOOP
	JRST LOCMDN		;LEAVE
	JRST LOCMDN		;LEAVE
	JRST MICERR		;UNKNOWN COMMAND

MICERR:	PUSHJ P,PERRET
	JRST LOCM
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;MOVE ALONG LINES
LINUP:	MOVEI TTT,2
	JRST DOMLIN

LINDWN:	MOVEI TTT,3
	JRST DOMLIN

LINRT:	TDZA TTT,TTT
LINLFT:	MOVEI TTT,1
DOMLIN:	TRNE INMOV
	JRST [	SKIPN A,CLOSES
		JRST PERRET
		JRST LINMOV]
	PUSHJ P,GETCLS
	JRST PERRET
LINMOV:
MD,<	HLRZ B,(A)
	HLRZ B,1(B)
	XCT PERTAB(TTT)
	JUMPN H,LINMV4		;PERFECT MATCH?
	XCT LASTAB(TTT)
	JUMPE H,PERRET		;ANY SECONDARY CHOICE?
	TLNN H,-1
	JRST LINMV4
	MOVS H,H
	TLNE H,-1
	JRST PERRET
>;MD
MPC,<
	SETZB H,G		;NO CHOICE YET, MAX SLOPE =0 SO FAR
	SETZ F,			;ALSO LAST DITCH CHOICE
	HLRZ B,(A)
	HLRZ B,1(B)
	JUMPE B,PERRET		;LOSE IF NO NEIGHBORS
LINMV1:	MOVEI C,2
LINMV2:	XCT (C)[HLRZ D,(B)
		HRRZ D,1(B)
		HLRZ D,1(B)]
	JUMPE D,LINMV3
	MOVE T,1(D)
	ADJUST(SUB,T,<1(A)>)
	HRRE TT,T		;Y TO TT
	HLRE T,T		;X TO T
	XCT LASTAB(TTT)		;IS IT A SECONDARY CHOICE??
	XCT SIDTAB(TTT)		;IS IT EVEN A CHOICE?
	XCT PERTAB(TTT)		;IS IT A PERFECT LINE?
	TRNE TTT,2		;IF VERT
	EXCH T,TT		;INTERCHANGE X AND Y
	IDIV T,TT		;X/Y (OR Y/X FOR VERT)
	MOVM T,T
	CAMG T,G		;BIGGER?
	JRST LINMV3		;NO
	MOVE H,D
	MOVE G,T
LINMV3:	SOJGE C,LINMV2
	HRRZ B,(B)
	JUMPN B,LINMV1
	JUMPN H,LINMV4		;ERROR IF NO GOOD ONE FOUND
	JUMPLE F,PERRET		;IF NONE, OR TOO MANY, LOSE
	MOVE H,F
	JRST LINMV4

LINMV6:	JUMPE F,.+2
	HRRO D,D		;FLAG TOO MANY
	MOVE F,D
	JRST LINMV3

LINMV5:	MOVE H,D
>;MPC
LINMV4:	HLRZ T,(H)
	HRRZ T,1(T)
	MOVE T,1(T)
MD,<	TDNN [TMOVE,,LMOVE]	>
MPC,<	TLNN TMOVE		>;IF MOVING OFFSET
	TLNE T,MPC,<CPIN!>ISPIN	;OR PIN
	TRZN INMOV		;STOP MOVING
	CAIA
	TRO NEEDCL
	MOVE T,H
	JRST SCLOSP

MD,<
PERTAB:	HRRZ H,1(B)		;R
	HLRZ H,1(B)		;L
	HRRZ H,(B)		;U
	HLRZ H,(B)		;D

LASTAB:	MOVE H,(B)		;UD
	MOVE H,(B)		;UD
	MOVE H,1(B)		;LR
	MOVE H,1(B)		;LR
>;MD

MPC,<
LASTAB:	JUMPE T,LINMV6		;R
	JUMPE T,LINMV6		;L
	JUMPE TT,LINMV6		;U
	JUMPE TT,LINMV6		;D

SIDTAB:	JUMPLE T,LINMV3		;R	NEG X IS WRONG
	JUMPGE T,LINMV3		;L	POS X IS WRONG
	JUMPLE TT,LINMV3	;U	NEG Y IS WRONG
	JUMPGE TT,LINMV3	;D	POS Y IS WRONG

PERTAB:	JUMPE TT,LINMV5		;R
	JUMPE TT,LINMV5		;L
	JUMPE T,LINMV5		;U
	JUMPE T,LINMV5		;D
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        COMMENT    VALID 00015 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	<DRAW>DRAW.FAI73, 29-JUL-75 17:39:04, EDIT BY HELLIWELL
C00003 00003	MAIN DISPLAY, CARD STUFF
C00006 00004	MAIN DISPLAY, BODIES AND POINTS
C00007 00005	BODIES
C00010 00006	POINTS
C00011 00007	MORE POINTS, SHOW PAD, DRILL HOLE, PLANE CONNECTIONS (PC)
C00014 00008	MORE POINTS, PIN NUMBERS, TEXT.
C00017 00009	POINT SUBR, DRAW LINES
C00019 00010	EDIT DISPLAY (D)
C00022 00011	OUTBOD:(PC)
C00025 00012	OUTBOD:(D)
C00029 00013	ALTER MODE DISPLAY
C00031 00014	ORIENTATION TABLES AND ROUTINES
C00033 00015	CARD SUBRS
C00037 ENDMK
C;
           ;<DRAW>DRAW.FAI;73, 29-JUL-75 17:39:04, EDIT BY HELLIWELL
VERSION(DRAW,11)
DISP:	TLNN DSPACT
	POPJ P,
	MOVE T,MODE	;GET MODE
MPC,<	CAIE T,MALTM
	CAIN T,ALTM
	JRST TXTDIS	;THIS IS SPECIAL
>;MPC
MD,<
	JRST @MTAB(T)	;DISPATCH

MTAB:	DP2	;S
	DP2	;B
	DP2	;P
	DP2	;L
	DP2	;T
	TXTDIS	;A
	TXTDIS	;MA
	DP2	;SP
	DP2	;BT
	TXTDIS	;BTA
	DPED	;E
	DPEDI	;EI
	DPED	;ET
	DPED	;EP
	DPEDGT	;EG
	TXTDIS	;EA
REPEAT NUMODES+<MTAB-.>,<CPOPJ
>
                                                                                                                                                                                             ;MAIN DISPLAY, CARD STUFF
DP2:	PUSHJ P,CLEAR1
	PUSHJ P,CLEAR2
>;MD
	TRZN MCHG
	JRST @DSPDSP
	SOFAR
	PUSHJ P,BLDISP
	SOFAR
	MOVEI T,MAINPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	PUSHJ P,UPSET		;UPDATE CURRENT SET!
MD,<	PUSHJ P,UPLOC		;UPDATE GLOBAL CARD LOC
	SKIPN SWIDTH		;ANY BOX TO SHOW?
	JRST NOSBOX		;NO
	PUSH P,M
	TLO M,LWINDOW		;ALWAYS LWINDOW THIS BOX
	MOVE T,SWIDTH
	HRR T,SHEIGHT
	PUSHJ P,AIVECT
	MOVS T,SWIDTH
	HRR T,SHEIGHT
	PUSHJ P,AVECT
	MOVS T,SWIDTH
	HLR T,SHEIGHT
	PUSHJ P,AVECT
	MOVE T,SWIDTH
	HLR T,SHEIGHT
	PUSHJ P,AVECT
	MOVE T,SWIDTH
	HRR T,SHEIGHT
	PUSHJ P,AVECT
	POP P,T
	TLNN T,LWINDOW
	TLZ M,LWINDOW
NOSBOX:
>;MD
MPC,<
ROUTE,<	PUSHJ P,PDISP	>
	PUSHJ P,UPSIDE		;SOLDER-COMPONENT STUFF
	TLNN M,CRDISP
	JRST CRDDON
	PUSHJ P,SETDEF
	MOVEI A,CRDLST
	JRST CRDLIP
CRDLOP:	MOVE T,1(A)
	TRZE T,1
	JRST [	PUSHJ P,AIVECT
		JRST CRDLIP]
	PUSHJ P,AVECT
CRDLIP:	HRRZ A,(A)
	JUMPN A,CRDLOP
	TRNE M,XFINGER
	JRST NOTARG		;SKIP TARGETS IF NO FINGERS
	HLRZ A,CRDLST
	JUMPE A,NOTARG
DOTARG:	MOVE T,1(A)
	PUSHJ P,BIGAIV
nodec,<	MOVEI T,""+""+1	>
dec,<	movei t,""+""+1	>
	PUSHJ P,TXTDPB
NTARG:	HRRZ A,(A)
	JUMPN A,DOTARG
NOTARG:	MOVE T,DEFBRT
	PUSHJ P,DPYBRT		;BRIGHT IN BOTH SIDES MODE
	PUSHJ P,FNGBAR		;DO FINGERS AND BARS
	TRNN BTHSDS
	JRST CRDDON		;ONLY ONE SIDE
	SWITCH
	PUSHJ P,FNGBAR
	SWITCH
CRDDON:	CHECKIN
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;MAIN DISPLAY, BODIES AND POINTS
	MOVE T,DEFBRT
	PUSHJ P,DPYBRT
	SKIPE E,DBODPN
	PUSHJ P,BODYS
	CHECKIN
MPC,<	MOVE T,BTHBRT
	TRNE BTHSDS
	PUSHJ P,DPYBRT
>;MPC
	SKIPE E,PONPNT
	PUSHJ P,POINTS
MPC,<	TRNN BTHSDS
	JRST NOBOTH
	CHECKIN
	SWITCH
	MOVE T,DEFBRT
	PUSHJ P,DPYBRT
	PUSH P,M
	TLZ M,CLOCS
	TRO M,NDIPS
	SKIPE E,PONPNT
	PUSHJ P,POINTS
	POP P,M			;RESTORE FLAGS
	SWITCH
NOBOTH:
>;MPC
	PUSHJ P,MAINOU		;ALL DONE, DISPLAY IT!
	SOFAR			;FINISHED, MAKE US A NOOP
	POPJ P,
                                                                                                                                           ;BODIES
BODYS:
	MOVE D,1(E)	;GET THE LOCATION OF THE CENTER OF THE BODY
	HLRZ T,(E)	;GET POINTER TO DATA BLOCK
	HRRZ A,1(T)	;GET POINTER TO BODY DEFINITION
	HLRZ F,(T)	;GET ORIENTATION
	TLNN M,BLOCS
	JRST NONUM
	HLRZ B,1(T)	;POINTER TO LOC BLOCK
MD,<	HLRZ T,1(B)	;GET BODY BITS
	TLNN M,UNHIDE	;IF UNHIDING, ALWAYS DISPLAY
	TRNN T,FIXLOC	;ARE WE TRACKING DEFINITION?
	JRST DISLC1	;NO, WILL DISPLAY
	HLRZ T,1(A)
	HLRZ T,(T)
	HLRZ T,(T)	;TYPE BITS
	TRNE T,XDISLOC	;SUPPRESSING DISPLAY OF LOC?
	JRST NONUM	;YES
DISLC1:	HRRZ B,(B)	;REAL POINTER
	JUMPE B,NONUM	;IS THERE ANY?
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	PUSH P,A
	MOVE A,1(E)
	ADJUST(ADD,A,<1(B)>)
	HLRZ B,(B)
	PUSH P,B
	MOVE B,1(B)
	PUSHJ P,ABCALC
	POP P,B
	POP P,A
>;MD
MPC,<
	HRRZ T,(B)
	JUMPE T,NONUM	;NO NUMBER
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	MOVE T,1(E)		;GET PIC OFFSET
	PUSHJ P,PINPOS
>;MPC
	PUSHJ P,BODNUM
NONUM:
MPC,<	TLNN M,%IDENT
	JRST NDIPID
	HLRZ B,(E)
	HLRZ B,1(B)
	HRRZ B,1(B)
	JUMPE B,NDIPID
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	MOVE T,1(E)
	PUSHJ P,AIVECT
	MOVEI T,25	;ASCID/LF/
	PUSHJ P,TXTDPB
	PUSHJ P,PLUNK	;AND STRING
NDIPID:
>;MPC
MD,<	HLRZ T,(E)
	HLRZ T,1(T)
	HRRZ T,1(T)
	MOVEM T,BTXLST
>;MD
	PUSHJ P,OUTBOD	;OUTPUT THE BODY
ARN1:	HRRZ E,(E)	;GET NEXT BODY
	JUMPN E,BODYS	;LOOP IF ANY LEFT
	POPJ P,

PLUNK:	MOVE T,1(B)
	TRO T,1
	PUSHJ P,TXTDPB
	HRRZ B,(B)
	JUMPN B,PLUNK
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ;POINTS
POINTS:	PUSHJ P,DLOP3
	HRRZ E,(E)
	JUMPN E,POINTS
	POPJ P,

;DLOP3 CALLED FROM LAYOUT STUFF TO BLINK WIRE
DLOP3:	HLRZ D,(E)
	MOVE T,1(E)
	PUSHJ P,ONSCR
	JRST [	TLNE M,LWINDOW
		PUSHJ P,DLOP5		;OFF SCREEN, DO LINES IF WINDOWING
		POPJ P,]		;THEN LEAVE
	PUSHJ P,DLOP5			;DO LINES, THEN GO ON
	HLRZ D,(E)
	HRRZ D,1(D)
	HLL D,1(D)
                                                                                                                                                                                                                                                                                               ;MORE POINTS, SHOW PAD, DRILL HOLE, PLANE CONNECTIONS (PC)
MPC,<	HRRZ T,1(D)
	TLNE D,ISPIN	;HANDLE PIN SEPERATELY
	JRST [	TRNE M,NDIPS	;SUPPRESSING DIP PINS?
		JRST NOPLAN	;YES
;		CAIE T,1	;LET 1 GO BY
;		JRST SHWPAD
		MOVE T,NSCALE
		CAIL T,5
		JRST SHWPAD
		JRST NOPLAN]
	TRNE M,XFEED		;SUPPRESSING FEED THROUGHS?
	JRST NOFEED
	TLNN D,FEEDTH
	JUMPE T,NOFEED
SHWPAD:	MOVE T,1(E)	;X,Y
	HRRZ TT,1(D)
	CAIN TT,2		;2 (CLEARANCE) SHOULD BE BIGGER
	JRST [	PUSHJ P,SM2AIV
		JRST .+2]
	PUSHJ P,SMLAIV
	TLNE D,ISPIN!FEEDTH
nodec,<	SKIPA T,[""+""+1]	>
dec,<	skipa t,[""+""+1]	>
	MOVEI T,"O"+"O"+1
	HRRZ TT,1(D)
	JUMPN TT,.+2
	MOVEI T,"X"+"X"+1
	CAILE TT,2
NOSTAN,<JRST [	CAILE TT,=9
		MOVEI TT,"??"-60	;FLAG AS ERROR
		MOVEI T,60(TT)
		LSH T,1			;MAKE ASCID
		TRO T,1
		JRST .+1]
>;NOSTAN
STANFO,<JRST [	CAILE TT,=99	;PAD TYPES OF MORE THAN TWO DIGITS ARE RIDICULOUS
		JRST [	MOVEI TT,"??"+1
			JRST .+1]
		IDIVI TT,=10
		MOVEI T,1
		ADDI TTT,60
		DPB TTT,[POINT 7,T,34]
		SKIPN TT
		JRST .+1
		ADDI TT,60
		DPB TT,[POINT 7,T,27]
		JRST .+1]
>;STANFO
	PUSHJ P,TXTDPB
NOFEED:	TLNN D,PLANES
	JRST NOPLAN
	MOVE T,1(E)
	PUSHJ P,SMGAIV
	LDB T,[POINT 3,1(D),6]
	MOVE T,(T)[	1
			ASCID/\/
			ASCID//
			ASCID/=/
			ASCID//
			1
			1
			1	]
	PUSHJ P,TXTDPB
NOPLAN:
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;MORE POINTS, PIN NUMBERS, TEXT.
	TLNE M,CLOCS
	TLNN D,CPIN	;DOING PINS, IS THIS A CONNECTOR PIN?
	JRST NOCONP	;DON'T HAVE TO FOOL AROUND HERE
	HRRZ B,(D)
MD,<
	TRNN M,NOCBOX	;SKIPPING CBOX FOR NOW?
	PUSHJ P,CONBOX	;PUT BOX FOR CONNECTOR ID
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	PUSHJ P,CALCOF
>;MD
MPC,<	MOVE T,1(E)
	PUSHJ P,SMLAIV	;VECTOR TO THERE
>;MPC
	PUSHJ P,CONNUM	;WILL DO RIGHT THING
MD,<	JRST NONUMP	;CHECK IF MUST FOOL

NOCONP:	TLNN D,ISPIN	;YES, IS THIS A PIN?
	JRST NONUMP
	TLNN M,RPINID
	JRST NORID
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	MOVE T,1(E)
	PUSHJ P,PINPOS
	HLRZ TTT,(E)
	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)		;GET ORIENTATION
	HRRZ T,(D)
	HLRZ T,(T)
	PUSHJ P,DISRID
	JRST NONUMP

NORID:	TLNN M,PLOCS	;DOING PINS?
	JRST CKPNID	;NO, CHECK ID'S
	HRRZ TT,(D)
	HLRZ TT,(TT)
	HLRZ T,(TT)	;PIN DEF BITS
	TRNE T,BUSSED	;BUSSED THROUGH?
	TLNE M,UNHIDE	;YES, ARE WE UNHIDING THEM?
	CAIA		;NOT BUSSED OR UNHIDING
	JRST NONUMP	;BUSSED AND NOT UNHIDING
	HRRZ T,1(D)	;GET PIN NUMBER
	JUMPN T,ISNUMP
	TLNN M,PINIDS
	JRST NONUMP
	HRRZ T,1(TT)
ISNUMP:	PUSH P,T
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	MOVE T,1(E)
	PUSHJ P,PINPOS	;THIS WILL GET FUDGED PROPERLY
	POP P,T
	HLRZ TTT,(E)
	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)
	HLRZ A,1(TTT)
	HLRZ A,1(A)
	HRL A,T
	HLRZ TTT,(TTT)
	PUSHJ P,DISPIN	;DISPLAY IT
	JRST NONUMP

CKPNID:	TLNN M,PINIDS
	JRST NONUMP
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	MOVE T,1(E)
	PUSHJ P,PINPOS
	HLRZ TTT,(E)
	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)	;ORIENTATION
	HRRZ T,(D)
	HLRZ T,(T)
	PUSHJ P,DISDEF
>;MD
MPC,<NOCONP:>
NONUMP:	HLRZ B,(D)	;GET TEXT POINTER
	JUMPE B,DLOP4	;ANY AT ALL?
	TRNE M,NPTEXT
	JRST DLOP4
	HRRZ T,(B)
	HLRZ T,(T)	;GET SIZE
	ANDI T,377777
	PUSHJ P,DPYBIG	;SET SIZE
	PUSHJ P,CALCOF
	HRRZ B,(B)
	PUSHJ P,DTXT	;DISPLAY TEXT
DLOP4:	POPJ P,
                                                  ;POINT SUBR, DRAW LINES
LINOUT:	MOVE T,1(E)
MPC,<	CAMGE T,1(A)
	POPJ P,
>;MPC
	PUSHJ P,AIVECT	;DRAW INVIS. TO IT
	MOVE T,1(A)	;GET X,Y FOR TARGET POINT
	JRST AVECT	;DRAW VIS. TO IT & LEAVE

;SUBR TO DRAW LINES
DLOP5:	TRNE M,NLINES
	POPJ P,		;NOT DOING LINES!
MD,<
	HLRZ D,1(D)	;GET POINTER TO ^_ BLOCK

	DEFINE FOO (Q,Z)
<	Q   A,Z(D)
	JUMPE A,.+2
	PUSHJ P,LINOUT>

	FOO(HRRZ)
	FOO(HRRZ,1)
	POPJ P,
>;MD
MPC,<
	HLRZ D,1(D)	;GET POINTER TO ^_ BLOCK
	JUMPE D,CPOPJ
DLOP7:	MOVEI B,2
DLOP8:	XCT (B)[	HLRZ A,(D)
			HRRZ A,1(D)
			HLRZ A,1(D)]
	JUMPE A,.+2
	PUSHJ P,LINOUT
	SOJGE B,DLOP8
	HRRZ D,(D)
	JUMPN D,DLOP7
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;EDIT DISPLAY (D)
MD,<
EDDISR:	TRZN MCHG
	TRNE INMOV
	JRST EDDIS1
	POP P,(P)
	POPJ P,

EDDIS1:	PUSHJ P,CLEAR1
	PUSHJ P,CLEAR2
	MOVEI T,MAINPG
	MOVEM T,PGLASS	;USE PIECE OF (GL)ASS NUMBER 3 (FOR EDITING BODY)
	PUSHJ P,DPYSET
	SETZ T,
	MOVEI TT,TITBIG
	MOVE TTT,[%LEFT,,SCRTOP-CHGHT*TITBIG*3]
	PUSHJ P,TITVCT
	MOVE T,[ASCID/BODYN/]
	PUSHJ P,TXTDPB
	MOVE T,[ASCID/AME: /]
	PUSHJ P,TXTDPB
	MOVE B,CURBOD
	HRRZ B,(B)
	JRST PLUNK

DPEDGT:	MOVE A,GETBOD	;BODY WE ARE GETTING
	MOVE D,CURSE	;PUT IT AT CURSOR
	MOVE F,GETORT
	MOVEI T,ANGLPG	;USE ANGLE PAGE
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	PUSH P,M
	TRZ M,NBTEXT
	PUSHJ P,PUTBOD	;DRAW BODY
	POP P,M
	PUSHJ P,BLINKO
DPED:	PUSHJ P,EDDISR
DPEDR:	MOVE A,CURBOD	;GET POINTER TO BODY
	SETZB D,F	;CLEAR OFFSET AND ORIENTATION
	PUSHJ P,PUTBDL	;OUTPUT IT
	JRST MAINOU

DPEDI:	PUSHJ P,EDDISR
	MOVE A,CLSTPN	;GET PRECEDING ("LAST") POINT
	SKIPN B,CRPPNT	;GET CURRENT POINT OF BODY
	JRST DPEDQ
	HRRZ D,(B)	;REMOVE LINK TO CURRENT POINT
	HRRM D,(A)	;...
	PUSH P,1(D)	;SAVE NEXT X,Y
	PUSH P,D	;SAVE D
	JUMPE D,DARN	;NO NEXT POINT?
	MOVEI T,1
	ORB T,1(D)	;MAKE INVISIBLE VECTOR AROUND CURRENT POINT
	MOVE T,-1(P)	;GET FOLLOW2 POINT
	TRNN T,1	;VISIBLE?
	PUSHJ P,FOLOW1	;YES, FOLLOW IT
DARN:	TRNE ATFP	;AT FIRST POINT?
	JRST FARN	;YES, DON'T FOLLOW
	MOVE T,1(A)	;NO, GET X,Y
	TRZ T,1		;SHUT OFF VIS/INVIS BIT
	TRNN TYPNEG	;NEGATIVE VECT FOLLOWING US?
	PUSHJ P,FOLOW2	;NO, FOLLOW IT
FARN:	MOVE A,CURBOD	;GET POINTER TO BODY
	SETZB D,F	;CLEAR OFFSET AND ORIENTATION
	PUSHJ P,PUTBDL	;PUT IT OUT
	POP P,D		;RESTORE D
	JUMPE D,[POP P,(P)
		JRST .+2]
	POP P,1(D)	;RESTORE X,Y FOR FOLLOWING POINT
	MOVE B,CRPPNT
	MOVE A,CLSTPN
	HRRM B,(A)	;RESTORE LINKAGE
	JRST MAINOU

DPEDQ:	MOVE T,1(A)
	TRZ T,1
	TRNN ATFP
	PUSHJ P,FOLOW1
	JRST DPEDR
>;MD
                                                                                 ;OUTBOD:(PC)
;	CALL WITH
;	A=POINTER TO TYPE DEFFINITION
;	D=X,Y OFFSET
;	F=ORIENTATION
MPC,<
PUTBDL:	HRRZ B,1(A)
	JUMPE B,OUTBD1
PUTBD1:	MOVE T,1(B)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,D)
	PUSHJ P,SMLAIV
nodec,<	MOVEI T,""+""+1	>
dec,<	movei t,""+""+1	>
	PUSHJ P,TXTDPB
	HRRZ B,(B)
	JUMPN B,PUTBD1
	JRST OUTBD1

OUTBOD:	MOVE T,NSCALE
	CAIGE T,5		;OR TOO SMALL TO DO ALL POINTS?
	JRST JSTBOX		;YES, SIMULATE WITH BOX
OUTBD1:	MOVEI T,STDBIG
	PUSHJ P,DPYBIG		;EVERYTHING HERE IS SIZE ONE
	TLNN M,PLOCS		;SHALL WE DO PINS
	JRST NONUMS
	MOVEI B,1(A)
	JRST NXTNUM
DONUM:	MOVE T,1(B)		;X,Y OF PIN
	PUSHJ P,ORIENT
	ADJUST(ADD,T,D)		;OFFSET IT
	PUSHJ P,AIVECT
	HLRZ T,(B)
	PUSHJ P,DISNUM
NXTNUM:	HRRZ B,(B)
	JUMPN B,DONUM
NONUMS:	HRRZ B,1(A)
	JUMPE B,NONMS1
FNPIN1:	HLRZ T,(B)
	CAIN T,1
	JRST ISPIN1
	HRRZ B,(B)
	JUMPN B,FNPIN1
	JRST NONMS1

ISPIN1:	MOVE T,1(B)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,D)
	PUSHJ P,SM1AIV
	MOVEI T,76*2+1
	PUSHJ P,TXTDPB
NONMS1:	TRNN M,NDIPS		;IF NO PINS BEING SHOWN, DRAW BOX
	POPJ P,
JSTBOX:	HLRO B,1(A)		;GET POINTER TO LINE LIST
	TRNN B,-1		;IS THERE ONE?
	HRRO B,1(A)		;NO, USE THIS ONE
JSTLOP:	MOVE T,1(B)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,D)
	TLNE B,-1		;FIRST TIME?
	JRST [	PUSHJ P,AIVECT	;YES
		JRST .+2]
	PUSHJ P,AVECT
	HRRZ B,(B)		;GET NEXT AND INDICATE NOT FIRST TIME
	JUMPN B,JSTLOP
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;OUTBOD:(D)
MD,<
PUTBDL:	TLNN M,BLOCS	;BODY LOCS ENABLED?
	JRST PUTBOD	;NO
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	PUSH P,A
	HLRZ A,1(A)
	HLRZ A,(A)
	HRRZ B,(A)
	MOVE A,1(A)
	ADJUST(ADD,A,D)
	JUMPN B,[MOVE B,1(B)
		JRST NLCFDG]
DEC,<	MOVNI T,CWIDTH*3
	IMUL T,CMUL+STDBIG
	ASH T,-1
	MOVNI B,CHGHT
	IMUL B,CMUL+STDBIG
	ASH B,-1
	HRL B,T
>;DEC
NODEC,<	SETZ B,	>
NLCFDG:	PUSHJ P,ABCALC
	POP P,A
	MOVE T,[ASCID/A01/]
	PUSHJ P,TXTDPB
	HLRZ T,1(A)
	HLRZ T,(T)
	HLRZ T,(T)		;TYPE BITS
	TRNN T,XDISLOC		;SUPPRESSING DISPLAY OF LOC FOR BODIES?
	JRST PUTBOD
	MOVE T,[ASCID/(-DIS/]
	PUSHJ P,TXTDPB
	MOVE T,[ASCID/LOC)/]
	PUSHJ P,TXTDPB
PUTBOD:	SETZM BTXLST
	TLNN M,RPINID!PINIDS	;DOING PIN ID'S?
	JRST OUTBOD	;NO
	MOVEI T,STDBIG
	PUSHJ P,DPYBIG
	HLRZ B,1(A)	;GET POINTER TO POINTER BLOCK
	JRST NXTNUM

DONUM:	MOVE T,1(B)	;GET X,Y OF PIN
	PUSHJ P,ORIENT	;ORIENT IT
	ADJUST (ADD,T,D);ADD BODY CENTER
	PUSHJ P,PINPOS
	HLRZ T,(B)	;PIN BITS ETC BLOCK
	MOVE TTT,F	;ORIENTATION
	TLNE M,RPINID
	PUSHJ P,DISRID
	TLNN M,RPINID
	PUSHJ P,DISDEF
NXTNUM:	HRRZ B,(B)
	JUMPN B,DONUM
OUTBOD:	MOVS B,1(A)	;GET POINTER TO POINTER BLOCK
	HRRZ B,1(B)	;GET POINTER TO LINES
	JUMPE B,DBPNT1	;NO MORE LINES?
DLOP1:	MOVE T,1(B)	;GET X,Y
	TRZE T,1	;INVISIBLE?
	TLO B,400000	;FLAG INVISIBLE (WAS CLEARED BY HRRZ)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,D)	;OFFSET IT
	TLNE B,400000	;INVISIBLE?
	JRST [	PUSHJ P,AIVECT ;YES
		JRST .+2]
	PUSHJ P,AVECT	;NO
	HRRZ B,(B)	;GET NEXT LINE
	JUMPN B,DLOP1
DBPNT1:	TRNE M,NBTEXT
	POPJ P,
	SKIPN B,BTXLST
	JRST DLOPDF
BDLOP1:	HLRZ T,(B)
	JUMPN T,BDLOP2
	PUSH P,B
	HRRZ B,1(B)
	PUSHJ P,BTXDSP
	POP P,B
	JRST BDLOP3

BDLOP2:	PUSHJ P,BTXDSP
BDLOP3:	HRRZ B,(B)
	JUMPN B,BDLOP1
	POPJ P,

DLOPDF:	MOVS B,1(A)	;GET POINTER TO POINTER BLOCK
	HLRZ B,1(B)	;GET POINTER TO TEXT
	JUMPE B,CPOPJ 	;NONE?
DLOP7:	PUSHJ P,BTXDSP
	HRRZ B,(B)	;GET POINTER TO NEXT ONE
	JUMPN B,DLOP7	;LOOP
	POPJ P,

BTXDSP:	HLRZ T,(B)
	HRRZ T,(T)
	HLRZ T,(T)
	TLNN M,%IDENT
	JUMPE T,CPOPJ
	MOVE T,1(B)	;GET X,Y
	TDZ T,[1,,1]
	PUSHJ P,ORIENT
	PUSH P,B	;SAVE B
	PUSH P,D
	PUSH P,E
	ADD D,T
	TLZ D,1
	HLRZ B,(B)	;GET POINTER TO TEXT DATA BLOCK
	MOVEI E,D-1	;POINT TO IT FOR CALCOF
	HRRZ T,(B)
	HLRZ T,(T)
	SKIPN T
	MOVEI T,STDBIG
	ANDI T,377777
	PUSHJ P,DPYBIG	;LET IT GO INTO VECTOR
	PUSHJ P,CALCOF	;VECTOR TO IT
	HRRZ B,(B)	;GET POINTER TO TEXT
	PUSHJ P,DTXT	;DISPLAY IT
	POP P,E
	POP P,D
	POP P,B		;GET B BACK
	POPJ P,
>;MD
                                                                  ;ALTER MODE DISPLAY
TXTDIS:	TRZN MCHG
	POPJ P,
	MOVEI T,BLPG
	PUSHJ P,HYDPOG
	MOVEI T,MAINPG		;USE MAIN PAGE FOR ALTER STUFF
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	MOVEI A,1
	LSH A,@MODE
	TDNN A,[MD,<1BTALTM!1EDTAM!>1MALTM]
	JRST NOANAM
	MOVE B,REMMAC
MPC,<	HRRZ B,1(B)	>	;PC ONLY DOES MALTM
MD,<	TDNN A,[1BTALTM!1EDTAM]
	JRST [	HRRZ B,1(B)
		MOVEI A,[ASCID/MACRO NAME: /
				0	]
		JRST DOANAM]
	HLRZ B,(B)
	HLRZ B,(B)
	JUMPE B,NOANAM
	MOVEI A,[ASCID/PROPERTY NAME: /
			0	]
DOANAM:
>;MD
	MOVEI T,0
	MOVEI TT,TITBIG
	MOVE TTT,[%LEFT,,SCRTOP-CHGHT*TITBIG*3]
	PUSHJ P,TITVCT
	HRLI A,(<POINT 36,0>)
ANMLOP:	ILDB T,A
	TRNN T,1
	JRST ANMLP1
	PUSHJ P,TXTDPB
	JRST ANMLOP

ANMLP1:	PUSHJ P,PLUNK
NOANAM:	MOVEI T,0
	MOVEI TT,ACHRSZ
	MOVE TTT,[AXPOS,,AYPOS]
	PUSHJ P,TITVCT
	MOVE B,TXTPNT
	ADD B,[POINT 7,1]
	SKIPG TT,ALTLIN		;GET TO CORRECT START LINE
	JRST ALTLN1
ALTLN2:	TLNN B,760000		;BYTE POINTER OUT?
	JRST [	HRR B,-1(B)
		TRNE B,-1
		JRST .+1
		JRST MAINOU]	;OUTPUT BLANK SCREEN
	ILDB T,B
	CAME T,EOLCHR
	JRST ALTLN2
	SOJG TT,ALTLN2
ALTLN1:	PUSHJ P,ALTTXT		;PUT OUT OUR TEXT
	JRST MAINOU
                                                                                                                                         ;ORIENTATION TABLES AND ROUTINES
ORIENT:	TRNE F,777770	;REASONABLE INDEX?
	PUSHJ P,FUCKUP	;NO!
	XCT (F)XTB1
	XCT (F)XTB2
	XCT (F)XTB3
	TDZ T,[1,,1]	;CLEAR OVERFLOW BITS
	POPJ P,

;XCT TABLE FOR 8 STATE ROTATION
;EACH STATE GOES COUNTER CLOCKWISE 90 DEGREES
;UNTIL 4 WHICH IS X,-Y ROTATED

XTB1:	TLZ T,1		;X,Y
	TRC T,-2	;-Y,X
	TDCA T,[-2,,-2]	;-X,-Y
	MOVS T,T	;Y,-X
MD,<
	TRCA T,-2	;X,-Y
	MOVS T,T	;Y,X
	TLCA T,-2	;-X,Y
	MOVS T,T	;-Y,-X
>;MD

XTB2:	CAIA
	ADDI T,2
	0
	TRC T,-2
MD,<
	0
	CAIA
	0
	TDC T,[-2,,-2]
>;MD

XTB3:	0
	MOVS T,T
	ADD T,[2,,2]
	ADDI T,2
MD,<
	ADDI T,2
	0
	ADD T,[2,,0]
	ADD T,[2,,2]
>;MD

;TABLE TO UNROTATE USING ORIENT AND CURRENT ROTATION
UNROT:	0
	3
	2
	1
MD,<	4
	5
	6
	7
>;MD

MD,<
;PIN NUMBER FROTZIS TABLES
PINORI:	PUSH P,T
IFN =17-POSB,<LSH T,POSB-=17>
	ANDI T,(1POSW)-1
	TRNE TTT,777770
	PUSHJ P,FUCKUP
	XCT XPTB1(TTT)
	TRZ T,-(1POSW)		;CLEAR ANY OVERFLOW
	TRNE TTT,4		;GREATER THAN OR EQUAL TO 4?
	HRR T,XPTB2(T)		;YES, PERFORM MAPPING
	DPB T,[POINT POSW,(P),POSB+18]
	POP P,T
	POPJ P,


XPTB1:	JFCL
	ADDI T,2
	ADDI T,4
	ADDI T,6
	JFCL
	SUBI T,2
	SUBI T,4
	SUBI T,6

XPTB2:	6
	5
	4
	3
	2
	1
	0
	7
>;MD
                                                      ;CARD SUBRS
MPC,<
FNGBAR:	SKIPE A,PONPNT
	PUSHJ P,CRDFNG
	TRNE M,XFINGER
	POPJ P,
	HRRZ A,BARLST
	JUMPE A,CPOPJ
CRDFN2:	MOVE B,1(A)
	HRRZ A,(A)
	JUMPE A,CRDDON
	MOVE C,1(A)
	PUSHJ P,FAKE		;FAKE BOX FOR FINGER
NFAKE:	HRRZ A,(A)
	JUMPN A,CRDFN2
	POPJ P,

CRDFNG:
	HLRZ C,(A)
	HRRZ C,1(C)
	HLL C,1(C)
	TLNN C,CPIN		;IS IT A CONNECTOR PIN?
	JRST CRDFN1		;NO, GET NEXT
	TRNE M,XFINGER		;SKIPING WHOLE FINGER?
	JRST [	TRNE M,XFEED	;THESE ALSO?
		JRST CRDFN1	;YES, DO NOTHING
		MOVE T,1(A)
		PUSHJ P,SMLAIV
		MOVEI T,"O"+"O"+1
		PUSHJ P,TXTDPB
		JRST CRDFN1]
	HRRZ C,(C)
	MOVE C,1(C)
	MOVE B,1(A)
	PUSHJ P,FAKE		;FAKE UP THE BOX!
CRDFN1:	HRRZ A,(A)
	JUMPN A,CRDFNG
	POPJ P,

FAKE:	MOVE T,B
	ADJUST(SUB,T,C)		;DELTA X,Y
	MOVEI E,0
	MOVEI F,2
	TLNE T,400000
	MOVEI E,1
	TRNE T,400000
	MOVEI F,3
	HLRE TT,T
	MOVMS TT
	HRRES T
	MOVMS T
	CAML TT,T
	MOVE F,E
	JRST @(F)[	FRIGHT
			FLEFT
			FUP
			FDOWN]
DEFINE XY(X,Y)
<	RADIX =10
	ADD T,[XWD <X>/5*2,<Y>/5*2]
	TDZ T,[(1)1]
	RADIX =8
>
FRIGHT:	MOVE T,C
	XY	-FWIDTH,FWIDTH
	PUSHJ P,AIVECT
	MOVE T,C
	XY	-FWIDTH,-FWIDTH
	PUSHJ P,AVECT
	MOVE T,B
	XY	FWIDTH,-FWIDTH
	PUSHJ P,AVECT
	MOVE T,B
	XY	FWIDTH,FWIDTH
	PUSHJ P,AVECT
	MOVE T,C
	XY	-FWIDTH,FWIDTH
	JRST AVECT
FLEFT:	MOVE T,B
	XY	-FWIDTH,FWIDTH
	PUSHJ P,AIVECT
	MOVE T,B
	XY	-FWIDTH,-FWIDTH
	PUSHJ P,AVECT
	MOVE T,C
	XY	FWIDTH,-FWIDTH
	PUSHJ P,AVECT
	MOVE T,C
	XY	FWIDTH,FWIDTH
	PUSHJ P,AVECT
	MOVE T,B
	XY	-FWIDTH,FWIDTH
	JRST AVECT
FUP:	MOVE T,C
	XY	-FWIDTH,-FWIDTH
	PUSHJ P,AIVECT
	MOVE T,C
	XY	FWIDTH,-FWIDTH
	PUSHJ P,AVECT
	MOVE T,B
	XY	FWIDTH,FWIDTH
	PUSHJ P,AVECT
	MOVE T,B
	XY	-FWIDTH,FWIDTH
	PUSHJ P,AVECT
	MOVE T,C
	XY	-FWIDTH,-FWIDTH
	JRST AVECT
FDOWN:	MOVE T,B
	XY	-FWIDTH,-FWIDTH
	PUSHJ P,AIVECT
	MOVE T,B
	XY	FWIDTH,-FWIDTH
	PUSHJ P,AVECT
	MOVE T,C
	XY	FWIDTH,FWIDTH
	PUSHJ P,AVECT
	MOVE T,C
	XY	-FWIDTH,FWIDTH
	PUSHJ P,AVECT
	MOVE T,B
	XY	-FWIDTH,-FWIDTH
	JRST AVECT
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               COMMENT    VALID 00030 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	<DRAW>GDP2.FAI.5, 12-NOV-75 14:57:24, EDIT BY HELLIWELL
C00008 00003	IMPURE STORAGE FOR GDP2 STUFF
C00012 00004	FILES TO BE COPIED TO THE GDP ON INITILAIZATION
C00013 00005	IFN 0,<
C00014 00006	INITIALIZE COMMUNICATIONS WITH THE GDP2 VIA THE ATY LINE
C00018 00007	OPATYO:	INIT ATYO,4		CMU IMAGE MODE
C00019 00008	OPATYI:	INIT ATYI,4		CMU IMAGE MODE
C00020 00009	INITIALIZE A BUFFER TO HOLD A MESSAGE FOR THE DP2
C00022 00010	ROUTINES TO READ A BYTE FROM THE GDP2
C00023 00011	ROUTINES TO WRITE A BYTE OR WORD TO THE GDP2
C00024 00012	ATYONX:
C00025 00013	OUTPUT A BUFFER TO THE GDP2
C00027 00014	ROUTINES TO OUTPUT A PIECE OF GLASS TO THE GDP2
C00031 00015	IIILV:	TRNE A,77B27		BRIGHTNESS OR SIZE?
C00034 00016	LNGVEC:	SKIPG GDPMOD		ARE WE ALREADY IN LONG VECTOR MODE?
C00035 00017	IIISV:	SKIPE GDPMOD		MAKE SURE WE ARE IN MEDIUM VECTOR MODE
C00036 00018	LIOFF1:	SKIPA T,[6]		LONG NEEDS 6
C00037 00019	IIICH:	CAIN A,1		IS IT REALLY NULL STRING?
C00040 00020	MACROS TO SIMULATE III DPYCLR, DPYPOS, DPYSIZ
C00041 00021	NOLAST:	TLNN DSPACT
C00042 00022	PMODE:	TLNN DSPACT
C00043 00023	UPLVL:	TLNN DSPACT
C00044 00024	UPSCAL:	TLNN DSPACT
C00045 00025	READY:	PUSH P,T
C00046 00026	CURBRT:	TLNN DSPACT
C00047 00027	CLRCLC:	SKIPA TT,[TRZN T,BIGFLG]
C00048 00028	VHLINE:	TLNN DSPACT
C00049 00029	FOLOW1:	PUSHJ P,VECT
C00051 00030	>GDP
C00052 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;<DRAW>GDP2.FAI.5, 12-NOV-75 14:57:24, EDIT BY HELLIWELL
VERSION(GDP2,2)

GDP,<

;ROUTINES FOR THE CMU GDP2 (GRAPHIC WONDER)

;PDP-11 INSTRUCTION DEFINITIONS
EMT11__104000
TRAP11__104400
NOP11__240
JMP.R0_110		;JMP @R0

;GRAPHIC MONITOR CONTROL WORDS
PASGRAPH__4	;FOR PASSING A BUFFER TO GRAPHIC MEMORY
PASBUF__0	;FOR PASSING A BUFFER TO ARBITRARY MEMORY
PASREGS__2	;FOR PASSING REGISTERS
GET2REGS__52	;CAUSES 2 REGISTERS TO BE RETURNED

;EXTENDED GRAPHIC CALLS FOR THE DRAWING PROGRAM
;(WE LOAD THE CODE FOR THESE FROM DRAW11.LNK)
LOADPG_EMT11+001	;LOADS A PIECE OF GLASS
BLNKPG_EMT11+002	;LOADS A BLINKING PIECE OF GLASS
ADDPG_EMT11+003		;ADDS DATA TO THE END OF THE LAST GLASS LOADED
REPPG_EMT11+024		;LIKE LOADPG, BUT DOESN'T CLEAR SCREEN
REPAPG_EMT11+025	;LIKE ADDPG, BUT DOESN'T CLEAR SCREEN
REPLPG_EMT11+026	;LIKE REPAPG, BUT FOR LAST PIECE - CLEARS REMAINING PIECES
SAVPOG_EMT11+027	;SAVES CURRENT POG INFO
RSTPOG_EMT11+030	;RESTORES CURRENT POG INFO
DELPG_EMT11+004		;DELETES A PIECE OF GLASS
CLRGDP_EMT11+005	;CLEARS ALL PIECES OF GLASS
PPTOP_TRAP11+113	;SETS POSITION OF TOP OF PIECE OF PAPER
PPSIZ_EMT11+006		;SETS SIZE OF PIECE OF PAPER
PG0SET_EMT11+007	;SETS SPECIAL STUFF IN PIECE OF GLASS # 0
SETFIL_EMT11+011	;SETS  FILE NAME IN POG 0
SETMOD_EMT11+013	;SETS MODE IN POG 0
SETLVL_EMT11+015	;SETS MACRO LEVEL IN POG 0
SETSCL_EMT11+014	;SETS SCALE IN POG 0
SETRDY_EMT11+012	;SETS THE READY INDICATOR (*) IN POG 0
SETFBR_EMT11+020	;SETS THE CURSOR BRIGHTNESSES IN POG 0
STFLG_EMT11+022		;SETS THE FLAGS WORD IN POG 0
SETCUR_EMT11+010	;SETS THE CURSOR POSITION IN POG 0
GETCUR_EMT11+023	;GETS THE CURSOR POSITION FROM POG 0
STLOC_EMT11+021		;SETS LOCATION OF CURRENTLY SELECTED THING IN POG 0
SETFV1_EMT11+016	;SETS THE LOCATION OF FOLLOW VECTOR 1 IN POG 0
SETFV2_EMT11+017	;SETS THE LOCATION OF FOLLOW VECTOR 2 IN POG 0

;GDP2 INSTRUCTIONS:
LFMT_100060		;SETS VECTOR FORMAT
LFMTM_LFMT+1		;SETS VECTOR FORMAT TO MEDIUM
LFMTL_LFMT+2		;SETS VECTOR FORMAT TO LONG
LCMD_100040		;SETS CMODE
TERM_100000		;TERMINATES A VECTOR LIST
ION_100201		;TURNS BEAM ON
IOFF1_100204		;TURNS OFF BEAM FOR THE NEXT VECTOR
LSCA_100140		;LOADS THE SCALE, ABSOLUTE
LILA_100100		;LOADS THE INTENSITY, ABSOLUTE
NOPGDP_100360		;NO OP FOR THE GDP2
SXYGDP_100222		;SET X AND Y

;LOCATION WELL OFF SCREEN, FOR HIDING THINGS
OFSCRN__4000
                                                                                                                                                                                ;IMPURE STORAGE FOR GDP2 STUFF

IIIX:	0			;ABSOLUTE POSITION OF THE BEAM
IIIY:	0

GDPMOD:	0			;CURRENT GDP2 VECTOR MODE (0=MED,+=LONG,-=UNKNOWN)

CHRWID__10			;WIDTH OF THE NORMAL SCALE CHARACTER
CHRSCL:	0			;LH = CURRENT CHAR WIDTH, RH = CURRENT CHAR SCALE
IFN 0,<
	XWD CHRWID/2,LSCA+4
	XWD CHRWID*5/8,LSCA+5
	XWD CHRWID*3/4,LSCA+6
VECSCL:	XWD CHRWID,LSCA+10	;THIS IS ALSO THE VECTOR SCALE
	XWD CHRWID*3/2,LSCA+12
	XWD CHRWID*2,LSCA+14
	XWD CHRWID*3,LSCA+16
>;IFN 0
IFE 0,<
VECSCL:	XWD CHRWID,LSCA+10	;THIS IS ALSO THE VECTOR SCALE
	XWD CHRWID*5/4,LSCA+11
	XWD CHRWID*3/2,LSCA+12
	XWD CHRWID*2,LSCA+14
	XWD CHRWID*3,LSCA+16
	XWD CHRWID*7/2,LSCA+17
	XWD CHRWID*7/2,LSCA+17
>;IFE 0

IIIBRT:	0			;CURRENT III BRIGHTNESS
	LILA+11
	LILA+12
	LILA+13
	LILA+14
	LILA+15
	LILA+16
	LILA+17

CMUFBF:				;PIECE OF GLASS 0 DATA
FILWRD:	NOPGDP			; FILE NAME
RDYWRD:	"*"*400+200		;READY FLAG
MODWRD:	"?"*401			;CURRENT MODE
SCLWRD: "?"*401		;CURRENT SCALE
LVLWRD: "?"*401		;CURRENT MACRO LEVEL
FVEC1X:	NOPGDP			;FOLLOW VECTOR 1
FVEC1Y:	NOPGDP
FVEC2X:	NOPGDP			;FOLLOW VECTOR 2
FVEC2Y:	NOPGDP
FBRT:	LILA+10			;CURSOR INTENSITY
LOCATX:	OFSCRN			;CURRENTLY SELECTED THING LOCATION
LOCATY:	OFSCRN
CURSX:	0			;CURSOR POSITION
CURSY:	0
FBFLGS:	0			;FLAGS (10000=BIG CURSOR, 200=FOLLOW SPARK PEN)
	BIGFLG__100000		;BIG CURSOR FLAG
	FOLFLG__200		;FOLLOW SPARK PEN
CMUFBL__.-CMUFBF

;IMPURE STORAGE FOR ATY STUFF
CHKSUM:	0			;RUNNING CHECKSUM OF THIS MESSAGE

ATYOHD:	BLOCK 3			;BUFFER HEADER FOR ATY OUTPUT
ATYOBL__2*(4+=256)+1		;SIZE OF ATY OUTPUT BUFFERS (=256 DATA WORDS)
ATYOB1:	0			;FIRST ATY OUTPUT BUFFER
	XWD ATYOBL+1,ATYOB2+1
	BLOCK ATYOBL+1
ATYOB2:	0			;SECOND ATY OUTPUT BUFFER
	XWD ATYOBL+1,ATYOB1+1
	BLOCK ATYOBL+1

ATYIHD:	BLOCK 3			;BUFFER HEADER FOR ATY INPUT
ATYIBL__7			;SIZE OF ATY INPUT BUFFERS
ATYIB1:	0			;FIRST ATY INPUT BUFFER
	XWD ATYIBL+1,ATYIB2+1
	BLOCK ATYIBL+1
ATYIB2:	0			;SECOND ATY INPUT BUFFER
	XWD ATYIBL+1,ATYIB1+1
	BLOCK ATYIBL+1

GDPFIL:	BLOCK 4			;FOR USE BY LOOKUP OF FILES TO INIT THE GDP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;FILES TO BE COPIED TO THE GDP ON INITILAIZATION

DEFINE FILMAC
<	FILMC2(DRAW11,LNK,DATPPN)
NOS1G,<
	FILMC2(GRAPH,GST,<XWD 1,4>)
>;NOS1G
>

DEFINE FILMC2 (A,B,C)
<	SIXBIT /A/
>
FILTAB:	FILMAC
NFILS__.-FILTAB

DEFINE FILMC2 (A,B,C)
<	SIXBIT /B/
>
GEXTAB:	FILMAC

DEFINE FILMC2 (A,B,C)
<	C
>
PPNTAB:	FILMAC
                                                                                                                                                                                                                                                                                                                      IFN 0,<
;TABLE OF GDP'S (USE UNTIL SYS GIVES BETTER WAY TO FIND OUT)

GDP2TB:	DPYTAB:	;SPARE NAMES IN CASE I FORGET WHEN PATCHING
GDPTAB:	-1	;SPARE WORD FOR PATCHING IN NEW GDP2'S
	3	;THE ORIGINAL GDP2
	10	;THE FIRST PRODUCTION GDP2
	13	;THE FIRST GDP2 REMOTE FROM ITS PDP-11
	1	;THERE'S ONE IN THE C.mmp ROOM
GDPCNT__.-GDPTAB
>;IFN 0
                                                                                                                                                                                                                                                                                                     ;INITIALIZE COMMUNICATIONS WITH THE GDP2 VIA THE ATY LINE

INIGDP:
;	TLNN DSPACT		;JBR
;	POPJ P,			;JBR
	PUSHJ P,OPATYI
	PUSHJ P,OPATYO
	JSP TT,INATYO		;RESTART THE PDP-11
	JMP.R0
	PASREGS
	MOVEI T,1000		;STARTING ADDRESS IS 1000
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
CMU,<
	MOVEI T,=1000		;GIVE IT A SECOND TO HAPPEN
	HIBER T,
>;CMU
S1G,<
	MOVEI T,1
	SLEEP T,
>;S1G

;NOW INITIALIZE THE GDP2 SPECIAL ROUTINES
	INIT DAT,14		;INIT THE DSK
	SIXBIT/DSK/
	XWD 0,IOHD
	JRST [	OUTSTR [ASCIZ/UNABLE TO INIT THE DSK, LOADING ATY
TYPE CONTINUE TO TRY AGAIN
/]
		HALT .-3 ]
	MOVEI T,IOBUF		;SET UP THE BUFFERS
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVSI TT,-NFILS		;GET COUNT OF FILES TO COPY
INGDP2:	MOVE T,FILTAB(TT)
	MOVEM T,GDPFIL
	MOVE T,GEXTAB(TT)
	MOVEM T,GDPFIL+1
	SETZM GDPFIL+2
	SETZM GDPFIL+3	;FIRST SEE IF HE HAS ONE!
	LOOKUP DAT,GDPFIL
	JRST [	MOVE T,PPNTAB(TT)
		MOVEM T,GDPFIL+3
		LOOKUP DAT,GDPFIL
		CAIA
		JRST .+1		;OUT OF THE LITERAL
		OUTSTR [ASCIZ/UNABLE TO FIND THE FILE "/]
		PUSH P,A
		PUSH P,TT
		MOVEI A,GDPFIL
		JSR FPRINT
		POP P,TT
		POP P,A
		OUTSTR [ASCIZ/"
TYPE CONTINUE TO TRY AGAIN
/]
		EXIT 1,
		JRST INGDP2 ]
	OUT ATYO,		;INIT THE ATYO BUFFERS
	CAIA
	HALT .
INGDPL:	SOSGE IOHD+2		;ANY WORDS THERE?
	JRST INGDPN		;NO, GET SOME MORE IF WE CAN
	ILDB T,IOHD+1		;GET THE WORD
	IDPB T,ATYOHD+1		;ZAP IT OUT
	SOSG ATYOHD+2		;IS THE BUFFER FULL
	OUT ATYO,		;YES, GET ANOTHER
	JRST INGDPL		;AND DO THE NEXT WORD
	JRST [	OUTSTR [ASCIZ/OUTPUT ERROR ON ATY, WHILE LOADING GDP2 PROGRAM
/]
		HALT . ]

INGDPN:	IN DAT,			;GET SOME MORE DATA
	JRST INGDPL		;AND TRY AGAIN
	GETSTS DAT,T		;HMMMMM....
	TRNN T,74B23		;ERROR?
	TRNN T,1B22		;NO, BETTER HAVE EOF!
	JRST [	OUTSTR [ASCIZ/INPUT ERROR ON GDP2 PROGRAM
/]
		HALT . ]
	CLOSE DAT,		;CLOSE THE DISK
	CLOSE ATYO,		;AND THE ATY
	AOBJN TT,INGDP2		;AND LOOP IF THERE ARE MORE FILES
	RELEAS DAT,		;DONE WITH THE DSK
	CLOSE ATYO,		;FLUSH THE LAST BUFFER
	POPJ P,			;THAT'S ALL FOLKS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        OPATYO:	INIT ATYO,4		;CMU IMAGE MODE
	SIXBIT/ATY/
	XWD ATYOHD,0
	JRST [	OUTSTR [ASCIZ/UNABLE TO INIT ATY FOR DISPLAY OUTPUT
TYPE CONTINUE TO TRY AGAIN
/]
		HALT OPATYO ]
	PUSH P,T
	MOVE T,[XWD 400000,ATYOB1+1]
	MOVEM T,ATYOHD
	MOVSI T,(<POINT 36,0,35>)
	MOVEM T,ATYOHD+1
	POP P,T
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                OPATYI:	INIT ATYI,4		;CMU IMAGE MODE
	SIXBIT/ATY/
	XWD 0,ATYIHD
	JRST [	OUTSTR [ASCIZ/UNABLE TO INIT ATY FOR DISPLAY INPUT
TYPE CONTINUE TO TRY AGAIN
/]
		HALT OPATYI ]
	PUSH P,T
	MOVE T,[XWD 400000,ATYIB1+1]
	MOVEM T,ATYIHD
	MOVSI T,(<POINT 36,0,35>)
	MOVEM T,ATYIHD+1
	POP P,T
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                 ;INITIALIZE A BUFFER TO HOLD A MESSAGE FOR THE DP2

;CALL IS:
;	JSP TT,INATYO
;	PDP-11 INSTRUCTION WORD
;	CONTROL WORD
;	(RETURN)

INATYO:	OUT ATYO,		;INIT THE BUFFERS
	CAIA
	HALT .
	HRRZ T,ATYOHD		;GET POINTER TO THE BUFFER
	ADD T,[POINT 36,2]	;MAKE IT A BYTE POINTER
	MOVEM T,ATYOHD+1	;SET UP THE HEADER
;	MOVEI T,<ATYOBL-5>/2*2	;GET THE BYTE COUNT, LEAVING ROOM FOR TERMINATE, WORD COUNT, AND CHECKSUM
	MOVEI T,<ATYOBL+1>/2*2	;GET THE BYTE COUNT
	MOVEM T,ATYOHD+2	;AND SET THE HEADER
	SETZM CHKSUM
	MOVEI T,1		;REQUIRED FOR MESSAGES
	PUSHJ P,ATYOW		;..
;;	MOVEI T,0		;REQUIRED FOR MESSAGES
;;	PUSHJ P,ATYOW
	MOVE T,(TT)		;GET FIRST ARGUMENT
	PUSHJ P,ATYOW
	MOVE T,1(TT)		;GET SECOND ARG
	PUSHJ P,ATYOW
	IBP ATYOHD+1		;SKIP THE WORD COUNT
	IBP ATYOHD+1
	JRST 2(TT)		;AND RETURN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;ROUTINES TO READ A BYTE FROM THE GDP2

ATYIB:	ILDB TT,ATYIHD+1
	SOSL ATYIHD+2
	POPJ P,
	IN ATYI,
	JRST ATYIB
	OUTSTR [ASCIZ/INPUT ERROR FROM GDP ATY LINE!
/]
	HALT .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;ROUTINES TO WRITE A BYTE OR WORD TO THE GDP2

;CALL IS:
;	LOAD WORD OR BYTE INTO LOW ORDER BITS OF T
;	PUSHJ P,ATYOW (OR ATYOB)

ATYOW:	PUSHJ P,ATYOB		;OUTPUT THE LOW BYTE FIRST
	ASH T,-10		;NOW THE HIGH BYTE
ATYOB:	IDPB T,ATYOHD+1		;STORE THE BYTE
	ADDM T,CHKSUM		;KEEP CHECKSUM AS WE GO
	SOSE ATYOHD+2		;COUNT IT
	POPJ P,			;AND RETURN IF BUFFER NOT FULL
	HALT .			;IN CASE WE GO TOO FAR
                                                                                                                                                                                                                                           ATYONX:
;	PUSH P,T		;SAVE SOME REGS
;	PUSH P,TT
	PUSHJ P,ATYOTM		;TERMINATE THIS BUFFER
	XSOFAR			;CHECK IF HE TYPED ANYTHING
	JSP TT,INATYO		;START A NEW MESSAGE
;	ADDPG
	REPAPG
	PASGRAPH
	MOVEI T,SXYGDP
	PUSHJ P,ATYOW
	MOVE T,IIIX
	PUSHJ P,ATYOW
	MOVE T,IIIY
	PUSHJ P,ATYOW
	SETOM GDPMOD		;FORGET THE VECTOR FORMAT!
;	POP P,TT
;	POP P,T
	POPJ P,
                                                                                                                                                                                                                                                                                ;OUTPUT A BUFFER TO THE GDP2

ATYOTM:
;	SETOM ATYOHD+2		;MAKE SURE WE DON'T RECURSE!
	MOVEI T,TERM		;OUTPUT A TERMINATE
	PUSHJ P,ATYOW
DOATYO:	HRRZ TT,ATYOHD		;GET THE BUFFER POINTER
	HRRZ T,ATYOHD+1		;FIND OUT WHERE WE ARE
	SUBI T,4*2+1(TT)	;GET THE BYTE COUNT
	ASH T,-1		;MAKE IT WORDS
	MOVEM T,2+<3*2>(TT)	;AND STORE THE LOW PART OF THE WORD COUNT
	ADDM T,CHKSUM
	ASH T,-10		;NOW THE HIGH PART
	MOVEM T,2+<3*2>+1(TT)
	ADD T,CHKSUM		;COMPUTE THE FINAL CHECKSUM
	MOVN T,T		;GDP-2 WANTS IT NEGATIVE
	IDPB T,ATYOHD+1		;PUT IT IN THE BUFFER
	HRRZ T,ATYOHD		;LOAD T FOR DEBUGGING
	MOVE T,2+<1*2>(T)
	CLOSE ATYO,		;ZAP IT OUT
	POPJ P,
	OUTSTR [ASCIZ/OUTPUT ERROR ON ATY !!!!!!
/]
	HALT .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;ROUTINES TO OUTPUT A PIECE OF GLASS TO THE GDP2

;FIRST, TO CLEAR A PIECE OF GLASS
HYDPOG:	TLNN DSPACT		;SHOULD WE EVEN BOTHER?
	POPJ P,			;NO
	PUSH P,TT
	MOVEI TT,1
	LSH TT,(T)
	TDNN TT,PAGACT		;IS THIS PIECE OF GLASS ACTIVE
	JRST HYDPG2		;NO, ITS ALREADY CLEAR
	ANDCAM TT,PAGACT	;MARK IT INACTIVE
	PUSH P,T
	JSP TT,INATYO		;OK SEND THE MESSAGE TO THE GDP2
	DELPG
	PASREGS
	MOVE T,(P)		;RESTORE THE PIECE OF GLASS NUMBER
	PUSHJ P,ATYOW		;SEND IT TOO
	PUSHJ P,DOATYO		;ZAP IT OUT
	POP P,T
HYDPG2:	POP P,TT
	POPJ P,

;NOW ONE TO OUTPUT A BLINKING PIECE OF GLASS
BLINKO:	TLNN DSPACT		;SHOULD WE EVEN BOTHER
	POPJ P,			;NO
	PUSH P,T
	PUSH P,TT
	JSP TT,INATYO		;START IT WITH BLINKING
	BLNKPG
	PASGRAPH
	JRST DPYOU2		;AND ACT AS IF IT WERE NOT BLINKING

;AND FINALLY ONE TO PUT OUT A NORMAL PIECE OF GLASS
DPYOUT:	TLNN DSPACT		;SHOULD WE EVEN BOTHER
	POPJ P,			;NO
	PUSH P,T
	PUSH P,TT
	JSP TT,INATYO		;AND START THE MESSAGE
;	LOADPG
	REPPG
	PASGRAPH
DPYOU2:	SKIPN T,PGLASS		;GET THE PIECE NUMBER
	JRST [	OUTSTR [ASCIZ/ASKED TO OUTPUT PIECE OF GLASS 0!
/]
		HALT . ]
	PUSHJ P,ATYOW		;OUTPUT IT
	PUSHJ P,MRKPAG		;MARK THE PIECE ACTIVE
	PUSH P,TTT
	PUSH P,A
	PUSH P,B
	SETZM IIIX		;MOVE TO CENTER SCREEN
	SETZM IIIY
	SETZM GDPMOD		;ASSUME WE ARE IN MEDIUM VECTOR MODE AT FIRST
	MOVE T,CHRSCL+1		;SCALE 1 (III)
	MOVEM T,CHRSCL
	MOVE T,IIIBRT+1		;BRIGHTNESS 1 (III)
	MOVEM T,IIIBRT
	MOVEI B,DPYBUF		;GET LENGTH OF III BUFFER
	SUBI B,@BUFPTR
	HRLZI B,(B)		;PUT IT IN LEFT HALF
	JUMPGE B,IIIDN		;GET OUT IF ITS A NULL LIST!
	HRRI B,DPYBUF+1		;GET THE FIRST WORD ADDRESS
IIILOP:
	MOVE T,ATYOHD+2
	CAIGE T,4*2+6		;MAKE SURE THERE IS ROOM FOR A LONG INVISIBLE VECTOR OF DIFFERENT BRIGHTNESS
	PUSHJ P,ATYONX
	MOVE A,(B)		;GET AN III WORD
	TRNE A,1		;ASCII?
	JRST IIICH		;YES, GO DO IT
	JUMPE A,IIIDN
	TRC A,6
	TRNN A,37		;LONG VECTOR
	JRST IIILV
	TDNN A,[4,,33]		;SHORT VECTOR
	JRST IIISV
	OUTSTR [ASCIZ/ILLEGAL III INSTRUCTION ENCOUNTERED IN DPYOUT!
/]
	HALT .
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    IIILV:	TRNE A,77B27		;BRIGHTNESS OR SIZE?
	JRST [	LDB T,[POINT 3,A,27]
		MOVE T,CHRSCL(T)
		MOVEM T,CHRSCL
		LDB T,[POINT 3,A,24]
		MOVE T,IIIBRT(T)
		CAMN T,IIIBRT
		JRST DOVEC
		MOVEM T,IIIBRT
		PUSHJ P,ATYOW
		JRST DOVEC ]
DOVEC:	MOVE TT,A
	ASHC TT,=11-=36		;TT NOW CONTAINS X FIELD, SIGN EXTENDED
	LSH TTT,1
	ASH TTT,=11-=36		;AND TTT CONTAINS Y
	TRNN A,100		;ABSOLUTE?
	JRST IIIREL		;NO
	SUB TT,IIIX		;YES, MAKE IT RELATIVE
	SUB TTT,IIIY
IIIREL:	ADDM TT,IIIX		;UPDATE CURRENT POSITION
	ADDM TTT,IIIY
	CAIG TT,177		;CAN WE DO THIS WITH A MEDIUM VECTOR?
	CAMGE TT,[-177]
	JRST LNGVEC		;NO, X IS TOO BIG
	CAIG TTT,177
	CAMGE TTT,[-200]
	JRST LNGVEC		;NO, Y IS TOO BIG
MEDVEC:	SKIPE GDPMOD		;ARE WE ALREADY IN MEDIUM VECTOR MODE?
	JRST [	MOVEI T,LFMTM	;SWITCH TO MEDIUM VECTOR FMT
		PUSHJ P,ATYOW
		SETZM GDPMOD
		JRST .+1 ]
	MOVEI T,IOFF1
	TRNE A,40		;INVISIBLE?
;	PUSHJ P,MIOFF1		;YES, GO TURN OFF BEAM
	PUSHJ P,ATYOW		;YES, GO TURN OFF BEAM
	MOVE T,TTT		;OUTPUT Y
	PUSHJ P,ATYOB
	MOVE T,TT		;OUTPUT X
	PUSHJ P,ATYOB

IIIVDN:	AOBJN B,IIILOP		;GO BACK IF THERE ARE ANY MORE VECTORS
IIIDN:	HRRZ TT,ATYOHD		;GET TOP OF BUFFER AGAIN
	MOVE T,2+<1*2>(TT)	;GET OLD INSTRUCTION
	CAIN T,REPPG		;IF IT IS A REPPG
	MOVEI T,LOADPG		;MAKE IT A LOADPG
	CAIN T,REPAPG		;AND IF IT IS A REPAPG
	MOVEI T,REPLPG		;MAKE IT A REPLPG
	SUB T,2+<1*2>(TT)
	ADDM T,2+<1*2>(TT)	;CHANGE THE LOW BYTE (THE HIGH BYTE STAYS AN EMT11)
	ADDM T,CHKSUM
	PUSHJ P,ATYOTM		;ALL DONE! TERMINATE IT.
	POP P,B
	POP P,A
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                     LNGVEC:	SKIPG GDPMOD		;ARE WE ALREADY IN LONG VECTOR MODE?
	JRST [	MOVEI T,LFMTL	;NO, PUT US IN LONG VEC FMT
		PUSHJ P,ATYOW
		MOVEM T,GDPMOD
		JRST .+1 ]
	MOVEI T,IOFF1
	TRNE A,40		;INVISIBLE?
;	PUSHJ P,LIOFF1		;YES, GO TURN IT OFF
	PUSHJ P,ATYOW		;YES, GO TURN IT OFF
;	MOVEI T,4		;WE NEED AT LEAST 4 CONTIGUOUS BYTES
;	CAMLE T,ATYOHD+2	;CAN WE FIT INTO THIS BUFFER?
;	PUSHJ P,ATYONX		;NO, GO TO THE NEXT BUFFER
	MOVE T,TTT		;OUTPUT Y
	PUSHJ P,ATYOW
	MOVE T,TT		;OUTPUT X
	PUSHJ P,ATYOW
	JRST IIIVDN		;AND SEE IF THERE ARE ANY MORE
                                                                                        IIISV:	SKIPE GDPMOD		;MAKE SURE WE ARE IN MEDIUM VECTOR MODE
	JRST [	MOVEI T,LFMTM
		PUSHJ P,ATYOW
		SETZM GDPMOD
		JRST .+1 ]
IIISV2:	MOVE TT,A
	ASHC TT,=7-=36		;TT GETS X FIELD
	LSH TTT,1
	ASH TTT,=7-=36		;TTT GETS Y FIELD
	ADDM TT,IIIX		;UPDATE POSITION
	ADDM TTT,IIIY
	MOVEI T,IOFF1
	TLNE A,10		;INVISIBLE?
;	PUSHJ P,MIOFF1		;YES, TURN IT OFF
	PUSHJ P,ATYOW		;YES, TURN IT OFF
	MOVE T,TTT		;OUTPUT Y
	PUSHJ P,ATYOB
	MOVE T,TT		;OUTPUT X
	PUSHJ P,ATYOB
IIISV3:	LSH A,=16		;GET THE OTHER VECTOR
	TLNE A,1		;DID WE ALREADY DO IT?
	JRST IIISV2		;NO, GO DO IT
	JRST IIIVDN
                                            ;LIOFF1:	SKIPA T,[6]		;LONG NEEDS 6
;MIOFF1:	MOVEI T,4		;AND MEDIUM 4 CONSECUTIVE BYTES
;	CAMLE T,ATYOHD+2	;DO WE HAVE ENOUGH ROOM IN THIS BUFFER?
;	PUSHJ P,ATYONX		;NO, START THE NEXT BUFFER
;	MOVEI T,IOFF1		;TURN OFF ONE VECTOR
;	JRST ATYOW
                                                                                                                                                                                                                                                                                                                                                                                                      IIICH:	CAIN A,1		;IS IT REALLY NULL STRING?
	JRST IIIVDN		;YES, IGNORE IT
	MOVE T,ATYOHD+2
	CAIGE T,2*5+<2*6>+6
	PUSHJ P,ATYONX
	MOVEI T,LCMD+1		;SWITCH TO CHARACTER MODE
	PUSHJ P,ATYOW
	MOVE T,CHRSCL		;CHECK THE SCALE
	CAME T,VECSCL		;IS IT LIKE VECTORS?
	PUSHJ P,ATYOW		;NO, GO CHANGE IT
	HLRE TT,CHRSCL		;GET THE CHARACTER WIDTH
	MOVEI T,200		;SPECIAL CODE TO INITIALIZE STRINGS
	PUSHJ P,ATYOB
IIICH2:
FOR I_1,5 <
	LDB T,[POINT 7,A,<7*I-1>]
	JUMPE T,.+5		;UNLESS ITS A NULL CHARACTER
	ADDM TT,IIIX		;COUNT ITS WIDTH
	PUSHJ P,ATYOB		;AND OUTPUT THE CHARACTER
	MOVEI T,301		;BACK UP 2 INCS FOR THE LOSING CHAR SET
	PUSHJ P,ATYOB
>;FOR LOOP
	MOVE TTT,ATYOHD+2
	CAIGE TTT,2*5+<2*3>+1+6	;IS THERE ENOUGH ROOM FOR ANOTHER WORD?
	JRST IIICNB		;NO, GO TO THE NEXT BUFFER
	MOVE A,1(B)		;GET THE NEXT WORD
	TRNE A,1		;IS IT ASCII TOO?
	AOBJN B,IIICH2		;YES, GO DO IT UNLESS OFF END
IIICNB:	MOVEI T,0
	TRNE TTT,1		;DID WE OUTPUT AN ODD NUMBER OF CHARS?
	PUSHJ P,ATYOB		;YES, GO OUTPUT ONE MORE
	AOBJP B,IIIDN		;IF WE HAVE NO MORE III STUFF, FINISH UP
;	JUMPE A,IIIDN		;0 IS END OF DISPLAY
	MOVE T,VECSCL		;CHECK THAT WE ARE BACK TO VECTOR SCALE
	CAME T,CHRSCL
	PUSHJ P,ATYOW
	MOVEI T,ION		;MAKE SURE WE ARE VISIBLE
	PUSHJ P,ATYOW
	MOVEI T,LCMD+0		;GO BACK TO VECTOR MODE
	PUSHJ P,ATYOW
	SETOM GDPMOD		;CHARACTERS CLOBBER THE VECTOR FORMAT!
	JRST IIILOP		;AND GO DO THE NEXT WORD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;MACROS TO SIMULATE III DPYCLR, DPYPOS, DPYSIZ

DEFINE DPYCLR <
PUSHJ P,[
	PUSH P,T
	PUSH P,TT
	JSP TT,INATYO
	CLRGDP
	PASREGS
	PUSHJ P,DOATYO
	POP P,TT
	POP P,T
	POPJ P,
]
>

DEFINE DPYPOS (I) <
PUSHJ P,[
	JSP TT,INATYO
	PPTOP
	PASREGS
	MOVEI T,<I>
	PUSHJ P,ATYOW
	JRST DOATYO
]
>

DEFINE DPYSIZ (I) <
PUSHJ P,[
	JSP TT,INATYO
	PPSIZ
	PASREGS
	MOVEI T,<I>&777
	PUSHJ P,ATYOW
	MOVEI T,<<I>&777>*<<I>/1000>
	PUSHJ P,ATYOW
	JRST DOATYO
]
>
                                                                                                                                                                  NOLAST:	TLNN DSPACT
	POPJ P,
	MOVE T,NAMBUF
	TLNN T,774000		;IS THE FILE NAME NULL?
	JRST [	JSP TT,INATYO	;YES, SPECIAL CASE IT.

		SETFIL
		PASREGS
		MOVEI T,NOPGDP
		PUSHJ P,ATYOW
		JRST DOATYO ]
	JSP TT,INATYO
	SETFIL
	PASGRAPH
	MOVE TT,[POINT 7,NAMBUF]
	MOVEI T,200		;SPECIAL CHAR TO SET UP CHARACTER SET
	PUSHJ P,ATYOB
	ILDB T,TT
	JUMPN T,.-2
	MOVE TT,ATYOHD+2	;CHECK IF WE OUTPUT AN ODD NUMBER OF BYTES
	TRNE TT,1
	PUSHJ P,ATYOB		;YES, PUT OUT A PAD
	JRST ATYOTM		;AND GO FINISH IT OUT
                                                                                                                            PMODE:	TLNN DSPACT
	POPJ P,
	PUSH P,TT
	MOVE T,MODE
	MOVE TT,DMODE(T)	;GET THE NEW MODE
	LSHC T,7		;T GETS FIRST CHAR
	LSH TT,=8-=36
	SKIPN TT
	MOVEI TT,40*2
	DPB TT,[POINT 9,T,28]	;AND THE SECOND CHAR
	CAMN T,MODWRD		;IS IT THE SAME AS BEFORE
	JRST PMODE2		;YES, DONT CHANGE IT
	MOVEM T,MODWRD
	JSP TT,INATYO
	SETMOD
	PASREGS
	MOVE T,MODWRD
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
PMODE2:	POP P,TT
	POPJ P,
                                                                                                                                                                                                                           UPLVL:	TLNN DSPACT
	POPJ P,
	HRRZ T,MACPNT
	SUBI T,MACPDL-1
	IDIVI T,5
	PUSHJ P,GETD2
	CAMN T,LVLWRD
	POPJ P,
	MOVEM T,LVLWRD
	JSP TT,INATYO
	SETLVL
	PASREGS
	MOVE T,LVLWRD
	PUSHJ P,ATYOW
	JRST DOATYO

GETD2:	PUSH P,TT
	IDIVI T,=10
	JUMPE T,[
		HRREI T,-20*400
		JRST GETD2B ]
	LSH TT,=8
	PUSH P,TT
	IDIVI T,=10
	POP P,T
GETD2B:	ADDI T,60*401(TT)
	POP P,TT
	POPJ P,
                                                                                                                                                                                                                                                     UPSCAL:	TLNN DSPACT
	POPJ P,
	MOVE T,NSCALE
	PUSHJ P,GETD2
	CAMN T,SCLWRD
	POPJ P,
	MOVEM T,SCLWRD
	JSP TT,INATYO
	SETSCL
	PASREGS
	MOVE T,SCLWRD
	PUSHJ P,ATYOW
	JRST DOATYO
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    READY:	PUSH P,T
	MOVEI T,"*"*400+200
	JRST SREADY

NREADY:	PUSH P,T
	MOVEI T,200
SREADY:	TLNE DSPACT
	CAMN T,RDYWRD
	JRST XREADY
	MOVEM T,RDYWRD
	PUSH P,TT
	JSP TT,INATYO
	SETRDY
	PASREGS
	MOVE T,RDYWRD
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
	POP P,TT
XREADY:	POP P,T
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                              CURBRT:	TLNN DSPACT
	POPJ P,
	ANDI T,7
	SKIPN T,IIIBRT(T)
	MOVE T,IIIBRT+6
	CAMN T,FBRT
	POPJ P,
	MOVEM T,FBRT
	JSP TT,INATYO
	SETFBR
	PASREGS
	MOVE T,FBRT
	PUSHJ P,ATYOW
	JRST DOATYO
                                                                                                                                                                                                                                                                                                                                                                                                                                                         CLRCLC:	SKIPA TT,[TRZN T,BIGFLG]
SETCLC:	MOVE TT,[TROE T,BIGFLG]
CHFLGS:	MOVE T,FBFLGS
	XCT TT
	POPJ P,
	MOVEM T,FBFLGS
	JSP TT,INATYO
	STFLG
	PASREGS
	MOVE T,FBFLGS
	PUSHJ P,ATYOW
	JRST DOATYO

CURSOFF:TRZ M,CURSOR
	MOVE TT,[TRZN T,FOLFLG]
	JRST CHFLGS

CURSON:	TRO M,CURSOR
	MOVE TT,[TROE T,FOLFLG]
	JRST CHFLGS
                                                                                                                                                                                                                                                                                                                 VHLINE:	TLNN DSPACT
	POPJ P,
	PUSH P,T
	TLNE LOCATE
	PUSHJ P,VECT
	JRST [	MOVEI TT,OFSCRN
		MOVEI T,OFSCRN
		JRST VHLIN2 ]
	MOVE T,TT
	LSH T,=11
	ASH T,=11-=36
	ASH TT,=11-=36
VHLIN2:	CAMN TT,LOCATX
	CAME T,LOCATY
	CAIA
	JRST VHLIN1
	MOVEM TT,LOCATX
	MOVEM T,LOCATY
	JSP TT,INATYO
	STLOC
	PASREGS
	MOVE T,LOCATX
	PUSHJ P,ATYOW
	MOVE T,LOCATY
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
VHLIN1:	POP P,T
	POPJ P,
                                                                                                                                                                                                                     FOLOW1:	PUSHJ P,VECT
	JRST CLEAR1
	MOVE T,TT
	LSH T,=11
	ASH T,=11-=36
	ASH TT,=11-=36
FOLW1B:	CAMN TT,FVEC1X
	CAME T,FVEC1Y
	TLNN DSPACT
	POPJ P,
	MOVEM TT,FVEC1X
	MOVEM T,FVEC1Y
	JSP TT,INATYO
	SETFV1
	PASREGS
	MOVE T,FVEC1X
	PUSHJ P,ATYOW
	MOVE T,FVEC1Y
	PUSHJ P,ATYOW
	JRST DOATYO

CLEAR1:	MOVEI TT,NOPGDP
	MOVEI T,NOPGDP
	JRST FOLW1B

FOLOW2:	PUSHJ P,VECT
	JRST CLEAR2
	MOVE T,TT
	LSH T,=11
	ASH T,=11-=36
	ASH TT,=11-=36
FOLW2B:	CAMN TT,FVEC2X
	CAME T,FVEC2Y
	TLNN DSPACT
	POPJ P,
	MOVEM TT,FVEC2X
	MOVEM T,FVEC2Y
	JSP TT,INATYO
	SETFV2
	PASREGS
	MOVE T,FVEC2X
	PUSHJ P,ATYOW
	MOVE T,FVEC2Y
	PUSHJ P,ATYOW
	JRST DOATYO

CLEAR2:	MOVEI TT,NOPGDP
	MOVEI T,NOPGDP
	JRST FOLW2B
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       >;GDP
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        COMMENT    VALID 00010 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(LAY,2)
C00009 00003	DISPLAY BLINKING STUFF
C00013 00004	LCENTER
C00016 00005	BLINE
C00019 00006	TRACE A WIRE
C00024 00007	PASS INFO TO OTHER PROG
C00027 00008	LOOK
C00031 00009	CALL ROUTING SUBRS FOR BLINKING PINS!
C00034 00010	PJUMP
C00038 ENDMK
C;
                                                                                                                                                                                                                                                                                             VERSION(LAY,2)
;CHECK FOR PASSED WIRE
LAY,<
BLCHK:	SKIPN DPCPNT
	JRST CKLTNM
	HLRZ A,DPCPNT
	HRRZ C,DPCPNT
	CAMG A,C	;ANYTHING IN LIST?
	JRST [	SKIPE B,BLPNTR	;MAKE SURE FLASHING STOPS WHEN
		PUSHJ P,PUTFS	;HE EXPLICITLY PASSES NOTHING
		SETZM BLPNTR
	MPC,<	SETZM UPINS	>
		JRST CKLTNM]
	PUSHJ P,LINKST
	HRRZ TT,DPCPNT
PASLOP:	MOVE T,(TT)
	MOVEM T,LETTER
	MOVE T,1(TT)
	MOVEM T,NUMBER
	PUSHJ P,LOOK	;FIND IT
	JRST PASLP1
	MOVE A,T
	PUSHJ P,LINKIT
PASLP1:	HRRZ TT,DPCPNT
	ADDI TT,2
	HRRM TT,DPCPNT
	HLRZ T,DPCPNT
	CAMG TT,T
	JRST PASLOP
	PUSHJ P,LINKMK
NILWIR:	SETZM DPCPNT		;DON'T TRACE AGAIN!
	TLNE M,LCENTER
	PUSHJ P,LCENMAK
CKLTNM:	SKIPN LAYLET
	POPJ P,
	MOVE T,LAYLET
	MOVEM T,LETTER
	SETZM LAYLET
	MOVE T,LAYNUM
	MOVEM T,NUMBER
	PUSHJ P,LOOK
	JRST [	OUTSTR[ASCIZ/SORRY, COULDN'T FIND THE POINT THE OTHER PROG PASSED ME!
/]
		POPJ P,]
ISLTNM:	MOVE A,T
MPC,<	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNN T,CPIN	;IF CONNECTOR PIN,
	JRST ISLTPN
	EQV T,SID
	JUMPL T,ISLTPN	;AND NOT ON THAT SIDE
	SWITCH		;CHANGE SIDES
	TRO MCHG
>;MPC
ISLTPN:	MOVE T,1(A)
	JRST CHKON
>;LAY

ALLOCL:	SKIPN T,BLPNTR
	POPJ P,
	SETZM BLINKN
ALLOC1:	HRRZ TT,1(T)
	HLRZ TT,(TT)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
MPC,<	TLNN TT,CPIN
	TLNE TT,FRONT
>;MPC
	TLNN TT,CPIN!ISPIN
	JRST ALLOC2
	AOS TT,BLINKN
	DPB TT,[POINT 17,(T),17]
ALLOC2:	HRRZ T,(T)
	JUMPN T,ALLOC1
ALLOC3:	EXCH T,BLINKN
	CAILE T,"Z"-100
	SETOM BLINKN
	POPJ P,

IFN LAYSW!UMLSW,<
LINKMK:	SKIPN T,BLPNTR
	JRST ALLOCL
PASST2:	SKIPGE (T)		;MARKED ALREADY?
	JRST PASST4		;YES
	HRRZ TT,1(T)
	HLRZ TT,(TT)
	HRRZ TT,1(TT)
	HLL TT,1(TT)
MD,<	TLNN TT,CPIN		;IF IT'S AN UNMARKED CPIN, MAYBE IT'S THE SAME AS A MARKED
	JRST PASST6		; CPIN SOMEWHERE ELSE IN THE LIST
	HRRZ TT,(TT)
	MOVE TT,(TT)		;LOC OF CPIN WE ARE LOOKING FOR
	SKIPE CRDLOC
	HLL TT,CRDLOC
	MOVEM TT,LETTER
	MOVE TT,BLPNTR
PASST8:	SKIPL (TT)		;SKIP IF THIS ONE IS MARKED
	JRST PASST7
	HRRZ TTT,1(TT)		;POINTER TO POINT
	HLRZ TTT,(TTT)
	HRRZ TTT,1(TTT)
	HLL TTT,1(TTT)		;GET BITS
	TLNN TTT,CPIN
	JRST PASST7
	HRRZ TTT,(TTT)
	MOVE TTT,(TTT)
	SKIPE CRDLOC
	HLL TTT,CRDLOC
	CAMN TTT,LETTER		;IF THIS ONE MATCHES, THEN THE ORIGINAL CPIN IS OK
	JRST PASST4		;MAKE BELIEVE ITS BIT WAS SET
PASST7:	HRRZ TT,(TT)
	JUMPN TT,PASST8
	HRRZ TT,1(T)		;IT'S REALLY A LOSER
	HLRZ TT,(TT)
	HRRZ TT,1(TT)
	HLL TT,1(TT)
PASST6:
>;MD
MPC,<	TLNN TT,CPIN
	TLNE TT,FRONT
>;MPC
	TLNN TT,CPIN!ISPIN
	JRST PASST3
	AOS TTT,BLINKN		;ASSIGN ERRORS A LETTER TOO
	TRO TTT,400000		;MARK AS ERROR
	HRLM TTT,(T)
	CAIA
PASST3:	HRRZS (T)
PASST5:	HRRZ T,(T)
	JUMPN T,PASST2
	JRST ALLOC3

PASST4:	AOS TTT,BLINKN
	HRLM TTT,(T)		;STORE # AND CLEAR FLAG
	JRST PASST5

LINKST:	SKIPE B,BLPNTR	;RETURN LIST
	PUSHJ P,PUTFS
	SETZM BLPNTR
MPC,<	SETZM UPINS	>
	SETZM BLINKN
LAY,<	SETZM DOPASS	;DON'T PASS PINS BACK>
	MOVSI C,1
MPC,<	SKIPE A,PONPN2
	PUSHJ P,CLRBTS
>;MPC
	SKIPE A,PONPNT
	JRST CLRBTS
	POPJ P,

LINKIT:	PUSH P,A	;WILL NEED THIS IN A MINUTE
	PUSHJ P,WIRLNK	;TRACE PIN AND FRIENDS!
	POP P,A
	SKIPN T,BLPNTR	;NOW MARK PIN IN LIST
	POPJ P,
PASST1:	CAMN A,1(T)
	JRST PASCK1
	HRRZ T,(T)
	JUMPN T,PASST1
	POPJ P,

PASCK1:	MOVSI TT,400000
	IORM TT,(T)
MPC,<	POPJ P,		>
MD,<	HLRZ TT,(A)
	HRRZ T,1(TT)
	HLL T,1(T)
	TLNN T,ISPIN	;PIN?
	POPJ P,		;NO, DONE
	HRRZ T,(T)
	HLRZ T,(T)	;PINID
	HRRZ T,1(T)
	HLRZ TT,(TT)	;BODY POINTER
	MOVE A,BLPNTR
PASCK2:	SKIPGE (A)
	JRST PASCK3
	HRRZ TTT,1(A)
	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)	;BODY POINTER
	CAME TTT,TT	;SAME?
	JRST PASCK3	;NO
	HRRZ TTT,1(A)
	HLRZ TTT,(TTT)
	HRRZ TTT,1(TTT)
	HLL TTT,1(TTT)
	TLNN TTT,ISPIN
	JRST PASCK3
	HRRZ TTT,(TTT)
	HLRZ TTT,(TTT)
	HRRZ TTT,1(TTT)
	CAME TTT,T	;SAME LOW ID?
	JRST PASCK3
	MOVSI TTT,400000
	IORM TTT,(A)
PASCK3:	HRRZ A,(A)
	JUMPN A,PASCK2
	POPJ P,
>;MD
>;LAYSW!UMLSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ;DISPLAY BLINKING STUFF
IFN LAYSW!UMLSW,<
CLRERR:	TRON M,ERRORD
	TRO MCHG
	POPJ P,

SETERR:	TRZE M,ERRORD
	TRO MCHG
	POPJ P,
>;UMLSW!LAYSW

BLDISP:
	MOVEI T,BLPG
SHORT,<	SKIPN SERR1	;ANY SHORT ERRORS TO SHOW?
	SKIPE SERR2
	JRST ISSHRT
>;SHORT
	SKIPN E,BLPNTR
	JRST HYDPOG	;NOTHING ANYWAY
SHORT,<ISSHRT:>
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
SHORT,<	SKIPN E,BLPNTR	;ANY REGULAR BLINKING STUFF?
	JRST NDOBL
>;SHORT
MD,<	MOVE T,DEFBRT
	ADD T,BLBRT
	PUSHJ P,DPYBRT
	SETZM OFFCLC	;NO CON OFF SCREEN YET
>;MD
IFN UMLSW!LAYSW,<
	SETZM OFFERR
MPC,<	SKIPE UPINS
	PUSHJ P,DUPIN
>;MPC
>;IFN UMLSW!LAYSW
	PUSH P,M
	TRZ M,MD,<NBTEXT!>NPTEXT!NLINES	;DON'T SUPPRESS THESE
	TLO M,CLOCS!PLOCS	;SHOW PINS
GOTBL1:	PUSH P,E
	HRRZ E,1(E)
	JUMPE E,NOBLXX
MPC,<	HLRZ T,(E)
	HRRZ T,1(T)
	MOVE T,1(T)
	EQV T,SID
	JUMPL T,THSSID
	TRNN BTHSDS
	JRST [	TLNE T,ISPIN	;DIP PIN? (EQV COMPLEMENTED IT)
		JRST NOBLXX	;NO, SKIP THE REST
		LDB T,[POINT 17,@(P),17]
		SKIPE T		;CHECK FOR LETTER
		PUSHJ P,BLNKLL
IFE LAYSW!UMLSW,<JRST NOBLXX>	;THAT'S ALL IF NO ERRORS
IFN LAYSW!UMLSW,<SKIPL @(P)	;YES, ERROR PIN?
		JRST NOBLXX	;NO
		MOVE T,DEFBRT
		ADD T,BLBRT
		PUSHJ P,DPYBRT
		JRST LQQ
>;LAYSW!UMLSW
				]	;YES, CHECK FOR _??
	SKIPA T,DEFBRT
THSSID:	MOVE T,BTHBRT
	ADD T,BLBRT
	PUSHJ P,DPYBRT
>;MPC
MD,<	MOVE T,1(E)
	PUSHJ P,ONSCR
	PUSHJ P,OFFCCK		;CHECK FOR CON HERE
>;MD
	PUSHJ P,DLOP3
	LDB T,[POINT 17,@(P),17]
	SKIPE T
	PUSHJ P,BLNKLL
IFN LAYSW!UMLSW,<
	SKIPL @(P)		;ILL PIN MARK HERE?
	JRST NOBLXX		;NO
LQQ:	TRNE M,ERRORD
	JRST NOBLXX
	MOVE T,1(E)
	PUSHJ P,ONSCR
	AOS OFFERR
	PUSHJ P,BIGAIV
	MOVE T,[ASCID/O_??/]
	PUSHJ P,TXTDPB
>;LAYSW!UMLSW
NOBLXX:	POP P,E
	HRRZ E,(E)
	JUMPN E,GOTBL1
	POP P,T
	AND T,[CLOCS!PLOCS,,MD,<NBTEXT!>NPTEXT!NLINES]
	ANDCM M,[CLOCS!PLOCS,,MD,<NBTEXT!>NPTEXT!NLINES]
	IOR M,T
MD,<	SKIPE E,OFFCLC
	PUSHJ P,OFFCLD
>;MD
IFN UMLSW!LAYSW,<
	SKIPE E,OFFERR
	PUSHJ P,OFFERD
>;UMLSW!LAYSW
SHORT,<
NDOBL:	SKIPN SERR1
	SKIPE SERR2
	PUSHJ P,SHRTDP		;DISPLAY SHORTS ALSO
>;SHORT
	JRST BLINKO

MD,<
OFFCCK:	HLRZ T,(E)
	HRRZ T,1(T)
	HLL T,1(T)
	TLNE T,CPIN
	MOVEM E,OFFCLC		;SAVE AS LAST CON SEEN OFF SCREEN
	POPJ P,
>;MD
BLNKLL:	PUSH P,T
	MOVEI T,STDBIG		;SMALL CHARS
	PUSHJ P,DPYBIG
	MOVE T,1(E)
	PUSHJ P,AIVECT
	POP P,T
	SKIPE BLINKN
	JRST BLNKL1
BLNKL2:	LSH T,1
	ADDI T,201		;ASCID LETTER
	JRST TXTDPB

BLNKL1:	SUBI T,1
	IDIVI T,=26
	LSH T,1
	ADDI T,203
	PUSHJ P,TXTDPB
	MOVE T,TT
	LSH T,1
	ADDI T,203
	JRST TXTDPB
                         ;LCENTER
LCENMAK:SKIPN A,BLPNTR
	POPJ P,
	PUSHJ P,MMSET
LCEN1:	HRRZ T,1(A)
	MOVE T,1(T)
	PUSHJ P,MINMAX
	HRRZ A,(A)
	JUMPN A,LCEN1
	PUSHJ P,DOCENT		;DO THE CENTER THING
	MOVE T,MODE
	CAIE T,PNTM		;CAN WE MAKE A POINT CLOSEST?
	POPJ P,			;NO
	SETZ T,
	PUSHJ P,LCENJC		;TRY TO FIND A CONNECTOR PIN
	CAIA
	JRST PJMPLC		;JUMP THE GUN (I MEAN POINT)
	MOVEI T,1		;OH WELL TRY TO A PIN
	PUSHJ P,RTFND2
	POPJ P,			;CAN'T WIN THEM ALL
	JRST PJMPLC		;GO GET'EM SCOUT

DOCENT:	TRZ TFLG		;INDICATE NO CHANGE YET!
	MOVE T,MAXX
	ADD T,MINX
	ASH T,-=19		;PUT IN RIGHT HALF AND DIVIDE BY 2
	CAME T,XOFF		;CHANGING?
	TRO TFLG
	MOVEM T,XOFF
	MOVE T,MAXY
	ADD T,MINY
	ASH T,-1
	CAME T,YOFF
	TRO TFLG
	MOVEM T,YOFF
	MOVE T,MAXX
	SUB T,MINX
	HLRES T
	MOVE TT,MAXY
	SUB TT,MINY
	CAMG T,TT
	MOVE T,TT
MPC,<	MOVEI TT,30000	>
MD,<	MOVEI TT,6000	>
	IDIV TT,T
	JUMPN TT,.+2
	MOVEI TT,1
NODEC,<	CAILE TT,=16		;DON'T LET IT BE TOO BIG!
	MOVEI TT,=16
>;NODEC
DEC,<
MD,<	CAILE TT,8
	MOVEI TT,8
>;MD
MPC,<	CAILE TT,=16
	MOVEI TT,=16
>;MPC
>;DEC
	CAME TT,NSCALE
	TRO TFLG
	MOVEM TT,NSCALE
	TRZN TFLG
	POPJ P,
	MOVE T,YOFF
	HRL T,XOFF
	JRST CHANGE		;ALWAYS CENTER CURSOR SO WE CAN FIND IT

MINMAX:	CAML T,MAXX
	MOVEM T,MAXX
	CAMG T,MINX
	MOVEM T,MINX
	HRRES T
	CAML T,MAXY
	MOVEM T,MAXY
	CAMG T,MINY
	MOVEM T,MINY
	POPJ P,

MMSET:	MOVSI T,400000
	MOVEM T,MAXX
	MOVEM T,MAXY
	HRLOI T,377777
	MOVEM T,MINX
	MOVEM T,MINY
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;BLINE

LAY,<
ROUTE,<
MD,<
CTMT.:	PUSHJ P,DODOT
	JRST PERRET
	MOVEI T,600+"."		;DO DOUBLE BUCKY . IN PC PROG
	MOVEM T,ODISP		;SET CHARACTER DISPATCH
	JRST GETPC
>;MD
>;ROUTE
>;LAY

META.:
LAY,<
	PUSHJ P,DODOT
	JRST PERRET
MD,<	JRST GETPC	>
MPC,<	JRST GETD	>
>;LAY				;IF NOT LAYOUT VERSION, META. FALLS INTO CTRL.

CTRL.:	PUSHJ P,DODOT
	JRST PERRET
	POPJ P,

DODOT:
LAY,<	SETOM DOPASS	>
	PUSHJ P,GETCLS
	POPJ P,
	PUSH P,A
	SKIPE B,BLPNTR
	PUSHJ P,PUTFS
	SETZM BLPNTR		;OUR LIST
IFN UMLSW!LAYSW,<
MPC,<	SETZM UPINS	>
>;IFN UMLSW!LAYSW
	MOVSI C,1		;CLEAR THIS BIT
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS
MPC,<	SKIPE A,PONPN2
	PUSHJ P,CLRBTS
>;MPC
LAY,<
;INITIALIZE PASSING LIST
MPC,<	SETZM LAYLOC	>
TWO,<	MOVE T,.JBFF		;GOOD PLACE TO START LIST>
LIB,<	MOVEI T,BLDATA		;HERE FOR FAST BAND VERSION>
	HRLI T,-1(T)
	MOVEM T,DPCPNT		;LEFT HALF 0 MEANS NO POINTS YET!
>;LAY
	POP P,A
	PUSHJ P,WIRLNK		;TRACE OUT WIRE
	PUSHJ P,ALLOCL		;ALLOC LETTERS
	TLNE M,LCENTER		;CENTERING?
	PUSHJ P,LCENMAK		;YES!
	TRO MCHG		;UPDATE THIS DRAWING!
	JRST CPOPJ1

LAY,<
PLAIN.:	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ B,(A)
	HRRZ C,1(B)
	MOVE T,1(C)
	TLNE T,ISPIN
	JRST PISPIN
	TLNN T,CPIN
	JRST [	OUTSTR[ASCIZ/SORRY, MUST BE PIN!
/]
		POPJ P,]
	SETZM LAYNUM
	HRRZ T,(C)
	MOVE T,(T)
MPC,<	HLL T,CRDLOC	>
	MOVEM T,LAYLET
MD,<	JRST GETPC	>
MPC,<	JRST GETD	>

PISPIN:	HLRZ B,(B)
	HLRZ B,(B)
	HLRZ B,1(B)
	HRRZ B,(B)
	JUMPE B,[OUTSTR[ASCIZ/SORRY, MUST HAVE LOCATION!
/]
		POPJ P,]
MD,<	HLRZ B,(B)
	MOVE TT,(B)
	MOVEM TT,LAYLET
	TRNE T,-1
	JRST GOTLPN
	HRRZ T,(C)
	HLRZ T,(T)
	HRRZ T,1(T)
GOTLPN:
>;MD
MPC,<	HLL B,CRDLOC
	MOVEM B,LAYLET
	HRRZ T,(C)
	HLRZ T,(T)
>;MPC
	HRRZM T,LAYNUM
MD,<	JRST GETPC	>
MPC,<	JRST GETD	>
>;LAY
                                                                                                                                    ;TRACE A WIRE
WIRLNK:	HLRZ B,(A)
	HRRZ C,1(B)
	MOVE D,1(C)
	TLOE D,1
	POPJ P,
	MOVEM D,1(C)
LAY,<	SKIPE DOPASS		;PASSING?
	PUSHJ P,PASS		;CALL ROUTINE TO PASS (MAYBE) AND PUT IN DISPLAY LIST
>;LAY
BUSLNK:	GETFS(C)		;ENTER HERE FOR BUSSED THROUGH PINS (DON'T PASS)
	HRRZM A,1(C)
	EXCH C,BLPNTR
	HRRZM C,@BLPNTR
	MOVE C,BLPNTR
	HRLM B,(P)
	HLRZ B,1(B)
	PUSH P,B
MD,<
	HRRZ A,(B)
	JUMPE A,.+2
	PUSHJ P,WIRLNK
	HLRZ A,@(P)
	JUMPE A,.+2
	PUSHJ P,WIRLNK
	AOS (P)
	HRRZ A,@(P)
	JUMPE A,.+2
	PUSHJ P,WIRLNK
	HLRZ A,@(P)
	JUMPE A,.+2
	PUSHJ P,WIRLNK
	POP P,(P)

	HLRZ B,(P)
	HRRZ B,1(B)
	HLRZ B,(B)		;TEXT POINTER
	JUMPE B,WTLOP6		;NO TEXT, THIS IS EASY
	HRRZ B,(B)
	SKIPN C,PONPNT		;NOW ON SCREEN POINTS!
	JRST WTLOP6		;THAT'S ALL
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;PREPARE COMPARE STRING
WTLOP4:	HLRZ A,(C)
	HRRZ A,1(A)
	HLRZ A,(A)
	JUMPE A,WTLOP5		;NO TEXT, SKIP CHECK
	HRRZ A,(A)
	ADD A,[POINT 7,1]
	MOVEI B,SIGTAB
	PUSHJ P,SIGMAT		;SAME SIGNAL?
	JRST WTLOP5		;NO MATCH
	JFCL			;EQUIVALENT IS CLOSE ENOUGH
	PUSH P,C
	MOVE A,C		;PUT INTO A
	PUSHJ P,WIRLNK		;AND LINK INTO THIS LINE
	POP P,C
WTLOP5:	HRRZ C,(C)
	JUMPN C,WTLOP4
WTLOP6:	HLRZ B,(P)		;DATA BLOCK POINTER IS STILL HERE
	HRRZ T,1(B)
	MOVE TT,1(T)		;BITS
	TLNN TT,ISPIN		;PIN?
	POPJ P,
	HRRZ T,(T)
	HLRZ T,(T)
	HRRZ T,1(T)
	PUSH P,T		;SAVE ID ON STACK
	HLRZ B,(B)
	HLRZ B,(B)
	JRST WTLOP8

WTLOP9:	HLRZ B,(A)
	HRRZ C,1(B)
	HRRZ T,(C)
	HLRZ T,(T)
	HRRZ T,1(T)
	HRRZ D,(P)
	CAME T,D		;SAME DEFAULT NAME?
	JRST WTLOP8		;NO
	MOVE D,1(C)		;YES,
	TLOE D,1		;DONE IT YET?
	JRST WTLOP8
	MOVEM D,1(C)		;NO, DO IT NOW
	HRLM B,(P)
	PUSHJ P,BUSLNK		;FOLLOW IT
	HLRZ B,(P)
WTLOP8:	HRRZ A,(B)
	JUMPN A,WTLOP9
	POP P,(P)		;FLUSH SAVED LOW ID
	POPJ P,			;THAT'S ALL
>;MD
MPC,<
	JUMPE B,WTLOPN
WTLOP0:	MOVEI C,2
WTLOP1:	XCT(C)[	HLRZ A,(B)
		HLRZ A,1(B)
		HRRZ A,1(B)]
	JUMPE A,WTLOP2
	HRLM C,(P)
	PUSHJ P,WIRLNK
	HLRZ C,(P)
	HRRZ B,(P)
WTLOP2:	SOJGE C,WTLOP1
	HRRZ B,(B)
	HRRM B,(P)
	JUMPN B,WTLOP0
WTLOPN:	POP P,(P)
	HLRZ B,(P)
	HRRZ B,1(B)
	MOVE T,1(B)
	TLNN T,ISPIN
	JRST WTLFED
	HRRZ T,(B)
	HLRZ TT,(T)
	MOVE T,B
	HLRZ B,(P)
	HLRZ B,(B)
	HLRZ B,(B)
	JRST WTLOP3

WTLOP4:	HLRZ B,(A)
	HRRZ TTT,1(B)
	CAMN TTT,T
	JRST WTLOP3
	HRRZ TTT,(TTT)
	HLRZ TTT,(TTT)
	CAMN TTT,TT
	JRST WTLOP5
WTLOP3:	HRRZ A,(B)
	JUMPN A,WTLOP4
	OUTSTR[ASCIZ/CAN'T FIND PIN ON OTHER SIDE, OOPS!
/]
	POPJ P,

WTLOP5:	HLRZ B,(A)
	HRRZ C,1(B)
	MOVE D,1(C)
	TLOE D,1
	POPJ P,
	MOVEM D,1(C)
	JRST BUSLNK

WTLFED:	TLNN T,FEEDTH
	POPJ P,
	HLRZ A,(P)
	HLRZ A,(A)
	JRST WTLOP5
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;PASS INFO TO OTHER PROG
LAY,<
PASS:	HLRZ T,(A)
	HLRZ TT,(T)
	HRRZ T,1(T)
	HLL TT,1(T)
	TLNN TT,ISPIN		;DOES IT HAVE A LOCATION?
	JRST CHKCPN		;NOT REG. PIN
	HLRZ TT,(TT)
	HLRZ TT,1(TT)
MD,<	HRRZ D,(TT)		;LOC BLOCK POINTER
	JUMPE D,CPOPJ		;ANY LOC?
	HLRZ D,(D)
	MOVE D,(D)		;GET GOOD STUFF
	SKIPE CRDLOC		;GLOBAL LOC?
	HLL D,CRDLOC		;YES, USE IT
	MOVEM D,LETTER
	HRRZ D,1(T)
	JUMPN D,ISPNUM		;ANY PIN #?
	HRRZ D,(T)
	HLRZ D,(D)
	HRRZ D,1(D)
ISPNUM:	HLLZ TT,1(TT)		;PICK UP BODY BITS
	TLNN TT,R1416		;HACK 14 PIN DIPS IN 16 PIN SOCKETS
	JRST [	TLNE TT,L1416
		ADDI D,1
		JRST STONUM]
	CAILE D,7
	ADDI D,2
STONUM:	MOVEM D,NUMBER		;YES, STO IT
>;MD
MPC,<	HRRZ D,(TT)		;LOC STUFF
	HLL D,CRDLOC		;USE CRDLOC ALSO
	MOVEM D,LETTER
	HRRZ T,(T)
	HLRZ T,(T)
	MOVEM T,NUMBER		;PASS PIN# HERE
>;MPC
	JRST PASSM1		;AND PASS IT

CHKCPN:	TLNN TT,CPIN		;CONNECTOR PIN?
	POPJ P,			;NO, NO PASS
	HRRZ TT,(T)		;PICKUP CON PIN BLOCK PTR
	MOVE T,(TT)
	MOVEM T,LETTER
MPC,<	EXCH T,LAYLOC
	SKIPE T
	HRROS LAYLOC		;FLAG TOO MANY FOUND
>;MPC
	SETZM NUMBER
PASSM1:	HLRZ T,DPCPNT
	ADDI T,2
TWO,<
	CAMG T,.JBREL
	JRST COREOK
	MOVE TT,T
	CORE TT,
	JRST [	OUTSTR[ASCIZ/CAN'T GET LOWER CORE TO PASS LOCATION!
CONTINUE TO INGNORE THIS POINT!
/]
		HALT CPOPJ]
>;TWO
LIB,<	CAIGE T,BLDATA+BLLEN
	JRST COREOK
	OUTSTR[ASCIZ/TOO MANY LOCATIONS, WILL IGNORE SOME!
/]
	POPJ P,
>;LIB
COREOK:	HRLM T,DPCPNT
	MOVE TT,LETTER
	MOVEM TT,-1(T)
	MOVE TT,NUMBER
	MOVEM TT,(T)
	POPJ P,
>;LAY
                                                                                                                                                                                                                                                                                                                                                                                                                  ;LOOK
IFN LAYSW!UMLSW,<
;CALL WITH LETTER & NUMBER SET TO LOC TO FIND
;RETURNS POINT IN T

LOOK:	SKIPN NUMBER		;PIN OR CPIN?
	JRST LOOKC0		;CPIN
	SKIPN T,DBODPN
	POPJ P,			;NONE AT ALL!!!
	HRRZS (P)		;CLEAR SAVED BODY POINTER
LOOKB1:	HLRZ TT,(T)
	HLRZ TTT,1(TT)
MD,<	HRRZ TTT,(TTT)
	JUMPE TTT,NOTB1		;NO BLOCK, NO MATCH
	HLRZ TTT,(TTT)
>;MD
	MOVE TTT,(TTT)
MD,<	SKIPE CRDLOC	>
	HLL TTT,CRDLOC
	XOR TTT,LETTER		;MATCH IF EITHER HIGH PART 0
	TRNE TTT,-1		;LOW PART MATCH?
	JRST NOTB1		;NO
	JUMPE TTT,ISB		;ALL MATCH?
	XOR TTT,LETTER		;CONVERT BACK
	TLNE TTT,-1		;ARE WE 0 CARD
	MOVE TTT,LETTER		;NO CHECK HIM
	TLNN TTT,-1		;HIM OR ME 0?
	JRST ISB		;YES, GO GET'M
NOTB1:	HRRZ T,(T)
	JUMPN T,LOOKB1
	POPJ P,			;NONE FOUND

ISB:	
MPC,<	HLRZ TTT,(P)
	SKIPE TTT
	OUTSTR[ASCIZ/MORE THAN ONE DIP FOUND AT ISB!
/]
>;MPC
	HRLM T,(P)
MD,<	MOVE TTT,NUMBER
	MOVEM TTT,DX1
	HLRZ TTT,1(TT)
	MOVE TTT,1(TTT)
	TLNN TTT,R1416
	JRST [	TLNE TTT,L1416
		SOS DX1
		JRST NOTP2]
	SOS TTT,DX1
	CAIL TTT,7
	SOSA DX1
	AOS DX1
>;MD
	JRST NOTP2

LOOKP1:	HLRZ TT,(T)
	HRRZ TT,1(TT)
MPC,<	MOVE TTT,1(TT)
	TLNN TTT,FRONT		;FIND ON FRONT
	JRST NOTP1
>;MPC
MD,<	HRRZ TTT,1(TT)		;GET PIN #
	JUMPE TTT,NOTP1		;ANY PIN #?
	HRRZ TT,(TT)
	HLRZ TT,(TT)
	HLRZ TT,(TT)
	TRNE TT,BUSSED		;DON'T FIND THE BUSSED THROUGH ONES
	JRST NOTP1
>;MD
MPC,<
	HRRZ TT,(TT)
	HLRZ TTT,(TT)
>;MPC
	CAMN TTT,NUMBER
	JRST CPOPJ1
NOTP1:	HLRZ TT,(T)
NOTP2:	HRRZ T,(TT)
	JUMPN T,LOOKP1
	HLRZ T,(P)		;GET SAVED BODY POINTER
	JRST NOTB1

;LOOKUP CONNECTOR PIN
LOOKC0:
MPC,<	PUSH P,A
	MOVE A,LETTER
	PUSHJ P,QUPIN
	CAIA
	JRST [	POP P,A
		AOS UPINS
		POPJ P,]
	POP P,A
	MOVE T,SID
	HRR T,LETTER
	TRNN T,1
	TLC T,FRONT
	TLNN T,FRONT
	SKIPA T,PONPN2
>;MPC
	MOVE T,PONPNT
	JUMPE T,CPOPJ
LOOKC1:	HLRZ TT,(T)
	HLRZ TTT,(TT)
	HRRZ TT,1(TT)
	HLL TTT,1(TT)
	TLNN TTT,CPIN
	JRST NOTC1
	HRRZ TTT,(TT)
	MOVE TTT,(TTT)
MD,<	SKIPE CRDLOC	>
	HLL TTT,CRDLOC
	XOR TTT,LETTER
	JUMPE TTT,CPOPJ1
	TRNE TTT,-1
	JRST NOTC1
	XOR TTT,LETTER
	TLNE TTT,-1
	MOVE TTT,LETTER
	TLNN TTT,-1
	JRST CPOPJ1
NOTC1:	HRRZ T,(T)
	JUMPN T,LOOKC1
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                      ;CALL ROUTING SUBRS FOR BLINKING PINS!
MPC,<
ROUTE,<
CTMT.:
RTBL:	SKIPN A,BLPNTR		;CAN WE DO ANYTHING?
	JRST PERRET		;NO, LOSE
	SETZM RCL1
	SETZM RCL2		;FLAG AS EMPTY FOR NOW
RCL12:	HRRZ T,1(A)		;GET PC POINT
	JUMPE T,RCL121
	HLRZ TT,(A)		;CHECK LETTER
	TRNN TT,377777		;ANY LETTER ASSIGNED?
	JRST RCL121		;NO, DON'T COUNT THIS ONE
	SKIPN RCL1
	JRST [	MOVEM T,RCL1
		JRST RCL121]
	SKIPE RCL2
	JRST RTLOP
	MOVEM T,RCL2
RCL121:	HRRZ A,(A)
	JUMPN A,RCL12
	SKIPE RCL2		;DID WE GET EXACTLY 2?
	JRST GOTLET		;YES
		OUTSTR[ASCIZ/NOT ENOUGH PINS BLINKING!!!
/]
	POPJ P,

RTLOP:	OUTSTR[ASCIZ/TYPE ROUTING PAIR
/]
	PUSHJ P,RTFND
	JRST RTLOS1
	MOVEM T,RCL1
	PUSHJ P,RTFND
	JRST RTLOS2
	MOVEM T,RCL2
GOTLET:	PUSHJ P,DOROUTE		;NOW DO ROUTING
	SETZM RCL1
	SETZM RCL2		;KEEP ARROWS AWAY
	SKIPN A,BLPNTR		;LEAVE NOW IF 2 OR LESS
	POPJ P,
	MOVEI T,2		;IF THIS GOES NEG, MUST ASK AGAIN
RCLQ1:	HRRZ TT,1(A)
	JUMPE TT,RCLQ2
	HLRZ TT,(A)
	TRNE TT,377777
	SOJL T,RTLOP		;COUNT DOWN AND BLAST OFF
RCLQ2:	HRRZ A,(A)
	JUMPN A,RCLQ1
	POPJ P,			;NOT ENOUGH MORE, LEAVE

RTLOS1:	CAIN C,ALTMOD
	POPJ P,			;LET HIM OUT
	OUTSTR[ASCIZ/CAN'T FIND FIRST POINT!
/]
	JRST RTLOP

RTLOS2:	CAIE C,ALTMOD
	OUTSTR[ASCIZ/CAN'T FIND SECOND POINT!
/]
	JRST RTLOP
>;ROUTE
>;MPC
>;LAYSW!UMLSW
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;PJUMP
PJUMP:
SHORT,<	SKIPN SERR1
	SKIPE SERR2
	JRST PJUMP0
>;SHORT
	SKIPN BLPNTR
	JRST PERRET
PJUMP0:	PUSHJ P,RTFND		;FIND IT
	JRST PJUMPN		;NOT FOUND
PJMPLC:	MOVE A,T
	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	MOVE T,1(A)
MPC,<	TLNE TT,ISPIN		;IF PIN, IT'S REALLY ON BOTH SIDES
	JRST PJUMP1		;SO DON'T CHECK FOR CHANGE
	EQV TT,SID
	JUMPL TT,PJUMP1		;ON RIGHT SIDE?
	SWITCH			;NO, SWITCH
	TRO MCHG		;MUST NOW UPDATE DISPLAY
PJUMP1:
>;MPC
	TRZ INMOV
	MOVE T,A
	JRST SCLOSP

PJUMPX:
SHORT,<	CAIL C,"1"
	CAILE C,"4"
	JRST PJUMPS
	XCT (C)0-"1"+[
		HRRZ T,SERR1
		HRRZ T,SERR2
		HLRZ T,SERR2
		HLRZ T,SERR1]
	JUMPN T,CPOPJ1
	POPJ P,
PJUMPS:
>;SHORT
	JRST INNERR

PJUMPN:	OUTSTR[ASCIZ/POINT NOT FOUND!!
/]
	POPJ P,

RTFND:	TLNE M,DSKACT!MACACT
	JRST RTFND1
SHORT,<	SKIPN BLPNTR
	JRST [	OUTSTR[ASCIZ/TYPE NUMBER (1-4)/]
		JRST RTFND1]
>;SHORT
	SKIPN BLINKN
	JRST [	OUTSTR[ASCIZ/TYPE LETTER/]
		JRST RTFND0]
	OUTSTR[ASCIZ/LARGE LIST, TYPE 2 LETTERS/]
RTFND0:
SHORT,<	SKIPN SERR1
	SKIPE SERR2
	OUTSTR[ASCIZ/ OR NUMBER (1-4)/]
>;SHORT
RTFND1:	PUSHJ P,GETCHR		;GET LETTER OF POINT HE WANTS!
	CAIN C,"_"
	JRST RTFNDC		;FIND CONNECTOR
	CAIL C,"A"
	CAILE C,"Z"
	JRST PJUMPX
	MOVEI T,-100(C)
	SKIPN BLINKN
	JRST RTFND2
	PUSHJ P,GETCHR
	CAIL C,"A"
	CAILE C,"Z"
	JRST PJUMPX
	SUBI T,1
	IMULI T,=26
	ADDI T,-100(C)
;ENTER HERE WITH 1 IN T TO FIND FIRST BLINKING POINT
;IF YOU COULDN'T FIND A CONNECTOR PIN TO JUMP TO
RTFND2:	SKIPN TTT,BLPNTR	;GET POINTER
	POPJ P,			;NONE
RTFND3:	HLRZ TT,(TTT)		;GET PC POINT FROM THIS BLOCK
	ANDI TT,377777
	CAMN TT,T
	JRST [	HRRZ T,1(TTT)
		JRST CPOPJ1]
	HRRZ TTT,(TTT)		;NO, TRY NEXT BLOCK
	JUMPN TTT,RTFND3
	POPJ P,			;NOT FOUND

;TRY TO FIND nTH CONNECTOR PIN ON RUN
RTFNDC:	PUSHJ P,READNC		;READ NUMBER (WILL POP POPJ ON ERROR)
;ENTER HERE WITH 0 IN T TO ATTEMPT TO JUMP TO CONNECTOR PIN
;WHEN CENTERING
LCENJC:	SKIPN TTT,BLPNTR
	POPJ P,			;LOSE
RTFNDD:	HRRZ TT,1(TTT)		;GET POINTER
	HLRZ TT,(TT)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TLNE TT,CPIN		;CONNECTOR PIN?
	SOJLE T,[HRRZ T,1(TTT)	;THIS IS IT
		JRST CPOPJ1]
	HRRZ TTT,(TTT)		;KEEP GOING DOWN LIST
	JUMPN TTT,RTFNDD
	POPJ P,			;NOT FOUND
                                                                                                                                                                                                                                                                                                                                                      COMMENT    VALID 00009 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	HERE RESIDES THE MAGICAL MYSTERY SHORT FINDER
C00005 00003	MAIN LOOP
C00010 00004	POINT TO POINT CHECK
C00012 00005	PUT ERRORS IN ERROR LIST
C00017 00006	POINT TO LINE CHECK, USES SAME ROUTINE AS CURSOR
C00021 00007	CHECK IF 2 LINES CROSS
C00025 00008	SORT SUBR
C00031 00009	SHOW AN ERROR
C00035 ENDMK
C;
                                                                                                                                                                                                                                               ;HERE RESIDES THE MAGICAL MYSTERY SHORT FINDER
MPC,{
SHORT,{

;MAXIMUM NUMBER OF PAD TYPES
MAXPAD__=34		;THIS SHOULD BE ENOUGH

;SHORTING VALUES IN MILS
STPVAL__=1000/5*2	;APPROX NUMBER OF MILS PER STRIPE FOR 1 INCH SQUARES
FOR I_-=35,0
<	IFE STPVALI<STPXXX__I>
>
STRIPE:		STPXXX&777777	;AMOUNT TO SHIFT BY TO GET STRIPE #

OVRVAL__=50/5*2		;APPROX 1 TWENTIETH INCH OVERLAP
FOR I_=35,0,-1
<	IFE OVRVAL-I<OVRXXX__I>
>
OVERLAP:	-1<STPXXX+=36+OVRXXX>	;ACTUAL BITS FOR TESTING AC+1

;THE FOLLOWING VALUES ARE THE OPTICAL PARAMETERS

STORAGE(IMPURE)
MINSEP:		=12		;12 MILS MIN SEPERATION

LINWID:		=13		;ASSUME 13 MILS WIDE FOR NOW

FEDDIA:		=35		;HOLES ARE THIS BIG
		=55		;PAD TYPE 1
		=70		;PAD TYPE 2
		=62		;PAD TYPE 3
	BLOCK MAXPAD-<.-FEDDIA>+1

CPNDIA:		=85		;USE THIS FOR CPIN DIAMETER
STORAGE(PURE)

SETDIA:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PAD TYPE NUMBER?/]
	PUSHJ P,READNC
	JUMPE T,PERRET
	CAILE T,MAXPAD
	JRST [	OUTSTR[ASCIZ/TOO LARGE!
/]
		POPJ P,]
	MOVEI B,FEDDIA(T)
	MOVE T,FEDDIA(T)
	TLNE M,DSKACT!MACACT
	JRST SETVL1
	OUTSTR[ASCIZ/OLD DIAMETER WAS /]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ MILS.
/]
	OUTSTR[ASCIZ/NEW DIAMETER?/]
	JRST SETVL1

SETCPN:	MOVEI A,[ASCIZ/CONNECTOR PIN PSEUDO-DIAMETER/]
	MOVEI B,CPNDIA
	JRST SETVAL

SETHOL:	MOVEI A,[ASCIZ/DRILL HOLE DIAMETER/]
	MOVEI B,FEDDIA
	JRST SETVAL

SETWID:	MOVEI A,[ASCIZ/LINE WIDTH/]
	MOVEI B,LINWID
	JRST SETVAL

SETSEP:	MOVEI A,[ASCIZ/MINIMUM SEPARATION/]
	MOVEI B,MINSEP
SETVAL:	TLNE M,DSKACT!MACACT
	JRST SETVL1
	OUTSTR (A)
	OUTSTR[ASCIZ/ WAS /]
	MOVE T,(B)
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ MILS.
NEW /]
	OUTSTR (A)
	OUTCHR["?"]
SETVL1:	PUSHJ P,READNC
	MOVEM T,(B)		;STORE NEW VALUE
	POPJ P,
                                                                                                                                                                                  ;MAIN LOOP
DOSHORT:SKIPE A,SHRTER		;ANY OLD ERROR LIST TO GIVE BACK?
	PUSHJ P,GIVERR
	SETZM SHRTER
	PUSHJ P,SERSET		;INTIALIZE ERROR, CORE AND TIME COUNTING CELLS
	SKIPE A,PONPNT
	PUSHJ P,SHORT1		;DO FRONT
	PUSHJ P,SERPNT
	PUSHJ P,SERSET
	SWITCH
	SKIPE A,PONPNT
	PUSHJ P,SHORT1
	SWITCH
	SKIPN SHRTER
	JRST [	OUTSTR[ASCIZ/NO ERRORS!
/]
		POPJ P,]
SERPNT:	SKIPN T,PCOP
	JRST NOPCOP
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ COINCIDENT POINTS.
/]
NOPCOP:	SKIPN T,PTOP
	JRST NOPTOP
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ POINT TO POINT ERRORS.
/]
NOPTOP:	SKIPN T,PTOL
	JRST NOPTOL
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ POINT TO LINE ERRORS.
/]
NOPTOL:	SKIPN T,LTOL
	POPJ P,
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ LINE TO LINE ERRORS.
/]
	POPJ P,

SERSET:	SETZM PCOP
	SETZM PTOP
	SETZM PTOL
	SETZM LTOL
	POPJ P,

GIVERR:	HLRZ T,(A)
	FSTRET(T)		;RETURN SECONDARY CELLS
	HRRZ A,(A)
	JUMPN A,GIVERR
	MOVE B,SHRTER
	JRST PUTFS		;THEN MAIN LIST

SHORT1:	PUSHJ P,SIDPNT
	OUTSTR[ASCIZ/ SORTING/]
	PUSHJ P,SSORT		;SORT INTO LIST
	SKIPN H,SRTLST
	JRST SHORTE		;OH MY
	OUTSTR[ASCIZ/ CHECKING/]
SHORT2:	HRRZ G,1(H)		;PICKUP X CHAIN POINTER
	JUMPE G,SHORT3		;IS THERE ONE
SHORT9:	HLRZ F,(G)		;NOW Y CHAIN POINTER
SHORT8:	HLRZ A,(F)		;PICK UP A POINT
	JUMPE A,SHORT4		;IS THERE ONE?
	MOVE E,F		;PREPARE TO GO DOWN LIST
	JRST SHORT5

SHORT6:	HLRZ B,(E)		;PICKUP ANOTHER POINT
	JUMPE B,SHORT5		;IS THERE ONE?
	PUSHJ P,PPCHK		;CHECK POINT TO POINT
SHORT5:	HLRZ B,1(E)		;NOW LINE
	JUMPE B,SHORT7		;ANY HERE?
	HRRZ C,1(E)		;OTHER END TOO
	PUSHJ P,PLCHK		;CHECK LINE TO POINT
SHORT7:	HRRZ E,(E)		;RUN DOWN THE LIST
	JUMPN E,SHORT6
SHORT4:	HLRZ B,1(F)		;ONE ENDPOINT
	JUMPE B,LSHRT1		;IS THERE ONE?
	MOVE E,F		;SETUP LIST AGAIN
	HRRZ C,1(F)		;OTHER ENDPOINT
	JRST LSHRT2		;START WITH POINT, DON'T DO US

LSHRT4:	HLRZ A,1(E)		;ONE END POINT OF LINE
	JUMPE A,LSHRT2
	HRRZ D,1(E)		;OTHER END POINT
	PUSHJ P,LLCHK		;LINE TO LINE CHECK (DEAD SHORT)
LSHRT2:	HLRZ A,(E)		;GET A POINT
	JUMPE A,LSHRT3		;ANY?
	PUSHJ P,PLCHK		;POINT TO LINE CHECK
LSHRT3:	HRRZ E,(E)		;NEXT CELL
	JUMPN E,LSHRT4
LSHRT1:	HRRZ F,(F)		;RUN DOWN THE LIST
	JUMPN F,SHORT8
	HRRZ G,(G)		;NEXT Y CHAIN
	JUMPN G,SHORT9
SHORT3:	HRRZ H,(H)		;NEXT X CHAIN
	JUMPN H,SHORT2
SHORTE:	OUTSTR[ASCIZ/
/]
	SKIPN H,SRTLST		;NOW GIVE BACK LIST
	POPJ P,
SRTRET:	HRRZ G,1(H)
	JUMPE G,SRTRT1
SRTRT2:	HLRZ B,(G)
	PUSHJ P,PUTFS
	MOVE T,G
	HRRZ G,(G)
	FSTRET(T)
	JUMPN G,SRTRT2
SRTRT1:	MOVE T,H
	HRRZ H,(H)
	FSTRET(T)
	JUMPN H,SRTRET
	SETZM SRTLST
	POPJ P,

SIDPNT:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE T,1(T)
	TLNN T,FRONT
	JRST [	OUTSTR[ASCIZ/SOLDER SIDE/]
		POPJ P,]
	OUTSTR[ASCIZ/COMPONENT SIDE/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;POINT TO POINT CHECK
PPCHK:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE T,1(T)
	AND T,[PLANES,,0]
	JUMPE T,NPLNPP		;ANY PLANE?
	HLRZ TT,(B)
	HRRZ TT,1(TT)
	XOR T,1(TT)
	TLNN T,PLANES		;DIFFERENT PLANES?
	POPJ P,			;NO, DOESN'T MATTER IF SHORTED!
NPLNPP:	HLRE T,1(A)
	HLRE TT,1(B)
	SUB T,TT		;DIF IN X
	IMUL T,T		;SQUARE IT
	HRRE TT,1(A)
	HRRE TTT,1(B)
	SUB TT,TTT		;DIF IN Y
	IMUL TT,TT		;SQUARE IT
	ADD T,TT		;THIS IS SQUARE OF DIST.
	JUMPE T,[SETO T,
		PUSH P,[PCOP]
		JRST SHRTMC]
	PUSHJ P,ADIS		;CALC A DISTANCE
	MOVE TTT,TT
	PUSHJ P,BDIS
	ADD TT,TTT		;ADD THIS STUFF TOGETHER
	ASH TT,-1		;HALF DIAMETERS
	ADD TT,MINSEP		;AND MIN SEPERATION
	IMUL TT,TT		;SQUARE IT
	CAMG TT,T		;SMALL ENOUGH BEFORE FIXING?
	POPJ P,			;YES
	IMULI T,=25
	ASH T,-2		;CONVERT TO MILS SQUARED
	CAMG TT,T		;TOO CLOSE?
	POPJ P,
	PUSH P,[PTOP]
;	JRST SHRTMK	;FALL INTO SHRTMK
                                                                                                                                                                                                                                                                                                                                                                                                               ;PUT ERRORS IN ERROR LIST
;MAKE SURE NOT ON SAME WIRE
;AND NOT ALREADY IN ERROR LIST
SHRTMK:	PUSH P,TT
	PUSHJ P,SQRT
	EXCH T,(P)
	PUSHJ P,SQRT
	POP P,TT
	SUB T,TT
SHRTML:	PUSH P,T		;SAVE DIST
	PUSH P,A
	PUSH P,B
	PUSH P,C
	MOVSI C,1
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;FIRST NOTE THAT WE HAVE SEEN NO ONE
	SKIPE A,PONPN2
	PUSHJ P,CLRBTS		;ALSO THIS SIDE (IN CASE OF FEEDING THROUGH ETC.)
	POP P,C
	POP P,B
	POP P,A
	SETZM CPLAN1
	SETZM CPLAN2
	PUSHJ P,SHRTWR		;CHECK IF A & B ON SAME WIRE
	JRST [	POP P,(P)
		JRST SHRTMQ]	;ON SAME WIRE, NO ERROR
	SKIPN T,CPLAN1
	JRST SHRTXP		;NO PLANE CONNEX
	MOVEM T,CPLAN2		;SAVE THAT PLANE HERE
	SETZM CPLAN1		;CLEAR THIS
	EXCH A,B
	PUSHJ P,SHRTWR		;AND SEE IF THIS GUY ALSO TOUCHES THAT PLANE
	JRST [	POP P,(P)
		JRST SHRTMQ]	;SAME PLANE CONNEX, NO ERROR
	EXCH A,B		;PUT THESE BACK
SHRTXP:	POP P,T
SHRTMC:	SKIPN TT,SHRTER		;CHECK FOR REDUNDANCY
	JRST SHRTMM
SHRTMN:	HLRZ TTT,(TT)
	CAMN A,1(TT)
	CAME B,1(TTT)
	JRST SHRTMP
SHRTMQ:	POP P,(P)
	POPJ P,			;REDUNDENT, FLUSH IT

SHRTMP:	CAMN B,1(TT)
	CAME A,1(TTT)
	JRST SHRTMO
	JRST SHRTMQ

SHRTMO:	HRRZ TT,(TT)
	JUMPN TT,SHRTMN
SHRTMM:	POP P,TT
	AOS (TT)		;COUNT IT
	GETFS(TT)		;STORE EVERYONE INTO ERROR LIST
	GETFS(TTT)
	HRLM TTT,(TT)
	MOVEM A,1(TT)
	MOVEM B,1(TTT)
	HRRZ A,A		;CLEAR CRUFT OUT OF LEFT HALF
	HRRZ B,B		;	"
	MOVEM T,(TTT)		;SAVE AMOUNT WE LOST BY HERE ALSO
	EXCH TT,SHRTER
	HRRM TT,@SHRTER
	POPJ P,

;NOW SEE IF A & B ARE ON SAME WIRE?
SHRTWR:	HRRZ T,A
	CAIN T,(B)		;ON SAME WIRE YET?
	POPJ P,			;YES
	HLRZ TTT,(A)
	HRRZ TT,1(TTT)
	HLL TT,1(TT)
	TLOE TT,1
	JRST CPOPJ1		;TERMINATE IF DONE ALREADY
	HLLM TT,1(TT)
	SKIPE CPLAN1
	JRST SHRTNP
	MOVSI T,PLANES
	AND T,TT		;EXTRACT PLANE CONNEX
	JUMPE T,SHRTNP		;SKIP IF NONE
	MOVEM T,CPLAN1
	CAMN T,CPLAN2		;SAME AS OTHER GUYS?
	POPJ P,			;YES, NO SHORT
SHRTNP:	PUSH P,A		;SAVE A
	HLRZ A,(TTT)
	TLNN TT,FEEDTH		;FEED THROUGH?
	JRST SHRTWS
	PUSHJ P,SHRTWR
	JRST SHRTL0		;FOUND HIM
	JRST SHRTWW

SHRTWS:	TLNN TT,ISPIN		;HOW ABOUT BEING A DIP PIN?
	JRST SHRTWW		;NO
	HRR TT,(TT)		;GET PIN TYPE POINTER (SAVE TYPE BITS)
	HRRZ A,(P)
	HLRZ A,(A)
	HLRZ A,(A)		;GET BODY POINTER
	JRST SHRTPB

SHRTPA:	HLRZ T,(A)
	HRRZ T,1(T)
	HRRZ TTT,(T)
	CAIE TTT,(TT)		;SAME TYPE POINTER?
	JRST SHRTPB
	MOVE TTT,1(T)
	EQV TTT,TT
	JUMPGE TTT,SHRTPC	;BITS ARE DIFFERENT IF THIS IS OTHER SIDE
SHRTPB:	HLRZ A,(A)
	HRRZ A,(A)
	JUMPN A,SHRTPA
	PUSHJ P,FUCKUP
	JRST SHRTWW		;OH WELL

SHRTPC:	PUSHJ P,SHRTWR		;CALL RECURSIVELY ON OTHER SIDE
	JRST SHRTL0		;WIN, WE FOUND HIM
SHRTWW:	HRRZ T,(P)
	HLRZ T,(T)
	HLRZ T,1(T)
	JUMPE T,SHRTL1		;NO LINES
SHRTWT:	MOVEI TT,2
SHRTWV:	XCT (TT)[HLRZ A,(T)
		HRRZ A,1(T)
		HLRZ A,1(T)]
	JUMPE A,SHRTWU
	HRL T,TT
	PUSH P,T
	PUSHJ P,SHRTWR
	JRST [	POP P,(P)
		JRST SHRTL0]	;FOUND HIM
	POP P,T
	HLRZ TT,T
SHRTWU:	SOJGE TT,SHRTWV
	HRRZ T,(T)
	JUMPN T,SHRTWT
SHRTL1:	AOS -1(P)
SHRTL0:	POP P,A
	POPJ P,
                                                                                                                                                                                                                        ;POINT TO LINE CHECK, USES SAME ROUTINE AS CURSOR
PLCHK:	CAME A,B		;SKIP IT IF EITHER END POINT THE SAME
	CAMN A,C
	POPJ P,
	MOVE T,1(C)
	MOVE TT,1(B)
	CAME T,1(A)
	CAMN TT,1(A)		;IF COINCEDENT WITH EITHER END, LET PTOP CATCH IT
	POPJ P,
	XOR T,TT
	TLNN T,-1
	JRST [	HRRE T,1(A)		;LINE IS VERT
		HRRE TT,1(B)
		HRRE TTT,1(C)
		CAMG TT,TTT
		JRST [	CAML T,TT	;BELOW BOTTOM?
			CAMLE T,TTT	;ABOVE TOP?
			POPJ P,		;YES, GIVE UP
			JRST GOTLD1]
		CAML T,TTT		;BELOW BOTTOM?
		CAMLE T,TT		;OR ABOVE TOP?
		POPJ P,			;YES, GIVE UP
	GOTLD1:	HLRE T,1(C)		;POINT X
		HLRE TT,1(A)		;LINE X
		JRST GOTLD3]
	TRNN T,-1
	JRST [	HLRE T,1(A)		;LINE IS HORZ
		HLRE TT,1(B)
		HLRE TTT,1(C)
		CAMG TT,TTT
		JRST [	CAML T,TT	;BELOW BOTTOM?
			CAMLE T,TTT	;OR ABOVE TOP?
			POPJ P,		;YES, GIVE UP
			JRST GOTLD2]
		CAML T,TTT		;BELOW BOTTOM?
		CAMLE T,TT		;OR ABOVE TOP?
		POPJ P,			;YES, GIVE UP
	GOTLD2:	HRRE T,1(C)		;POINT Y
		HRRE TT,1(A)		;LINE Y
	GOTLD3:	SUB T,TT		;DIF
		IMUL T,T		;SQUARE
		IMULI T,=25
		ASH T,-2
		JRST GOTLD]
	PUSH P,E
	MOVE E,C
	HLRE T,1(A)
	MOVEM T,DX1
	HRRE T,1(A)
	PUSHJ P,CALINE		;CALC DIST TO LINE
	JRST [	POP P,E		;LOSE IF OFF END
		POPJ P,]
	POP P,E
	ASHC TT,4		;PRESERVE SOME SIGNIFICANCE
	DIV TT,L2
	IMULI TT,=25
	ASH TT,-2-4		;NOW REMOVE SIGNIFICANCE
	MOVM T,TT		;THIS IS SQUARE OF DIST
GOTLD:	PUSHJ P,ADIS
	ADD TT,LINWID
	ASH TT,-1		;HALF DIAMETERS
	ADD TT,MINSEP
	IMUL TT,TT
	CAMG TT,T		;SMALL ENOUGH?
	POPJ P,			;YES
	HRL B,C			;SET THIS UP
	PUSH P,[PTOL]
	JRST SHRTMK		;AND LET THIS GUY DO THE REST

BDIS:	HLRZ TT,(B)
	CAIA
ADIS:	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TDNN TT,[FEEDTH!CPIN,,-1]	;PAD OR FEEDTHROUGH?
	JRST [	MOVE TT,LINWID	;NO, USE LINE WIDTH
		POPJ P,]
	TLNE TT,CPIN	;CONNECTOR SQUARE?
	JRST [	MOVE TT,CPNDIA
		POPJ P,]
	TRNE TT,-1	;ANY PAD TYPE?
	JRST GPADIA
	MOVE TT,FEDDIA
	POPJ P,

GPADIA:	HRRZ TT,TT
	CAILE TT,MAXPAD	;TOO BIG?
	JRST [	MOVEI TT,=1000		;AN INCH SHOULD BE ENOUGH
		POPJ P,]		;DON'T SAY ANYTHING, ELSE WE WILL SAY TOO MUCH
	SKIPE FEDDIA(TT)
	JRST [	MOVE TT,FEDDIA(TT)
		POPJ P,]
	PUSH P,T
	PUSH P,TT
	PUSH P,C
	OUTSTR[ASCIZ/NO DIAMETER IN TABLE FOR PAD TYPE /]
	MOVE T,TT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/.
/]
DILOSE:	OUTSTR[ASCIZ/PLEASE TELL ME THE DIAMETER IN MILS?/]
	PUSHJ P,READN
	CAIN C,ALTMOD
	JRST DILOSE
	CAIE C,12
	JRST [	PUSHJ P,SCARF	;HE'S JUST GOT TO TELL US!!!!
		JRST DILOSE]
	JUMPE T,DILOSE
	POP P,C
	POP P,TT
	MOVEM T,FEDDIA(TT)
	MOVE TT,T
	POP P,T
	POPJ P,
             ;CHECK IF 2 LINES CROSS
;A & D ARE ENDS OF ONE LINE
;B & C ARE ENDS OF THE OTHER LINE
;USES CROSS PRODUCT TO CALC WHICH SIDE OF A LINE A POINT IS ON
;ASSUMPTION IS, "IF ENDPOINTS OF ONE LINE ARE ON OPPOSITE SIDES
;OF THE OTHER, AND VICE VERSA, THEN THERE IS A DEAD SHORT".
LLCHK:	CAME A,B
	CAMN A,C
	POPJ P,			;NOT TO OURSELVES
	CAME D,B
	CAMN D,C
	POPJ P,
	HLRE T,1(A)
	HLRE TT,1(D)
	CAML T,TT
	EXCH T,TT
	HLRE TTT,1(B)
	CAMG TTT,T
	JRST XCHK1
	CAMG TTT,TT
	JRST YCHK
	HLRE TTT,1(C)
	CAML TTT,TT
	POPJ P,			;VERT SEPERATOR
	JRST YCHK

XCHK1:	HLRE TTT,1(C)
	CAMG TTT,T
	POPJ P,			;VERT SEPERATOR
YCHK:	HRRE T,1(A)
	HRRE TT,1(D)
	CAML T,TT
	EXCH T,TT
	HRRE TTT,1(B)
	CAMG TTT,T
	JRST YCHK1
	CAMG TTT,TT
	JRST DOCROSS
	HRRE TTT,1(C)
	CAML TTT,TT
	POPJ P,			;VERT SEPERATOR
	JRST DOCROSS

YCHK1:	HRRE TTT,1(C)
	CAMG TTT,T
	POPJ P,			;VERT SEPERATOR
DOCROSS:
;MUST DO CROSS PRODUCT, BUT NOW NO SOMETHING ABOUT COLINEAR LINES
	HLRE T,1(B)
	HLRE TT,1(A)
	SUBM T,TT
	MOVEM TT,DX1
	HLRE TT,1(C)
	SUBM T,TT
	MOVEM TT,DX2
	HLRE TT,1(D)
	SUBM T,TT
	MOVEM TT,DX3
	HRRE T,1(B)
	HRRE TT,1(A)
	SUBM T,TT
	MOVEM TT,DY1
	HRRE TT,1(C)
	SUBM T,TT
	MOVEM TT,DY2
	HRRE TT,1(D)
	SUBM T,TT
	MOVEM TT,DY3
;	MOVE TT,DY3
	IMUL TT,DX2
	MOVE T,DX3
	IMUL T,DY2
	SUB T,TT
	JUMPE T,CPOPJ		;IF 0 THEN ON LINE, IF SHORTED, WILL BE CAUGHT BY POINT TO LINE CHECKER
	MOVE TT,DX1
	IMUL TT,DY2
	MOVE TTT,DX2
	IMUL TTT,DY1
	SUB TT,TTT
	JUMPE TT,CPOPJ		;WILL BE CAUGHT BY POINT TO LINE CHECKER
	EQV TT,T
	JUMPL TT,CPOPJ		;NOW IF SAME SIGN, THEN BOTH ON SAME SIDE OF LINE
	HLRE T,1(D)
	HLRE TT,1(A)
	SUBM T,TT
	MOVEM TT,DX2
	HLRE TT,1(C)
	SUBM T,TT
	MOVEM TT,DX1
	HRRE T,1(D)
	HRRE TT,1(A)
	SUBM T,TT
	MOVEM TT,DY2
	HRRE TT,1(C)
	SUBM T,TT
	MOVEM TT,DY1
;	MOVE TT,DY1
	IMUL TT,DX2
	MOVE T,DX1
	IMUL T,DY2
	SUB T,TT
	JUMPE T,CPOPJ		;IF THIS CROSS PRODUCT IS 0, THEN ONLY ONE END ON LINE
	MOVE TT,DX2
	IMUL TT,DY3
	MOVE TTT,DX3
	IMUL TTT,DY2
	SUB TT,TTT
	JUMPE TT,CPOPJ		;AND WILL BE CAUGHT BY LINE TO LINE CHECKER
	EQV TT,T
	JUMPL TT,CPOPJ		;IF SAME SIGN, THEN BOTH ON SAME SIDE
ISONLS:	SETZ T,			;LOSE BY!
	HRL A,D
	HRL B,C
	PUSH P,[LTOL]
	JRST SHRTML		;THIS WILL STORE INTO ERROR LIST
                                                                                                                                                                                                                                                                                                           ;SORT SUBR
SSORT:	SETZM SRTLST		;CLEAR LIST 
	MOVEI H,SRTLST		;FIRST PASS GOES INTO SRTLST
XSORT1:	TRZ TFLG		;NO LINES SEEN YET
	HLRZ C,(A)
	HLRZ C,1(C)
	JUMPE C,XSORTE		;TRY ANOTHER?
XSORT2:	MOVEI D,2
XSORT3:	XCT (D)[HLRZ B,(C)
		HLRZ B,1(C)
		HRRZ B,1(C)]
	JUMPE B,XSORT4
	TRO TFLG		;FLAG LINE HERE
	MOVE T,1(A)
	CAML T,1(B)		;ONLY DO SEGMENT ONCE
	JRST XSORT4
	HLRE T,1(A)		;BY X VALUE
	HLRE TT,1(B)
	PUSHJ P,ILSORT		;SORT LINE INTO LIST
XSORT4:	SOJGE D,XSORT3
	HRRZ C,(C)
	JUMPN C,XSORT2
XSORTE:	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)		;PADTYPE
	HLRE T,1(A)		;BY X VALUE
	TRNN TFLG		;LINES SEEN?
	TDNE TT,[FEEDTH!CPIN,,-1]	;NO, PAD HERE, OR FEED THROUGH OR CPIN?
	PUSHJ P,IPSORT		;SORT POINT INTO LIST
	HRRZ A,(A)		;TRY ANOTHER
	JUMPN A,XSORT1
	SKIPN H,SRTLST
	POPJ P,			;NOTHING???
YSORT1:	ADDI H,1		;POINT TO PLACE TO BUILD LIST
	SETZM (H)		;CLEAR IT OUT FOR NOW
	HLRZ G,-1(H)		;PICKUP X CHAIN POINTER
	JRST YSORT2

YSORT3:	HLRZ A,(G)		;GET POINT FROM HERE
	JUMPE A,YSORT4
	HRRE T,1(A)		;BY Y VALUE
	PUSHJ P,IPSORT		;SORT INTO H LIST BY Y VALUE
YSORT4:	HLRZ A,1(G)		;NOW LINE
	JUMPE A,YSORT5
	HRRZ B,1(G)
	HRRE T,1(A)
	HRRE TT,1(A)
	CAMG T,TT		;AB?
	JRST YSORT6		;YES
	EXCH T,TT
	EXCH A,B		;INTERCHANGE
YSORT6:	PUSHJ P,ILSORT		;SORT LINE IN BY Y
YSORT5:	MOVE T,G
	HRRZ G,(G)
	FSTRET(T)
YSORT2:	JUMPN G,YSORT3
	HRRZS H,-1(H)		;CLEAR OUT OLD X CHAIN POINTER AND PICKUP NEXT
	JUMPN H,YSORT1		;NEXT X CHAIN
	POPJ P,			;FINI

;INSERT POINT INTO PROPER CHAIN ACCORDING
;TO X OR Y VALUE IN T
IPSORT:	ASHC T,@STRIPE		;CONVERT TO STRIPE # AND REMAINDER
	HLLM TT,(P)		;SAVE REMAINDER
	PUSHJ P,IPSRTP		;NOW SORT INTO BUCKET BY VALUE IN T
	HLLZ TT,(P)
	TDNE TT,OVERLAP		;NEED OVERLAP?
	POPJ P,			;NOT IN OVERLAP REGION
	SOJA T,IPSRTP		;IN OVERLAP REGION, SORT INTO THIS BUCKET TOO

;CALL WITH BUCKET VALUE IN T
;STORES PIN POINTER A INTO CHAIN WITH VALUE
IPSRTP:	PUSHJ P,IPSRTA		;FIND CORRECT BUCKET (RETURNS IN E)
	HLRZ E,(E)
IPSRTQ:	HLRZ TT,(E)
	JUMPE TT,[HRLM A,(E)	;STO PIN POINTER
		POPJ P,]	;AND RETURN
	MOVE F,E
	HRRZ E,(E)
	JUMPN E,IPSRTQ
	GETFS(E)
	HRRM E,(F)
	HRLZM A,(E)
	SETZM 1(E)		;CLEAR LINE BUCKET
	POPJ P,

;INSERT LINE INTO ALL CHAINS IT CROSSES
;A & B ARE ENDPOINTS T & TT ARE SORT VALUES
;T IS ALREADY DETERMINED TO BE LESS THAN TT
ILSORT:	ASHC TT,@STRIPE
	PUSH P,TT		;THIS IS ENDING STRIPE, SAVE IT
	ASHC T,@STRIPE		;THIS IS STARTING VALUE
	TDNN TT,OVERLAP		;NEED OVERLAP?
	SUBI T,1		;YES BACKUP 1 STRIPE
ILSRT1:	PUSHJ P,ILSRTL		;SORT IN ONCE
	ADDI T,1
	CAMG T,(P)
	JRST ILSRT1		;CONTINUE
	POP P,(P)
	POPJ P,			;DONE

;CALL WITH BUCKET VALUE IN T
;STORES A & B IN LINE BUCKET WITHIN CHAIN WITH VALUE
ILSRTL:	PUSHJ P,IPSRTA		;FIND PROPER CHAIN
	HLRZ E,(E)
ILSRTM:	SKIPN 1(E)
	JRST [	MOVEM B,1(E)	;FOUND A SPOT, STORE LINE POINTERS
		HRLM A,1(E)
		POPJ P,]
	MOVE F,E
	HRRZ E,(E)
	JUMPN E,ILSRTM
	GETFS(E)		;END OF LIST, MAKE A NEW CELL
	HRRM E,(F)
	SETZM (E)
	MOVEM B,1(E)		;NOW STORE LINE POINTERS
	HRLM A,1(E)
	POPJ P,

;CALL WITH BUCKET VALUE IN T
;RETURNS WITH BUCKET POINTER IN E
IPSRTA:	MOVE E,H		;SET TT TO LIST HEADER
	JRST IPSRTB

IPSRTC:	CAMG T,1(E)		;GOT TO RIGHT BUCKET YET?
	JRST [	CAMN T,1(E)
		POPJ P,		;RETURN TO SENDER
		JRST IPSRTD]	;YES
IPSRTB:	MOVE F,E
	HRRZ E,(E)
	JUMPN E,IPSRTC
IPSRTD:	GETFS(E)
	HRRZ TT,(F)
	HRRM TT,(E)
	HRRM E,(F)
	MOVEM T,1(E)		;SET VALUE
	GETFS(TT)
	HRLM TT,(E)		;STO CHAIN POINTER
	SETZM (TT)		;CLEAR POINT AND LINK
	SETZM 1(TT)		;CLEAR LINE BUCKET
	POPJ P,			;RETURN TO SENDER
                                                                                                                                                                                                                                                                  ;SHOW AN ERROR
SHWERR:	SKIPN A,SHRTER
	JRST PERRET		;NOTHING LEFT IN LIST
	PUSHJ P,MMSET		;SETUP PARAMETERS
	TRZ TFLG		;NOTE NO ONE OFF SCREEN YET
	HLRZ B,(A)		;SECONDARY BLOCK POINTER
	HLRZ T,1(A)
	PUSHJ P,MMCK
	HRRZ T,1(A)
	PUSHJ P,MMCK
	HLRZ T,1(B)
	PUSHJ P,MMCK
	HRRE T,1(B)
	PUSHJ P,MMCK
	MOVE T,1(A)
	MOVEM T,SERR1
	MOVE TT,1(B)
	MOVEM TT,SERR2
	TLNE T,-1		;LINE TO LINE?
	JRST [	OUTSTR[ASCIZ/LINE TO LINE DEAD SHORT!
/]
		JRST DOCNTS]	;AND THEY'RE OFF
	TLNE TT,-1		;POINT TO LINT?
	JRST [	OUTSTR[ASCIZ/POINT TO LINE, LOSE BY /]
		JRST DOLOSE]
	SKIPGE (B)
	JRST [	OUTSTR[ASCIZ/COINCIDENT POINTS
/]
		JRST DOCNTS]
	OUTSTR[ASCIZ/POINT TO POINT, LOSE BY /]
DOLOSE:	MOVE T,(B)
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ MILS
/]
DOCNTS:	HRRZ C,(A)
	MOVEM C,SHRTER		;TAKE THIS ONE OUT OF LIST
	JUMPN C,.+2		;ANY MORE?
	OUTSTR[ASCIZ/NO MORE ERRORS!
/]
	HRRZ C,1(A)
	FSTRET(A)
	FSTRET(B)
	HLRZ T,(C)
	HRRZ T,1(T)
	MOVE T,1(T)
	EQV T,SID
	JUMPL T,DOCNTQ		;ON RIGHT SIDE ALREADY?
	SWITCH			;NO, CHANGE SIDES
	JRST DOCNTR		;SINCE CHANGING SIDES, MIGHT AS WELL DO THIS

DOCNTQ:	TRO MCHG		;MUST GET ERROR DISPLAY OUT!
	MOVE T,NSCALE
	TRNN TFLG		;ANYONE OFF SCREEN?
	CAIGE T,=16		;IF SMALLER THAN THIS, CHECK ANYWAY
DOCNTR:	PUSHJ P,DOCENT		;OK NOW DO THE CENTER THING
	HRRZ T,SERR1
	JUMPE T,CPOPJ
	MOVE T,1(T)		;IF THERE IS A POINT FOR O__1
	TRZE INMOV!INLIN	;MAKE SURE WE DON'T MOVE SOMETHING THERE
	TRO NEEDCL
	JRST SETPOS		;THEN PUT CURSOR THERE

MMCK:	JUMPE T,CPOPJ
	MOVE T,1(T)
	PUSHJ P,ONSCR
	TRO TFLG		;NOTE SOMEONE OFF SCREEN
	JRST MINMAX

CSHORT:	SETZM SERR1
	SETZM SERR2
	TRO MCHG
	POPJ P,

SHRTDP:	MOVE A,SERR1
	TRNE BTHSDS		;IN BOTH SIDES MODE?
	JRST ALSHRT
	HLRZ T,(A)		;THIS POINTER IS ALWAYS HERE
	HRRZ T,1(T)
	MOVE T,1(T)
	EQV T,SID		;ON THIS SIDE?
	JUMPGE T,CPOPJ		;NO
	SKIPA T,DEFBRT
ALSHRT:	MOVE T,BTHBRT
	ADD T,BLBRT
	PUSHJ P,DPYBRT
	SETZ C,
	PUSHJ P,SHRTD1
	MOVE A,SERR2
	MOVEI C,1
	PUSHJ P,SHRTD1
	JRST BLINKO

SHRTD1:	MOVE T,1(A)
	TLNN A,-1
	JRST SHRTD2
	PUSHJ P,AIVECT
	HLRZ T,A
	MOVE T,1(T)
	PUSHJ P,AVECT
	MOVE T,1(A)
SHRTD2:	PUSHJ P,BIGAIV
	MOVE T,(C)[ASCID/O__1/
		   ASCID/O__2/	]
	PUSHJ P,TXTDPB
	HLRZ A,A
	JUMPE A,CPOPJ
	MOVE T,1(A)
	PUSHJ P,BIGAIV
	MOVE T,(C)[ASCID/O__4/
		   ASCID/O__3/	]
	JRST TXTDPB
>;SHORT
>;MPC
                                                                                                                                                                                                                        COMMENT    VALID 00021 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	bit array initializer - - clobbers T, TT, TTT, A, B, C, D, E, F, G.
C00008 00003	initialization routine - - mark all lines to this point
C00010 00004	MARK A LINE IN THE BIT ARRAY (UGH,BLETCH)!
C00012 00005	CASE1:	IMUL T,DX
C00014 00006	CASE2:	IMUL T,DY
C00016 00007	HERE WE TRY TO ACTUALLY ROUTE A WIRE
C00019 00008	RWIN:	MOVEM SID,SIDSAV		GET REAL SID FROM STORAGE
C00021 00009	MAKFED:	PUSH P,B
C00022 00010	STKN__6			NUMBER OF THINGS PUSHED ON STACK IN RECURSIVE ROUTINES
C00024 00011	NVB:	XCT VTAB(F)
C00025 00012	PHB:	XCT HTAB(F)
C00026 00013	NHB:	XCT HTAB(F)
C00027 00014	PNF:	XCT FTAB(F)
C00029 00015	LOSE:	MOVEI T,0
C00031 00016	SDIF__ARRAYB-ARRAYA
C00033 00017	%__0		SO BLANK CONCATINATED WITH % IS 0.
C00036 00018	XNV:	XD	PH1,NVA,NHA1,PNF,NVB,NHB1
C00039 00019	PWIN:	JUMPG G,SKIP2A		COUNT MUST BE EXACT!
C00040 00020	ROUTER DISPLAY
C00042 00021	BITBYA, BITBYT
C00044 ENDMK
C;
                                                                                                                                                                                                                                                                                               ;bit array initializer - - clobbers T, TT, TTT, A, B, C, D, E, F, G.
ROUTE,<
VERSION(ROUTE,1)
MPC,<
BITINI:	MOVE T,[ARRAYA,,ARRAYA+1]
	SETZM ARRAYA
	BLT T,ARRAYB+ARRAYB-ARRAYA-1	;CLEAR ARRAYS
	TLO M,%ROUTE
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ROUTING TABLES INITIALIZED!
/]
	PUSHJ P,BITIN1
BITIN1:	SKIPE B,PONPNT
	PUSHJ P,MARK
	HRRZ B,CRDLST
	JUMPE B,BITIN2
	HRRZ B,(B)
	MOVEI G,3			;MARK IT SOLIDLY
	JUMPN B,BITIN3
	JRST BITIN2
BITIN4:	MOVE E,1(B)
	TRNE E,1
	JRST BITIN3
	MOVE F,1(A)
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/CARD EDGE EXCEEDS ARRAY BOUNDS!
/]
BITIN3:	MOVE A,B
	HRRZ B,(B)
	JUMPN B,BITIN4
BITIN2:	SWITCH
	POPJ P,

;bit array display routine - - clobbers T, TT, TTT, A, B, C, D, E, F, G.
PDISP:	MOVEI T,2
	PUSHJ P,DPYBIG
	SKIPN A,RCL1
	JRST NRCL1
	MOVE T,1(A)
	PUSHJ P,AIVECT
	MOVE T,[ASCID/_/]
	PUSHJ P,TXTDPB
NRCL1:	SKIPN A,RCL2
	JRST NRCL2
	MOVE T,1(A)
	PUSHJ P,AIVECT
	MOVE T,[ASCID//]
	PUSHJ P,TXTDPB
NRCL2:	TLNN M,RDISP
	POPJ P,
	MOVEI T,0		;FIND PIC COORDINATE OF LOWER LEFT
	ADJUST(SUB,T,<[%XCEN,,%YCEN]>)	;CORNER OF POINT ARRAY.
	MOVE TT,[%XSIZ,,%YSIZ]
	ADJUST(SUB,TT,<[%XCEN,,%YCEN]>)	;AND UPPER RIGHT
	MOVNI A,20000		;NOW CORNERS OF SCREEN
	IDIV A,NSCALE
	IDIVI A,%GRAIN
	IMULI A,%GRAIN
	HRL A,A
	MOVSI B,1
	SUB B,A
	HRL C,XOFF
	HRR C,YOFF
	ADJUST(ADD,A,C)		;LOWER LEFT IN A
	ADJUST(ADD,B,C)		;UPPER RIGHT IN B
	MOVE TTT,A
	ADJUST(SUB,TTT,T)	;FIND GREATER OF LOWER LEFT CORNER OF
	TLNN TTT,400000		;POINT ARRAY AND SCREEN
	HLL T,A
	TRNN TTT,400000
	HRR T,A
	MOVE TTT,B
	ADJUST(SUB,TTT,TT)	;FIND LESSER OF UPPER RIGHT CORNER OF
	TLNE TTT,400000		;POINT ARRAY AND SCREEN
	HLL TT,B
	TRNE TTT,400000
	HRR TT,B
	ADJUST(SUB,TT,T)	;FIND DELTA X AND Y FOR PORTION OF
	TDNE TT,[400000,,400000];SCREEN WE WILL DISPLAY
	POPJ P,			;ONE OR BOTH WERE NEGATIVE(NOTHING TO DISPLAY)
	MOVE A,T
	HLRZ T,TT		;NOW GET DELTA X AND Y IN ARRAY STEPS
	HRRZ TT,TT
	IDIVI TT,%GRAIN
	MOVE B,TT		;Y STEPS IN B
	IDIVI T,%GRAIN
	EXCH T,A		;X STEPS IN A AND X,Y COORD'S IN T.
	MOVE F,T		;SAVE COPY OF X,Y FOR APOINT.
	PUSHJ P,BITBYT		;MAKE BYTE POINTER
	JRST DPYOUT		;WHAT A SCREW-UP
	MOVE C,TTT		;TTT GETS CLOBBERED BY APOINT, USE C.
PDISP1:	MOVE G,F		;RESET X,Y (BEGIN NEXT ROW)
	MOVE E,A		;RESET X COUNT
	MOVE D,C		;RESET BYTE POINTER
PDISP2:	LDB T,D			;PICK UP A BYTE
	JUMPE T,PDISP3		;PUT A POINT HERE?
	MOVE T,G
	PUSHJ P,APOINT
PDISP3:	HRLZI T,%GRAIN
	ADD G,T			;INC X,Y BY ONE GRAIN.
	IBP D
	SOJG E,PDISP2		;LOOP ON ROW
	ADDI C,%ROW		;INC SAVED BYTE POINTER BY ONE ROW
	ADDI F,%GRAIN		;INC SAVED X,Y BY ONE ROW
	SOJG B,PDISP1		;AND LOOP ON ROW
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;initialization routine - - mark all lines to this point
;and the point if a pin or feed through
;clobbers T, TT, TTT, A, B, C, D, E, F, G.
;G=1 to set bits | G=0 to clear bits.
MARK:	HLRZ A,(B)
	HLRZ C,1(A)
	JUMPE C,MARK31
MARK1:	MOVEI D,2
MARK2:	XCT (D)[	HLRZ E,(C)
			HLRZ E,1(C)
			HRRZ E,1(C)]
	JUMPE E,MARK3
	MOVE E,1(E)
	MOVE F,1(B)
	MOVEI G,1		;1 FOR LINES
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/
POINT EXCEEDS ARRAY BOUNDS!/]
MARK3:	SOJGE D,MARK2
	HRRZ C,(C)
	JUMPN C,MARK1
MARK31:	HRRZ C,1(A)
	HLL C,1(C)
	TDNN C,[ISPIN!FEEDTH!CPIN,,-1]	;DRILL HOLE OR SOME PAD!
	JRST MARK4
	MOVEI G,3		;3 FOR PADS!
	TRNN C,-1		;UNPADDED?
	MOVEI G,2		;IN WHICH CASE WE USE 2
	MOVE E,1(B)
	MOVE F,E		;MARK LINE FROM POINT TO ITSELF
	TLNN C,CPIN		;CPIN MUST BE DONE SPECIAL
	JRST MRKPNT
	ADDI F,%SEPAR	;MARK ABOVE
	ADDI E,-%SEPAR	;AND BELOW
	TLZ F,1
	TLZ E,1
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/CONNECTOR NOT IN ARRAY!
/]
	MOVE E,1(B)
	HRRZ F,(C)		;CPIN OTHER END POINTER
	MOVE F,1(F)
	PUSHJ P,MRKLIN		;MAKE A LINE TO FLUSH CROSSING OF CPIN
	OUTSTR[ASCIZ/CONNECTOR STICKS OUT OF ARRAY!
/]
MRKPNT:	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/
POINT EXCEEDS ARRAY BOUNDS!/]
MARK4:	HRRZ B,(B)
	JUMPN B,MARK
	POPJ P,
                                                      ;MARK A LINE IN THE BIT ARRAY (UGH,BLETCH)!
;one endpoint in E the other in F.
;clobbers T, TT, TTT, E, F, G.
;G0 check for clear path(skip if clear)
;G=0 clear bits
;G=1 sets line bits
;G=2 sets unpadded feed through bits
;G=3 sets pad bits
MRKLIN:	TDZ F,[1,,1]
	TDZ E,[1,,1]
	CAMG F,E
	EXCH F,E
	MOVE T,F
	PUSHJ P,BITBYT
	POPJ P,
	MOVE T,E
	PUSHJ P,BITBYT
	POPJ P,
	MOVE T,F
	ADJUST(SUB,T,E)
	HRLM T,(P)	;SAVE HERE TEMPORARILY
	HLRE T,T
	IDIVI T,%GRAIN
	JUMPE TT,.+2
	ADDI T,1
	MOVEM T,DX
	HLRE T,(P)
	IDIVI T,%GRAIN
	JUMPE TT,.+4
	JUMPG TT,.+2
	SUBI T,2
	ADDI T,1
	MOVEI E,%ROW
	JUMPGE T,.+2
	MOVNI E,%ROW
	MOVMM T,DY
	MOVM T,T
	SETZM XCNT
	SETZM YCNT
	SETZ TT,
	CAMGE T,DX
	JRST CASE2C
	MOVNI T,%STEP/2
	MOVEM T,YCNT
	IMUL T,E
	ADD TTT,T
	MOVNI T,%STEP/2
	IMUL T,DX
	IDIV T,DY
	MOVEM T,XCNT
	SUBI T,%STEP/2
	CAIA
	PUSHJ P,DBP
	AOJLE T,.-1
	MOVE T,YCNT
	JRST CASE1

CASE2C:	MOVNI T,%STEP/2
	MOVEM T,XCNT
	CAIA
	PUSHJ P,DBP
	AOJLE T,.-1
	MOVNI T,%STEP/2
	IMUL T,DY
	IDIV T,DX
	MOVEM T,YCNT
	SUBI T,%STEP/2
	IMUL T,E
	ADD TTT,T
	MOVE T,XCNT
	JRST CASE2
                                                                                                                                                        CASE1:	IMUL T,DX
	IDIV T,DY
IFG %STEP-1,<
	JUMPGE TT,.+2
	SUBI T,1
	CAMGE T,XCNT
	JRST CASE1A
	CAMG T,XCNT
	JUMPE TT,CASE1A
>
IFLE %STEP-1,<
	CAMG T,XCNT
	JRST CASE1A
>
	IBP TTT
	AOS XCNT
CASE1A:	JUMPE G,CASE1J
	LDB F,TTT
	JUMPG G,CASE1I
	JUMPN F,CPOPJ
	JRST CASE1K
CASE1I:	CAMGE F,G
CASE1J:	DPB G,TTT
CASE1K:	MOVE T,TTT
IFG %STEP-2,<
REPEAT %STEP-2,<
	ILDB F,T
	JUMPGE G,.+3
	JUMPN F,CPOPJ
	JRST .+4
	JUMPE G,.+2
	CAMGE F,G
	DPB G,T
>
>
IFLE %STEP-1,<
	JUMPE TT,CASE1B
>
IFG %STEP-1,<
	JUMPN TT,CASE1B
>
	ILDB F,T
	JUMPGE G,.+3
	JUMPN G,CPOPJ
	JRST CASE1B
	JUMPE G,.+2
	CAMGE F,G
	DPB G,T
CASE1B:	AOS T,YCNT
	SUBI T,%STEP/2
	CAMLE T,DY
	JRST CPOPJ1
	ADDI T,%STEP/2
	ADD TTT,E
	JRST CASE1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       CASE2:	IMUL T,DY
	IDIV T,DX
IFG %STEP-1,<
	JUMPGE TT,.+2
	SUBI T,1
	CAMGE T,YCNT
	JRST CASE2A
	CAMG T,YCNT
	JUMPE TT,CASE2A
>
IFLE %STEP-1,<
	CAMG T,YCNT
	JRST CASE2A
>
	AOS YCNT
	ADD TTT,E
CASE2A:	JUMPE G,CASE2J
	LDB F,TTT
	JUMPG G,CASE2I
	JUMPN F,CPOPJ
	JRST CASE2K
CASE2I:	CAMGE F,G
CASE2J:	DPB G,TTT
CASE2K:	MOVE T,TTT
IFG %STEP-2,<
REPEAT %STEP-2,<
	ADD T,E
	LDB F,T
	JUMPGE G,.+3
	JUMPN F,CPOPJ
	JRST .+4
	JUMPE G,.+2
	CAMGE F,G
	DPB G,T
>
>
IFLE %STEP-1,<
	JUMPE TT,CASE2B
>
IFG %STEP-1,<
	JUMPN TT,CASE2B
>
	ADD T,E
	JUMPE G,CASE2L
	LDB F,T
	JUMPG G,.+3
	JUMPN F,CPOPJ
	JRST CASE2B
	CAMGE F,G
CASE2L:	DPB G,T
CASE2B:	AOS T,XCNT
	SUBI T,%STEP/2
	CAMLE T,DX
	JRST CPOPJ1
	ADDI T,%STEP/2
	IBP TTT
	JRST CASE2

RSET1:	PUSHJ P,GETCLS
	JRST PERRET
	CAMN A,RCL2
	JRST PERRET
	MOVEM A,RCL1
	TRO MCHG
	POPJ P,

RSET2:	PUSHJ P,GETCLS
	JRST PERRET
	CAMN A,RCL1
	JRST PERRET
	MOVEM A,RCL2
	TRO MCHG
	POPJ P,
                                                                                                                                                                                                                                                                                                              ;HERE WE TRY TO ACTUALLY ROUTE A WIRE
DOROUTE:
	TLNN M,%ROUTE
	PUSHJ P,BITINI		;INTIALIZE FOR HIM!
	SKIPE B,RLIST
	PUSHJ P,PUTFS
	SETZM RLIST
	SKIPE D,RCL1
	SKIPN E,RCL2
	JRST PERRET
	MOVE T,1(D)
	CAMLE T,1(E)
	EXCH E,D
	MOVE F,RCODE		;SET UP ROUTING CODE
	HLRZ A,(E)
	HRRZ A,1(A)
	MOVE A,1(A)
	TLNE A,FEEDTH!ISPIN	;IS THIS POINT ONLY ON ONE SIDE?
	JRST REACHB		;NO.
	XCT STAB1(F)		;YES, ARE WE ROUTING ON THAT SIDE?
	JRST NTROUTE		;NO, LOSE
REACHB:	MOVE T,1(E)		;X2,Y2
	HRREM T,Y2
	HLREM T,X2
	PUSHJ P,BITBYA
	JRST NTROUTE
	MOVEM TTT,ENDBYT
	TLNE A,FEEDTH!ISPIN	;CAN WE END ON EITHER SIDE?
	XCT STAB2(F)		;YES, COMPUTE OTHER SIDE POINTER
	MOVEM TTT,ENDBY2	;THIS IS ANOTHER WINNING BYTE POINTER
	MOVE TTT,ENDBYT		;GET RIGHT ONE BACK
	HLRZ A,(D)
	HRRZ A,1(A)
	MOVE A,1(A)
	TLNE A,FEEDTH!ISPIN
	JRST REACHC
	XCT STAB1(F)
	JRST NTROUTE
REACHC:	MOVE T,1(D)
	HRREM T,Y1
	HLREM T,X1
	MOVE B,T
	PUSHJ P,BITBYA
	JRST NTROUTE
	MOVE T,Y1
	SUB T,Y2
	MOVEI TT,0
	JUMPL T,.+2
	MOVEI TT,1
	MOVEM TT,ROUIDX		;SAVE AS ROUTING INDEX
	TRZ TFLG		;MAGIC FLAG FOR SKIP RETURN
	SETZB G,RTCNT		;CLEAR COUNTS
NXTG1:	OUTSTR[ASCIZ/TRYING /]
	MOVE T,G
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	PUSHJ P,RBEGIN
	JRST RWIN		;WIN BIG
	TRZE TFLG		;ADVANCING ONE OR LEAVING?
	CAIA
	JRST NOROU1		;LEAVING
	AOS G,RTCNT
	JRST NXTG1

NTROUTE:OUTSTR[ASCIZ/NO ROUTING POSSIBLE!
/]
NOROU1:	TRO NEEDCL		;GET IT ON (BIGPG)
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   RWIN:	MOVEM SID,SIDSAV		;GET REAL SID FROM STORAGE
	XCT (F)[TLNE SID,FRONT
		TLNN SID,FRONT
		JFCL
		JFCL]
	JRST MAKRT
	SWITCH
MAKRT:	MOVE A,RLIST
	JRST MAKRT1
MAKRT2:	MOVE T,1(A)
	TLNE SID,FRONT
	TRC T,1
	TRNN T,1
	JRST RTSID
	SWITCH
RTSID:	MOVE T,1(A)
	XOR T,1(B)
	CAIN T,1
	JRST MAKFED
	PUSH P,B
	PUSH P,A
	MOVE E,1(A)
	MOVE F,1(B)
	MOVEI G,1
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/LINE EXCEEDS ARRAY BOUNDS!
/]
	POP P,A
	MOVE TTT,1(A)
	TDZ TTT,[1,,1]
	PUSHJ P,FIND.P
	PUSH P,D
	PUSH P,TTT
	MOVE TTT,1(B)
	TDZ TTT,[1,,1]
	PUSHJ P,FIND.P
	POP P,T
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	MOVE T,TTT
	POP P,D
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	POP P,A
MAKRT1:	HRRZ B,(A)
	JUMPN B,MAKRT2
	TRO MCHG
	TLO M,%ROUTE		;PUTPNT CLEARED THIS!
NOTYET:	SKIPE B,RLIST		;FOR NOW JUST GIVE BACK THE ROUTE
	PUSHJ P,PUTFS
	SETZM RLIST
	MOVE T,SIDSAV
	EQV T,SID
	JUMPL T,CPOPJ		;ON RIGHT SIDE ALREADY?
	SWITCH			;NO, GET THERE
	POPJ P,
                                                                                                                                                                                                                                                                                                                                      MAKFED:	PUSH P,B
	PUSH P,E
	MOVE TTT,1(A)
	TDZ TTT,[1,,1]
	PUSHJ P,FIND.P
	MOVE G,D
	PUSHJ P,RDFEED
	JRST CANTFD
	PUSH P,SID
	MOVE G,D
	TLZ SID,FRONT
	MOVE T,1(G)
	PUSHJ P,BITBYT
	JRST NOTINA
	MOVEI T,2
	DPB T,TTT
	ADDI TTT,ARRAYB-ARRAYA
	DPB T,TTT
NOTINA:	POP P,SID
CANTFD:	POP P,E
	POP P,A
	JRST MAKRT1
                                                                                                                                                                                                                                                                                                                        STKN__6			;NUMBER OF THINGS PUSHED ON STACK IN RECURSIVE ROUTINES

%LIMIT__%SEPAR*4	;LIMIT SIZE OF SEARCH BOX!


RBEGIN:	HRRZM P,PSAV
	PUSH P,G
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	SETZM DX		;USE THIS AS COUNTER FOR WHEN TO TRY INCHRS
	ADD G,.CNR		;COMPENSATE FOR ROUTINES THINKING THIS IS A CORNER
	MOVEI H,XPNF		;ASSUME THIS
	XCT (F)[JRST XRLOC
		JRST XRLOC
		TLNN A,FEEDTH!ISPIN
		TLNN A,FEEDTH!ISPIN]
	JRST XRLOC
	MOVEI H,XR0
	JRST XRLOC

PVB:	XCT VTAB(F)
PVB1:	MOVE C,.CNR
	MOVEI H,XPV
	JRST PVAB

PVA:	XCT VTAB(F)
PVA1:	MOVE C,.CNR
	MOVEI H,XPVA
PVAB:	ADD C,.BAK
	JRST PVI

PV:	XCT VTAB(F)
PV1:	MOVE C,.CNR
	MOVEI H,XPV
PVI:	PUSH P,G
	SUB G,C		;DO WEIGHTING
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HRRE T,B
	MOVE TT,ROUIDX
	SUB T,(TT)[%LIMIT
		 -%LIMIT]
	XCT (TT)[CAMLE T,Y2
		CAMGE T,Y2]
	JRST SKIP2A
	ADD TTT,(TT)[%ROW
		   -%ROW]
	ADD B,(TT)[%SEPAR
		0,,-%SEPAR]
	TLZ B,1
	JRST XLOCA	;ENTER MAIN LOOP
                                                                                                                                                                                                                                                                                                                      NVB:	XCT VTAB(F)
NVB1:	MOVE C,.CNR
	MOVEI H,XNV
	JRST NVAB

NVA:	XCT VTAB(F)
NVA1:	MOVE C,.CNR
	MOVEI H,XNVA
NVAB:	ADD C,.BAK
	JRST NVI

NV:	XCT VTAB(F)
NV1:	MOVE C,.CNR
	MOVEI H,XNV
NVI:	PUSH P,G
	SUB G,C
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HRRE T,B
	MOVE TT,ROUIDX
	ADD T,(TT)[%LIMIT
		 -%LIMIT]
	XCT (TT)[CAMGE T,Y1
		CAMLE T,Y1]
	JRST SKIP2A
	ADD TTT,(TT)[-%ROW
		     %ROW]
	ADD B,(TT)[0,,-%SEPAR
		  %SEPAR	]
	TLZ B,1
	JRST XLOCA
                                                                                                                                                             PHB:	XCT HTAB(F)
PHB1:	MOVE C,.CNR
	MOVEI H,XPH
	JRST PHAB

PHA:	XCT HTAB(F)
PHA1:	MOVE C,.CNR
	MOVEI H,XPHA
PHAB:	ADD C,.BAK
	JRST PHI

PH:	XCT HTAB(F)
PH1:	MOVE C,.CNR
	MOVEI H,XPH
PHI:	PUSH P,G
	SUB G,C
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HLRE T,B
	SUBI T,%LIMIT
	CAMLE T,X2
	JRST SKIP2A
	IBP TTT
	ADD B,[%SEPAR,,0]
	JRST XLOCA
                                                                                                                                                                                                                                                                            NHB:	XCT HTAB(F)
NHB1:	MOVE C,.CNR
	MOVEI H,XNH
	JRST NHAB

NHA:	XCT HTAB(F)
NHA1:	MOVE C,.CNR
	MOVEI H,XNHA
NHAB:	ADD C,.BAK
	JRST NHI

NH:	XCT HTAB(F)
NH1:	MOVE C,.CNR
	MOVEI H,XNH
NHI:	PUSH P,G
	SUB G,C
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HLRE T,B
	ADDI T,%LIMIT
	CAMGE T,X1
	JRST SKIP2A
	PUSHJ P,DBP
	ADD B,[-%SEPAR,,0]
	JRST XLOCA
                                                                                                                                                                                                                                                                       PNF:	XCT FTAB(F)
	MOVEI H,XPNF
	PUSH P,G
	SUB G,.FED
	JUMPL G,GPOPJ2
	ADD G,.CNR		;ACCOUNT FOR IMPLIED CORNER COMING UP
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	PUSHJ P,DBP
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	IBP TTT
	ILDB T,TTT
	CAIL T,3
	JRST SKIP2A
	MOVE TTT,-2(P)
	ADDI TTT,%ROW
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	SUBI TTT,%ROW*2
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	PUSHJ P,OBYT	;GET TO OTHER SIDE
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	ADDI TTT,%ROW*2
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	SUBI TTT,%ROW
	PUSHJ P,DBP
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	IBP TTT
	ILDB T,TTT
	CAIL T,3
	JRST SKIP2A
	PUSHJ P,DBP	;GET REAL BYTE POINTER
	TLC A,FRONT
XLOCA:	CAME TTT,ENDBYT	;AT ENDPOINT?
	CAMN TTT,ENDBY2		;EITHER OF THEM?
	JRST PWIN		;YES
	LDB T,TTT
	JUMPN T,SKIP2A
	MOVEI T,1
	DPB T,TTT
DEBUG:	JRST ENDBUG
	MOVEI T,-2(P)
	MOVEM T,STARLOC
	MOVEI T,UPROUTE
	MOVEM T,SPDISP
	MOVE T,[ASCIZ/RD/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/_____
/]
	PUSHJ P,GETCHR
	PUSHJ P,RCHNGM
ENDBUG:
XRLOC:	PUSHJ P,HJUST
	HRLI H,(<POINT 5,0>)	;MAKE IT INTO A BYTE POINTER
	PUSH P,H		;SAVE BYTE POINTER
XLOC:	ILDB H,(P)		;GET INDEX
	XCT XCTAB(H)		;AND CALL ROUTINE
	JRST WIN
	JRST SKIP1
	JRST XLOC
   LOSE:	MOVEI T,0
	CAME TTT,-3(P)			;CROCKISH WAY TO TELL IF THIS IS THE GUY
					;WE SHOULDN'T CLOBBER!!!!!! ARRG****
	DPB T,TTT
	POP P,(P)
SKIP2A:	POP P,A
	POP P,B
	POP P,TTT
GPOPJ2:	POP P,G
	SOSL DX		;TIME TO CHECK YET?
	JRST CPOPJ2	;NO
	MOVEI T,20	;WAIT A WHILE
	MOVEM T,DX
	INCHRS T	;LET HIM OUT HERE IF NECESSARY!!!
	JRST CPOPJ2
	OUTSTR[ASCIZ/_____
/]
	CAIN T,ALTMOD	;ONLY ALTMODE WILL WORK!
	JRST CPOPJ1	;YES, SINGLE SKIP RETURN
	TRZE T,600	;MUST HAVE CTRL BITS!
	CAIE T," "	;**SPACE WILL GO TO NEW COUNT
	CAIA
	TROA TFLG
	AOS (P)
	JRST CPOPJ1

SKIP1:	MOVEI T,0
	DPB T,TTT
	POP P,(P)
SKIP1A:	POP P,A
	POP P,B
	POP P,TTT
	POP P,G
	JRST CPOPJ1

WIN:	TRZ B,1
	TLNE A,FRONT
	TRO B,1
	SKIPN T,RLIST
	JRST NOLIST
	HRRZ H,(T)
	JUMPE H,NOLIST
	MOVE TT,B
	XOR TT,1(T)
	CAIN TT,1
	JRST NOLIST
	MOVE TT,1(H)
	XOR TT,B
	TRNN TT,1
	TLNE TT,-1
	TRNN TT,-1
	JRST [	MOVEM B,1(T)
		JRST ISLIST]
NOLIST:	GETFS(TT)
	HRRZM T,(TT)
	HRRZM TT,RLIST
	MOVEM B,1(TT)
ISLIST:	MOVEI T,0
	DPB T,TTT
	POP P,(P)
	POP P,A
	POP P,B
	POP P,TTT
	POP P,G
	POPJ P,
                                                                                                                                                                                     SDIF__ARRAYB-ARRAYA

HJUST:	HLRE T,B
	CAML T,X2
	ADDI H,2
	CAMLE T,X2
	ADDI H,2
	HRRE T,B
	MOVE TT,ROUIDX
	XCT (TT)[CAML T,Y2
		CAMG T,Y2]
	ADDI H,6
	XCT (TT)[CAMLE T,Y2
		CAMGE T,Y2]
	ADDI H,6
	POPJ P,

OBYTA:	PUSHJ P,OBYT
	TLC A,FRONT
	JRST CPOPJ2

OBYT:	TLNN A,FRONT
	ADDI TTT,SDIF*2
	SUBI TTT,SDIF
	POPJ P,

STAB1:	TLNN A,FRONT
	TLNE A,FRONT
	CAIA
	CAIA

STAB2:	JFCL
	JFCL
	PUSHJ P,OBYT
	PUSHJ P,OBYT

VTAB:	SKIPA C,[0]
	SKIPA C,[0]
	PUSHJ P,BACKTB
	PUSHJ P,FRNTTB

HTAB:	SKIPA C,[0]
	SKIPA C,[0]
	PUSHJ P,FRNTTB
	PUSHJ P,BACKTB

BACKTB:	TLNN A,FRONT
	TDZA C,C
	MOVEI C,%SID
	JRST CPOPJ1

FRNTTB:	TLNE A,FRONT
	TDZA C,C
	MOVEI C,%SID
	JRST CPOPJ1

FTAB:	JRST CPOPJ2
	JRST CPOPJ2
	JFCL
	JFCL

XCTAB:	JRST LOSE
	PUSHJ P,PV
	PUSHJ P,NV
	PUSHJ P,PH
	PUSHJ P,NH
	PUSHJ P,PV1
	PUSHJ P,NV1
	PUSHJ P,PH1
	PUSHJ P,NH1
	PUSHJ P,PVA
	PUSHJ P,NVA
	PUSHJ P,PHA
	PUSHJ P,NHA
	PUSHJ P,PVA1
	PUSHJ P,NVA1
	PUSHJ P,PHA1
	PUSHJ P,NHA1
	PUSHJ P,PVB
	PUSHJ P,NVB
	PUSHJ P,PHB
	PUSHJ P,NHB
	PUSHJ P,PVB1
	PUSHJ P,NVB1
	PUSHJ P,PHB1
	PUSHJ P,NHB1
	PUSHJ P,PNF
	PUSHJ P,OBYTA
                                                                                                                                      %__0		;SO BLANK CONCATINATED WITH % IS 0.
%PV__1
%NV__2
%PH__3
%NH__4
%PV1__5
%NV1__6
%PH1__7
%NH1__10
%PVA__11
%NVA__12
%PHA__13
%NHA__14
%PVA1__15
%NVA1__16
%PHA1__17
%NHA1__20
%PVB__21
%NVB__22
%PHB__23
%NHB__24
%PVB1__25
%NVB1__26
%PHB1__27
%NHB1__30
%PNF__31
%OBYTA__32

DEFINE XD $ (A,B,C,D,E,F,G,H,I,J,K,L,M)
<	BYTE (5)%$A,%$B,%$C,%$D,%$E,%$F,%$G,%$H,%$I,%$J,%$K,%$L,%$M,0
>

XR0:	XD	PV1,PH1,NVA1,NHA1,OBYTA,PV1,PH1,NVB1,NHB1,OBYTA,NVB1,NHB1
	XD	PV1,NHA1,PHA1,NVA1,OBYTA,PV1,NHB1,PHB1,NVB1,OBYTA,NHB1,PHB1,NVB1
	XD	PV1,NH1,PHA1,NVA1,OBYTA,PV1,NH1,PHB1,NVB1,OBYTA,PHB1,NVB1
	XD	PH1,NVA1,PVA1,NHA1,OBYTA,PH1,NVB1,PVB1,NHB1,OBYTA,NVB1,PVB1,NHB1
	0
	XD	NH1,PVA1,NVA1,PHA1,OBYTA,NH1,PVB1,NVB1,PHB1,OBYTA,PVB1,NVB1,PHB1
	XD	NV1,PH1,NHA1,PVA1,OBYTA,NV1,PH1,NHB1,PVB1,OBYTA,NHB1,PVB1
	XD	NV1,PHA1,NHA1,PVA1,OBYTA,NV1,PHB1,NHB1,PVB1,OBYTA,PHB1,NHB1,PVB1
	XD	NV1,NH1,PVA1,PHA1,OBYTA,NV1,NH1,PVB1,PHB1,OBYTA,PVB1,PHB1

XPNF:	XD	PV1,PH1,PNF,NVB1,NHB1
	XD	PV1,PNF,NHB1,PHB1,NVB1
	XD	PV1,NH1,PNF,PHB1,NVB1
	XD	PH1,PNF,NVB1,PVB1,NHB1
	XD	PNF
	XD	NH1,PNF,PVB1,NVB1,PHB1
	XD	NV1,PH1,PNF,NHB1,PVB1
	XD	NV1,PNF,PHB1,NHB1,PVB1
	XD	NV1,NH1,PNF,PVB1,PHB1

XPV:	XD	PV,PH1,NHA1,PNF,NHB1
	XD	PV,PHA1,NHA1,PNF,PHB1,NHB1
	XD	NH1,PV,PHA1,PNF,PHB1
	XD	PH1,PVA,NHA1,PNF,PVB,NHB1
	XD	PNF
	XD	NH1,PVA,PHA1,PNF,PVB,PHB1
	XD	PH1,PVA,NHA1,PNF,PVB,NHB1
	XD	PHA1,NHA1,PVA,PNF,PHB1,NHB1,PVB
	XD	NH1,PVA,PHA1,PNF,PVB,PHB1

XPVA:	XD	PVA,PHA1,NHA1
	XD	PVA,PHA1,NHA1
	XD	NHA1,PVA,PHA1
	XD	PHA1,PVA,NHA1
	XD	PNF
	XD	NHA1,PVA,PHA1
	XD	PHA1,PVA,NHA1
	XD	PHA1,PVA,NHA1
	XD	NHA1,PVA,PHA1
                                                                                                                                                                                                                                                                                                            XNV:	XD	PH1,NVA,NHA1,PNF,NVB,NHB1
	XD	PHA1,NHA1,NVA,PNF,PHB1,NHB1,NVB
	XD	NH1,NVA,PHA1,PNF,NVB,PHB1
	XD	PH1,NVA,NHA1,PNF,NVB,NHB1
	XD	PNF
	XD	NH1,NVA,PHA1,PNF,NVB,PHB1
	XD	NV,PH1,NHA1,PNF,NHB1
	XD	NV,PHA1,NHA1,PNF,PHB1,NHB1
	XD	NV,NH1,PHA1,PNF,PHB1

XNVA:	XD	PHA1,NVA,NHA1
	XD	PHA1,NVA,NHA1
	XD	NHA1,PHA1,NVA
	XD	PHA1,NVA,PHA1
	XD	PNF
	XD	NHA1,NVA,PHA1
	XD	NVA,PHA1,NHA1
	XD	NVA,NHA1,PHA1
	XD	NVA,NHA1,PHA1

XPH:	XD	PH,PV1,NVA1,PNF,NVB1
	XD	PV1,PHA,NVA1,PNF,PHB,NVB1
	XD	PV1,PHA,NVA1,PNF,PHB,NVB1
	XD	PH,PVA1,NVA1,PNF,PVB1,NVB1
	XD	PNF
	XD	PVA1,NVA1,PHA,PNF,PVB1,NVB1,PHB
	XD	PH,NV1,PVA1,PNF,PVB1
	XD	NV1,PHA,PVA1,PNF,PHB,PVB1
	XD	NV1,PHA,PVA1,PNF,PHB,PVB1

XPHA:	XD	PHA,PVA1,NVA1
	XD	PVA1,PHA,NVA1
	XD	PVA1,PHA,NVA1
	XD	PHA,NVA1,PVA1
	XD	PNF
	XD	PVA1,PHA,NVA1
	XD	PHA,NVA1,PVA1
	XD	NVA1,PHA,PVA1
	XD	NVA1,PHA,PVA1

XNH:	XD	PV1,NHA,NVA1,PNF,NHB,NVB1
	XD	PV1,NVA1,NHA,PNF,NVB1,NHB
	XD	NH,PV1,NVA1,PNF,NVB1
	XD	PVA1,NVA1,NHA,PNF,PVB1,NVB1,NHB
	XD	PNF
	XD	NH,NVA1,PVA1,PNF,NVB1,PVB1
	XD	NV1,PVA1,NHA,PNF,PVB1,NHB
	XD	NV1,PVA1,NHA,PNF,PVB1,NHB
	XD	NH,NV1,PVA1,PNF,PVB1

XNHA:	XD	PVA1,NHA,NVA1
	XD	PVA1,NHA,NVA1
	XD	PVA1,NHA,NVA1
	XD	PVA1,NHA,NVA1
	XD	PNF
	XD	NHA,PVA1,NVA1
	XD	NVA1,PVA1,NHA
	XD	NVA1,NHA,PVA1
	XD	NHA,NVA1,PVA1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             PWIN:	JUMPG G,SKIP2A		;COUNT MUST BE EXACT!
	MOVEI T,-1(P)		;GET POINTER TO OUR STACK
	MOVEM T,STARLOC		;PASS AS DATUM
	MOVEI T,UPROUTE
	MOVEM T,SPDISP
	MOVE T,[ASCIZ/R/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/HOW ABOUT THIS ONE?/]
	PUSHJ P,GETCHR
	PUSHJ P,RCHNGM		;RETURN TO OLD MODE
	CAIN C,ALTMOD		;ALTMODE?
	JRST SKIP1A		;YES, GET OUT OF HERE
	CAIE C,"Y"
	CAIN C,"y"
	JRST [	PUSH P,(P)	;HE EXPECTS SOMETHING ON THE STACK
		JRST WIN]
	TRZE C,600
	CAIE C,40		;CTRL SPACE?
	JRST SKIP2A		;TRY ANOTHER ROUTE
	TRO TFLG		;FLAG TO SKIP TO NEXT # OF CORNERS
	JRST SKIP1A
       ;ROUTER DISPLAY
UPROUTER:
	PUSHJ P,SPSETUP
	MOVE D,STARLOC		;GET POINTER TO NEXT X,Y BACK UP STACK
	MOVE T,B
	PUSHJ P,AIVECT		;START HERE
	MOVE T,B
	MOVE E,A		;SIDE OF LAST POINT PLOTTED
	JRST PLOP1		;ENTER LOOP

PLOP:	MOVE TT,T		;LAST POINT WE DREW
	XOR TT,(D)
	TDZ TT,[1,,1]
	TLNE TT,-1		;SAME X
	TRNN TT,-1		;OR Y
	CAIA			;WELL, SAME POS.
	JRST PLOTIT
	MOVE TT,E
	XOR TT,1(D)		;STILL ON SAME SIDE?
	JUMPGE TT,PLOP1		;YES, SKIP IT
PLOTIT:	MOVEI T,7		;ASSUME ON CURRENT SIDE
	MOVE TT,STKN+1(D)	;GET WHAT SIDE HE'S ON
	EQV TT,SID		;IS HE ON BRIGHT SIDE?
	JUMPL TT,.+2		;YES
	MOVE T,DEFBRT		;NO
	PUSHJ P,DPYBRT
	MOVE T,B		;GET LAST POINT STILL IN LINE
	PUSHJ P,AVECT		;PLOT IT
	MOVE T,B
	MOVE E,STKN+1(D)
PLOP1:	MOVE B,(D)		;GET NEXT X,Y FROM STACK
	SUBI D,STKN		;BACK UP STACK
	CAMLE D,PSAV		;OFF TOP?
	JRST PLOP		;NO, CONTINUE CHECK
	MOVE T,BTHBRT		;ASSUME ON CURRENT SIDE
	MOVE TT,STKN+1(D)	;GET WHAT SIDE HE'S ON
	EQV TT,SID		;IS HE ON BRIGHT SIDE?
	JUMPL TT,.+2		;YES
	MOVE T,DEFBRT		;NO
	PUSHJ P,DPYBRT
	MOVE T,B
	PUSHJ P,AVECT		;PLOT LAST POINT
	JRST BLINKO		;DISPLAY IT
                                                                                                                                                               ;BITBYA, BITBYT
BITBYA:	PUSH P,SID
	MOVE SID,A
	PUSHJ P,BITBYT
	CAIA
	AOS -1(P)
	POP P,SID
	POPJ P,

BITBYT:	ADJUST(ADD,T,<[%XCEN,,%YCEN]>)	;MAKE IT ALL POS.
	TDNE T,[400000,,400000]
	POPJ P,
	HRRZ TT,T
	HLRZ T,T
	CAIG T,%XSIZ
	CAILE TT,%YSIZ
	POPJ P,
	IDIVI TT,%GRAIN
	MOVE TTT,TT
	IMULI TTT,%ROW		;GET INDEX TO BEGGINING OF ROW
	IDIVI T,%GRAIN
	IDIVI T,=36/BYTSIZ
	ADD TTT,T
	IMULI TT,BYTSIZ		;LOW ORDER BIT OF BYTE + 1 - BYTSIZ
	SUBI TT,=36-BYTSIZ
	MOVN TT,TT
	LSH TT,=12
	TRO TT,BYTSIZ6
	HRL TTT,TT
	ADDI TTT,ARRAYA
	JUMPGE SID,CPOPJ1
	ADDI TTT,ARRAYB-ARRAYA
	JRST CPOPJ1

;DECREMENT BYTE POINTER IN TTT.
DBP:	ADD TTT,[BYTE (6)BYTSIZ]
	JUMPGE TTT,CPOPJ
	TLNE TTT,40000
	SUB TTT,[440000,,1]
	POPJ P,
>;ROUTE
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       COMMENT    VALID 00023 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	VERSION(MAC,4)
C00009 00003	GETCAN:	SKIPE LCFLAG		CONVERT LC TO UC?
C00014 00004	"D"
C00016 00005	"F"
C00019 00006	SEMI COLON DISPATCH	RENMAC	DELMAC	PMACRO
C00026 00007	"P" "V"
C00031 00008	":" "R" "S"
C00036 00009	"M" "C" , STUFF SUBRS
C00044 00010	"U" "T" "L" "^" "A" "N" "#" "="
C00050 00011	"E" "X" "O" "I"
C00055 00012	MACRO MAKERS
C00057 00013	READ/WRITE MACRO FILES
C00064 00014	HERE TO DEFINE A NEW (OR REDEFINE AN OLD) VARIABLE
C00067 00015	VARFND:	MOVEI	E,VARPNT	SEARCH VARIABLE LIST FOR A NAME
C00070 00016	VARNM:	GETFS	(B)		READ ONE VARIABLE NAME
C00072 00017	HERE TO TYPE THE VALUES OF ALL VARIABLES
C00075 00018	VARNX8:	SKIPL	(C)		ALPHABETIC VARIABLE?
C00077 00019	VARN17:	JUMPGE	T,VARN19	NEGATIVE?
C00079 00020	VARNX2:	PUSHJ	P,VARNUM	GET INCREMENT
C00082 00021	VARN14:	JUMPL	G,[CAMG T,TTT	ARGS IN RIGHT ORDER FOR NEG INCREMENT?
C00084 00022	VARN30:	AOS	D		STEP TO NEXT CHR
C00087 00023	
C00088 ENDMK
C;
                                                                                                                                                                                                                                                            VERSION(MAC,4)
CHARIN:	MOVE P,CHARP
	MOVEM C,CHARP
	TIMER C,
	MOVEM C,BOOPLR
	PUSHJ P,POPIT
	MOVE C,CHARP		;RETURN CHAR IN C
	POPJ P,

GREADY:	PUSHJ P,READY
	MOVEM 0,SAVER0
	MOVEM M,SAVERM
	SKIPN BOOPCN
	POPJ P,
	PUSH P,T
	TIMER T,
	SUB T,BOOPLR
	ADDM T,BOOPLR
	IDIVI T,=60
	CAMGE T,BOOPCN
	JRST GRDY1
	PUSH P,[3]
	SKIPA T,[1]
GRDY2:	SLEEP T,
	OUTCHR[7]
	SOSL (P)
	JRST GRDY2
	POP P,(P)
GRDY1:	POP P,T
	POPJ P,

GDP,<
XCHRIN:	EXCH C,CHKSVC		;SAVE CHAR AND GET BACK C
	PUSHJ P,PUSHIT		;SAVE THE REGISTERS
	SUBM P,P-17(P)		;MAKE THE SAVED P RELATIVE
GDP,<	JSP TT,INATYO		;SAVE THE CURRENT POG INFO IN THE GDP2
	SAVPOG
	PASREGS
	PUSHJ P,DOATYO
	PUSH P,IIIX		;SAVE THE PDP-10 INFO TOO!
	PUSH P,IIIY
	PUSH P,IIIBRT
	PUSH P,CHRSCL
	PUSH P,PGLASS
>;GDP
	MOVE T,P
	MOVE P,CHARP		;POP THE STACK
	SUB T,P			;FIGURE OUT HOW MUCH WE POPPED
	CAMLE T,[PSVLEN,,PSVLEN]	;SEE IF IT'S TOO MUCH
	JRST [	OUTSTR [ASCIZ/INTERNAL ERROR: PSVLEN IS TOO SMALL FOR SAVING THE PDL IN ROUTINE XCHRIN
/]
		HALT . ]
	MOVEM T,PSVCNT
	HRLZI TT,1(P)
	HRRI TT,PDLSAV
	BLT TT,PDLSAV-1(T)	;SAVE THE STUFF ON THE STACK
	PUSHJ P,POPIT
	JSP C,[	EXCH C,DSPDSP
		MOVEM C,C
		MOVE C,CHKSVC
		POPJ P, ]	;AND RETURN TO THE CALLER OF THE DISPLAY ROUTINES.
;WE GET HERE (@DSPDSP) WHEN WE DECIDE TO CONTINUE BECAUSE MCHG=0.
	MOVE P,CHARP		;RESTORE THE PDL
	HRLZI TT,PDLSAV
	HRRI TT,1(P)
	ADD P,PSVCNT		;BUMP THE PDL POINTER
	BLT TT,(P)		;RESTORE THE CONTENTS
GDP,<	JSP TT,INATYO		;RESTORE THE CURRENT POG INFO IN THE GDP2
	RSTPOG
	PASREGS
	PUSHJ P,DOATYO
	POP P,PGLASS		;RESTORE THE PDP-10 INFO ABOUT THE POG.
	POP P,CHRSCL
	POP P,IIIBRT
	POP P,IIIY
	POP P,IIIX
>;GDP
	SUBM P,P-17(P)		;RE ABSOLUTIZE THE SAVED P
	PUSHJ P,POPIT
	POPJ P,
>;GDP

MACDSP:	TLNN DSPACT		;DISPLAYING?
	JRST CPOPJ1		;NO, SAY WE'RE DONE
	MOVEM C,CINST		;STORE INSTRUCTION TO GET CHAR
	PUSHJ P,PUSHIT
	MOVEM P,CHARP
	CHECKIN
	PUSHJ P,GETCLS		;UPDATE IT BEFORE DISPLAYING IT
	JFCL
	PUSHJ P,UPCLOS
	PUSHJ P,PMODE
	PUSHJ P,UPSCAL
	PUSHJ P,UPLVL
	PUSHJ P,UPCURS
	PUSHJ P,DOSLPB
	CHECKIN
	PUSHJ P,DISP
NOGDP,<	PUSHJ P,DOPOGS	>	;HIDE ANY REQUESTED POGS
	PUSHJ P,POPIT
	JRST CPOPJ1

GETLET:	PUSHJ P,GETLIN
	CAIL C,"a"
	CAILE C,"z"
	CAIA
	SUBI C,40
	CAIL C,"A"
	CAILE C,"Z"
	POPJ P,
	JRST CPOPJ1

GETLCH:	PUSHJ P,GETLIN
	CAIL C,"A"+40
	CAILE C,"Z"+40
	POPJ P,
	SUBI C,40
	POPJ P,

YORN:	TLNN M,DSKACT!MACACT
	OUTCHR["?"]
	PUSHJ P,GETCH
	JRST YORN
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
/]
	CAIN C,ALTMOD
	POPJ P,
	AOS (P)
	CAIE C,"Y"
	CAIN C,"y"
	AOS (P)
	POPJ P,

GETLI1:	TLNN M,DSKACT!MACACT
NODEC,<	OUTSTR[ASCIZ/
/]
>;NODEC
DEC,<	OUTSTR[ASCIZ/
^/]
>;DEC
GETLIN:	PUSHJ P,GETLN
	JRST GETLI1
	POPJ P,

GETCHM:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
*/]
	PUSHJ P,GETCH
	JRST GETCHM
	POPJ P,

GETCHR:	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ /
_/]
	PUSHJ P,GETCH
	JRST GETCHR
	POPJ P,

GETLN:	SETZM BITS
	SKIPE C,INPNT
	JRST GETMAC	;GETTING INPUT INTERNALLY
	TLNE M,DSKACT
	JRST [	PUSHJ P,DSKCHR
		POPJ P,
		JRST GETCAN]
GETLP2:	MOVE C,[INCHSL C]
	PUSHJ P,MACDSP
	JRST GOTCL
	PUSHJ P,GREADY
	INCHWL C
	PUSH P,T
	TIMER T,
	MOVEM T,BOOPLR
	POP P,T
	PUSHJ P,NREADY
GOTCL:
CMU,<			;I'M NOT SURE EVERYONE WANTS THIS, THOUGH THEY PROBABLY DO
	CAIN C,177	;IGNORE SPURIOUS RUBOUTS IN LINE MODE!
	JRST GETLP2
>;CMU
	JRST GETCAN


GETCH:	SKIPE C,INPNT	;GETTING INPUT INTERNALLY?
	JRST GETMAC	;YES
ZERBTS:	SETZM BITS
GETLP1:	TLNE M,DSKACT
	JRST [	PUSHJ P,DSKCHR
		POPJ P,
		JRST GETCAN]
	MOVE C,[INCHRS C]
	PUSHJ P,MACDSP
	JRST GETCAN
	PUSHJ P,GREADY
	INCHRW C
	PUSH P,T
	TIMER T,
	MOVEM T,BOOPLR
	POP P,T
	PUSHJ P,NREADY
                                                                                                                         GETCAN:	SKIPE LCFLAG		;CONVERT LC TO UC?
	JRST NOLCCN		;NO
	CAIL C,"a"
	CAILE C,"z"
	CAIA
	SUBI C,40
NOLCCN:
DEC,<	CAIE C,33
	CAIN C,175
	JRST ALTXFN
	CAIN A,176
	JRST [
	ALTXFN:	MOVEI C,200
		ADDB C,BITS
		TRNN C,1000	;OVERFLOW?
		JRST GETLP1	;NO
		MOVEI C,ALTMOD
		SETZM BITS
		JRST .+1]
	CAIN C,177		;BS?
	JRST [	SKIPN BITS	;ONLY IF BITS TYPED, SO LOSER CAN TYPE BS
		JRST .+1
		TLNN M,DSKACT!MACACT
		OUTSTR[ASCIZ/XXX /]
		JRST ZERBTS]
>;DEC
NODEC,<
	CAIN C,CTRL
	JRST [	MOVEI C,200
		MOVEM C,BITS
		JRST GETLP1]
	CAIN C,META
	JRST [	MOVEI C,400
		MOVEM C,BITS
		JRST GETLP1]
	CAIN C,CTLMTA
	JRST [	MOVEI C,600
		MOVEM C,BITS
		JRST GETLP1]
	CAIN C,TTYCM
	JRST [
NOGDP,<		SKIPE ISDPY
		JRST DODEPA
>;NOGDP
		MOVE C,BITS
		TRCE C,200
		TRC C,400
		MOVEM C,BITS
		JRST GETLP1]
>;NODEC
	CAIN C,15
	JRST GETLP1
	IOR C,BITS
DODEPA:	CAIN C,600+"!"	;IS THIS THE MAGIC CHAR.?
	JRST [	PUSHJ P,DSPOUT
		POPJ P,]
	CAIN C,600+LAMBDA	;DISK CONTINUE CHAR?
	JRST DSKCON		;YES, CONTINUE IT
	TLNE M,DSKACT	;DOING DISK INPUT?
	JRST DODEPB	;YES, NO OUTPUT CHECK!
	SKIPE DSKOPN	;DISK OUTPUT?
	PUSHJ P,DSKOCHR	;YES
DODEPB:	CAIE C,12	;DEC ONLY USES LF
	JRST DODEP
	PUSH P,T
	MOVE T,MACPNT
	SKIPL -4(T)	;;I ACTIVE?
	JRST TREST	;NO, RESTORE T AND GO ON
	MOVEI C,200+":"	;IT IS, CHANGE TO END OF ;I
TREST:	POP P,T
DODEP:	SKIPN CDEPPN	;ARE WE DEPOSITING A DEFINITION?
	JRST DODEP1
	PUSH P,T	;YES, SAVE T
	MOVE T,CDEPPN	;GET DEPOSIT LIST POINTER
	PUSH P,TT	;SAVE TT
	PUSH P,TTT	;SAVE TTT
DODLOP:	MOVE TT,1(T)	;GET BYTE POINTER
	TLNE TT,770000	;END OF WORD?
	JRST DOTP4	;NO
	GETFS (TTT)
	SETZM (TTT)	;CLEAR POINTER TO NEXT
	SETZM 1(TTT)	;AND DATA
	HRRM TTT,-1(TT)	;DEPOSIT POINTER HERE
	HRR TT,TTT
DOTP4:	IDPB C,TT	;DEPOSIT CHR.
	MOVEM TT,1(T)	;DEPOSIT NEW POINTER
	HRRZ T,(T)	;GET NEXT THING IN DEPOSIT LIST
	JUMPN T,DODLOP	;LOOP IF MORE DEPOSITING TO DO
	POP P,TTT
	POP P,TT
	POP P,T
DODEP1:	TLNN IGNORE	;DOING DEFINITION OR FALSE PART OF ;F?
	TRNN C,600	;NO, BITS?
	JRST CPOPJ1
	CAIN C,":"+200	;IS THIS ;R0?
	JRST ITRETX	;YES
	MOVEM C,1(P)
	ANDI C,177
	CAIN C,";"	;OR SEMI COLON
	JRST DOSEMI	;WILL POPJ
	CAIE C,12	;DON'T PUT BITS BACK ON LF!
	MOVE C,1(P)
	JRST CPOPJ1	;IT'S A CHARACTER

ITRETX:	PUSHJ P,PUSHIT
	PUSHJ P,ITRETZ
	PUSHJ P,POPIT
	POPJ P,		;TELL HIM TO ASK AGAIN

DOSEMI:	PUSHJ P,PUSHIT
	PUSHJ P,ITSEM	;DO THE SEMICOLON THING
	PUSHJ P,POPIT
	POPJ P,

GETMAC:	TLNN C,770000	;END OF WORD?
	JRST GETBYT
GOTBYT:	ILDB C,INPNT	;GET CHR.
	JUMPN C,DODEP
ENDMAC:	MOVEI C,":"+200		;GET A ;R0 AT END
	JRST DODEP

GETBYT:	HRR C,-1(C)
	TRNN C,-1	;END OF LIST?
	JRST ENDMAC	;YES, GENERATE <CTRL>:
	MOVEM C,INPNT	;DEPOSIT INCREMENTED POINTER
	JRST GOTBYT
                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;"D"
ITDEF:	PUSHJ P,ITMAC	;STARTS JUST LIKE NAMED MACRO
	HRRZ T,MACPNT
ITSKPF:	TLOE IGNORE	;START IGNORING
	POPJ P,		;ALREADY IGNORING, LEAVE
	PUSH P,T
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/IGNORING!
/]
ITLOP1:	SETZ B,		;KEEP LEVEL HERE
ITLOOP:	PUSHJ P,GETLN
	JRST ITLOOP	;GET AGAIN
	CAIN C,":"+200	;ITZERO?
	JRST ITPOP	;UP A LEVEL
	TRZN C,600	;ANY BITS?
	JRST ITLOOP
	CAIE C,";"	;YES, IS IT SEMI COLON?
	JRST ITLOOP	;NO
	PUSHJ P,MREADN	;GET ARG AND COMMAND
	TRZ C,600	;CLEAR BITS
	CAIN C,"R"
	JRST ITPOPA
	CAIN C,"S"	;THIS ENDS IT ALL
	JRST ITPOP
	CAIE C,"M"	;THESE 3 HAVE MATCHING ;R'S OR $:'S
	CAIN C,"P"
	AOJA B,ITLOOP
	CAIN C,"D"
	AOJA B,ITLOOP
	JRST ITLOOP

ITPOPA:	PUSHJ P,READN		;EAT ARG TO ;R
ITPOP:	SOJGE B,ITLOOP
	PUSHJ P,ITRETZ	;THIS WILL POP UP A LEVEL
	HRRZ TT,MACPNT
	CAML TT,(P)	;HAVE WE PASSED WHERE WE WANTED TO STOP?
	JRST ITLOP1	;NO
	POP P,(P)	;POP OFF LEVEL
	TLZ IGNORE	;YES, STOP IGNORING
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/END IGNORING!
/]
	POPJ P,
                                                                                                                                                                                                                                                                         ;"F"
ITFLAG:	PUSHJ P,READN		;GET LEVEL TO RETURN UP TO
	MOVE TT,T
	IMULI TT,5	;MULT LEVEL BY 5
	MOVE T,MACPNT	;GET MACRO PDL POINTER
	SUB T,TT	;BACK UP CORRECT NUMBER OF LEVELS
	ANDI T,-1
	CAIG T,MACPDL	;TOO FAR?
	JRST [ADDI T,5	;YES
		JRST .-1]
	PUSH P,T	;SAVE POINTER TO MACPDL
	MOVE TT,C
	CAIN TT,"-"
	JRST [	PUSHJ P,GETWRD
		JRST WASNOT]
	MOVE A,[POINT 6,T]
	SETZ T,
	PUSHJ P,ISCHRX
WASNOT:	EXCH TT,C
	CAIE TT,12
	JRST ERRXT
	MOVSI TT,-FLGLEN	;TABLE LENGTH
	CAME T,FLGNAM(TT)
	AOBJN TT,.-1
	POP P,T
	JUMPGE TT,PERRET	;ERROR RETURN IF FLAG NOT FOUND
	HRRZ TT,TT		;CLEAR COUNT IN LEFT HALF
	XCT FLGTAB(TT)
	TDZA TT,TT		;FALSE
	SETO TT,		;TRUE
	CAIN C,"-"		;DID HE TYPE  ?
	SETCA TT,		;FLAG	YES
	JUMPE TT,CPOPJ		;NOOP IF NOT TRUE
	JRST ITSKPF		;AND START IGNORING

ERRXT:	POP P,(P)
	JRST ERRX

DEFINE FLGMAC(A,B,C)
<
IFIDN<B><BOTH><	<SIXBIT/A/>	>
IFIDN<B><D><MD,<<SIXBIT/A/>>	>
IFIDN<B><PC><MPC,<<SIXBIT/A/>>	>
>
FLGNAM:	FLAGS			;MACRO FROM DATA FILE
FLGLEN__.-FLGNAM
;HERE ARE SOME FLAG TESTING ROUTINES
DEFINE FLGMAC(A,B,C)
<
IFIDN<B><BOTH><		IFIDN<C><><SKIPN A;>C	>
IFIDN<B><D><MD,<	IFIDN<C><><SKIPN A;>C>	>
IFIDN<B><PC><MPC,<	IFIDN<C><><SKIPN A;>C>	>
>
FLGTAB:	FLAGS			;COMMAND TO EXECUTE FOR FLAG TEST

;ROUTINE FOR CLOSES FLAG
CLTEST:	PUSH P,A
	PUSHJ P,GETCLS
	CAIA
	AOS -1(P)	;THERE IS A CLOSEST, SKIP
	POP P,A
	POPJ P,

;ROUTINE FOR RITEON FLAG
ROTEST:	PUSH P,T
	PUSH P,A
	MOVEI T,1
	LSH T,@MODE
	TDNN T,[MD,<1BTXTM!1EDTM!1EDTTM!1EDTPM!>1SETM!1BODM!1PNTM!1TXTM]
	JRST ROTST1
	PUSHJ P,GETCLS
	JRST ROTST1
	MOVE T,1(A)
	TDZ T,[1,,1]
	CAMN T,CURSE
	AOS -2(P)
ROTST1:	POP P,A
	POP P,T
	POPJ P,

;ROUTINE FOR EXPR FLAG
FEXPR:	PUSHJ P,PUSHIT
	PUSHJ P,EXPSET	;READ AND TEST EXPRESSION
	JFCL		;GIVE FALSE RETURN ON ERROR
	JRST [	PUSHJ P,POPIT	;FALSE
		POPJ P,]
	PUSHJ P,POPIT		;TRUE
	JRST CPOPJ1
                        ;SEMI COLON DISPATCH	RENMAC	DELMAC	PMACRO
ITSEM:	SKIPN T,CDEPPN	;ARE WE DEPOSITING A DEFINITON?
	JRST NOMFIX	;NO, NOTHING TO DO
DOFIX:	LDB C,1(T)	;GET SEMI-COLON
	TRO C,600	;MAKE SURE IT ALWAYS LOOKS LIKE A MACRO COMMAND
	DPB C,1(T)	;AND PUT IT BACK
	HRRZ T,(T)
	JUMPN T,DOFIX	;DO SOME MORE?
NOMFIX:	PUSHJ P,MREADN	;GET # AND CHAR WHICH FOLLOWS
SEMCAL:	TRZ C,600	;IGNORE CONTROL BITS
	CAIL C,"A"+40
	SUBI C,40	;CONVERT LC TO UC
;HERE ARE THE COMMANDS WHICH DON'T PUSH THE MACRO PDL.
	CAIN C,"R"
	JRST ITRET
	CAIN C,"O"
	JRST ITOUT
	CAIN C,"F"
	JRST ITFLAG
	CAIN C,"S"
	JRST ITSTOP
;HERE ARE THE COMMANDS WHICH DO PUSH THE MACRO PDL.
	HLRE T,MACPNT
	CAML T,[-5]	;ENOUGH ROOM FOR ANOTHER MACRO LEVEL?
	JRST [	OUTSTR[ASCIZ/

****** MACRO PDL OVERFLOW ******

/]
		JRST ITSTOP]
	CAIN C,"M"	;IS IT M?
	JRST ITMAC	;YES
	CAIN C,"P"
	JRST ITPNT
	CAIN C,"T"
	JRST ITTYP
	CAIN C,"U"
	JRST ITOOPS
	CAIN C,"C"
	JRST ITCAL
	CAIN C,"A"
	JRST ITARG
	CAIN C,"N"
	JRST ITSARG
	CAIN C,"L"
	JRST ITLET
	CAIN C,"D"
	JRST ITDEF
	CAIN C,"V"
	JRST ITVAR
	CAIN C,"E"
	JRST ITEVAL
	CAIN C,"X"
	JRST ITEXPR
	CAIN C,"#"
	JRST ITDEQU
	CAIN C,"="
	JRST ITEQU
	CAIN C,"H"
	JRST ITVAR0
	CAIN C,"I"
	JRST ITIN
	CAIN C,"Y"
	JRST ITYANK
	CAIN C,"G"
	JRST ITLOWG
	CAIN C,"^"
	JRST ITCTRL
	JRST PERRET

RENMAC:	PUSHJ P,ITGET
	JRST NXMAC
	HRLM E,(P)
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE NEW MACRO NAME./]
	PUSHJ P,ITGETA
	JRST ITMOK
	TLNE M,DSKACT!MACACT
	JRST PERRET
	OUTSTR[ASCIZ/SORRY, ALREADY IN USE!
/]
	POPJ P,

UNSAVM:	SKIPA F,[ANDCAM T,(E)]
SAVMAC:	MOVE F,[IORM T,(E)]
	PUSHJ P,ITGET
	JRST NXMAC
	MOVSI T,MSAVE
	XCT F			;SET OR CLEAR BIT
	POPJ P,

ITMOK:	HLRZ E,(P)
	HRRZ B,1(E)		;GET OLD NAME
	HRRM D,1(E)		;STORE NEW ONE
	JRST PUTFS

DELMAC:	HRRZ T,MACPNT
	CAIL T,MACPDL
	JRST NINMAC
	PUSHJ P,ITGET		;GET MACRO
	JRST NXMAC
	HRRZ T,MACPNT
	CAIL T,MACPDL
	JRST NINMAC
;ENTER HERE WITH E:MACRO TO DELETE, C:PREVIOUS MACRO
DELMC1:	HRRZ T,(E)
	HRRM T,(C)		;LINK HIM OUT
	HRRZ B,1(E)
	PUSHJ P,PUTFS		;GIVE BACK NAME
	HLRZ B,1(E)
	PUSHJ P,PUTFS		;GIVE BACK BODY
	MOVE TT,E		;SAVE COPY OF MACRO HEADER
	FSTRET(E)		;GIVE BACK HEADER
	MOVE T,MODE
	CAIN T,MALTM
	CAME TT,REMMAC		;DID WE JUST DELETE MACRO WE WERE EDITING?
	POPJ P,
	TRO MCHG
	MOVE T,MODALT
	JRST CHNGMD		;LEAVE MACRO ALTER MODE

DELMCS:	HRRZ T,MACPNT
	CAIL T,MACPDL
	JRST NINMAC
	MOVEI E,MDPNT
DLMCS1:	MOVE C,E		;SAVE PREVIOUS
DLMCS2:	HRRZ E,(C)		;GET NEXT
	JUMPE E,CPOPJ		;DONE IF NO MORE
	HRRZ T,1(E)		;GET MACRO NAME
	PUSHJ P,OUTTXT		;TYPE IT
	HRL E,C
	PUSHJ P,YORN
	POPJ P,			;QUIT ON ALT
	JRST DLMCS1		;GET NEXT IF NO
	HLRZ C,E
	HRRZ T,MACPNT
	CAIL T,MACPDL
	JRST NINMAC		;IF HE STARTED A MACRO, BLOW HIM OUT OF THE WATER
	PUSHJ P,DELMC1		;DELETE IF YES
	JRST DLMCS2		;GET NEXT FROM C THIS TIME

NINMAC:	TLNE M,DSKACT!MACACT
	JRST PERRET
	OUTSTR[ASCIZ/NOT INSIDE MACRO!!
/]
	POPJ P,

MREADN:	PUSHJ P,GETCHR
	SETZ A,
	CAIE C,"-"
	JRST MREADP
	PUSHJ P,MREADM
	MOVN A,A
	POPJ P,

MREADM:	SETZ A,
MREADO:	PUSHJ P,GETCH
	JRST MREADO
MREADP:	CAIL C,"0"
	CAILE C,"9"
	POPJ P,
	IMULI A,=10
	ADDI A,-"0"(C)
	JRST MREADO

PMACRO:	PUSHJ P,ITGET	;WHICH MACRO
	JRST NXMAC
	HLRZ E,1(E)	;GET POINTER TO BODY
	ADD E,[POINT 9,1]
PMAC1:	TLNE E,770000	;END OF WORD?
	JRST PMAC2
	HRR E,-1(E)
	TRNE E,-1	;END OF MACRO?
	JRST PMAC2	;NO
	OUTSTR[ASCIZ/
/]
	POPJ P,

PMAC2:	ILDB C,E	;GET CHAR
	JUMPE C,PMAC1
NODEC,<	TRC C,600
	TRCN C,600	;CTRL META?
	JRST [	ANDI C,177	;YES
		OUTCHR[CTLMTA]
		JRST PMAC3]
	TRZE C,200	;CTRL?
	OUTCHR[CTRL]
	TRZE C,400	;META?
	OUTCHR[META]
PMAC3:
>;NODEC
DEC,<	MOVE T,C
	LSH T,-7
	CAIA
	OUTCHR["$"]
	SOJGE T,.-1
>;DEC
	CAIN C,12
	JRST [	OUTSTR[ASCIZ/
/]
		JRST PMAC1]
DEC,<	CAIGE C,40
	JRST [	CAIE C,11
		CAIN C,ALTMOD
		JRST .+1
		ADDI C,100
		OUTCHR["^"]
		JRST .+1]
>;DEC
	OUTCHR C
	JRST PMAC1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;"P" "V"
ITPNT:	HRRZ T,MACPNT
	CAIGE T,MACPDL	;IS THIS TOP LEVEL?
	JRST ITLAST	;YES DO ";MLAST"
	MOVE T,MACPNT	;GET MACRO PDL POINTER
	TLNE M,MACACT
	JRST GOTINP	;YES
	SKIPE B,CDEPPN	;ARE WE ALREADY DEPOSITING?
	JRST GOTDEP	;YES
	GETFS (B)	;NO
	SETZM (B)	;CLEAR "TO NEXT" POINTER
	HRRZM B,CDEPPN	;DEPOSIT DEPOSIT LIST POINTR
	GETFS (C)
	HRLM C,(B)	;DEPOSIT POINTER TO START OF CHAIN
	SETZM (C)
IMCON1:	SETZM 1(C)
	HRLI C,441100	;MAKE A BYTE POINTER
	ADDI C,1
	MOVEM C,1(B)	;DEPOSIT POINTER
	PUSH T,B	;PUSH POINTER TO THING TO REMOVE
	SKIPA
GOTDEP:	PUSH T,[0]	;DON'T REMOVE ANYTHING
	SETZM BRKCHR
	PUSH T,[0]	;MAKE PLACE TO SAVE CDEPPN LATER ON
	PUSH T,1(B)	;PUSH POINTER TO START OF LOOP
GOTRET:	PUSH T,[0]	;MAKE PLACE TO SAVE COUNT
	PUSH T,[-1]	;MAKE PLACE TO SAVE POINTER TO END OF LOOP
GOTRTV:	MOVEM T,MACPNT	;SAVE PDL POINTER
	TLNE M,DSKACT!MACACT
	POPJ P,
	HRRZS T
	SUBI T,MACPDL-1
	IDIVI T,5
	OUTSTR[ASCIZ/
ENTERING MACRO LEVEL /]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/.
/]
	POPJ P,

GOTINP:	PUSH T,[0]	;DON'T REMOVE ANYTHING
	SETZM BRKCHR
	PUSH T,[0]	;MAKE PLACE TO SAVE CDEPPN LATER
	PUSH T,INPNT	;SAVE CURRENT INPUT POINTER AS LOOP START POINT
	JRST GOTRET

;VARIABLE INPUT, TTY INPUT FIRST TIME THROUGH LOOP
ITVAR:	PUSHJ P,READN	;READ LEVEL NUMBER
	MOVE TT,T
	IMULI TT,5	;MULT LEVEL BY 5
	MOVE T,MACPNT	;GET MACRO PDL POINTER
	SUB T,TT	;BACK UP CORRECT NUMBER OF LEVELS
	ANDI T,-1
	CAIG T,MACPDL	;TOO FAR?
	JRST [	ADDI T,5	;YES
		TLNN M,MACACT!DSKACT
		OUTSTR[ASCIZ/TRUNCATING MACRO LEVEL!
/]
		JRST .-1]
	HRRZ TT,MACPNT	;CHECK IF ALL INTERVENING MACROES ARE IN FIRST TIME
VARCHK:	SKIPE -1(T)	;FIRST TIME AT THIS LEVEL?
	JRST ITCAL	;NO, DO ";C"
	ADDI T,5
	CAIG T,(TT)	;CHECK ALL INTERVENING MACROES YET?
	JRST VARCHK	;NO
	PUSHJ P,ITMACS
	MOVE T,MACPNT	;GET MACRO PDL POINTER
	GETFS (B)
	HRRZ B,B
	PUSH T,B	;THING TO RETURN LATER
	SETZM BRKCHR
	PUSH T,CDEPPN	;WE DON'T NEED TO DEPOSIT NEW DEFINITION (WILL ALWAYS BE TYPED)
	HRRZM B,CDEPPN	;.....
	GETFS (C)
	HRLM C,1(E)	;PUT IN LINK TO TEXT
	HRLZM C,(B)	;...
	SETZM (C)
	HRROS (C)	;MARK AS MACRO (SO IT WON'T GET DELETED)
	SETZM 1(C)
	HRLI C,441100	;MAKE A BYTE POINTER
	ADDI C,1
	MOVEM C,1(B)	;DEPOSIT POINTER
	PUSH T,1(B)	;LOOP START LOC
	PUSH T,[0]	;MAKE PLACE FOR COUNT
	PUSH T,INPNT	;SAVE CURRENT INPUT POINTER
	SETZM INPNT	;TAKE INPUT FROM TTY
	PUSHJ P,RSTMAC
	PUSHJ P,GOTRTV
	TLNE M,DSKACT	;DISK INPUT ACTIVE?
	POPJ P,		;YES
	OUTSTR[ASCIZ/TYPE VALUE OF /]
	HRRZ T,1(E)
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;":" "R" "S"
ITRETZ:
;	TLNN M,MACACT!DSKACT	;DISK OR MACRO ACTIVE?
;	OUTSTR[ASCIZ/
;/]				;NO, ECHO CRLF
	MOVE A,MACPNT
	HRRZ B,A
	CAIG B,MACPDL
	POPJ P,
	SETOM -1(A)	;MAKE COUNT BE OUT NOW
	JRST ITSTP2

ITRET:	PUSHJ P,READN	;READ NUMBER OF TIMES TO ITERATE
	CAIE C,"#"	;THIS SPECIAL CHAR?
	JRST ITRTLF	;NO, LOSE
	JUMPN T,INNERR	;ERROR IF NUMBER PRECEEDING
	MOVE T,FNDNUM	;USE COUNT OF THINGS FOUND
	PUSHJ P,GETLIN	;GET LF
ITRTLF:	CAIE C,12	;MUST BE LF
	JRST INNERR	;LOSE
	MOVE A,MACPNT	;GET PDL POINTER
	HRRZ B,A	;GET ADDRESS PART
	CAIG B,MACPDL	;BACK AT START?
	POPJ P,		;YES, LEAVE
	SKIPGE B,-1(A)	;GET COUNT. ANY COUNT YET?
	JRST DONBEF	;YES, THIS IS NOT THE FIRST TIME THROUGH THIS LOOP
	MOVN B,T	;NEGATE COUNT
	HRLZ B,B	;DEPOSIT COUNT IN LT HF, # OF TIMES THROUGH LOOP IN RT HF
	MOVEM B,-1(A)	;DEPOSIT
ITSTP2:	MOVE C,INPNT	;GET CURRENT INPUT POINTER
	MOVSI D,1
	TDNE D,(A)	;ALREADY SAVED?
	MOVEM C,(A)	;NO, SAVE
	MOVE T,CDEPPN	;GET DEPOSIT LIST POINTER
	SKIPN -3(A)
	MOVEM T,-3(A)	;SAVE IT
	SETZM CDEPPN	;DON'T DEPOSIT WHILE LOOPING
DONBEF:	TLNE IGNORE	;ARE WE TRYING TO IGNORE?
	JRST DONDON	;YES, MAKE BELIEVE COUNT IS OUT
	MOVE B,-1(A)	;GET COUNT
	AOBJP B,DONDON	;INC COUNTS, DONE?
	MOVEM B,-1(A)	;NO, STO IT
	MOVE C,-2(A)	;GET POINTER TO START OF LOOP
	MOVEM C,INPNT	;TAKE INPUT FROM THERE
RSTMAC:	SKIPE INPNT
	TLOA M,MACACT
	TLZN M,MACACT	;TURN OFF, AND IF WAS ALREADY OFF
	JRST DSPSET	;JUST CALC STATE OF DSPACT
	PUSHJ P,DSPSET	;ELSE CALC DSPACT
	JRST ENDDSP	;AND CHECK DISPLAY

DONDON:	POP A,INPNT	;RESTORE INPUT POINTER
	PUSHJ P,RSTMAC	;FIX BIT
	POP A,TT	;THROW AWAY COUNT
	POP A,TT	;SAVE LOOP-START POINTER FOR CHECK LATER
	POP A,CDEPPN	;RESTORE DEPOSIT LIST POINTER
	HRRZS CDEPPN
	POP A,B		;GET THING-TO-THROW-AWAY POINTER
	HRRZ B,B	;CLEAR FLAGS AND BRKCHR
	MOVEM A,MACPNT	;STORE MACRO PDL POINTER
	HRRZ T,A
	CAIGE T,MACPDL
	TDZA T,T
	HLRZ T,-4(T)
	ANDI T,177
	MOVEM T,BRKCHR		;RESTORE BRKCHR FROM MACRO NOW IN FORCE (IF ANY)
	JUMPE TT,NOLEVP	;IF NOT LOOP START POINTER, DON'T PRINT LEVEL
	TLNE M,DSKACT!MACACT
	JRST NOLEVP
	HRRZ T,A
	SUBI T,MACPDL-1
	IDIVI T,=5
	ADDI T,1
	OUTSTR[ASCIZ/LEAVING MACRO LEVEL /]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/.
/]
NOLEVP:	JUMPE B,CPOPJ	;NOTHING TO THROW AWAY
	MOVEI A,CDEPPN	;GET DEPOSIT LIST POINTER
DONDN1:	HRRZ D,(A)	;GET POINTER
	JUMPE D,DARN2
	CAMN B,D	;SAME?
	JRST DONDN2	;YES
	MOVE A,D	;NO, TRY NEXT
	JRST DONDN1
DONDN2:	HRRZ C,(B)	;GET POINTER TO NEXT
	HRRM C,(A)	;DEPOSIT POINTER AROUND
DARN2:	MOVSS (B)
	HRRZ C,(B)	;GET FLAG
	HLRZ C,(C)
	JUMPE C,PUTFS	;IF NOT A MACRO, RETURN WHOLE THING TO FS
	FSTRET (B)	;OTHERWISE RETURN ONLY FIRST THING
	POPJ P,

ABMAC:	MOVE T,MACPNT
	CAMG T,[-MPDLEN,,MACPDL]
	POPJ P,
	GETFS(B)
	SETZM (B)
	MOVE T,[BYTE(9)";"+600,"S"]
	MOVEM T,1(B)
	TLZ IGNORE
	JRST ITLET2

ITSTOP:	MOVE A,MACPNT
	HRRZ B,A
	TLZ IGNORE
	CAIG B,MACPDL
	POPJ P,		;NOT DOING ANY MACRO HACKING NOW
	SETOM -1(A)	;TO COUNT OUT THIS TIME
	PUSHJ P,ITSTP2	;FAKE A ;R
	JRST ITSTOP	;& TRY AGAIN AT NEXT LEVEL
                                                                                                                                ;"M" "C" , STUFF SUBRS

;COME HERE TO GENERATE STOP ON ERROR DURING MACRO
ITERR:	OUTSTR[ASCIZ/DOING ;T
/]
	MOVEI B,0
	JRST MACRT1

ITMACS:	PUSHJ P,TREADV	;GET MACRO NAME
	MOVE D,B	;HOLD POINTER TO IT
;ENTER HERE WITH MACRO NAME IN D
ITMACI:	SKIPE 1(D)
	JRST ITMLP0
	MOVE E,[ASCIZ/NIL/]
	MOVEM E,1(D)
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NAMING MACRO AS NIL
/]
ITMLP0:	MOVEI E,MDPNT	;GET POINTER TO MACROS
ITMLP1:	HRRZ E,(E)	;GET POINTER TO MACRO
	JUMPE E,NOMOTM	;NONE? ( OR NO MORE?)
	HRRZ A,1(E)	;GET NAME POINTER
	MOVE B,D	;GET OTHER NAME POINTER
	PUSHJ P,TXTMAT	;SEE IF THE SAME
	JRST ITMLP1	;NO, TRY NEXT
	HLRZ B,1(E)	;SAME, GET POINTER TO BODY
	PUSHJ P,PUTFS	;RETURN TO FREE STORAGE
	HRRZ B,1(E)	;GIVE BACK OLD NAME
	HRRM D,1(E)	;NOT NEW (HIGHER UPS LOOK AT IT)
	JRST PUTFS	;RETURN TO FREE STORAGE

NOMOTM:	GETFS (E)	;GET FREE STORAGE
	MOVE B,MDPNT	;GET MACRO POINTER
	MOVEM B,(E)	;LINK NEW ONE IN
	HRRM D,1(E)	;PUT IN NAME
	HRRZM E,MDPNT	;(LINK IN)
	POPJ P,

ITLAST:	PUSH P,A		;SAVE ARG
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/;MLAST/]
	GETFS(D)
	SETZM (D)
	MOVE T,[ASCIZ/LAST/]
	MOVEM T,1(D)
	PUSHJ P,ITMACI
	JRST ITMAC0

ITMAC:	PUSH P,A		;SAVE ; ARG
	PUSHJ P,ITMACS
	MOVE B,1(D)	;GET FIRST WORD OF NAME
	CAME B,[ASCIZ/INIT/]	;THIS MACRO GETS AUTOMATIC SMACRO
	JRST ITMAC0
	MOVSI B,MSAVE
	IORM B,(E)		;MARK IT SAVED
ITMAC0:	MOVE T,MACPNT	;GET MACRO PDL POINTER
	POP P,A
	CAIE A,1		;1 WILL SET MSAVE
	TDZA A,A
	MOVSI A,MSAVE
	IORM A,(E)
	GETFS (B)
	MOVE F,CDEPPN	;GET DEPOSIT LIST POINTER
	MOVEM F,(B)	;LINK NEW ONE IN
	HRRZM B,CDEPPN	;.....
	GETFS (C)
	HRLM C,1(E)	;PUT IN LINK TO TEXT
	HRLM C,(B)	;...
	SETZM (C)
	HRROS (C)	;MARK AS MACRO (SO IT WON'T GET DELETED)
	JRST IMCON1

ITGET:	TLNN M,DSKACT!MACACT	;INSIDE A MACRO?
	OUTSTR [ASCIZ /TYPE MACRO NAME./]
ITGETA:	PUSHJ P,TREADV	;GET MACRO NAME
	MOVE D,B	;HOLD POINTER
	MOVEI E,MDPNT	;GET POINTER TO LIST OF MACROS
ITCLP1:	MOVE C,E	;SAVE PREVIOUS HERE
	HRRZ E,(E)	;GET POINTER TO MACRO
	JUMPE E,CPOPJ
	HRRZ A,1(E)	;GET MACRO NAME
	MOVE B,D	;GET TYPED NAME
	PUSHJ P,TXTMAT	;SAME?
	JRST ITCLP1	;NO, LOOP
	MOVE B,D	;YES
	PUSHJ P,PUTFS	;RETURN TYPED NAME TO FS
	HLRZ B,1(E)	;GET BODY POINTER
	ADD B,[XWD 441100,1];MAKE BYTE POINTER
	JRST CPOPJ1

NXMAC:	MOVE B,D
	PUSHJ P,PUTFS
	TLNE M,DSKACT!MACACT
	JRST PERRET
	OUTSTR [ASCIZ /NO SUCH MACRO
/]
	POPJ P,

MACCAL:	SKIPN E,MDPNT
	JRST CPOPJ1	;LOSE
MACCL1:	HRRZ A,1(E)
	MOVE D,1(A)
	CAMN D,@(P)	;SAME AS ARG?
	JRST MACCL2	;YES
	HRRZ E,(E)
	JUMPN E,MACCL1
	JRST CPOPJ1

MACCL2:	AOS (P)		;SKIP ARG
	TRNN TFLG	;CHECK READIN BIT?
	JRST MACCL3
	HLRZ B,(E)	;GET BITS
	TRNN B,MACTMP	;JUST READ IN?
	POPJ P,		;NO, SKIP IT
MACCL3:	HLRZ B,1(E)
	ADD B,[POINT 9,1]
	JRST MACRT1	;CALL IT

ITCAL:	PUSHJ P,ITGET
	JRST NXMAC
MACRT1:	MOVE T,MACPNT	;GET MACRO PDL POINTER
	PUSH T,[0]	;DON'T RETURN ANYTHING TO FREE STORAGE AT END
	SETZM BRKCHR
MACRT2:	PUSH T,CDEPPN	;SAVE CDEPPN
	HRROS (T)
	SETZM CDEPPN
	PUSH T,B	;SAVE START POINTER
	PUSH T,[0]	;MAKE PLACE FOR COUNT
	PUSH T,INPNT	;SAVE CURRENT INPUT POINTER
	MOVEM B,INPNT	;TAKE INPUT FROM MACRO BODY
	MOVEM T,MACPNT	;STORE MACRO PDL POINTER
	JRST RSTMAC

;CALL WITH POINTER TO 9 BIT TEXT IN A
;BYTE POINTER TO END OF 9 BIT TEXT IN TT
ITSTUF:	PUTBYT 200+":"		;ADD <CTRL><COLON> AT END
	TLNN M,MACACT!DSKACT
	OUTSTR[ASCIZ/TYPE TEXT MACRO NAME./]
	PUSH P,A
	PUSHJ P,ITMACS
	POP P,A
	HRROS (A)	;MARK AS PERMANENT
	HRLM A,1(E)	;STUFF AWAY TEXT POINTER
	POPJ P,

;ENTER HERE WITH 7 BIT MACRO NAME IN D
;AND 9 BIT MACRO IN A
ITMAKE:	PUSH P,A
	PUSHJ P,ITMACI	;FIND OLD AND DELETE, OR JUST MAKE NEW BLOCK
	POP P,A
	HRROS (A)
	HRLM A,1(E)	;PUT IN MACRO BODY
	TLNE M,DSKACT!MACACT
	POPJ P,
	MOVE T,D
	PUSHJ P,OUTTXT	;PRINT MACRO NAME
	OUTSTR[ASCIZ/
/]
	POPJ P,

;CALL WITH BYTE POINTER IN T, RETURNS CHAR IN C
GETTT:	TLNE T,760000
	JRST GETTT1
	HRR T,-1(T)
	TRNN T,-1
	POPJ P,
GETTT1:	ILDB C,T
	JUMPN C,CPOPJ1
	JRST GETTT

SETTT7:	PUSHJ P,SETTT0
	TLO TT,(<POINT 7,0>)
	MOVEM TT,TTPTR
	POPJ P,

SETTT0:	GETFS(A)
	SETZM (A)
	SETZM 1(A)
	MOVE TT,[PUSHJ P,PUTTTC]
	MOVEM TT,PUTCHR
	MOVEI TT,1(A)
	POPJ P,

SETTT:	PUSHJ P,SETTT0
	TLO TT,(<POINT 9,0>)
	MOVEM TT,TTPTR
	POPJ P,

;CALL WITH NUM IN B , AFTER SETTING UP WITH SETTT
PUTTTN:	IDIVI B,=10
	HRLM C,(P)
	JUMPE B,.+2
	PUSHJ P,PUTTTN
	HLRZ C,(P)
	MOVEI TTT,60(C)
;CALL WITH CHAR IN TTT, POINTER SET UP BY SETTT
PUTTTC:	EXCH TT,TTPTR
	TLNE TT,760000
	JRST PUTTT1
	PUSH P,TTT
	GETFS(TTT)
	HRRM TTT,-1(TT)
	SETZM 1(TTT)
	SETZM (TTT)
	HRR TT,TTT
	POP P,TTT
PUTTT1:	IDPB TTT,TT
	EXCH TT,TTPTR
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;"U" "T" "L" "^" "A" "N" "#" "="
ITOOPS:	SKIPE INPNT	;IF INPUTTING FROM MACRO,
	POPJ P,		;THIS IS A NOOP
			;ELSE IT IS A ;T
ITTYP:	TLNN M,DSKACT
	OUTSTR [ASCIZ /TYPE ARGUMENT./]
	MOVEI B,	;TAKE INPUT FROM TYPING
	JRST MACRT1

ITDEQU:	PUSHJ P,GETCHR
	CAIL C,"a"
	CAILE C,"z"
	CAIA
	SUBI C,40
	CAIL C,"A"
	CAILE C,"Z"
	JRST [	HRREI T,-100(C)	;IF NOT LETTER, DO ITEQU
		JRST .+2]
	MOVE T,L2N-100(C)	;ELSE CONVERT LETTER TO NUMBER
	MOVEI C,"#"
	JRST ITLET0

ITEQU:	PUSHJ P,GETCHR
	HRREI T,-100(C)		;GET CODE FOR LETTER AS NUMBER IN STANDARD FORMAT
	MOVEI C,"="
	JRST ITLET0

ITLET:	PUSHJ P,SREADN	;READ # ARG
	CAIN C,12
	JRST ITLETA
	CAIE C,"D"
	JRST INNERR
	JUMPN T,INNERR
	PUSHJ P,SREADN
	CAIE C,12
	JRST INNERR
	JUMPLE T,ITLETA
	CAMG T,MAXN2L	;IN LETTER RANGE?
	SKIPA TT,N2L(T)	;USE THIS
ITLETA:	MOVEI TT,100(T)	;CONVERT TO CHARACTER
	PUSHJ P,MACLET	;MAKE LETTER MACRO
	MOVEI C,"L"
	JRST ITLET1	;AND MERGE WITH IT ARG

ITCTRL:	PUSHJ P,GETCHR		;GET CHARACTER
	CAIL C,"A"+40
	CAILE C,"Z"+40
	CAIA
	SUBI C,40		;CONVERT LC TO UC
	CAIL C,100		;IF NOT ALREADY BELOW 100
	SUBI C,100		;MAKE IT A CONTROL CHARACTER
	ANDI C,177		;NO CONTROL BITS PLEASE
	MOVE TT,C
	PUSHJ P,MACLET		;MAKE THE MACRO
	MOVEI C,"^"
	JRST ITLET1

ITSARG:	PUSHJ P,ARGSET	;READ ARGS
	POPJ P,		;ERROR
	PUSHJ P,SMACNM	;SIGNED NUMBER
	MOVEI C,"N"
	JRST ITLET1

ITARG:	PUSHJ P,ARGSET	;READ ARGS
	POPJ P,		;ERROR
	MOVEI C,"A"
ITLET0:	PUSHJ P,MACNUM	;CREATE TEXT NUMBER FROM IT
ITLET1:	TLNE M,DSKACT!MACACT
	JRST ITLET2
	OUTSTR[ASCIZ/END ;/]
	OUTCHR C
	OUTSTR[ASCIZ/
/]
ITLET2:	HRRZ T,(B)	;GET POINTER TO TEXT
	HRLM T,(B)	;DUPLICATE IN LEFT HALF SO THAT LIST REMOVER AT
			;END OF ITRET WILL RETURN IT TO FREE STORAGE PROPERLY
	MOVE T,MACPNT	;GET MACRO PDL POINTER
	HRRZ B,B
	PUSH T,B	;RETURN TO FREE STORAGE AT END
	SETZM BRKCHR
	PUSH T,CDEPPN	;SAVE DEPOSIT LIST
	HRROS (T)	;MARK AS SAVED
	PUSH T,[0]	;PUSH ZERO AS START BYTE POINTER
	PUSH T,[-1,,0]	;1 AS COUNT (DO ONCE) LOOP COUNT OF 0
	PUSH T,INPNT	;SAVE INPUT POINTER
	SETZM CDEPPN	;DON'T DEPOSIT
	ADD B,[XWD 441100,1]	;MAKE BYTE POINTER
	MOVEM B,INPNT	;TAKE INPUT FROM THERE
	PUSHJ P,RSTMAC
	MOVEM T,MACPNT
	POPJ P,

ITVAR0:	TLNN	M,DSKACT!MACACT
DEC,<	OUTSTR	[ASCIZ/VARIABLE NAME.
^/]>
NODEC,<	OUTSTR[ASCIZ/VARIABLE NAME.
/]>
	PUSHJ	P,VARNM		;GET VARIABLE NAME
	CAIE	C,12		;MUST END WITH <LF>
	JRST	INNERR
	PUSHJ	P,VARFND	;LOOKUP NAME
	JRST	VARN99		;NOT FOUND, ERROR
	HLRZ	T,(E)		;GET PTR TO EXPANSION
	PUSHJ	P,SETTT		;COPY INTO A 9-BIT STRING
	JUMPE	T,ITVAR1
	ADD	T,[XWD 440700,1];MAKE A BYTE PTR TO TEXT
	PUSHJ	P,GETTT
	JRST	ITVAR1
	PUTBYT (C)
	JRST	.-3
ITVAR1:	MOVE	B,A
	PUTBYT 200+":"
	MOVEI	C,"H"
	JRST	ITLET1

ARGSET:	HRRZ G,MACPNT	;SETUP INTIAL MACPDL POINTER
	PUSHJ P,SREADN	;GET LEVEL # (OR INITIAL VALUE)
	MOVE TT,T
	CAIN C,12	;NEW FORMAT?
	JRST [	MOVEI T,1	;ASSUME INC OF 1
		JRST GOTANM]
	CAIE C,","
	JRST INNERR
	PUSHJ P,SREADN
	CAIN C,12
	JRST GOTANM
	MOVE TTT,T
	PUSHJ P,READN
	CAIE C,12	;NOW IT MUST BE LF
	JRST INNERR	;LOSE BIG
	PUSHJ P,PDLCAL
	MOVE T,TTT
GOTANM:	HRRZ TTT,-1(G)	;GET LOOP COUNT
	IMUL TTT,T	;MULT BY INC
	ADD TT,TTT	;ADD TO INITIAL VALUE
	MOVE T,TT	;PUT RESULT IN T
	JRST CPOPJ1	;SUCCESSFUL SCAN

PDLCAL:	IMULI T,5	;MULT LEVEL BY 5
	SUB G,T		;BACK UP CORRECT NUMBER OF LEVELS
TRNLVL:	CAILE G,MACPDL	;TOO FAR?
	POPJ P,
	ADDI G,5	;YES
	TLNN M,MACACT!DSKACT
	OUTSTR[ASCIZ/TRUNCATING MACRO LEVEL!
/]
	JRST TRNLVL
                                                                                                                                                                                                                                                                                                                                              ;"E" "X" "O" "I"
;"X"
ITEXPR:	PUSHJ P,EXPSET
	POPJ P,				;LOSE
	TDZA T,T			;FALSE RETURN
	SETO T,				;TRUE RETURN
	MOVEM T,LSTEXP			;STORE HERE
	GETFS (B)
	HRRZ D,B			;HOLD POINTER
	SETZM (D)			;CLEAR POINTER TO NEXT
	SETZM 1(D)			;CLEAR DATA
	ADD D,[XWD 441100,1]		;MAKE BYTE POINTER
	MOVE T,[POINT 7,SIGBUF]
	JRST ITEXP1

ITEXP2:	PUSHJ P,PUTINL
ITEXP1:	ILDB TT,T
	JUMPN TT,ITEXP2
	PUSHJ P,PUTRET
	MOVEI C,"X"
	JRST ITLET1

EXPSET:	TLNN M,DSKACT!MACACT
DEC,<	OUTSTR[ASCIZ/TYPE EXPRESSION.
^/]>
NODEC,<	OUTSTR[ASCIZ/TYPE EXPRESSION.
/]>
	PUSHJ P,TREADX			;READ STRING
	POPJ P,				;NULL OR ALTMODE
	MOVE A,B
	ADD A,[POINT 7,1]
MD,<	SETZM DOVARS	>
	PUSHJ P,SIGSUB
	JRST [	PUSHJ P,PUTFS		;ERROR, GIVE BACK STRING AND RETURN
MD,<		SETOM DOVARS	>
		JRST EXPERR]
	PUSHJ P,PUTFS			;GIVE BACK STRING
MD,<	SETOM DOVARS	>
	MOVS T,SIGBUF
	CAIE T,(<ASCIZ/0/>)		;DID EXPRESSION EVALUATE TO 0?
	AOS (P)
	JRST CPOPJ1

TREADX:	PUSHJ P,GETLIN		;GET FIRST CHAR
	CAIN C,12
	POPJ P,			;IGNORE BLANK LINES
	GETFS(B)
	SETZM (B)
	MOVSI T,(<ASCII/[/>)
	MOVEM T,1(B)
	MOVE T,B
	ADD T,[POINT 7,1,6]
TREADY:	PUSHJ P,TREADZ
	PUSHJ P,GETLIN
	CAIN C,ALTMOD
	JRST PUTFS		;RETURN STRING IF ALTMODE
	CAIE C,12
	JRST TREADY
	MOVEI C,"]"
	AOS (P)
TREADZ:	TLNE T,760000
	JRST TREADW
	GETFS(TT)
	HRRM TT,-1(T)
	HRR T,TT
	SETZM (T)
	SETZM 1(T)
TREADW:	IDPB C,T
	POPJ P,

;"E"
ITEVAL:	PUSHJ P,TREADU			;READ MACRO NAME
	POPJ P,				;ALTMODE
	JFCL				;NULL, LET IT THROUGH
	MOVE D,B			;SAVE POINTER TO NAME
	PUSHJ P,SETTT
ITEVA1:	PUSHJ P,GETLIN
	CAIN C,600+":"			;CTRL META COLON?
	JRST ITEVA2
	PUTBYT (C)
	JRST ITEVA1

ITEVA2:	PUTBYT 200+":"
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
END ;E /]
	JRST ITMAKE

ITOUT:	PUSHJ P,TREAD
	MOVE T,B
	TLNN M,DSKACT!MACACT		;PRINT IF NOT TAKING INPUT FROM TTY
	OUTSTR[ASCIZ/END ;O
/]
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/
/]
	JRST PUTFS

ITIN:	TLNN M,DSKACT
	OUTSTR[ASCIZ/TYPE ARGUMENT (END WITH CRLF).
/]
	MOVE T,MACPNT
	PUSH T,[400000,,0]
	MOVEI B,
	SETZM BRKCHR
	JRST MACRT2

ITYANK:	TLNN M,DSKFLG	;ANY I FILE?
	JRST [	TLNN DSKACT!MACACT
		OUTSTR[ASCIZ/SORRY, NO DSKIN FILE OPEN.
/]
		POPJ P,]
	PUSHJ P,GETCHR	;GET CHARACTER TO USE AS BREAK CHAR
	ANDI C,177	;NO CTRL OR META PLEASE
IFN ALTMOD-ALTCHR,<
	CAIN C,ALTCHR	;MAKE SAME CONVERSIONS AS DSKIN
	MOVEI C,ALTMOD
>;IFN ALTMOD-ALTCHR
	MOVEM C,BRKCHR
	PUSHJ P,DSKCON	;CONTINUE DSK INPUT
	HRLZ TT,C
	MOVE T,MACPNT
	PUSH T,TT	;SAVE BRKCHR ON STACK
	MOVEI B,
	JRST MACRT2	;AND DO ;T

DSKCON:	TLNN M,DSKFLG	;DOING DISK INPUT AT ALL?
	POPJ P,		;NO
NOLAY,<TLO M,DSKACT>
LAY,<MOVSI C,DSKACT
	TDO M,C
	IORM C,LAYM
>;LAY
	POPJ P,

ITLOWG:	TLNN M,DSKACT!MACACT
DEC,<	OUTSTR[ASCIZ/TYPE STRING TO CONVERT.
^/]>
NODEC,<	OUTSTR[ASCIZ/TYPE STRING TO CONVERT.
/]>
	PUSHJ P,SETTT
ITLOW1:	PUSHJ P,GETLIN
	CAIN C,12		;EOL?
	JRST ITLOW2
	CAIL C,100		;CONVERT RANGE 100-137 TO 140-177
	TRO C,40
	PUTBYT (C)
	JRST ITLOW1

ITLOW2:	PUTBYT 200+":"
	MOVEI C,"G"		;FOR END ; MUMBLE
	MOVE B,A
	JRST ITLET1
                                                                                                                               ;MACRO MAKERS
MACLET:	GETFS(B)
	HRRZ D,B
	SETZM (D)
	ADD D,[XWD 441100,1]
	PUSHJ P,PUTINL
	JRST PUTRET

SMACNM:	GETFS (B)
	HRRZ D,B	;HOLD POINTER
	SETZM (D)	;CLEAR POINTER TO NEXT
	ADD D,[XWD 441100,1];MAKE BYTE POINTER
	JUMPE T,PUTRET	;NULL TEXT IF ZERO
	MOVEI TT,"+"
	SKIPG T
	MOVEI TT,"-"
	PUSHJ P,DODIV2
	JRST PUTRET

MACNUM:	GETFS (B)
	HRRZ D,B	;HOLD POINTER
	SETZM (D)	;CLEAR POINTER TO NEXT
	SETZM 1(D)	;CLEAR DATA
	ADD D,[XWD 441100,1];MAKE BYTE POINTER
	PUSHJ P,DODIV	;PUT IN THE TEXT
PUTRET:	MOVEI TT,":"+200;PUT IN THE END
PUTINL:	TLNE D,770000	;END OF WORD?
	JRST DODV1	;NO
	GETFS (E)	;YES, GET MORE FREE STORAGE
	SETZM (E)	;CLEAR POINTER TO NEXT
	SETZM 1(E)	;CLEAR DATA
	HRRM E,-1(D)	;POINT TO THIS ONE
	HRR D,E
DODV1:	IDPB TT,D	;DEPOSIT CHR
	POPJ P,

DODIV:	SKIPL T
	JRST DODIV1
	MOVEI TT,"-"
DODIV2:	PUSHJ P,PUTINL
	MOVM T,T
DODIV1:	IDIVI T,=10
	SOJG A,DODIV3	;GO AT LEAST UNTIL WIDTH COUNT RUNS OUT
	JUMPE T,DODIV4
DODIV3:	HRLM TT,(P)
	PUSHJ P,DODIV1
	HLRZ TT,(P)
DODIV4:	ADDI TT,60
	JRST PUTINL

MACCLR:	SKIPN T,MDPNT
	POPJ P,
	MOVSI TT,MACTMP
MCCRL1:	ANDCAM TT,(T)		;CLEAR TMP BIT
	HRRZ T,(T)
	JUMPN T,MCCRL1		;LOOP THRU ALL
	POPJ P,
                                                                      ;READ/WRITE MACRO FILES
WMACRS:	SETOM DX1
	CAIA
WMACRO:	SETZM DX1		;FLAG NO SELECT
	SKIPE VARPNT
	JRST WMAC2
	SKIPN MDPNT
	JRST [	OUTSTR[ASCIZ/NO MACROES.
/]
		POPJ P,]
WMAC2:	MOVEM P,PERRSAV
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/MACRO /]
	MOVSI T,EXTMCR
	PUSHJ P,SETNAM		;SET WIRE LIST FILENAME
	POPJ P,			;LET HIM OUT
	ENTPPN
	INIT DAT,10
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,EXIST		;DOES IT EXIST?
	POPJ P,			;DOESN'T WANT TO OVERWRITE IT
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER DAT,FILNAM
	JRST [	RELEASE DAT,
		OUTSTR[ASCIZ/, ENTER FAILED.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
	SKIPN A,VARPNT
	JRST WMAC14
	TLNN M,DSKACT!MACACT
	SKIPN DX1
	CAIA
	OUTSTR[ASCIZ/VARIABLES:
/]
	PUSHJ P,WRTZERO
WMAC4:	SKIPN DX1
	JRST WMAC4A
	TLNE M,DSKACT!MACACT
	JRST WMAC4B
	HRRZ T,1(A)
	PUSHJ P,OUTTXT
WMAC4B:	PUSHJ P,YORN
	JRST WMAC3		;SKIP THE REST OF THE VARIABLES ON ALT
	JRST WMAC6		;SKIP THIS ONE ON NO
WMAC4A:	HRRZ TT,1(A)
	PUSHJ P,WSTR		;WRITE VARIABLES
	HLRZ TT,1(A)
	JUMPE TT,WMAC5
	HLRZ B,(TT)
	HRLZ TTT,(TT)
	HLR TTT,(B)
	TLO TTT,400000
	PUSHJ P,WORDOUT
	MOVE TT,B
	PUSHJ P,WSTR
WMAC13:	HLRZ TT,(A)
	PUSHJ P,WSTR
WMAC6:	HRRZ A,(A)
	JUMPN A,WMAC4
WMAC3:	PUSHJ P,WRTZERO
WMAC14:	SKIPN A,MDPNT
	JRST WMAC8
	TLNN M,DSKACT!MACACT
	SKIPN DX1
	CAIA
	OUTSTR[ASCIZ/MACROES:
/]
WMAC1:	SKIPN DX1
	JRST WMAC1A
	TLNE M,DSKACT!MACACT
	JRST WMAC1B
	HRRZ T,1(A)
	PUSHJ P,OUTTXT
WMAC1B:	PUSHJ P,YORN
	JRST WMAC8			;END ON ALT
	JRST WMAC1C			;SKIP ON NO
WMAC1A:	HRRZ TT,1(A)
	PUSHJ P,WSTR
	HLRZ TT,1(A)
	PUSHJ P,WSTR			;WORKS FOR 9 BIT TEXT IF NO <META><NULL>'S
WMAC1C:	HRRZ A,(A)
	JUMPN A,WMAC1
WMAC8:	PUSHJ P,WRTZERO
	RELEASE DAT,
	POPJ P,

WMAC5:	HLRZ B,(A)
	HLLZ TTT,(B)
	SKIPE TTT
	MOVEI TTT,1		;MULTI-STRING VARIABLE
	PUSHJ P,WORDOUT
	JUMPE TTT,WMAC13
WMAC7:	MOVE TT,B
	PUSHJ P,WSTR
	HLRZ B,(B)
	JUMPN B,WMAC7
	JRST WMAC6		;NOTE: NULL STRING WRITTEN AS LAST OF MULTI-STRING VAR

MACOUT:	SKIPN A,MDPNT
	JRST WRTZERO			;NONE, MARK END
MACOU1:	HLRZ TT,(A)
	TRNN TT,MSAVE			;SHALL WE SAVE IT?
	JRST MACOU3
	HRRZ TT,1(A)
	PUSHJ P,WSTR			;WRITE MACRO NAME
	HLRZ TT,1(A)
	PUSHJ P,WSTR			;NOW BODY
MACOU3:	HRRZ A,(A)
	JUMPN A,MACOU1
	PUSHJ P,WRTZERO			;FINISH OFF
	POPJ P,

IMACRO:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/MACRO /]
	MOVSI T,EXTMCR
	PUSHJ P,SETNAM
	POPJ P,				;LET HIM OUT
	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,RSTRZ
	CAIA
	JRST IMAC2		;NO VARIABLES
IMAC8:	PUSHJ P,RSTRZ		;READ VARIABLE NAME
	JRST IMAC1
	MOVE D,T
	PUSHJ P,OUTTXT		;PRINT ALL VARIABLES
	OUTSTR[ASCIZ/
/]
	PUSHJ P,VARFND
	JRST IMAC6		;DOESN'T EXIST YET
	HLRZ C,1(E)
	JUMPE C,IMAC4
	HLRZ B,(C)
	PUSHJ P,PUTFS
	FSTRET (C)
	HRRZS 1(E)
IMAC4:	HLRZ B,(E)
IMAC5:	HLRZ D,(B)
	PUSHJ P,PUTFS
	SKIPE B,D
	JRST IMAC5
IMAC3:	PUSHJ P,WORDIN
	TLZE TTT,400000
	JRST IMAC9
	SKIPA C,TTT
IMAC7:	MOVE E,T
	PUSHJ P,RSTRZ
	JRST [	GETFS(T)	;MARK END OF MULTI STRING VAR
		SETZM (T)	;WITH NULL STRING
		SETZM 1(T)
		HRLM T,(E)
		JRST IMAC8]
	HRLM T,(E)
	JUMPN C,IMAC7		;MULTI-STRING?
	JRST IMAC8		;NO

IMAC6:	GETFS (E)		;MAKE NEW VARIABLE
	MOVE B,VARPNT
	HRRZM B,(E)
	HRRZM D,1(E)
	MOVEM E,VARPNT
	JRST IMAC3

IMAC9:	MOVE C,TTT
	PUSHJ P,RSTR
	GETFS (D)
	HRLM D,1(E)
	HRLZM T,(D)
	HRLM C,(T)
	HLRM C,(D)
	PUSHJ P,RSTR
	HRLM T,(E)
	TRNN C,400000
	JRST IMAC12
	MOVE T,1(T)		;ALPHABETIC VARIABLE
	ROT T,7
	MOVEM T,1(D)
	JRST IMAC8

IMAC12:	ADD T,[POINT 7,1]
	SETZB A,B
IMAC10:	PUSHJ P,GETTT		;CONVERT VALUE TO BINARY
	JRST IMAC11
	CAIN C,"-"
	SOJA A,IMAC10
	IMULI B,=10
	ADDI B,-"0"(C)
	JRST IMAC10

IMAC11:	SKIPE A
	MOVN B,B
	MOVEM B,1(D)
	JRST IMAC8

IMAC1:	PUSHJ P,RSTRZ
	JRST IMAC0
IMAC2:	SETZ C,				;CLEAR FLAGS WORD
	PUSHJ P,MACINX
IMAC0:	RELEASE DAT,
	POPJ P,

MACIN:	PUSHJ P,RSTRZ
	POPJ P,
MACINX:	MOVE D,T
	PUSHJ P,RSTR			;WORKS FOR 9 BIT IF NO <META><NULL>'S IN MACRO
	MOVE A,T
	PUSHJ P,ITMAKE			;MAKE THIS ONE
	IORM C,(E)			;OR IN BITS
	JRST MACIN
                                                                                   ;HERE TO DEFINE A NEW (OR REDEFINE AN OLD) VARIABLE

VARDEF:	TLNN	M,DSKACT!MACACT
	OUTSTR	[ASCIZ /VARIABLE DEFINITION?/]
	PUSHJ	P,VARNM		;BUILD LIST STRUCTURE FOR NAME
	CAIN	C,":"		;NAME ENDED WITH ":"?
	JRST	VARDE4		;YES
	CAIE	C,"="		;NAME ENDED WITH "="?
	CAIN	C,"_"		;NAME ENDED WITH "_"?
	JRST	VARDE4		;YES
	JRST INNERR

VARDE4:	PUSH	P,C		;SAVE NAME TERMINATING CHR
	PUSHJ	P,VARFND	;OLD VARIABLE?
	JRST	VARDE1		;NO, MAKE A NEW ONE
	JRST	VARDE2

VARDE1:	GETFS	(E)		;BUILD VARIABLE LIST STRUCTURE
	MOVE	B,VARPNT
	HRRZM	B,(E)		;HOOK INTO LIST OF VAR NAMES
	HRRZM	D,1(E)
	HRRZM	E,VARPNT
VARDE2:	PUSHJ	P,TREAD		;READ DEFINITION
	MOVE	D,B		;SAVE POINTER TO DEFINITION
	HLRZ	C,1(E)		;RETURN OLD DEFINITION TO FREE STG
	JUMPE	C,VARDE5	;MORE STRUCTURE EXISTS?
	HLRZ	B,(C)
	PUSHJ	P,PUTFS
VARDE5:	MOVE	B,(P)		;GET NAME TERMINATING CHR
	CAIE	B,"="		;NUMERIC VARIABLE?
	JRST	VARDE6		;NO, GO DEFINE STRING VARIABLE
	JUMPN	C,VARDE8	;NEED TO BUILD MORE STRUCTURE?
	GETFS	(C)		;YES
	HRLM	C,1(E)
	SETZM	1(C)
VARDE8:	HRLZM	D,(C)		;PLUG IN PTR TO NEW DEFINITION
	JRST	VARDE7

VARDE6:	JUMPE	C,VARDE7	;STRUCTURE TO FLUSH?
	SETZM	(C)
	MOVE	B,C
	PUSHJ	P,PUTFS		;YES, FLUSH IT
VARDE7:	HLRZ	B,(E)		;RETURN OLD VALUE
	JUMPE	B,VARD10
VARDE9:	HLRZ	C,(B)
	PUSHJ	P,PUTFS
	SKIPE	B,C		;MULTI-STRING VARIABLE VALUE?
	JRST	VARDE9		;YES, MORE TO RETURN
VARD10:	HRRZS	(E)		;CLEAR PTR TO OLD STRUCTURE
	POP	P,B		;GET NAME TERMINATING CHR
	CAIN	B,"="		;NUMERIC VARIABLE?
	JRST	VARNX0		;SET UP INITIAL VALUE
	HRLM	D,(E)		;PLUG IN NEW VALUE
	HRRZS	1(E)		;CLEAR PTR TO OLD STRUCTURE
	CAIE	B,":"		;MULTI-STRING DEFINITION?
	POPJ	P,
VARDE0:	TLNN	M,DSKACT!MACACT
	OUTCHR	[":"]		;PROMPT FOR NEXT LINE
	PUSHJ	P,TREAD		;GET NEXT STRING
	HRLM	B,(D)		;SAVE PTR TO STRING
	MOVE	D,B		;DO NEXT STRING
	SKIPE	1(B)
	JRST	VARDE0
	POPJ	P,
                                                                     VARFND:	MOVEI	E,VARPNT	;SEARCH VARIABLE LIST FOR A NAME
VARFN1:	HRRZ	E,(E)		;GET PTR TO NEXT VARIABLE
	JUMPE	E,CPOPJ		;AT END OF LIST?
	HRRZ	A,1(E)		;NO, COMPARE NAMES
	MOVE	B,D
	PUSHJ	P,TXTMAT
	JRST	VARFN1		;NOT FOUND, DO NEXT VARIABLE
	MOVE	B,D		;BINGO!
	AOS	(P)		;SKIP RETURN
	JRST	PUTFS		;RETURN NAME TO FREE STG

VARNUM:	SETZB	TTT,G		;READ ONE NUMBER FROM VARIABLE DEF
VARNU4:	PUSHJ	P,VARCHR	;GET NEXT CHR
	JRST	VARNU3		;AT END
	CAIL	T,"0"		;NUMERIC?
	CAILE	T,"9"
	JRST	VARNU2		;NO
	IMULI	TTT,=10		;COMPILE VALUE
	ADDI	TTT,-"0"(T)
	AOS	G		;COUNT CHARACTERS
	AOJA	D,VARNU4	;STEP TO NEXT INPUT CHR

VARNU2:	CAIN	T,"-"		;MINUS?
	TROE	G,200000	;YES, 2 MINUSES?
	JRST	VARNU3		;NOT MINUS OR 2 MINUSES, QUIT
	AOJA	D,VARNU4

VARNU3:	TRNE	G,200000	;MINUS TYPED?
	MOVNS	TTT		;YES, SO NEGATE VALUE
	POPJ	P,

VARCHR:	PUSHJ	P,VARBYT	;GET PTR TO CHR
	POPJ	P,		;OFF THE END
	LDB	T,TT		;GET CHR
	JUMPE	T,CPOPJ		;AT END
	CAIL	T,"a"		;LOWER CASE?
	CAILE	T,"z"
	JRST	CPOPJ1		;NO, DONE
	SUBI	T,40		;CONVERT TO UPPER CASE
	JRST	CPOPJ1

VARBYT:	MOVE	T,C		;GET TEXT PTR
	MOVE	TT,D		;GET CHR COUNT
VARBY1:	CAILE	TT,4		;CHR IN THE CURRENT WORD?
	JRST	[SUBI TT,5	;NO, REDUCE COUNT
		HRRZ T,(T)	;GET NEXT PTR
		JUMPN T,VARBY1	;AT END?
		POPJ P,]	;YES, RETURN
	MOVE	TT,VARBY2(TT)	;GET BYTE PTR
	JRST	CPOPJ1
VARBY2:	POINT	7,1(T),6	;TABLE OF BYTE PTRS FOR GETTING CHR
	POINT	7,1(T),13
	POINT	7,1(T),20
	POINT	7,1(T),27
	POINT	7,1(T),34
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     VARNM:	GETFS	(B)		;READ ONE VARIABLE NAME
	PUSH	P,B		;SAVE PTR TO START OF STRUCTURE
	SETZM	(B)
	SETZM	1(B)
	HRLI	B,020700	;MAKE A BYTE PTR
VARNM2:	PUSHJ	P,GETLIN	;GET ONE CHR
	CAIL	C,"a"		;LOWER CASE?
	CAILE	C,"z"
	JRST	VARNM1		;NO
	SUBI	C,40		;CONVERT TO UPPER CASE
VARNM3:	TLNE	B,760000	;PUT CHR INTO NAME. AT END OF WORD?
	JRST	VARNM4		;NO
	GETFS	(D)		;GET NEW WORD
	SETZM	(D)
	SETZM	1(D)
	HRRZM	D,-1(B)		;ADD TO END OF STRUCTURE
	HRR	B,D		;MAKE NEW BYTE PTR
VARNM4:	IDPB	C,B
	JRST	VARNM2

VARNM1:	CAIL	C,"A"		;ALPHABETIC?
	CAILE	C,"Z"
	CAIN	C,"."		;PERIOD?
	JRST	VARNM3		;YES, VALID SYMBOL CONSTITUENT
	CAIL	C,"0"		;NUMERIC?
	CAILE	C,"9"
	CAIN	C,"%"		;PERCENT?
	JRST	VARNM3		;YES, VALID
	CAIN	C,"$"		;DOLLAR SIGN?
	JRST	VARNM3		;YES, VALID
	POP	P,D		;NO, END OF SYMBOL. GET PTR TO BEGINING
	POPJ	P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;HERE TO TYPE THE VALUES OF ALL VARIABLES

VARTYP:	MOVEI	A,VARPNT	;POINT TO VARIABLE NAME LIST
VARTY1:	OUTSTR	[ASCIZ /
/]
	HRRZ	A,(A)		;GET NEXT VARIABLE
	JUMPE	A,CPOPJ		;DONE?
	HRRZ	T,1(A)		;PTR TO NAME
	PUSHJ	P,OUTTXT
	HLRZ	T,(A)		;MULTI-STRING VARIABLE?
	HLLZ	T,(T)
	HRRI	T,":"
	TLZE	T,-1
	JRST	VARTY2		;YES, FLAG WITH ":"
	HLRZ	T,1(A)		;STRING VARIABLE?
	SKIPN	T
	TROA	T,"_"		;YES, FLAG WITH "_"
	MOVEI	T,"="
VARTY2:	OUTCHR	T
	HLRZ	T,(A)		;PTR TO EXPANSION
	PUSHJ	P,OUTTXT
	JRST	VARTY1		;DO NEXT ONE

;HERE TO INCREMENT A VARIABLE

VARNXT:	TLNN	M,DSKACT!MACACT
	OUTSTR	[ASCIZ /VARIABLE NAME?/]
	PUSHJ	P,VARNM		;GET VARIABLE NAME
	CAIE	C,12		;ENDED WITH LINE FEED?
	JRST	INNERR		;NO, ERROR
	PUSHJ	P,VARFND	;LOOKUP VARIABLE NAME
	JRST	[VARN99:
		TLNN M,MACACT	;NOT FOUND
		OUTSTR [ASCIZ /NO SUCH NAME!/]
		MOVE B,D	;RETURN NAME TO FREE STG
		JRST PUTFS]

VARNX0:	HLRZ	B,1(E)		;GET PTRS TO VARIOUS PIECES OF STRUCTURE
	JUMPE	B,VARN40	;INCREMENTING A STRING VARIABLE?
	HLRZ	C,(B)		;PTR TO TEXT
	HRRZ	D,(B)		;CHR NUMBER
	PUSHJ	P,VARNUM	;NO, GET A NUMBER
	TRNN	G,177777	;ANY DIGITS SEEN?
	JRST	VARNX3		;NO
	PUSHJ	P,VARN31	;CHECK FORMAT
	JRST	VARILL		;NO, FORMAT ERROR
VARNX5:	MOVEM	TTT,1(B)	;SAVE VALUE
VARNX7:	HRRM	D,(B)		;SAVE CHR COUNT
	HRLM	G,(C)		;SAVE DIGIT COUNT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          VARNX8:	SKIPL	(C)		;ALPHABETIC VARIABLE?
	JRST	VARN16		;NO, PUT OUT A NUMBER
	HRRZ	D,1(B)
	HLRZ	B,(E)		;GET PTR TO OLD VALUE EXPANSION
	PUSHJ	P,PUTFS		;RETURN TO FREE STG
	GETFS	(T)		;MAKE NEW EXPANSION
	SETZM	(T)
	HRLM	T,(E)
	ROT	D,-7
	HLLZM	D,1(T)
	POPJ	P,

VARN16:	MOVE	T,1(B)		;GET THE NUMBER
	HLRZ	G,(C)		;GET DIGIT COUNT
	TRZ	G,600000	;CLR FLAG BITS
	GETFS	(TTT)		;BUILD NEW EXPANSION
	PUSH	P,TTT		;SAVE PTR TO BEGINNING
	SETZM	(TTT)
	SETZM	1(TTT)
	HRLI	TTT,020700	;MAKE BYTE PTR
	PUSHJ	P,VARN17	;DO THE DECIMAL PRINT
	HLRZ	B,(E)		;RETURN OLD EXPANSION TO FREE STG
	PUSHJ	P,PUTFS
	POP	P,T		;PLUG IN NEW EXPANSION
	HRLM	T,(E)
	POPJ	P,

VARNX1:	JUMPE	D,VARILL	;EMPTY DEFINITION?
	MOVEI	G,1		;NO USE DEFAULT INCREMENT OF 1

VARNX9:	MOVE	T,1(B)		;GET VALUE
	SKIPGE	(C)		;ALPHABETIC?
	JUMPN	G,VARN15	;YES, NON-ZERO INCREMENT?
	ADD	T,G		;NO, ADD INCREMENT TO VALUE
	JRST	VARN12

VARN15:	HRLOI	TTT,377777	;MAKE SUPER-BIG UPPER LIMIT
	JUMPG	G,VARN14	;INCREMENT POS?
	MOVNS	TTT		;NO, MAKE UPPER LIMIT NEGATIVE
	JRST	VARN14		;GO TO GIOQ SKIPPER
                                                                                                                                                                                                      VARN17:	JUMPGE	T,VARN19	;NEGATIVE?
	MOVNS	T		;YES, SO MAKE POSITIVE
	SETZM	G		;NO FIXED NUMBER OF DIGITS
	MOVEI	TT,"-"		;OUTPUT A MINUS SIGN
	IDPB	TT,TTT
VARN19:	IDIVI	T,=10		;RECURSIVE DECIMAL PRINT
	HRLM	TT,(P)
	SOSG	G		;DONT ZERO SUPPRESS UNTIL COUNT RUNS OUT
	SKIPE	T		;ALL DIGITS DONE?
	PUSHJ	P,VARN19	;NO
	HLRZ	TT,(P)
	ADDI	TT,"0"		;CONVERT DIGIT TO ASCII
VARN20:	TLNE	TTT,760000	;WORD FULL?
	JRST	VARN18		;NO
	GETFS	(D)		;YES, GET ANOTHER WORD
	HRRZM	D,-1(TTT)
	SETZM	1(D)
	SETZM	(D)
	HRR	TTT,D		;MAKE NEW BYTE PTR
VARN18:	IDPB	TT,TTT		;SAVE DIGIT
	POPJ	P,

VARNX3:	TRNE	G,200000	;MINUS TYPED?
	JRST	VARILL		;YES, ERROR BECAUSE NO DIGITS TYPED
	JUMPE	T,VARNX1	;AT END OF DEFINITION?
	CAIN	T,"("		;INCREMENT COMING?
	AOJA	D,VARNX2	;YES, GO GET IT
	CAIL	T,"A"		;ALPHABETIC VARIABLE?
	CAILE	T,"Z"
	JRST	[VARILL:OUTSTR [ASCIZ /ILLEGAL VARIABLE DEFINITION!/]
			POPJ P,]
	MOVEM	T,1(B)		;SAVE VALUE
	PUSHJ	P,VARN30	;GET NEXT CHR AND CHECK FORMAT
	JRST	VARILL		;NO, FORMAT ERROR!
VARNX6:	MOVEI	G,400000	;FLAG ALPHABETIC VARIABLE
	JRST	VARNX7
                                                                                                                                                                                                         VARNX2:	PUSHJ	P,VARNUM	;GET INCREMENT
	CAIE	T,")"		;MUST END WITH ")"
	JRST	VARILL
	PUSH	P,TTT		;SAVE VALUE
	AOS	D		;STEP TO NEXT CHR
	PUSHJ	P,VARNUM	;GET UPPER LIMIT
	POP	P,TT		;GET INCREMENT
	TRNN	G,177777	;ANY DIGITS TYPED?
	JRST	VARN10		;NO
	PUSHJ	P,VARN31	;CHECK FORMAT
	JRST	VARILL		;NO, FORMAT ERROR

VARN11:	JUMPE	TT,VARILL	;0 INCREMENT WONT GO ANYWHERE
	SKIPGE	(C)		;ALPHABETIC?
	JRST	VARILL		;YES, SO NUMERIC UPPER LIMIT ILLEGAL
	MOVE	T,1(B)		;GET VALUE
	JUMPL	TT,[CAMG T,TTT	;ARGS IN RIGHT ORDER FOR NEG INCREMENT?
		    JRST VARILL	;NO
		    ADD T,TT	;ADD INCREMENT TO VALUE
		    CAMG T,TTT	;GONE PAST UPPER LIMIT?
		    MOVE T,TTT	;YES, USE UPPER LIMIT ITSELF
		    JRST VARN12];NO
	CAML	T,TTT		;ARGS IN RIGHT ORDER FOR POS INCREMENT?
	JRST	VARILL		;NO
	ADD	T,TT		;ADD INCREMENT TO VALUE
	CAML	T,TTT		;GONE PAST UPPER LIMIT?
	MOVE	T,TTT		;YES, USE UPPER LIMIT AS VALUE
VARN12:	MOVEM	T,1(B)		;SAVE INCREMENTED VALUE
	CAMN	T,TTT		;AT UPPER LIMIT?
	HRRM	D,(B)		;YES, UPDATE CHR COUNT
	JRST	VARNX8		;EXPAND THE RESULT

VARN10:	TRNE	G,200000	;MINUS TYPED?
	JRST	VARILL		;YES, ILLEGAL ALPHABETIC!
	MOVE	G,TT		;SAVE INCREMENT
	JUMPE	T,VARNX9	;AT END OF DEFINITION?
	CAIL	T,"A"		;ALPHABETIC UPPER LIMIT?
	CAILE	T,"Z"
	JRST	VARILL		;NO
	MOVE	TTT,T		;SAVE UPPER LIMIT
	JUMPE	G,VARILL	;INCREMENT 0?
	PUSHJ	P,VARN30	;GET NEXT CHR AND CHECK FORMAT
	JRST	VARILL		;NO, FORMAT ERROR
VARN13:	SKIPL	(C)		;ALPHABETIC VALUE?
	JRST	VARILL		;NO, ALPHABETIC UPPER LIMIT ILLEGAL
	MOVE	T,1(B)		;GET VALUE
                                                                                                                                                                                                                                                                                                                                                                                           VARN14:	JUMPL	G,[CAMG T,TTT	;ARGS IN RIGHT ORDER FOR NEG INCREMENT?
		    JRST VARILL	;NO
		    ADD G,T	;ADD INCREMENT TO VALUE
		    CAILE T,"Q"	;WENT PAST Q?
		    CAILE G,"Q"
		    CAIA	;NO
		    SOS G	;YES, IT SHOULD BE SKIPPED
		    CAILE T,"O"	;WENT PAST O?
		    CAILE G,"O"
		    CAIA	;NO
		    SOS G	;YES, IT SHOULD BE SKIPPED
		    CAILE T,"I"	;WENT PAST I?
		    CAILE G,"I"
		    CAIA	;NO
		    SOS G	;YES, IT SHOULD BE SKIPPED
		    CAILE T,"G"	;WENT PAST G?
		    CAILE G,"G"
		    SKIPA T,G	;NO
		    SOS T,G	;YES, IT SHOULD BE SKIPPED
		    CAMG G,TTT	;WENT PAST UPPER LIMIT?
		    MOVE T,TTT	;YES, USE UPPER LIMIT AS VALUE
		    JRST VARN12];NO
	CAML	T,TTT		;ARGS IN RIGHT ORDER FOR POS INCREMENT?
	JRST	VARILL		;NO
	ADD	G,T		;ADD VALUE TO INCREMENT
	CAIGE	T,"G"		;WENT PAST G?
	CAIGE	G,"G"
	CAIA			;NO
	AOS	G		;YES, IT SHOULD BE SKIPPED
	CAIGE	T,"I"		;WENT PAST I?
	CAIGE	G,"I"
	CAIA			;NO
	AOS	G		;YES, IT SHOULD BE SKIPPED
	CAIGE	T,"O"		;WENT PAST O?
	CAIGE	G,"O"
	CAIA			;NO
	AOS	G		;YES, IT SHOULD BE SKIPPED
	CAIGE	T,"Q"		;WENT PAST Q?
	CAIGE	G,"Q"
	SKIPA	T,G		;NO
	AOS	T,G		;YES, IT SHOULD BE SKIPPED
	CAML	G,TTT		;WENT PAST UPPER LIMIT?
	MOVE	T,TTT		;YES, USE UPPER LIMIT AS VALUE
	JRST	VARN12		;NO
           VARN30:	AOS	D		;STEP TO NEXT CHR
	PUSHJ	P,VARCHR	;GET IT
VARN31:	JUMPE	T,CPOPJ1	;END OF DEFINITION IS LEGAL
	CAIN	T,","		;COMMA IS VALID
	AOJA	D,CPOPJ1	;MOVE PAST COMMA
	CAIE	T,"("		;NEW INCREMENT ALSO LEGAL
	POPJ	P,		;OTHERS ARE ILLEGAL
	JRST	CPOPJ1

VARN40:	HLRZ	C,(E)		;PTR TO STRING
	HLRZ	D,(C)		;MULTI-STRING VARIABLE
	JUMPN	D,VARN44	;NON 0 = MULTISTRING, 0=START AT 1ST CHR
VARN41:	PUSHJ	P,VARCHR	;SEARCH FOR FIRST NUMBER
	JRST	[TLNN M,MACACT
		OUTSTR [ASCIZ /NO NUMBER TO INCREMENT!/]
		POPJ P,]
	CAIL	T,"0"
	CAILE	T,"9"
	AOJA	D,VARN41
	MOVE	G,D		;SAVE POSITION OF 1ST DIGIT
VARN42:	PUSHJ	P,VARCHR	;SEARCH FOR END OF NUMBER
	JRST 	.+3		;END OF DEFINITION
	CAIL	T,"0"
	CAILE	T,"9"
	SOSA	D		;STEP BACK TO LAST DIGIT
	AOJA	D,VARN42
VARN43:	PUSHJ	P,VARBYT	;GET BYTE PTR TO CHR
NODEC,<	HALT	.+1	>	;CANT HAPPEN
DEC,<	PUSHJ	P,TODDT	>
	LDB	TTT,TT		;GET DIGIT
	AOS	TTT
	CAIN	TTT,"9"+1	;DIGIT OVERFLOW?
	MOVEI	TTT,"0"		;YES
	DPB	TTT,TT		;SAVE INCREMENTED DIGIT
	CAIE	TTT,"0"		;NEED TO PROPAGATE A CARRY?
	POPJ	P,		;NO
	CAMLE	D,G		;YES, OVERFLOWING FIELD?
	SOJA	D,VARN43	;NO, INCREMENT NEXT DIGIT
	OUTSTR	[ASCIZ /NUMERIC FIELD OVERFLOW!/]
	POPJ	P,

VARN44:	HRLM	D,(E)		;NEXT STRING BECOMES CURRENT VALUE
	SKIPN 1(D)		;IS THIS END OF MULTI STRING VAR?
	SETOM ENDMUL		;YES, FLAG IT
	MOVE	B,C		;RETURN OLD STRING
	JRST	PUTFS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          COMMENT    VALID 00012 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(PLT,5)
C00005 00003	PUT OUT BODYS
C00008 00004	CALL POINT SUBRS, DO END STUFF
C00012 00005	POINTS (D)
C00018 00006	LINE SUBR (D)
C00021 00007	DIAMONDS, RANDOM NUMBERS (D)
C00023 00008	LINE TABLES (D)
C00025 00009	POINTS (PC)
C00028 00010	OFFSET TEXT ROUTINE
C00032 00011	OUTPUT ROUTINES
C00035 00012	
C00036 ENDMK
C;
                                                                                                                                                                                                                        VERSION(PLT,5)
;SETUP

MPC,<
SIGPLT:	SETZM FILNAM
	TLO WFLAG
	JRST SIGPL1
>;MPC

EWPLOT:	MOVSI T,EXTPLT
	PUSHJ P,SETLST		;WILL SKIP IF THERE IS SAVED NAME
	JRST PLOT
NOSTAN,<
MPC,<	MOVE T,[POINT 6,FILNAM]
EWPLT1:	ILDB TT,T
	JUMPE TT,EWPLT2
	TLNE T,770000
	JRST EWPLT1
EWPLT2:	TLNN SID,FRONT
	SKIPA TT,['S']		;BACK IS SOLDER
	MOVEI TT,'C'		;FRONT IS COMPONENT
	DPB TT,T
>;MPC
>;NOSTAN
	CAIA
PLOT:	SETZM FILNAM
MPC,<	TLZ WFLAG		;CLEAR FLAG FOR SIG FILES
SIGPL1:	SETZM CPLANE
	TRNN M,FLIP		;DO WE WARN HIM?
	JUMPL SID,PLPLT1
	TRNE M,FLIP
	JUMPGE SID,PLPLT1
	OUTSTR[ASCIZ/TEXT IS INVALID UNLESS YOU PLOT THIS FLIPPED!
/]
	CAIA
PLPLOT:	SETZM FILNAM		;FLAG NEED TO ASK FILENAME
PLPLT1:	>;MPC
MD,<	MOVEI T,10
	MOVEM T,CSCALE
	SETOM CBOX		;NO DEFAULT BOX SIZE
	CAIA
DPLOT:	SETZM FILNAM
	MOVE T,CSCALE
	IMUL T,CMUL+STDBIG
STAN,<
IFE STDBIG-1,<
	PUSH P,T
>
>;STAN
	IMULI T,CWIDTH
	MOVEM T,LSCALX
STAN,<
IFE STDBIG-1,<
	POP P,T
	IMULI T,CWIDTH+1
	MOVEM T,LSCLX1
>
>;STAN
	MOVE T,CSCALE
	IMULI T,CHGHT
	IMUL T,CMUL+STDBIG
	ASH T,-1
	MOVEM T,LSCALY
>;MD
	SKIPE FILNAM		;ALREADY GOT NAME?
	JRST GOTPNM
	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ /PLOT /]
	MOVSI T,EXTPLT
MPC,<	TLNE WFLAG
	MOVSI T,EXTSIG
>;MPC
	PUSHJ P,SETNAM
	POPJ P,
GOTPNM:	ENTPPN
	INIT DAT,10
	SIXBIT /DSK/
	XWD IOHD,0
	JRST [	OUTSTR[ASCIZ/WHERE'S THE DISK!
/]
		POPJ P,]
	PUSHJ P,EXIST	;SEE IF IT ALREADY EXISTS
	POPJ P,		;DON'T OVERWRITE
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER DAT,FILNAM
	JRST [	OUTSTR [ASCIZ/, ENTER FAILED.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
	MOVEI A,IOBUF
	EXCH A,.JBFF
	OUTBUF DAT,2
	MOVEM A,.JBFF
MPC,<	SETZM MXPADN	>
MD,<	MOVEI TTT,PLTVER	;PUT OUT PLOT VERSION #	>
MPC,<	MOVEI TTT,PCPVER	;PUT OUT PLOT VERSION #	>
	PUSHJ P,PUTWRD
                                                                                                 ;PUT OUT BODYS
MD,<	MOVE B,DBODPN
	JUMPE B,NOBOSS
PBLP:	HLRZ C,(B)	;GET POINTER TO DATA BLOCK
	TLNN M,BLOCS	;SHALL WE DO DIP NUMBER?
	JRST NOLOC
	HLRZ D,1(C)	;DIP NUMBER BLOCK
	HLRZ T,1(D)	;BODY BITS
	TRNN T,FIXLOC	;IS IT TRACKING DEF?
	JRST DISLC2	;NO, NO CHECK
	HRRZ T,1(C)	;BODY DEF POINTER
	HLRZ T,1(T)
	HLRZ T,(T)
	HLRZ T,(T)	;BODY DEF BITS
	TRNE T,XDISLOC	;SHOULD WE DISPLAY LOC?
	JRST NOLOC	;NO
DISLC2:	HRRZ D,(D)
	JUMPE D,NOLOC	;SKIP IF NO LOC BLOCK
	MOVE T,1(B)	;LOC OF BODY
	ADJUST(ADD,T,<1(D)>)	;OFFSET FOR NLNLN
	HLRZ TTT,(D)
	PUSHJ P,TXTCAL
	PUSHJ P,PUTWRD
	HLRZ D,(D)
	PUSHJ P,STDSIZ	;SMALLEST SIZE
	PUSHJ P,PLTBNM	;PLOT DIP NUMBER
NOLOC:	HRRZ D,1(C)	;GET POINTER TO TYPE
	HLRZ F,(C)	;GET ORIENTATION
	HLRZ E,1(D)	;GET POINTER TO TYPE DATA BLOCK
	HRRZ A,1(E)	;GET POINTER TO TYPE LINES
	JUMPE A,NOLINS	;NONE?
PLOPP1:	MOVE T,1(A)	;GET X,Y OF LINE
	TRZE T,1	;VIS OR INVIS?
	JRST [PUSHJ P,PINVS  ;INVISIBLE
		JRST .+2]
	PUSHJ P,PVIS	;VISIBLE
	HRRZ A,(A)	;GO TO NEXT LINE
	JUMPN A,PLOPP1
NOLINS:	TRNE M,NBTEXT
	JRST NOTINS
	HLRZ A,(B)
	HLRZ A,1(A)
	HRRZ A,1(A)
	JUMPE A,PBTLP0
PBTLP1:	HLRZ T,(A)
	JUMPN T,PBTLP2
	PUSH P,A
	HRRZ A,1(A)
	PUSHJ P,PBTLPX
	POP P,A
	JRST PBTLP3

PBTLP2:	PUSHJ P,PBTLPX
PBTLP3:	HRRZ A,(A)
	JUMPN A,PBTLP1
	JRST NOTINS

PBTLP0:	HLRZ A,1(E)	;GET POINTER TO TEXT
	JUMPE A,NOTINS	;NONE?
PBTLP:	PUSHJ P,PBTLPX
	HRRZ A,(A)	;GET NEXT TEXT
	JUMPN A,PBTLP
NOTINS:	HRRZ B,(B)	;GET NEXT BODY
	JUMPN B,PBLP	;LOOP
	JRST NOBOSS

PBTLPX:	HLRZ T,(A)
	HRRZ T,(T)
	HLRZ T,(T)
	TLNN M,%IDENT
	JUMPE T,CPOPJ
	MOVE T,1(A)	;GET X,Y
	TDZ T,[1,,1]
	PUSHJ P,ORIENT	;ORIENT IT
	ADJUST(ADD,T,<1(B)>);ADD BODY CENTER
	HLRZ TTT,(A)	;GET POINTER TO TEXT DATA BLOCK
	JRST PTXTS	;PLOT TEXT (GENERAL FORMAT)
                                                                                                                                  ;CALL POINT SUBRS, DO END STUFF
NOBOSS:	MOVE B,PONPNT	;GET ON-SCREEN POINTER
	PUSHJ P,SETBTS	;SET THE BITS UP
	TLNN M,DIAMONDS	;SHALL WE DO THE DIAMONDS?
	JRST NODIAMONDS
	MOVE B,PONPNT
	PUSHJ P,DODIAMONDS
NODIAMONDS:
	SETZM CIRC	;DON'T DO CLOSED LOOPS YET!
>;MD
	SKIPE B,PONPNT	;GET ON-SCREEN POINTER
	PUSHJ P,DOPNTS	;DO THE POINTS
MD,<	SETOM CIRC	;NOW GET THE CLOSED LOOPS
	SKIPE B,PONPNT
	PUSHJ P,DOPNTA
	AOSG TTT,CBOX		;GET BOX ID
	JRST NOTBOX		;NONE
	MOVE TTT,BTAB-1(TTT)	;GET LETTER FOR THIS BOX
	SUBI TTT,"A"-1		;AND NORMALIZE IT SO A=1
	TLZE TTT,400000		;VERT?
	TRO TTT,200000		;YES
	LSH TTT,1		;MAKE SURE LOW ORDER BIT ISN'T ON!
NOTBOX:	HRLI TTT,400001
	PUSHJ P,PUTWRD
FOR I IN(TAUTHOR,TIT1,TIT2)
<	MOVE T,I
	PUSHJ P,PSTR
>
	MOVE TTT,DRWDAT
	PUSHJ P,WORDOUT		;STUFF DATE INTO FILE AFTER AUTHOR TITLE STUFF
	SKIPN TTT,DRWNAM
	MOVE TTT,FILNAM
	PUSHJ P,WORDOUT
	MOVE TTT,DRWPPN
	PUSHJ P,WORDOUT
	PUSHJ P,INIPCH
	HLRZ A,CRDLOC
	PUSHJ P,SLTOUT		;MAKE STRING OF SLOT LOCATION
	PUSHJ P,FINPCZ
	MOVE T,TREV
	PUSHJ P,PSTR
	PUSHJ P,INIPCH
	SKIPE T,TMODULE
	PUSHJ P,PCHRS
	SKIPN T,TVARIABLE
	JRST NOPVAR
	PUTBYT "-"
	PUSHJ P,PCHRS
NOPVAR:	SKIPN T,TPREFIX
	JRST NOPFIX
	PUTBYT "-"
	PUSHJ P,PCHRS
NOPFIX:	PUSHJ P,FINPCZ
FOR I IN(TPROJ,TPAGE,TOF,TDCODE,SITE1,SITE2)
<	MOVE T,I
	PUSHJ P,PSTR
>
DEC,<	MOVE T,TNXTHI
	PUSHJ P,PSTR
FOR @$I IN(DRN,CHK,ENG)
<	SKIPN TTT,I$NAM
	JRST NOP$I
	PUSHJ P,WORDOUT
	MOVE TTT,I$NAM+1
	PUSHJ P,WORDOUT
	MOVE TTT,I$NAM+3
NOP$I:	PUSHJ P,WORDOUT
>
>;DEC
>;MD
MPC,<	HLRZ TTT,SID
	SKIPE CPLANE	;INNER PLANE?
	TRO TTT,200000	;YES
	HRLI TTT,400001
	PUSHJ P,PUTWRD
	TLNE WFLAG
	JRST SIGPL2
	TRNN M,FLIP		;FLIPPED?
	TDZA TTT,TTT
	MOVEI TTT,1		;FLIPPED BIT TO PLOT PROG
	PUSHJ P,PUTWRD
	MOVE TTT,CRDNAM
	PUSHJ P,WORDOUT
	HLLZ TTT,CRDEXT
	PUSHJ P,WORDOUT
	MOVE TTT,CRDPPN
	PUSHJ P,WORDOUT
	PUSHJ P,MXPADQ		;PRINT MAX PAD # SEEN
SIGPL2:
>;MPC
	RELEASE DAT,
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;POINTS (D)
MD,<
DOPNTS:	HLRZ C,(B)	;GET POINTER TO DATA BLOCK
	HRRZ D,1(C)	;GET POINTER TO BITS AND TEXT BLOCK
	HLL D,1(D)
	TLNE M,CLOCS	;DOING LOCATIONS?
	TLNN D,CPIN	;AND CONNECTOR PIN!?
	JRST CNOPIN	;NO
	MOVE T,1(B)
	HRRZ E,(D)
	HLRZ F,(D)
	JUMPE F,NTXCPN
	HRRZ F,(F)
	HLRZ F,(F)	;GET TEXT SIZE FOR REFERENCE
NTXCPN:	MOVE TTT,E
	PUSHJ P,TXTCAL	;CALC OFFSET
	PUSHJ P,PUTWRD	;WRITE IT
	TLZ TTT,1
	PUSH P,TTT
	PUSHJ P,VSIZES	;CHECKS FOR VERT BIT IN F
	PUSHJ P,PLTCNM
	TRNE M,NOCBOX	;DOING BOX?
	JRST NPTCBX
	MOVE TTT,(P)
	PUSHJ P,PUTWRD	;START BOX
	PUSH P,B	;SAVE B
	MOVE B,E
	PUSHJ P,CONCAL	;CALC LENGTH OF CPIN DESIG
	POP P,B
STAN,<
IFE STDBIG-1,<
	SKIPE XTHICK
	IMUL T,LSCLX1	;SCALE IT FOR WIDE CHARACTER SET
	SKIPN XTHICK
>
>;STAN
	IMUL T,LSCALX	;SCALE IT
	TRNE F,400000	;VERT?
	JRST VCONBX
	MOVSS TTT,T	;MAKE IT X PART
	ADD TTT,(P)	;GO RIGHT
	PUSHJ P,PUTLIN	;+X,0
	HRLZ TT,LSCALX
	ADD TTT,LSCALY
	ADD TTT,TT
	PUSHJ P,PUTLIN	;+X,+Y
	SUB TTT,TT
	ADD TTT,LSCALY
	PUSHJ P,PUTLIN	;-X,+Y
	SUB TTT,T
	PUSHJ P,PUTLIN	;-X,0
	SUB TTT,TT
	SUB TTT,LSCALY
	PUSHJ P,PUTLIN	;-X,-Y
	ADD TTT,TT
	SUB TTT,LSCALY
	PUSHJ P,PUTLIN	;+X,-Y
	JRST NPTCBX

VCONBX:	MOVE TTT,T	;GET IT HERE
	ADD TTT,(P)	;GO UP
	TLZ TTT,1
	PUSHJ P,PUTLIN	;0,+Y
	HRLZ TT,LSCALY
	SUB TTT,TT
	ADD TTT,LSCALX
	TLZ TTT,1
	PUSHJ P,PUTLIN	;-X,+Y
	SUB TTT,TT
	TLO TTT,1
	SUB TTT,LSCALX
	TLZ TTT,1
	PUSHJ P,PUTLIN	;-X,-Y
	TLO TTT,1
	SUB TTT,T
	TLZ TTT,1
	PUSHJ P,PUTLIN	;0,-Y
	ADD TTT,TT
	TLO TTT,1
	SUB TTT,LSCALX
	TLZ TTT,1
	PUSHJ P,PUTLIN	;+X,-Y
	ADD TTT,TT
	ADD TTT,LSCALX
	TLZ TTT,1
	PUSHJ P,PUTLIN	;+X,+Y
NPTCBX:	POP P,(P)
	JRST TSTXT

CNOPIN:	TLNN D,ISPIN
	JRST TSTXT
	TLNN M,PLOCS	;DOING PINS?
	JRST PCKPND	;NO, CHECK ID'S
	HRRZ TT,(D)
	HLRZ TT,(TT)
	HLRZ T,(TT)
	TRNE T,BUSSED
	JRST TSTXT
	HRLZ A,1(D)
	JUMPN A,PLTPNN
	TLNN M,PINIDS
	JRST TSTXT
	HRLZ A,1(TT)
PLTPNN:	HLRZ TT,(C)	;BODY POINTER
	HLRZ TT,(TT)
	HLRZ TT,1(TT)
	HLR A,1(TT)	;BODY BITS
	PUSH P,A
	SETZM CHRCNT
	PUSH P,PUTCHR
	MOVE TTT,[AOS CHRCNT]
	MOVEM TTT,PUTCHR
	PUSHJ P,PINPLS
	POP P,PUTCHR
	MOVN A,CHRCNT	;GET LEN OF PIN #
	HLRZ TT,(C)	;BODY POINTER
	HLRZ TT,(TT)
	HLRZ TTT,(TT)	;GET ORIENTATION
	HRRZ T,(D)	;GET PIN TYPE BLOCK POINTER
	HLRZ T,(T)	;PIN POS, BITS, ETC BLOCK
	PUSHJ P,PINCAL	;CALC X,Y OFFSET FOR PIN #
	PUSHJ P,PNSPOT	;CALC PIN LOC, OUTPUT IT, SWITCH TO SIZE 1 ( OR 2)
	POP P,A
	PUSHJ P,INIPCH
	PUSHJ P,PINPLS
	PUSHJ P,FINPCH
	JRST TSTXT

PCKPND:	TLNN M,PINIDS
	JRST TSTXT
	HRRZ T,(D)	;PIN TYPE BLOCK POINTER
	HLRZ T,(T)	;BITS, NAME, ETC BLOCK
	HLRZ TTT,(C)
	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)	;ORIENTATION
	PUSHJ P,PIDCAL
	PUSHJ P,PNSPOT
	PUSHJ P,PLTPND
TSTXT:	TRNE M,NPTEXT
	JRST NOPTXT
	HLRZ TTT,(D)	;GET TEXT POINTER
	JUMPE TTT,NOPTXT	;NONE?
	MOVE T,1(B)		;TEXT LOC
	PUSHJ P,PTXTS		;DO IT
NOPTXT:	MOVS E,1(D)	;GET BITS
	ANDI E,17	;CLEAR OTHERS
	PUSH P,B	
	XCT PPTB1(E)	;CALL THE ROUTINE OR NOT
	POP P,B
	HRRZ B,(B)	;GET NEXT ONE
	JUMPN B,DOPNTS
	POPJ P,

PNSPOT:
	IMUL A,CSCALE		;DO CHAR SCALE THING
	IMUL TT,CSCALE
	HRRE TTT,1(B)
	SUB TTT,YOFF
	SCALET (TTT)
	ADD TTT,TT	;Y PART
	TRZE TTT,1
	ADDI TTT,2
	HLRE TT,1(B)
	SUB TT,XOFF
	SCALET (TT)
	ADD TT,A
	HRL TTT,TT
	TLO TTT,1
	PUSHJ P,PUTWRD	;THIS WILL PUT THE PIN # IN THE RIGHT PLACE (I HOPE!)
	JRST STDSIZ
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;LINE SUBR (D)
DOPNTA:	HLRZ C,(B)
	HRRZ D,1(C)
	HLRZ E,1(D)
	ANDI E,17		;JUST GOOD BITS
	PUSH P,B		;SAVE THIS GUY
	CAIE E,17		;ALL DONE?
	PUSHJ P,DOPPIT		;NO, FINISH THE BUM
	POP P,B
	HRRZ B,(B)
	JUMPN B,DOPNTA
	POPJ P,

DOPPIT:	HLRZ A,1(C)	;GET POINTER TO ^_ BLOCK
	XCT PPTB2(E)	;GET POINTER TO NEXT (LINE) POINT
	HRLZ C,PPTB3(E)	;TURN ON BIT FOR LINE WE ARE DOING
	ORM C,1(D)	;......
	MOVE T,1(B)	;GET X,Y
	MOVEI TTT,0
	PUSHJ P,PUTXY	;DO THE LINE(BEGGINING POINT)
PLPLOP:	MOVE A,PPTB3(E)	;GET MAGIC BITS
	MOVE B,F	;GET POINTER TO NEXT POINT IN LINE
	HLRZ C,(B)	;GET POINTER TO DATA BLOCK
	HRRZ D,1(C)	;GET POINTER TO BITS AND TEXT BLOCK
	IOR A,1(D)	;TURN ON BIT FOR LINE WE ARE DOING
	HLLM A,1(D)	;STORE
	HLRS A
	ANDI A,17	;GET BITS
	MOVE T,1(B)	;GET X,Y
	MOVEI TTT,1
	PUSHJ P,PUTXY	;DRAW THE LINE
	HRLZ E,PPTB3(A)	;GET MAGIC BITS
	XCT PPTB5(A)	;TO SKIP OR NOT TO SKIP!
	POPJ P,		;QUIT IF NO SKIP!
	ORM E,1(D)	;TURN ON BIT FOR NEXT SEGMENT
	MOVE E,A
	HLRZ A,1(C)	;GET POINTER TO ^_ BLOCK
	XCT PPTB2(E)	;GET POINTER TO NEXT POINT IN LINE
	JRST PLPLOP

SETBTA:	PUSHJ P,SETBTO
	HRRZ B,(B)
SETBTS:	JUMPN B,SETBTA
	POPJ P,

SETBTO:	HLRZ C,(B)	;GET POINTER TO DATA BLOCK
	HLRZ D,1(C)	;GET POINTER TO ^_ BLOCK
	HRRZ E,1(C)	;GET POINTER TO BITS BLOCK
	MOVE F,1(E)	;GET BITS WORD
	TLZ F,17	;TURN OFF THE "SEGMENT DONE" BITS
	MOVE A,(D)	;GET THE ^ POINTER WORD
	TRNN A,-1	;ANY ^?
	TLO F,1		;NO
	TLNN A,-1	;ANY ?
	TLO F,2		;NO
	MOVE A,1(D)	;GET _ POINTER WORD
	TRNN A,-1
	TLO F,4
	TLNN A,-1
	TLO F,10
	MOVEM F,1(E)	;RE-DEPOSIT WORD
	POPJ P,
                                                                                                                                                                                                                                                                                                                            ;DIAMONDS, RANDOM NUMBERS (D)
DODIAMONDS:
	JUMPE B,CPOPJ
	HLRZ A,(B)
	HRRZ A,1(A)
	HLRZ A,1(A)
	ANDI A,17		;THESE ARE THE BITS
	XCT PPTB4(A)		;DISPATCH
	HRRZ B,(B)
	JRST DODIAMONDS

PUTTI3:	TLNN M,JUNC3		;DOING JUNCTIONS OF 3?
	POPJ P,			;NO
PUTTIT:	MOVE T,1(B)
	MOVSI TTT,1
	PUSHJ P,PUTXY
	MOVE TTT,[2,,1]		;CODE FOR DIAMOND
	JRST PUTWRD

PLTPND:	PUSHJ P,INIPCH
	PUSHJ P,OUTPID
	JRST FINPCH

PLTBNM:	PUSHJ P,INIPCH
	PUSH P,A	;I DONT THINK THIS IS NEEDED
	HLRZ A,(D)
	PUSHJ P,SLTOUT
	HRRZ A,(D)
	PUSHJ P,LOCOUT
FNPCHA:	POP P,A
	JRST FINPCH

PLTCNM:	PUSHJ P,INIPCH
	PUSH P,A		;IS THIS NEEDED?
	MOVS A,(E)
	PUSHJ P,CSLTLP
	JRST FNPCHA
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;LINE TABLES (D)
PPTB1:	JFCL
	PUSHJ P,DOPPIT
	PUSHJ P,DOPPIT
	JFCL
	PUSHJ P,DOPPIT
	JFCL
	JFCL
	PUSHJ P,DOPPIT
	PUSHJ P,DOPPIT
	JFCL
	JFCL
	PUSHJ P,DOPPIT
	JFCL
	PUSHJ P,DOPPIT
	PUSHJ P,DOPPIT
	JFCL

PPTB2:	HLRZ F,1(A)	;_^		_
	HLRZ F,(A)	;_		
	HRRZ F,(A)	;_^		^
	HLRZ F,1(A)	;_		_
	HLRZ F,1(A)	;_^		_
	HLRZ F,1(A)	;_		_
	HLRZ F,1(A)	;_^		_
	HLRZ F,1(A)	;_		_
	HRRZ F,1(A)	;^		
	HRRZ F,1(A)	;^		
	HRRZ F,1(A)	;		
	HRRZ F,1(A)	;		
	HRRZ F,(A)	;^		^
	HLRZ F,(A)	;		
	HRRZ F,(A)	;^		^
	JRST 4,.	;0		0

PPTB3:	4,,10
	1,,2
	2,,1
	4,,10
	4,,10
	4,,10
	4,,10
	4,,10
	10,,4
	10,,4
	10,,4
	10,,4
	2,,1
	1,,2
	2,,1
	0

PPTB4:	PUSHJ P,PUTTIT		;0
	PUSHJ P,PUTTI3		;1
	PUSHJ P,PUTTI3		;2
	JFCL			;3
	PUSHJ P,PUTTI3		;4
	JFCL			;5
	JFCL			;6
	JFCL			;7
	PUSHJ P,PUTTI3		;10
	JFCL			;11
	JFCL			;12
	JFCL			;13
	JFCL			;14
	JFCL			;15
	JFCL			;16
	JFCL			;17

PPTB5:	SKIPN CIRC
	CAIA
	CAIA
	SKIPN CIRC
	CAIA
	SKIPN CIRC
	SKIPN CIRC
	CAIA
	CAIA
	SKIPN CIRC
	SKIPN CIRC
	CAIA
	SKIPN CIRC
	CAIA
	CAIA
	JFCL		;ALWAYS QUIT ON THIS ONE!!!
>;MD
                                                                                                                                                     ;POINTS (PC)
MPC,<
DOPNTS:	HLRZ C,(B)	;GET POINTER TO DATA BLOCK
	HRRZ D,1(C)	;GET POINTER TO BITS AND TEXT BLOCK
	TLNE WFLAG	;IF SIG FILE
	JRST PNOPIN	;SKIP ALL PADS ETC.
	TRNE M,NPTEXT
	JRST NOPTXT
	HLRZ TTT,(D)	;GET TEXT POINTER
	JUMPE TTT,NOPTXT	;NONE?
	MOVE T,1(B)
	PUSHJ P,PTXTS
NOPTXT:	MOVE G,1(B)
	MOVE E,1(D)
	TLNN E,ISPIN!FEEDTH
	JRST DOPADA
	MOVE T,G
	MOVSI TTT,1
	PUSHJ P,PUTXY
	MOVE TTT,[2,,1]		;DRILL HOLE!
	PUSHJ P,PUTWRD
DOPADA:	TRNN E,-1		;ANY PAD TYPE?
	JRST PNOPIN		;NO
	SKIPN CPLANE
	JRST DOPAD
	LDB T,[POINT 3,E,6]	;PLANE NUMBER
	CAMN T,CPLANE
	JRST PNOPIN
DOPAD:	MOVE T,G
	MOVSI TTT,1
	PUSHJ P,PUTXY
	HRRZ TTT,E
	CAMLE TTT,MXPADN
	MOVEM TTT,MXPADN
	LSH TTT,1
	TDO TTT,[4,,1]		;MARK AS PAD!
	PUSHJ P,PUTWRD
PNOPIN:	PUSH P,B	
	HLRZ B,1(C)
	JUMPE B,PPTB4
PPTB1:	MOVEI H,2
PPTB2:	XCT (H)[HLRZ A,(B)
		HRRZ A,1(B)
		HLRZ A,1(B)]
	JUMPE A,PPTB3
	CAML G,1(A)
	JRST PPTB3
	MOVE TTT,1(A)
	PUSH P,G
	PUSH P,C
	PUSHJ P,PADFIX
	MOVE T,G
	MOVEI TTT,0
	PUSHJ P,PUTXY
	HLRZ C,(A)
	MOVE TTT,-1(P)
	MOVE G,1(A)
	PUSHJ P,PADFIX
	MOVE T,G
	MOVEI TTT,1
	PUSHJ P,PUTXY
	POP P,C
	POP P,G
PPTB3:	SOJGE H,PPTB2
	HRRZ B,(B)
	JUMPN B,PPTB1
PPTB4:	POP P,B
	HRRZ B,(B)	;GET NEXT ONE
	JUMPN B,DOPNTS
	POPJ P,

PADFIX:	TLNE WFLAG		;NO FIX FOR SIG FILES
	POPJ P,
	HRRZ T,1(C)
	MOVE T,1(T)
	CAIE T,1
	CAIN T,3
	TLNN T,ISPIN
	POPJ P,			;ONLY FIX DIP PINS
	HRRZS T
	CAIE T,1		;AND ONLY THE ONES WE KNOW ABOUT
	CAIN T,2
	CAIA
	POPJ P,
	ADJUST(SUB,TTT,G)
	HLRZ T,(C)
	HLRZ T,(T)
	HLRZ T,(T)		;ORIENTATION (WHEW!)
	JRST @(T)[VFIX
		HFIX
		VFIX
		HFIX]
VFIX:	TRNN TTT,-1
	JRST VFIX1
HFIX1:	TRNE TTT,400000
	SKIPA T,[XWD 0,-=8]
	MOVEI T,=8
VHFIX:	ADJUST(ADD,G,T)
	POPJ P,
HFIX:	TLNN TTT,-1
	JRST HFIX1
VFIX1:	SKIPGE TTT
	SKIPA T,[XWD -=8,0]
	MOVSI T,=8
	JRST VHFIX
>;MPC
                                                           ;OFFSET TEXT ROUTINE
;CALL WITH T CONTAINING ABS LOC
;TTT POINTER TO CONSTANT OFFSET BLOCK
;WRITES X,Y AND RETURNS IT IN TTT

TXTCAL:
MD,<	PUSHJ P,PSETXY
	HRL T,TT
	TDZ T,[1,,1]
	HLRE TT,1(TTT)
	IMUL TT,CSCALE
	HRRE TTT,1(TTT)
	IMUL TTT,CSCALE
	HRL TTT,TT
	TDZ TTT,[1,,1]
	EXCH TTT,T		;LEAVE OFFSET VALUES IN T
	ADD TTT,T
	TLO TTT,1
	POPJ P,
>;MD
MPC,<	ADJUST(ADD,T,<1(TTT)>)
	MOVSI TTT,1
	JRST PUTXY
>;MPC

PTXTS:	PUSH P,TTT
	PUSHJ P,TXTCAL		;CALC LOC+OFFSET AND WRITE IT OUT
MPC,<	POP P,T
	HRRZ T,(T)
	HLRZ TTT,(T)		;SIZE
	LSH TTT,4
	TLZE TTT,10		;TEST VERT BIT
	TRO TTT,400000		;AND COPY TO HERE
	TRO TTT,1		;MARK AS PART OF THIS COMMAND
	PUSHJ P,PUTWRD		;WRITE SIZE
	JRST PSTR		;AND NOW TEXT
>;MPC
MD,<	PUSHJ P,PUTWRD		;WRITE X,Y WORD
	EXCH TTT,(P)		;SAVE X,Y JUST PUT OUT AND GET TEXT POINTER
	MOVEI TT,1(TTT)
	HRLI TT,(<POINT 7,0,35>)
	HRRZ TTT,(TTT)
	HLRZ TTT,(TTT)	;TEXT SIZE
	SKIPN TTT
	MOVEI TTT,STDBIG	;CHANGE 0 TO STANDARD
	MOVE T,TTT
	ANDI TTT,377777
	MOVE TTT,CMUL(TTT)	;GET SIZE MULTIPLIER
	IMUL TTT,CSCALE		;TEXT SCALE
	LSH TTT,1
	PUSH P,TTT	;SAVE THIS HERE
	TRO TTT,1
	TRNE T,400000	;WAS IT VERTICAL?
	TRO TTT,400000	;YES, FLAG AS SUCH
	PUSHJ P,PUTWRD	;PUT OUT SIZE
	EXCH TTT,(P)	;SAVE SIZE TO WRITE OUT
	IMULI TTT,CHGHT
	ASH TTT,-1		;ACCOUNT FOR EARLIER SHIFT
	TRZ TTT,1	;LOW ORDER BIT MUST BE OFF
	TRNN T,400000
	MOVN TTT,TTT
	HRRZS TTT
	TRNE T,400000
	MOVSS TTT
	PUSH P,TTT	;SAVE LF INCREMENT
PTXTS1:	SETZ TTT,	;GATHER TEXT HERE
PTXTS2:	TLNN TT,760000	;END OF WORD?
	JRST [	HRR TT,-1(TT)	;FOLLOW LINK
		TRNE TT,-1	;WAS THERE ONE THERE?
		JRST .+1	;YES
		POP P,(P)
		POP P,(P)	;FIX UP STACK
		POP P,(P)
		JRST PTXTFN]	;NO
	ILDB T,TT
	JUMPE T,PTXTS2		;SKIP NULLS
	CAIN T,DBLARR		;THIS IS REALLY CRLF
	JRST PTXTS3
	TLNE TTT,776000		;TTT FULL?
	PUSHJ P,PTXTFN		;FLUSH IT OUT
	LSH TTT,7
	IOR TTT,T		;OR IN NEW CHAR
	JRST PTXTS2		;LOOP FOR ANOTHER CHAR

PTXTFN:	JUMPE TTT,CPOPJ		;IGNORE NULL WORDS
	JRST PTXTF2
PTXTF1:	LSH TTT,7
PTXTF2:	TLNN TTT,776000
	JRST PTXTF1
	LSH TTT,1
	TRO TTT,1
	PUSHJ P,PUTWRD
	SETZ TTT,		;CLEAR OUT TTT FOR ANOTHER WORD
	POPJ P,

PTXTS3:	PUSHJ P,PTXTFN		;FLUSH OUT CURRENT WORD
	MOVE TTT,-2(P)		;GET LAST X,Y
	TLZ TTT,1
	ADD TTT,(P)		;MOVE ONE LINE
	MOVEM TTT,-2(P)		;SAVE THIS AS LAST
	TLO TTT,1		;MAKE SURE THIS IS ON
	PUSHJ P,PUTWRD
	MOVE TTT,-1(P)		;SIZE WORD
	PUSHJ P,PUTWRD
	JRST PTXTS1
>;MD
                                                                                                                 ;OUTPUT ROUTINES
MD,<
PSETXY:	HLRE TT,T	;GET X
	HRRES T		;GET Y
	SUB TT,XOFF	;OFFSET
	SUB T,YOFF	;OFFSET	
	SCALET (T)
	SCALET (TT)
	POPJ P,
>;MD
PUTXY:
MD,<	PUSHJ P,PSETXY
	TRZ T,1
	TRZ TT,1
	TLO TTT,(TT)
	TRO TTT,(T)
>;MD
MPC,<	TRNN M,FLIP
	JRST PUTXYF
	TLC T,-1	;INVERT X
	ADD T,[2,,0]
PUTXYF:	TDZ T,[1,,1]
	TDO TTT,T
>;MPC
PUTWRD:	SOSG IOHD+2
	OUT DAT,
	CAIA
	OUTSTR[ASCIZ/PLOT FILE OUTPUT ERROR!
/]
	IDPB TTT,IOHD+1
	POPJ P,

PONE:	MOVEI TTT,1
	JRST PUTWRD

PSTR:	JUMPE T,PONE
	MOVE TTT,1(T)
	TRO TTT,1
	PUSHJ P,PUTWRD
	HRRZ T,(T)
	TRNE TTT,376
	JRST PSTR
	POPJ P,

PCHRS:	ADD T,[POINT 7,1]
PCHRS1:	PUSHJ P,GETTT
	POPJ P,
	PUTBYT (C)
	JRST PCHRS1

MD,<
PUTLIN:	TLZ TTT,1
	TRO TTT,1
	JRST PUTWRD

PINVS:	PUSHJ P,ORIENT
	ADD T,1(B)	;GET X,Y
	TDZ T,[(1)1]
	MOVEM T,SAVLOC	;SAVE IT
	POPJ P,
PVIS:	PUSHJ P,ORIENT	;ORIENT IT
	ADD T,1(B)	;ADD IN BODY CENTER
	TDZ T,[(1)1]
	EXCH T,SAVLOC
	MOVEI TTT,
	PUSHJ P,PUTXY
	MOVE T,SAVLOC
	MOVEI TTT,1
	JRST PUTXY

VSIZES:	TRNN F,400000
	JRST STDSIZ
	MOVE TTT,CSCALE
	TROA TTT,200000
STDSIZ:	MOVE TTT,CSCALE
NODEC,<	LSH TTT,1	>
DEC,<	LSH TTT,2	>
	TRO TTT,1
	JRST PUTWRD
>;MD

INIPCH:	SETZM PCHBUF
	MOVE TTT,[PUSHJ P,PLTCH]
	EXCH TTT,PUTCHR
	MOVEM TTT,PLTPSV
	POPJ P,

PLTCH:	IOR TTT,PCHBUF
	TLNN TTT,376000
	JRST [	LSH TTT,7
		MOVEM TTT,PCHBUF
		POPJ P,]
	SETZM PCHBUF
PLTCH2:	LSH TTT,1
	TRO TTT,1
	JRST PUTWRD

FINPCZ:	MOVE TTT,PLTPSV
	MOVEM TTT,PUTCHR
	SKIPN TTT,PCHBUF
	JRST PLTCH2
	JRST FNPCH2

FINPCH:	MOVE TTT,PLTPSV
	MOVEM TTT,PUTCHR
	SKIPN TTT,PCHBUF
	POPJ P,
FNPCH2:	TLNE TTT,376000
	JRST PLTCH2
	LSH TTT,7
	JRST FNPCH2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 COMMENT    VALID 00033 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	<DRAW>SUB.FAI192, 30-JUL-75 14:42:03, EDIT BY HELLIWELL
C00007 00003	ESAVE, EWRITE, SETSM, SETWM, MAKEWD
C00010 00004	REENTER CODE
C00013 00005	NOFST, UNSCALE, PERRET
C00016 00006	NODEC,<
C00017 00007	TXTMAT, SIGMAT, SIGMAA
C00020 00008	CHANGE ONE SIGNAL NAME TO ANOTHER PERVASIVELY
C00024 00009	PUTFS, READN, TXREAD, READSZ, TREAD, SCARF, INNERR
C00030 00010	LOOKUP A SIGNAL IN WIRLST, AND FLASH IT!
C00034 00011	CURSOR MOVING
C00035 00012	SET AND CLEAR FLAGS
C00047 00013	TITLES, MUNGER, INNER, DIAMONDS
C00058 00014	MORE SET AND CLEAR STUFF
C00063 00015	ROUTING PARAMETERS
C00065 00016	SET CARD LOC(D,PC)
C00068 00017	UML STUFF
C00070 00018	MORE UML
C00073 00019	STILL MORE UML
C00075 00020	COUNT THINGS
C00079 00021	BRIGHTNESS, SCALE
C00082 00022	SIZE STUFF - ITSET, PICCEN
C00089 00023	MORE SIZE STUFF
C00092 00024	SHOWBOX
C00095 00025	PBOX
C00097 00026	SLICE
C00100 00027	MORE SLICE STUFF - EXPRESSION SUBRS
C00104 00028	CLEAR
C00108 00029	**C, OFFSET, MOVE, POSIT
C00112 00030	BIG, SMALL, SHIFT SCREEN
C00116 00031	MODE SWITCHING
C00118 00032	SIXBIT, FILEUP
C00120 00033	
C00121 ENDMK
C;
                                                                 ;<DRAW>SUB.FAI;192, 30-JUL-75 14:42:03, EDIT BY HELLIWELL
VERSION(SUB,17)
;HERE WE SAVE DUMP FILES OF ALL SORTS
LAY,<
RSAVEM:	TROA TFLG
>;LAY
SAVEME:
LAY,<	TRZ TFLG	>
DEC,<	TLNE M,DSKFLG
	JRST [	OUTSTR[ASCIZ/SORRY, DSKIN ACTIVE!
/]
		POPJ P,]
>;DEC
NODEC,<
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/DISK SAVE /]
LAY,<	MOVE H,SAVNAM
	EXCH H,LSTNAM			;USE THIS AS LSTNAM FOR NOW
	MOVE G,SAVPPN
	EXCH G,LSTPPN
>;LAY
	MOVSI T,EXTSAV
	PUSHJ P,SETNAM
NOLAY,<	POPJ P,	>
LAY,<	JRST [	MOVEM H,LSTNAM		;CHANGED HIS MIND, RESTORE LSTNAM
		MOVEM G,LSTPPN
		POPJ P,]
	MOVEM H,LSTNAM
	MOVEM G,LSTPPN
>;LAY
	ENTPPN
ESAVEM:
	MOVE T,[FILNAM,,DPCNAM]
	BLT T,DPCPPN
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK FOR EXISTS CHECK!
/]
		POPJ P,]
	PUSHJ P,EXIST
	POPJ P,				;LET HIM OUT
	RELEASE DAT,
	PUSH P,0
	PUSH P,M
	PUSHJ P,PUSHIT
	MOVEM P,SSSP
LAY,<	TRNE TFLG
	SKIPA T,[.STRTN]		;START FROM TOP ON RESAVE
>;LAY
	MOVEI T,CONTLC
	MOVEM T,STRTLC
NOLAY,<	JSR SVREST	>
LAY,<
MD,<	JSR DOSAVD	>
MPC,<	JSR DOSAVP	>
>;LAY
	CAIA				;LOSE, CRLF ALREADY OUT
	OUTSTR[ASCIZ/
/]					;WIN, NEED CRLF
>;NODEC
DEC,<	MOVEI T,CONTLC
	HRRM T,.JBSA
	OUTSTR[ASCIZ/SAVE CORE IMAGE WITH "SAVE" COMMAND,
THEN TYPE "START" OR "RUN".
/]
	PUSHJ P,CTRLCS			;SIMULATE CONTROL-C
>;DEC
NODEC,<
	MOVE P,SSSP
	PUSHJ P,POPIT
	POP P,M
	POP P,0
>;NODEC
	JRST SAVCON

NOLAY,<CONTLC:>
CNTSAV:
DEC,<	JSP T,CTRLCX	>	;CALL CONTROL-C EXIT ROUTINE
LAY,<
MD,<	OUTSTR[ASCIZ/LAYOUT, D SIDE!
/]
>;MD
MPC,<	OUTSTR[ASCIZ/LAYOUT, PC SIDE!
/]
>;MPC
>;LAY
NODEC,<
	MOVE P,SSSP
	PUSHJ P,POPIT
	POP P,M
	POP P,0
	PUSHJ P,DCLAIM		;RECLAIM DISPLAY FOR EVERYONE ELSE (DEC DONE IN CTRLC CODE)
>;NODEC
DEC,<	PUSHJ P,CLTIME >	;RE INIT TIME CELLS
SAVCON:
NODEC,<	MOVE T,DPCNAM
NOLAY,<	MOVEM T,LSTNAM		;UPDATE 	>
LAY,<	MOVEM T,SAVNAM				>
	MOVE T,DPCPPN
NOLAY,<	MOVEM T,LSTPPN	>
LAY,<	MOVEM T,SAVPPN	>
	JRST FILEUP
>;NODEC
DEC,<	MOVEI T,STRT
	HRRM T,.JBSA
	POPJ P,
>;DEC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;ESAVE, EWRITE, SETSM, SETWM, MAKEWD
NODEC,<
ESAVE:	MOVE T,AUTOSM
	MOVEM T,AUTOSN		;UPDATE AUTO-SAVE COUNTER
LAY,<	SKIPN T,SAVNAM	>
NOLAY,<	SKIPN T,LSTNAM	>
	JRST [	OUTSTR[ASCIZ/NO REMEMBERED NAME AT ESAVE!
/]
		POPJ P,]
	MOVEM T,FILNAM
	SETOM THEREXISTS
	MOVSI T,EXTSAV
	MOVEM T,FILEXT
	SETZB T,FILDAT
LAY,<	MOVE T,SAVPPN	>
NOLAY,<	MOVE T,LSTPPN	>
	MOVEM T,FILPPN
	JRST ESAVEM

SETSM:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NUMBER OF COMMANDS BETWEEN ESAVES?/]
	PUSHJ P,READNC
	MOVEM T,AUTOSM
	MOVEM T,AUTOSN
	POPJ P,

CLRSM:	SETZM AUTOSM
	POPJ P,
>;NODEC

SETWM:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NUMBER OF COMMANDS BETWEEN EWRITES?/]
	PUSHJ P,READNC
	MOVEM T,AUTOWM
	MOVEM T,AUTOWN
	POPJ P,

CLRWM:	SETZM AUTOWM
	POPJ P,

MAKWIR:	MOVEI T,BODM
	PUSHJ P,CHNGMD
	PUSHJ P,CLEAR
	OUTSTR[ASCIZ/BODY MODE, CLEAR.
/]
	MOVEM P,PERRSAV
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVSI G,EXTWIR
	EXCH G,FILEXT
	SETZ H,
	DSKPPN H,		;WILL WRITE 'WD' FILE ON CURRENT AREA
	EXCH H,FILPPN
	OUTSTR[ASCIZ/READING DATE FROM /]
	MOVEI A,FILNAM
	JSR FPRINT
	MOVE T,FILPPN
	LOOKUP DAT,FILNAM
	JRST [	HRRZ TT,FILEXT
		JUMPN TT,LOOKRR
		SETZM FILDAT
		JRST MAKWR1]
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
MAKWR1:	OUTSTR[ASCIZ/
/]
	MOVE T,FILDAT
	LDB TT,[POINT 3,FILEXT,20]
	DPB TT,[POINT 6,T,23]
	HRLZM T,WIRDAT
	LDB T,[POINT 11,FILDAT,23]
	HRRM T,WIRDAT
	MOVEM G,FILEXT
	MOVEM H,FILPPN
	RELEASE DAT,
	TLZ M,TYPREP!TYPNLY
	PUSHJ P,WIRENT
	SKIPN LSTNAM
	POPJ P,			;LOST, OR WD FILE NOT NEEDED
	JRST EWLIST
                                                                                                                                                                                                                                                                           ;REENTER CODE
%R:	MOVEM T,RSAVET		;SAVE T HERE FOR NOW!
DEC,<
NOGT,<
	MOVEI T,0
	SETUWP T,		;UNWRITEPROTECT THE HIGH SEGMENT
	JFCL
>;NOGT
>;DEC
	MOVE T,P			;SAVE STACK HERE A SEC
	MOVE P,[IOWD SPPDSZ,SPPDL]	;NOW GET A GOOD ONE (IN CASE OF PDLOV)
	PUSH P,T			;NOW SAVE STACK ON STACK
	OUTSTR[ASCIZ/TYPE Y TO REINITIALIZE PROGRAM
ON THIS DRAWING./]
	PUSHJ P,TTYORN
	CAIA
	JRST REINIT
	POP P,P			;NOT RESTARTING, ASSUME STACK GOOD
	MOVE T,RSAVET
	PUSHJ P,PUSHIT
	OUTSTR[ASCIZ/FLUSH MACROS IN PROGRESS?/]
	PUSHJ P,TTYORN
	CAIA
	PUSHJ P,ABMAC
NODEC,<	PUSHJ P,DCLAIM	>	;RE-SETUP DISPLAY STUFF
	PUSHJ P,POPIT
R:	JRST @.JBOPC

TTYORN:	TTYUUO 4,T
	PUSH P,T
TTYRN1:	TTYUUO 4,T
	CAIE T,12		;GOBBLE TO END OF LINE
	JRST TTYRN1
	POP P,T
	CAIE T,"Y"+40
	CAIN T,"Y"
	AOS (P)
	POPJ P,

MPC,<
GOTPNT:	HLRZ T,(T)
	HRRZ T,1(T)
	HLLZ SID,1(T)
	TLZ SID,777777-FRONT
	POPJ P,

>;MPC

REINIT:	MOVE P,[IOWD PDLEN,PDL]	;REQUESTING PSEUDO START
	MOVE 0,SAVER0
	TRO MCHG!NEEDCL
	MOVE M,SAVERM
	SETZM DSKOPN
	RELEASE ODSK,		;GIVE LOG FILE A CHANCE TO BE RESTARTED
DEC,<	PUSHJ P,DECGO	>
	PUSHJ P,DCLAIM
DEC,<	PUSHJ P,LOGINI	>
	PUSHJ P,RCHNGM		;RESTORE OMODE
MPC,<	SETZ SID,
	SKIPE T,PONPNT
	PUSHJ P,GOTPNT
	TLC SID,FRONT
	SKIPE T,PONPN2
	PUSHJ P,GOTPNT
	TLC SID,FRONT
>;MPC
	JRST MAIN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;NOFST, UNSCALE, PERRET
NOFSTA:	MOVEM A,SAVEA
	MOVEM B,SAVEB
NOFST3:
NOTWO,<
NODEC,<	HRRZ A,.JBREL		>
DEC,<
VB10,<		HRRZ	A,.JBHRL	>
NOVB10,<	HRRZ	A,.JBREL	>
>;DEC
>;NOTWO
TWO,<	HRRZ A,.JBHRL	>
	ADDI A,1
	MOVEM A,FSTPNT
NODEC,<	ADDI A,1777	>
DEC,<
VB10,<		MOVSI	A,1777(A)>
NOVB10,<	ADDI	A,1777	>
>;DEC
NOTWO,<	CORE A,	>
TWO,<	CORE2 A,	>
	JRST [	JSR NOCORE
		JRST NOFST3]
	MOVE A,FSTPNT
NOTWO,<
NODEC,<	HRRZ B,.JBREL		>
DEC,<
VB10,<		HRRZ	B,.JBHRL	>
NOVB10,<	HRRZ	B,.JBREL	>
>;DEC
>;NOTWO
TWO,<	HRRZ B,.JBHRL	>
NOFST1:	ADDI A,2
	CAILE A,(B)
	JRST NOFST2
	HRRZM A,-2(A)
	JRST NOFST1
NOFST2:	HRLI A,[0]
	HLRZM A,-2(A)		;LINK END OF LIST TO 0
	SOS NOFST
	SOS NOFST
	MOVE B,SAVEB
	MOVE A,SAVEA
	JRST @NOFST

MPC,<
%SWITCH:MOVE T,PONPNT
	EXCH T,PONPN2
	MOVEM T,PONPNT
	TLC SID,400000
	MOVSS BARLST
	POPJ P,
>;MPC

%UNSCAL:
	PUSH P,TT
	PUSH P,TTT
MPC,<	ASH T,4	>
MD,<	ASH T,2	>
	IDIV T,NSCALE
	LSH TT,1
	MOVM TTT,TT
	HLLE TT,TT
	TRZ TT,1
	CAML TTT,NSCALE		;GREATER OR EQUAL TO HALF NSCALE?
	ADD T,TT		;YES, FUDGE BY ONE IN PROPER DIRECTION
	TRZ T,1
	POP P,TTT
	POP P,TT
	POPJ P,

PERRET:
	TLNN M,MACACT
	OUTSTR[ASCIZ/???
/]
LERRET:	PUSHJ P,COMCLR		;IN CASE IN ALTER MODE
	TLNE M,MACACT
	POPJ P,			;MACRO USERS TAKE THEIR CHANCES
	TLC M,DSKACT!DSKFLG
	TLCE M,DSKACT!DSKFLG	;BOTH DISK INPUT AND ACTIVE?
	POPJ P,			;NO
	OUTSTR[ASCIZ/DUE TO ERROR, /]
	JRST IBREAK
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   NODEC,<

%UUOCON:MOVEM T,UUOSAV
	LDB T,[POINT 9,UUO,8]
	CAIL T,UUO2-UUO1
	MOVEI T,0
	MOVE T,(T)[
		UUO1:	BADUUO
			PTBYT
			PTSTR
		UUO2:	]
	EXCH T,UUOSAV
	JRST 2,@UUOSAV

BADUUO:	OUTSTR [ASCIZ/ILLEGAL UUO PERFORMED!! /]
	HALT CPOPJ

>;NODEC

PTBYT:	PUSH P,TTT
	HRRZ TTT,UUO
	XCT PUTCHR
	POP P,TTT
	POPJ P,

PTSTR:	PUSH P,TTT
	PUSH P,T
	HRRZ T,UUO
	TLOA T,(<POINT 7,0>)
PTSTRL:	XCT PUTCHR
	ILDB TTT,T
	JUMPN TTT,PTSTRL
	POP P,T
	POP P,TTT
	POPJ P,
                                                                                                                                                            ;TXTMAT, SIGMAT, SIGMAA
TXTMAT:	MOVE T,1(B)	;GET NEXT WORD OF TEXT
	CAME T,1(A)	;COMPARE IT WITH OTHER STRING
	POPJ P,		;DIFFERENT, NO MATCH
	HRRZ A,(A)	;GO TO NEXT WORD
	HRRZ B,(B)	;...
	JUMPE A,[JUMPN B,CPOPJ  ;IF A ENDS AND B DOESN'T, NO MATCH
		AOS(P)	;IF BOTH END, MATCH
		POPJ P,]
	JUMPN B,TXTMAT	;IF NEITHER ENDS, LOOP
	POPJ P,		;IF B ENDS AND A DOESN'T, NO MATCH

IFN 0,<
NODEC,<
SIGMAT:	ADD A,[POINT 7,1]
	ADD B,[POINT 7,1]
	LDB T,[POINT 14,(A),13]
	CAIE T,""
	CAIN T,""
	SUB A,[160000,,0]
	LDB T,[POINT 14,(B),13]
	CAIE T,""
	CAIN T,""
	SUB B,[160000,,0]
	PUSHJ P,GETITA
	JRST CKENDB
	CAIN T,""
	MOVEI T,""
	MOVE TT,T
	PUSHJ P,GETITB
	POPJ P,
	CAIN T,""
	MOVEI T,""
	JRST SIGMA2

SIGMA1:	PUSHJ P,GETITA
	JRST [CKENDB:PUSHJ P,GETITB
		AOS (P)		;ENDS ALSO, MATCH
		POPJ P,]
	MOVE TT,T
	PUSHJ P,GETITB
	POPJ P,			;A DIDN'T END, NO MATCH
SIGMA2:	CAME T,TT
	POPJ P,
	JRST SIGMA1
>;NODEC

GETITA:	TLNN A,760000
	JRST [	HRR A,-1(A)
		TRNN A,-1
		POPJ P,
		JRST .+1]
	ILDB T,A
	JUMPE T,GETITA
NODEC,<	TRNE M,SPACES		;ARE SPACES SIGNIFICANT?
	JRST SIGCHR		;YES
	CAIE T,DBLARR
	CAIN T," "
	JRST GETITA
	JRST SIGCHR

GETITB:	TLNN B,760000
	JRST [	HRR B,-1(B)
		TRNN B,-1
		POPJ P,
		JRST .+1]
	ILDB T,B
	JUMPE T,GETITB
	TRNE M,SPACES
	JRST SIGCHR
	CAIE T," "
	CAIN T,DBLARR
	JRST GETITB
SIGCHR:
>;NODEC
DEC,<	CAIN T,11		;FLUSH TABS
	JRST GETITA
>;DEC
	CAIL T,"a"			;CONVERT LOWER CASE TO UPPER CASE
	CAILE T,"z"
	CAIA
	SUBI T,40
	CAIE T,";"			;THIS IS THE COMMENT CHAR
	AOS (P)
	POPJ P,
>;IFN 0
SIGMAT:	SETZM VARLST		;NO VARS
	PUSH P,D
	PUSH P,C
	PUSH P,B
	PUSHJ P,PERMUT
	POP P,TT
	POP P,C
	POP P,D
	MOVEI T,CMPWRD
	PUSHJ P,ALPHA
	POPJ P,
	POPJ P,
	JRST CPOPJ1
	JRST CPOPJ1
	JRST CPOPJ2
                                                                                                                       ;CHANGE ONE SIGNAL NAME TO ANOTHER PERVASIVELY
MD,<
SIGCHG:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/OLD SIGNAL NAME?
/]
	PUSHJ P,TREADC
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;PERPARE OLD NAME FOR SEARCHING
	POP P,B
	PUSHJ P,PUTFS
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW SIGNAL NAME?
/]
	PUSHJ P,TREADC
	POPJ P,
	POPJ P,
	MOVEM B,DX1
	MOVSI C,17
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR MARK BITS
	SKIPE H,PONPNT
	PUSHJ P,SIGCDO
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,.+2
	SETOM FIND
	SKIPN T,FNDNUM
	JRST [	OUTSTR[ASCIZ/NO/]
		JRST SIGCHF]
	PUSHJ P,DECOUT
SIGCHF:	OUTSTR[ASCIZ/ SIGNAL NAME/]
	MOVE T,FNDNUM
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/ CHANGED.
/]
	MOVE B,DX1
	JRST PUTFS

;SIGCDO: CALLING SEQUENCE
;	<STRING TO FIND IN A>
;	ADD A,[POINT 7,1]
;	PUSHJ P,SIGMAA
;	<NEW SIG IN DX1>
;	SKIPE H,PONPNT
;	PUSHJ P,SIGCDO
;	<RETURNS HERE ALWAYS>
;	<FIND AOS'D ONCE FOR EACH SIGNAL CHANGED>
SIGCDO:	HLRZ F,(H)
	HRRZ F,1(F)
	MOVE T,1(F)
	TLNE T,1
	JRST SIGCH2		;ALREADY DONE
	HLRZ G,(F)
	JUMPE G,SIGCH2
	HRRZ A,(G)
	ADD A,[POINT 7,1]
	MOVEI B,SIGTAB
	PUSHJ P,SIGMAT
	JRST SIGCH2		;NO MATCH
	JFCL			;EQUIVALENT IS OK
	AOS FIND
	MOVSI T,FOUNDP!1	;MARK CHANGED
	IORM T,1(F)
	HRRZ A,(G)
	ADD A,[POINT 7,1]
	PUSHJ P,PERME1		;EXTRACT LEADING STUFF
	MOVE T,POLAR		;GET OLD POLARITY
	MOVEM T,OPOLAR		;AND SAVE HERE FOR PERMES
	PUSH P,PUTCHR
	PUSHJ P,SETTT7
	PUSH P,A
	PUSHJ P,SIGCHX
	MOVE A,DX1
	ADD A,[POINT 7,1]
	PUSHJ P,PERMES		;EXTRACT NEW SIGNAL NAME (POSSIBLY CHANGING POLARITY)
	PUSHJ P,SIGCHX
	HRRZ A,(G)
	ADD A,[POINT 7,1]
	PUSHJ P,PERME2		;NOW GET TRAILER
	PUSHJ P,SIGCHX
	HRRZ B,(G)
	HLRZ TT,(B)		;GET SIZE
	PUSHJ P,PUTFS
	POP P,A
	HRLM TT,(A)		;RESTORE SIZE
	HRRM A,(G)
	POP P,PUTCHR
	TRO MCHG
	SKIPE 1(A)
	JRST SIGCH6
	MOVE A,H
	PUSHJ P,PTKIL1		;FLUSH NULL TEXT
	JRST SIGCH2

SIGCH6:	MOVE A,H
	PUSHJ P,FIXEM
SIGCH2:	HRRZ H,(H)
	JUMPN H,SIGCDO
	POPJ P,

SIGCHX:	SKIPA A,[POINT 7,ESGTAB]
SIGCHY:	PUTBYT (C)
	ILDB C,A
	JUMPN C,SIGCHY
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                       ;PUTFS, READN, TXREAD, READSZ, TREAD, SCARF, INNERR
PUTFS:	JUMPE B,CPOPJ
PUTFS1:	HRRZ T,(B)	;GET LINK TO NEXT
	FSTRET (B)
	JUMPE T,CPOPJ
	HRRZ B,(T)
	FSTRET (T)
	JUMPN B,PUTFS1	;IF NON-ZERO LINK, LOOP
	POPJ P,

SREADN:	MOVEI T,0
	PUSHJ P,GETLIN
	CAIE C,"-"
	JRST RNLOP1
	PUSHJ P,READN
	MOVN T,T	;GIVE HIM NEGATIVE
	POPJ P,

;TO BE CALLED TO SCAN A SINGLE NUMBER WHICH SHOULD
;END WITH LF, CALL ONLY AT TOP LEVEL (WILL POP POPJ ON ERROR)
READNC:	PUSHJ P,READN
	CAIN C,12
	POPJ P,
	POP P,(P)	;LOSE THE RETURN
	JRST INNERR	;AND JUMP TO INPUT ERROR ROUTINE

CREADN:	SETZ T,
	JRST RNLOP1

READN:	MOVEI T,
RNLOP:	PUSHJ P,GETLIN	;GET A CHR.
RNLOP1:	PUSH P,[=10]
	CAIE C,"'"
	JRST RNLOP3
	MOVEI C,10
	MOVEM C,(P)
RNLOP2:	PUSHJ P,GETLIN
RNLOP3:	CAIL C,"0"	;IS IT A DIGIT?
	CAILE C,"9"	;???
	JRST [	POP P,(P);NO
		POPJ P,]
	IMUL T,(P)	;YES, MULT BY PROPER AMOUNT
	ADDI T,-60(C)	;ADD IN NEW THING
	AOS NDIG	;COUNT A DIGIT
	JRST RNLOP2

TXREAD:	GETFS(B)
	PUSH P,B	;SAVE POINTER TO BEGINNING OF STRING
	SETZM 1(B)	;CLEAR BYTE WORD
	ADD B,[POINT 7,1]
	SETZB TT,TTT	;ZERO COUNTERS
	MOVNI T,1	;FLAG NO SIZE TYPED YET
	PUSHJ P,GETLIN	;GET FIRST CHR.
	ANDI C,177
	CAIE C,"\"	;\?
	JRST BLOPP	;NO
	PUSHJ P,READSZ	;GET SIZE STUFF INTO T
	CAIA
	JRST BLOP
	MOVNI T,1	;ERROR, FLAG AS IF NONE TYPED
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ILLEGAL TEXT SIZE, WILL MAKE BELIEVE NONE WAS TYPED.
/]
BLOP:	PUSHJ P,GETLIN	;GET NEXT CHR OF NAME
	ANDI C,177
BLOPP:	CAIE C,ALTMOD	;QUIT ON ALTMODE ALSO
	CAIN C,12	;DONE (LINE FEED)
	JRST BDON
	CAIE C,DBLARR	;END OF LINE?
	AOJA TTT,BLOPCR	;NO, COUNT CHAR
	ADD TT,[1,,0]	;COUNT ANOTHER LINE
	CAILE TTT,(TT)	;THIS LINE LONGEST SO FAR?
	HRR TT,TTT	;YES
	SETZ TTT,	;RESET LINE LENGTH COUNT
BLOPCR:	TLNE B,760000	;END OF WORD?
	JRST BPNT1
	GETFS(D)
	SETZM 1(D)
	HRRZM D,-1(B)
	HRR B,D
BPNT1:	IDPB C,B
	JRST BLOP

BDON:	CAILE TTT,(TT)	;LAST LINE LONGEST?
	HRR TT,TTT	;YES
	SETZM -1(B)	;CLEAR LAST POINTER
	POP P,B		;GET POINTER TO FRONT OF STRING
	POPJ P,

READSZ:	PUSHJ P,GETLIN	;YES, GET SIZE
	ANDI C,177
	SETZ T,		;ASSUME HORIZONTAL
	CAIE C,"V"	;IS HE ASKING FOR VERTICAL?
	JRST NOVERT	;NO
	PUSHJ P,GETLIN
	ANDI C,177
	MOVEI T,400000	;MARK AS VERTICAL
NOVERT:	SUBI C,60	;NORMALIZE NUMBER
	JUMPL C,CPOPJ	;TOO SMALL?
	IOR T,C		;MAKE SIZE
	CAIG C,CSIZES	;OR TOO BIG?
	AOS (P)
	POPJ P,		;ERROR RETURN

TREADU:	PUSHJ P,TREADV
	CAIA
TREADC:	PUSHJ P,TREAD
	CAIN C,ALTMOD	;END WITH ALTMODE?
	JRST PUTFS	;YES, GIVE BACK STRING AND DIRECT RETURN
	AOS (P)		;AT LEAST ONE SKIP
	SKIPE 1(B)	;NULL?
	AOSA (P)	;NO, ANOTHER SKIP
	JRST PUTFS	;YES, GIVE IT BACK
	POPJ P,

TREADV:	SETOM LOW2UP
	CAIA
TREAD:	SETZM LOW2UP
	GETFS(B)
	PUSH P,B
	ADD B,[POINT 7,1]
	SETZM (B)
TREADA:	PUSHJ P,GETLIN
	CAIE C,ALTMOD
	CAIN C,12
	JRST BDON
	TLNE B,760000
	JRST TREADG
	GETFS(T)
	HRRZM T,-1(B)
	SETZM 1(T)
	HRR B,T
TREADG:	SKIPN LOW2UP
	JRST TREADL
	CAIL C,"A"+40
	CAILE C,"Z"+40
	CAIA
	SUBI C,40
TREADL:	IDPB C,B
	JRST TREADA

SCARF:	CAIN C,12
	AOSA (P)
	CAIN C,ALTMOD
	POPJ P,
	PUSHJ P,GETLIN
	JRST SCARF

INNERR:	PUSHJ P,SCARF
	JRST LERRET
	OUTSTR[ASCIZ/INPUT ERROR!
/]
	JRST LERRET
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ;LOOKUP A SIGNAL IN WIRLST, AND FLASH IT!
XFLASH:	SKIPN B,BLPNTR
	POPJ P,
	PUSHJ P,PUTFS
	SETZM BLPNTR
IFN UMLSW!LAYSW,<
MPC,<	SETZM UPINS	>
>;IFN UMLSW!LAYSW
	TRO MCHG
	POPJ P,

NOUML,<
LOKSIG:	JRST PERRET
>;NOUML

UML,<
LOOKN:	SKIPN A,WIRLST
	JRST NOWIRL
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/WIRE NUMBER FROM WFAIL.DAT FILE?/]
	PUSHJ P,READNC
	MOVE C,A
	SETZM DX1
LOOKN0:	AOS DX1
	SOJLE T,LOOKN1
	HRRZ C,(C)
	JUMPN C,LOOKN0
	OUTSTR[ASCIZ/NO SUCH WIRE!
/]
	POPJ P,

LOKSIG:	SKIPN WIRLST
	JRST [NOWIRL:	OUTSTR[ASCIZ/NO WIRES IN WIRLST!
/]
		POPJ P,]
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SIGNAL NAME TO LOOKUP?/]
	PUSHJ P,TREADC
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	PUSH P,B		;SAVE POINTER TO ORIG STRING
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
	POP P,B
	PUSHJ P,PUTFS		;GIVE BACK TYPED IN VERSION
	PUSHJ P,LOOKIT		;LOOK IT UP
	JRST LOKSGN		;NONE
LOOKN1:	HRRZ B,1(C)		;GET WIRE POINTER
	PUSHJ P,LSTSGO		;PRINT ALL THE NAMES
	PUSH P,C
	PUSHJ P,LINKST
	POP P,C
	HRRZ C,1(C)		;POINTER TO LIST OF PINS, ETC
POKSG1:
MPC,<	HRRZ A,1(C)		;WILD CON STUFF IS HERE
	ADDM A,UPINS
>;MPC
	HLRZ A,(C)		;PIN POINTER
	JUMPE A,POKSG2
	PUSH P,C
	PUSHJ P,LINKIT
	POP P,C
POKSG2:	HRRZ C,(C)
	JUMPN C,POKSG1
	PUSHJ P,LINKMK		;NOW MARK BAD GUYS
	TRO MCHG		;GET IT ON
	TLNN M,LCENTER
	POPJ P,
	JRST LCENMAK		;CENTER IT!

LOOKIT:	MOVE C,WIRLST		;LOOK DOWN THE LIST
	SETZM DX1
LOKSG3:	HRRZ D,1(C)
	AOS DX1
LOKSG1:	HLRZ A,1(D)
	JUMPE A,LOKSG2
	ADD A,[POINT 7,1]
	MOVEI B,SIGTAB
	PUSHJ P,SIGMAT
	JRST LOKSG2		;NO MATCH
	JFCL			;EQUIVALENT IS CLOSE ENOUGH
	AOS (P)
	POPJ P,

LOKSG2:	HRRZ D,(D)
	JUMPN D,LOKSG1
	HRRZ C,(C)
	JUMPN C,LOKSG3
	POPJ P,

LOKSGN:	OUTSTR[ASCIZ/NOT FOUND!
/]
	POPJ P,

LSTSIG:	SKIPN A,WIRLST
	JRST NOWIRL
	SETZM DX1
LSTSG1:	HRRZ B,1(A)
	AOS DX1
	PUSHJ P,LSTSGO
	HRRZ A,(A)
	JUMPN A,LSTSG1
	POPJ P,

;CALL (LSTSGO) WITH SINGLE WIRE POINTER IN B, AND DX1 = SIGNAL #

LSTSGO:	MOVE T,DX1
	PUSHJ P,DECOUT
LSTSG6:	HLRZ T,1(B)
	JUMPE T,LSTSG3
	OUTCHR[11]
	PUSHJ P,OUTTXT
LSTSG3:	HRRZ B,(B)
	JUMPN B,LSTSG6
MPC,<	HRRZ T,1(A)
	HRRZ T,1(T)
	JUMPE T,LSTSG4
	OUTCHR[11]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ "WILD"/]
LSTSG4:
>;MPC
	OUTSTR[ASCIZ/
/]
	POPJ P,

MD,<
SHWERR:	SOSL TT,%LAST		;COUNT DOWN AND PICKUP LAST GEN NAME
	SKIPN C,WIRLST		;ANY WIRES?
	JRST PERRET		;NO MORE
	SOJL TT,LOOKN1
	HRRZ C,(C)
	JUMPN C,.-2
	JRST SHWERR
>;MD
>;UML
                                                                                ;CURSOR MOVING
	DEFINE MOV $ (SHFT,MOVT,ADDT)
<	MOVSI TT,1
	LSH TT,SHFT(A)
MPC,<	IMUL TT,STPSIZ>
	MOV$MOVT T,CURSE
	ADDT T,TT
	MOV$MOVT$M T,T
	JRST SETPOS
>

MOVUP1:	MOV (1,S,ADD)
MOVDN1:	MOV (1,S,SUB)
MOVUP2:	MOV (5,S,ADD)
MOVDN2:	MOV (5,S,SUB)

MOVLF1:
MPC,<	TRNE M,FLIP
	JRST MOVRT3
>;MPC
MOVLF3:	MOV (1,E,SUB)
MOVRT1:
MPC,<	TRNE M,FLIP
	JRST MOVLF3
>;MPC
MOVRT3:	MOV (1,E,ADD)

MOVLF2:
MPC,<	TRNE M,FLIP
	JRST MOVRT4
>;MPC
MOVLF4:	MOV (5,E,SUB)

MOVRT2:
MPC,<	TRNE M,FLIP
	JRST MOVLF4
>;MPC
MOVRT4:	MOV (5,E,ADD)
                                                                                    ;SET AND CLEAR FLAGS
STBOOP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NUMBER OF SECONDS BEFORE BOOP?/]
	PUSHJ P,READN
	CAIE C,12
	JRST INNERR
	MOVEM T,BOOPCN
	TIMER T,
	MOVEM T,BOOPLR
	POPJ P,

CLBOOP:	SETZM BOOPCN
	POPJ P,

DEC,<
STTIME:
GT,<	MOVE T,NBYTES
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ BYTES TRANSMITTED TO GT40 (/]
	SKIPN OPTFLG
	OUTSTR[ASCIZ/NON-/]
	OUTSTR[ASCIZ/OPTIMIZED)
/]
>;GT
	MOVE A,RTIME		;SAVE LAST RUNTIME
	MOVE B,QTIME		;AND LAST RUN QUEUE TIME
	MOVE C,DTIME		;AND LAST REAL TIME
	PUSHJ P,CLTIME		;UPDATE CELLS
	OUTSTR[ASCIZ/RTIME = /]
	SUB A,RTIME
	MOVN T,A
	PUSHJ P,SECPNT		;PRINT SECONDS WITH 3 DECIMAL POINTS
	OUTSTR[ASCIZ/, QTIME = /]
	SUB B,QTIME
	CAMLE B,A
	MOVE B,A		;MAKE SURE QTIME.GE.RTIME (NEG)
	MOVN T,B
	PUSHJ P,SECPNT
	OUTSTR[ASCIZ/, /]
	IMULI A,=100
	IDIV A,B
	MOVE T,A		;THIS IS PERCENTAGE SERVICE
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/%
REALTIME = /]
	SUB C,DTIME
	MUL C,[-=24*=60*=60*=60]	;MAKE IT POSITIVE AND TICS
	LSHC C,=18
	MOVE T,C
	PUSHJ P,SECPNT
	OUTSTR[ASCIZ/
/]
	POPJ P,

CLTIME:	MOVE T,[-1,,4]
	GETTAB T,		;GET RUNTIME
	SETZ T,
	MOVEM T,RTIME
	MOVE T,[-1,,53]		;GET RUN QUEUE TIME
	GETTAB T,
	SETZ T,
	MOVEM T,QTIME
	MOVE T,[53,,11]
	GETTAB T,		;GET UNIVERSAL DAY TIME
	SETZ T,
	MOVEM T,DTIME
GT,<	SETZM NBYTES	>
	POPJ P,

SECPNT:	IDIVI T,=60
	HRLM TT,(P)
	PUSHJ P,DECOUT
	OUTCHR["."]
	HLRZ T,(P)
	IMULI T,=10
	IDIVI T,=6		;MAKE IT HUNDREDTHS
	CAIGE T,=10
	OUTCHR["0"]
	JRST DECOUT
>;DEC

STINIT:	TLZ NOINIT
	POPJ P,

CLINIT:	TLO NOINIT
	POPJ P,

EXACTS:	TROA M,SEXACT
EXACTC:	TRZ M,SEXACT
	POPJ P,

SETLC:	SETOM LCFLAG
	POPJ P,

CLRLC:	SETZM LCFLAG
	POPJ P,

SIDENT:	TLON M,%IDENT
	TRO MCHG!NEEDCL
	POPJ P,

CIDENT:	TLZE M,%IDENT
	TRO MCHG!NEEDCL
	POPJ P,

STLPPN:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LIBRARY PPN?/]
NOCMU,<
NOITS,<	PUSHJ P,GETPPN
	JRST INNERR
	CAIN C,12
	JRST [	HRRZM T,LIBPPN
		SETZ T,
		DSKPPN T,
		HLLM T,LIBPPN
		POPJ P,]
	CAIE C,","
	JRST INNERR
	MOVE B,T
	PUSHJ P,GETPPN
	JRST INNERR
	CAIE C,12
	JRST INNERR
	HRLZM B,LIBPPN
	HRRM T,LIBPPN
>;NOITS
>;NOCMU
ITS,<	PUSHJ P,GETNAM
	JUMPE T,INNERR
	CAIE C,12
	JRST INNERR
	MOVEM T,LIBPPN
>;ITS
CMU,<	SETZM PPNBUF		;CLEAR OUT A BUFFER FOR THE PPN
	SETZM PPNBUF+1
	SETZM PPNBUF+2
	MOVE B,[POINT 7,PPNBUF]
	MOVEI T,=13		;13 CHARACTERS AT MOST!
CMUPP7:	PUSHJ P,GETLIN		;GET A CHAR
	JRST CMUPP9
	CAIE C,15		;IGNORE CR
	CAIN C,40		;AND SPACE
	JRST CMUPP7
	CAIN C,12		;LF
	JRST CMUPP9		;YES, THAT'S ALL FOLKS.
	CAIE C,"["		;IGNORE [
	CAIN C,"]"		;AND ]
	JRST CMUPP7
	CAIL C,"a"		;CONVERT LOWER CASE TO UPPER CASE
	CAILE C,"z"
	JRST .+2
	SUBI C,40		;CONVERT IT
CMUPP8:	IDPB C,B
	SOJGE T,CMUPP7		;AND GO GET ANOTHER CHAR UNLES WE HAVE 13+1
	JRST INNERR		;FUNNY, WE DIDN'T GET THERE IN 13 CHARACTERS!
CMUPP9:	MOVE T,[XWD B,PPNBUF]
	CMUDEC T,		;CONVERT THE PPN TO DEC FORMAT
	JRST INNERR		;WHOOPS, BAD PPN
	MOVEM A,LIBPPN
>;CMU
	POPJ P,

CLLPPN:
	MOVE T,[DATPPN]
	MOVEM T,LIBPPN
	POPJ P,

SETSPC:	TRO M,SPACES
	POPJ P,

CLRSPC:	TRZ M,SPACES
	POPJ P,

SETCNT:	TLO M,LCENTER
	JRST LCENMAK

CLRCNT:	TLZ M,LCENTER
	POPJ P,

SETLCA:	TLON LOCATE
	TRO NEEDCL
	POPJ P,

CLRLCA:	TLZE LOCATE
	TRO NEEDCL
	POPJ P,

NEWID:	SETZM BID
	SETOM OLDBID
	SETZM PID
	SETOM OLDPID
	JRST REEID		;RE-ASSIGN ID FROM START!

LMACRO:	SKIPN A,MDPNT		;GET DEFINED MACRO LIST POINTER
	POPJ P,
	OUTSTR[ASCIZ/
/]
LMAC1:	HRRZ T,1(A)
	PUSHJ P,OUTTXT
	HLRZ T,(A)
	TRNE T,MSAVE		;BEING SAVED?
	OUTSTR[ASCIZ/		*/];YES
	OUTSTR[ASCIZ/
/]
	HRRZ A,(A)
	JUMPN A,LMAC1
	POPJ P,

GETDDT:	SKIPN T,.JBDDT
	JRST [	OUTSTR[ASCIZ/NO DDT.....
/]
		POPJ P,]
	MOVE TT,[10000,,CPOPJ]
	MOVEM TT,.JBOPC
	JRST (T)

STBLCS:	TLON M,BLOCS
	TRO MCHG
	POPJ P,

CLBLCS:	TLZE M,BLOCS
	TRO MCHG
	POPJ P,

STCLCS:	TLON M,CLOCS
	TRO MCHG
	POPJ P,

CLCLCS:	TLZE M,CLOCS
	TRO MCHG
	POPJ P,

SETPNS:	TLON M,PLOCS
	TRO MCHG
	POPJ P,

CLRPNS:	TLZE M,PLOCS
	TRO MCHG
	POPJ P,

STLINS:	TRZE M,NLINES
	TRO MCHG
	POPJ P,

CLLINS:	TRON M,NLINES
	TRO MCHG
	POPJ P,
MPC,<
STDIPS:	TRZE M,NDIPS
	TRO MCHG
	POPJ P,

CLDIPS:	TRON M,NDIPS
	TRO MCHG
	POPJ P,

STFLIP:	TRC M,FLIP		;INVERT X
	TRO MCHG
	MOVE T,CURSE
	JRST SETPOS		;GET CURSOR TO RIGHT PLACE!

STCOMP:	TLNE SID,FRONT
	POPJ P,
SWSID:	TRZ INLIN!INMOV
	SWITCH
	TRO MCHG!NEEDCL
	POPJ P,

STSOLD:	TLNN SID,FRONT
	POPJ P,
	JRST SWSID

STFEED:	TRZE M,XFEED
	TRO MCHG
	POPJ P,

CLFEED:	TRON M,XFEED
	TRO MCHG
	POPJ P,

STFING:	TRZE M,XFINGER
	TRO MCHG
	POPJ P,

CLFING:	TRON M,XFINGER
	TRO MCHG
	POPJ P,

STANFO,<
NOLAY,<
PDPY:	SETOM GRABUF	;FLAG THAT WE WANT TO COPY III BUFFER ONTO DISK FOR P.O.G. 4
	PUSHJ P,DSPOUT	;REFRESH DISPLAY
	POPJ P,
>;NOLAY
>;STANFO
>;MPC
MD,<
SETOUT:	SETOM OUTSIDE
	POPJ P,

CLROUT:	SETZM OUTSIDE
	POPJ P,

SETCBX:	TRZN M,NOCBOX
	POPJ P,
	TLNE M,CLOCS
	TRO MCHG
	POPJ P,

CLRCBX:	TROE M,NOCBOX
	POPJ P,
	TLNE M,CLOCS
	TRO MCHG
	POPJ P,

SETIDS:	TLON M,PINIDS
	TRO MCHG
	POPJ P,

CLRIDS:	TLZE M,PINIDS
	TRO MCHG
	POPJ P,

SETRID:	TLON M,RPINID
	TRO MCHG
	POPJ P,

CLRRID:	TLZE M,RPINID
	TRO MCHG
	POPJ P,

STUNHI:	TLON M,UNHIDE
	TRO MCHG
	POPJ P,

CLUNHI:	TLZE M,UNHIDE
	TRO MCHG
	POPJ P,

STPTXT:	TRZE M,NPTEXT
	TRO MCHG
	POPJ P,

CLPTXT:	TRON M,NPTEXT
	TRO MCHG
	POPJ P,

STBTXT:	TRZE M,NBTEXT
	TRO MCHG
	POPJ P,

CLBTXT:	TRON M,NBTEXT
	TRO MCHG
	POPJ P,

STMLIB:	SETOM MODLIB
	POPJ P,

CLMLIB:	SETZM MODLIB
	POPJ P,

UREST:	SKIPN A,PONPNT
	POPJ P,
UREST1:	HLRZ B,(A)
	HRRZ B,1(B)
	MOVE T,1(B)
	TLNE T,CPIN
	TRNN T,-1
	JRST UREST2
	HRRZ C,(B)
	MOVE TT,(C)
	HRRM T,(C)
	HRRM TT,1(B)			;EXCHANGE PIN NAMES
	TRO MCHG
	PUSHJ P,OFFCON			;FIX CON OFFSET
UREST2:	HRRZ A,(A)
	JUMPN A,UREST1
	POPJ P,
>;MD

SETTXT:	TRZE M,MD,<NBTEXT!>NPTEXT
	TRO MCHG
	TLON M,CLOCS
	TRO MCHG
	POPJ P,

CLRTXT:	TRO M,MD,<NBTEXT!>NPTEXT
	TLZ M,CLOCS
	TRO MCHG
	POPJ P,

SETWIN:	TLZN M,XWINDOW
	POPJ P,
	JRST DOWIN

CLRWIN:	TLOE M,XWINDOW
	POPJ P,
DOWIN:	MOVE T,CURSE
	JRST SETPOS

SETLWN:	TLON M,LWINDOW
	TRO MCHG
	POPJ P,

CLRLWN:	TLZE M,LWINDOW
	TRO MCHG
	POPJ P,

SETDPY:
NOGDP,<	SKIPE ISDPY	>
GDP,<	SKIPLE DONTDPY	>
	POPJ P,
	SETZM DONTDPY
DLX,<	SETOM DLXFLG	>	;IF USER DOESN'T SPECIFY, TRY DL10
	JRST DTRY		;CLAIM DISPLAY

CLRDPY:
NOGDP,<	SKIPE DONTDPY	>
GDP,<	SKIPGE DONTDPY	>
	POPJ P,
	SETOM DONTDPY
	SKIPE ISDPY
	PUSHJ P,DPYREL
	JRST DSPSET

NODEC,<
DPYREL:	DPYCLR
GDP,<	RELEASE ATYO,	>
	SETZM ISDPY
	POPJ P,
>;NODEC

GT,<
SETOPT:	SKIPE OPTFLG
	SKIPN ISDPY
	CAIA
	POPJ P,
DLX,<	SKIPN ISDPY		;IF NOT CURRENTLY DISPLAY,
	SETOM DLXFLG		;THEN TRY DL10 FIRST
>;DLX
	PUSHJ P,CLRDPY		;LET GO OF DISPLAY
	SETZM DONTDPY
	SETOM OPTFLG		;THEN TELL IT TO OPTIMIZE
	JRST DTRY

CLROPT:	SKIPN OPTFLG
	SKIPN ISDPY
	CAIA
	POPJ P,
DLX,<	SKIPN ISDPY		;IF NOT CURRENTLY DISPLAY,
	SETOM DLXFLG		;THEN TRY DL10 FIRST
>;DLX
	PUSHJ P,CLRDPY
	SETZM DONTDPY
	SETZM OPTFLG
	JRST DTRY		;TRY DISPLAY IN CURRENT MODE

DLX,<
SETDLX:	SKIPE DLXFLG
	SKIPN ISDPY
	CAIA
	POPJ P,
	PUSHJ P,CLRDPY
	SETZM DONTDPY
	SETOM DLXFLG
	JRST DTRY

CLRDLX:	SKIPN DLXFLG
	SKIPN ISDPY
	CAIA
	POPJ P,
	PUSHJ P,CLRDPY
	SETZM DONTDPY
	SETZM DLXFLG
	JRST DTRY
>;DLX
>;GT
                                                                                                                                                                                                                                                                                                                             ;TITLES, MUNGER, INNER, DIAMONDS
;ROUTINE TO PUT FILENAME INTO MACRO
CLRSIG:	PUSHJ P,SETTT
	SKIPN TT,(B)
	JRST ITSTUF
	PUSHJ P,STFSIX
	PUTBYT "."
	HLLZ TT,1(B)
	PUSHJ P,STFSIX
	PUTBYT "["
	HLLZ TT,3(B)
	PUSHJ P,STFPPN
	PUTBYT ","
	HRLZ TT,3(B)
	PUSHJ P,STFPPN
	PUTBYT "]"
	JRST ITSTUF

STFPPN:
DEC,<	HLRZ T,TT
STFPP1:	IDIVI T,10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,STFPP1
	HLRZ T,(P)
	PUTBYT 60(T)
	POPJ P,
>;DEC
STFSIX:	JUMPE TT,CPOPJ
	SETZ T,
	LSHC T,6
	PUTBYT 40(T)
	JRST STFSIX

MD,<
CTITLE:	MOVE B,TIT1
	PUSHJ P,STUFT1
	PUTBYT 12
	MOVE B,TIT2
	PUSHJ P,STUFT2
	JRST ITSTUF

STITLE:	TLNE M,DSKACT!MACACT
	JRST STITL1
	SKIPE T,TIT1
	PUSHJ P,OUTTCR
	SKIPE T,TIT2
	PUSHJ P,OUTTCR
	OUTSTR[ASCIZ/NEW TITLE LINE 1?/]
STITL1:	PUSHJ P,TREADC
	POPJ P,				;ALTMODE
	SETZ B,				;NULL
	SKIPE T,B
	MOVS T,1(B)
	CAIE T,(<BYTE(7)TEXIST>)	;DON'T CHANGE IF HE TYPE THERE EXISTS
	EXCH B,TIT1
	JUMPE B,.+2
	PUSHJ P,PUTFS
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW TITLE LINE 2?/]
	PUSHJ P,TREADC
	POPJ P,				;ALTMODE
	SETZ B,				;NULL
	SKIPE T,B
	MOVS T,1(B)
	CAIE T,(<BYTE(7)TEXIST>)
	EXCH B,TIT2
	JUMPN B,PUTFS
	POPJ P,

CSITE:	MOVE B,SITE1
	PUSHJ P,STUFT1
	PUTBYT 12
	MOVE B,SITE2
	PUSHJ P,STUFT2
	JRST ITSTUF

SITE:	TLNE M,DSKACT!MACACT
	JRST SITE0
	SKIPE T,SITE1
	PUSHJ P,OUTTCR
	SKIPE T,SITE2
	PUSHJ P,OUTTCR
	OUTSTR[ASCIZ/NEW SITE LINE 1?/]
SITE0:	PUSHJ P,TREADC
	POPJ P,				;ALTMODE
	SETZ B,				;NULL
	SKIPE T,B
	MOVS T,1(B)
	CAIE T,(<BYTE(7)TEXIST>)	;DON'T CHANGE IF HE TYPE THERE EXISTS
	EXCH B,SITE1
	JUMPE B,.+2
	PUSHJ P,PUTFS
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW SITE LINE 2?/]
	PUSHJ P,TREADC
	POPJ P,				;ALTMODE
	SETZ B,				;NULL
	SKIPE T,B
	MOVS T,1(B)
	CAIE T,(<BYTE(7)TEXIST>)
	EXCH B,SITE2
	JUMPN B,PUTFS
	POPJ P,

DEFINE TITLIN $ (LABEL,CLABEL,TPTR,PROMPT,MAXLEN,CHANGE)
<
CLABEL:	MOVE B,TPTR
	JRST STUFT0

LABEL:	TLNE M,DSKACT!MACACT
	JRST .$LABEL
	SKIPE T,TPTR
	PUSHJ P,OUTTCR
	OUTSTR[ASCIZ/NEW PROMPT?/]
.$LABEL:
	PUSHJ P,TREADC
	POPJ P,				;ALTMODE
	SETZ B,				;NULL
IFDIF<MAXLEN><><
	MOVEI T,MAXLEN
	PUSHJ P,LENCHK		;CHECK LENGTH AND PRINT WARNING MESSAGE
>
	SKIPE T,B
	MOVS T,1(B)
	CAIE T,(<BYTE(7)TEXIST>)	;THIS SHOULD ALWAYS WORK
	EXCH B,TPTR
IFIDN<CHANGE><C><TRO MCHG>
	JUMPN B,PUTFS
	POPJ P,
>

LENCHK:	JUMPE B,CPOPJ
	HRLM T,(P)		;SAVE ORIGINAL NUMBER
	PUSH P,T
	MOVE T,B
	ADD T,[POINT 7,1]
LENCK1:	TLNE T,760000
	JRST LENCK2
	HRR T,-1(T)
	TRNN T,-1
	JRST LENCK3		;END BEFORE COUNT OUT
LENCK2:	ILDB TT,T
	JUMPE TT,LENCK1
	SOSL (P)		;COUNT DOWN BY ONE
	JRST LENCK1		;LOOP IF NOT COUNTED OUT
	OUTSTR[ASCIZ/STRING TOO LONG, MAX LENGTH IS /]
	HLRZ T,-1(P)
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/.
WILL STORE STRING ANYWAY.
/]
LENCK3:	POP P,(P)
	POPJ P,

TITLIN(AUTHOR,CAUTHOR,TAUTHOR,AUTHOR)

TITLIN(REVISE,CREVISE,TREV,REVISION,4,C)

TITLIN(MODULE,CMODULE,TMODULE,MODULE NAME,5,C)

TITLIN(VARIABLE,CVARIABLE,TVARIABLE,VARIABLE,2,C)

TITLIN(PREFIX,CPREFIX,TPREFIX,DRAWING PREFIX,4,C)

CLRNUM:	MOVE B,TMODULE
	PUSHJ P,STUFT1
	PUTBYT 12
	PUSHJ P,STUFT2
	PUTBYT 12
	PUSHJ P,STUFT2
	JRST ITSTUF

SETNUM:	PUSHJ P,MODULE
	PUSHJ P,VARIABLE
	JRST PREFIX

TITLIN(PROJECT,CPROJECT,TPROJ,PROJECT NAME,10)

CPAGEOF:
	MOVE B,TPAGE
	PUSHJ P,STUFT1
	PUTBYT 12
	MOVE B,TOF
	PUSHJ P,STUFT2
	JRST ITSTUF

PAGEOF:	TLNE M,DSKACT!MACACT
	JRST PAGOF0
	SKIPE T,TPAGE
	PUSHJ P,OUTTCR
	SKIPE T,TOF
	PUSHJ P,OUTTCR
	OUTSTR[ASCIZ/SHEET?/]
PAGOF0:	PUSHJ P,TREADC
	POPJ P,				;ALTMODE
	SETZ B,				;NULL
	SKIPE T,B
	MOVS T,1(B)
	CAIE T,(<BYTE(7)TEXIST>)	;DON'T CHANGE IF HE TYPE THERE EXISTS
	EXCH B,TPAGE
	JUMPE B,.+2
	PUSHJ P,PUTFS
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/OF?/]
	PUSHJ P,TREADC
	POPJ P,				;ALTMODE
	SETZ B,				;NULL
	SKIPE T,B
	MOVS T,1(B)
	CAIE T,(<BYTE(7)TEXIST>)
	EXCH B,TOF
	JUMPN B,PUTFS
	POPJ P,

TITLIN(DCODE,CDCODE,TDCODE,DRAWING CODE,2)

DEC,<
TITLIN(SETNXT,CLRNXT,TNXTHI,NEXT HIGHER ASSEMBLY NUMBER,=20)

CLRDRN:	MOVEI B,DRNNAM
	JRST CLRSIG

CLRENG:	MOVEI B,ENGNAM
	JRST CLRSIG

SETDRN:	MOVEI A,DRNNAM
	MOVEI T,[ASCIZ/DRN./]
	JRST SETSIG

SETENG:	MOVEI A,ENGNAM
	MOVEI T,[ASCIZ/ENG./]
SETSIG:	TLNE M,DSKACT!MACACT
	JRST SETSG1
	PUSH P,T
	SKIPE (A)
	JSR FPRINT
	OUTSTR[ASCIZ/
NEW /]
	POP P,T
	OUTSTR(T)
	OUTSTR[ASCIZ/ SIGNATURE /]
SETSG1:	PUSH P,A
	MOVSI T,EXTSIG
	PUSHJ P,SETNAM
	JRST [	POP P,A
		SETZM (A)
		POPJ P,]
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POP P,A
		POPJ P,]
	MOVEI A,FILNAM
	TLNE M,DSKACT!MACACT
	JRST SETSG2
	OUTSTR[ASCIZ/CHECKING EXISTENCE OF /]
	JSR FPRINT
SETSG2:	SKIPN T,FILPPN
	MOVE T,LIBPPN
	MOVEM T,FILPPN
	LOOKUP DAT,FILNAM
	JRST [	POP P,A
		JRST LOOKRR]
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
	OUTSTR[ASCIZ/
/]
	RELEASE DAT,
	POP P,A
	MOVE T,FILNAM
	MOVEM T,(A)
	MOVE T,FILEXT
	HLLZM T,1(A)
	MOVE T,FILPPN
	MOVEM T,3(A)
	DATE T,		;USE CURRENT DATE
	HRRM T,1(A)
	POPJ P,
>;DEC

STUFT0:	PUSHJ P,STUFT1
	JRST ITSTUF

STUFT1:	PUSHJ P,SETTT
STUFT2:	JUMPE B,CPOPJ
	MOVEI T,1(B)
	HRLI T,(<POINT 7,0>)
STUFT3:	PUSHJ P,GETTT
	POPJ P,
	PUTBYT (C)
	JRST STUFT3

LTITLE:	SKIPE T,SITE1
	PUSHJ P,[OUTSTR[ASCIZ/
SITE LINE 1  /]
		JRST OUTTXT]
	SKIPE T,SITE2
	PUSHJ P,[OUTSTR[ASCIZ/
SITE LINE 2  /]
		JRST OUTTXT]
	SKIPE T,TAUTHOR
	PUSHJ P,[OUTSTR[ASCIZ/
AUTHOR /]
		JRST OUTTXT]
	SKIPE T,TIT1
	PUSHJ P,[OUTSTR[ASCIZ/
TITLE LINE 1  /]
		JRST OUTTXT]
	SKIPE T,TIT2
	PUSHJ P,[OUTSTR[ASCIZ/
TITLE LINE 2  /]
		JRST OUTTXT]
	SKIPN TVARIABLE
	SKIPE TPREFIX
	JRST DODNUM
	SKIPN TMODULE
	JRST NODNUM
DODNUM:	OUTSTR[ASCIZ/
DRAWING NUMBER:	/]
	SKIPE T,TMODULE
	PUSHJ P,OUTTXT
	SKIPE T,TVARIABLE
	PUSHJ P,[OUTCHR["-"]
		JRST OUTTXT]
	SKIPE T,TPREFIX
	PUSHJ P,[OUTCHR["-"]
		JRST OUTTXT]
NODNUM:	SKIPE T,TREV
	PUSHJ P,[OUTSTR[ASCIZ/
REVISION /]
		JRST OUTTXT]
	SKIPE T,TPROJ
	PUSHJ P,[OUTSTR[ASCIZ/
PROJECT /]
		JRST OUTTXT]
	SKIPE T,TDCODE
	PUSHJ P,[OUTSTR[ASCIZ/

DRAWING CODE = /]
		JRST OUTTXT]
	SKIPN T,TPAGE
	SKIPE TOF
	CAIA
	JRST NODCOD
	OUTSTR[ASCIZ/
SHEET /]
	JUMPE T,.+2
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ OF /]
	SKIPE T,TOF
	PUSHJ P,OUTTXT
NODCOD:
DEC,<
FOR @$I IN(DRN,ENG)
<	SKIPN I$NAM
	JRST NLT$I
	OUTSTR[ASCIZ/
I:	/]
	MOVEI A,I$NAM
	JSR FPRINT
NLT$I:
>
	SKIPE T,TNXTHI
	PUSHJ P,[OUTSTR[ASCIZ/

NEXT HIGHER ASSEMBLY NUMBER = /]
		JRST OUTTXT]
>;DEC
	OUTSTR[ASCIZ/
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;MORE SET AND CLEAR STUFF
UNDRLN:	SETOM ULNFLG
	POPJ P,

NUNDRL:	SETZM ULNFLG
	POPJ P,

SETDMD:	TLO M,DIAMONDS
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/DIAMONDS AT JUNCTIONS OF 3 LINES/]
	PUSHJ P,YORN
	JFCL
	TLZA M,JUNC3
	TLO M,JUNC3		;YES.
	POPJ P,

CLRDMD:	TLZ M,DIAMONDS!JUNC3
	POPJ P,
>;MD

MPC,<
STCARD:	TLON M,CRDISP
	TRO MCHG
	POPJ P,

CLCARD:	TLZE M,CRDISP
	TRO MCHG
	POPJ P,

;HERE WE DELETE LINES, TEXT, AND POINTS WITHOUT DRILL HOLES
;ALSO SET PAD TYPES TO 2 (CLEARANCE)
INNER:	TRZ INLIN!INMOV
	TRO NEEDCL
	MOVEI B,PONPNT
	PUSHJ P,PNTKIL
	MOVEI B,PONPN2
	PUSHJ P,PNTKIL
	OUTSTR[ASCIZ/WELL, NOW YOU'VE REALLY DONE IT OLLY!
THIS USED TO BE A NICE PC CARD!
/]
	SETZM LSTNAM		;DISABLE 
LAY,<	SETZM SAVNAM	>
	TRO MCHG
	JRST FILEUP		;UPDATE ON SCREEN

PNTKL1:	HLRZ T,(B)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLNE TT,CPIN
	JRST STCLR1		;CONNECTORS ARE SPCIAL
	TLNE TT,ISPIN!FEEDTH
	JRST STCLR
	TRZ TFLG
	PUSH P,A		;SAVE LAST
	PUSHJ P,DELPNT		;DELETE POINT
	POP P,B			;RESTORE LAST AS THIS
	JRST PNTKIL

STCLR:	MOVEI TT,2		;SET CLEARANCE PAD
	HRRM TT,1(T)
STCLR1:	PUSHJ P,KILPNT		;FLUSH LINES AND TEXT
PNTKIL:	MOVE A,B
	HRRZ B,(B)
	JUMPN B,PNTKL1
	POPJ P,

PPLOT:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PLANE NUMBER?/]
	PUSHJ P,READNC
	ADDI T,1
	MOVEM T,CPLANE
	JRST PLPLOT

MUNG:	MOVE T,MODE
	CAIE T,SETM	;SET MODE IS SPECIAL
	JRST MUSH
	JRST STMUSH	;MUSH SET ONLY

SETPWR:	MOVEI D,1	;DIVIDE BY 1 TO GET PWR PIN
	MOVEI F,2	;AND DEPOSIT A 2 (POWER PLANE)
	OUTSTR[ASCIZ/CONNECT HIGHEST NUMBERED PIN OF DIP TO POWER/]
	PUSHJ P,YORN
	JFCL
	CAIA
	PUSHJ P,PWRGND
NOUML,<	POPJ P,>
UML,<	MOVEI E,[<ASCII/VCC/>
		ASCIZ/VCC/]
PGSIGS:	OUTSTR[ASCIZ/CONNECT /]
	OUTSTR 1(E)
	OUTSTR[ASCIZ/ RUN TO INNER PLANE/]
	PUSHJ P,YORN
	POPJ P,
	POPJ P,
	SKIPN G,WIRLST
	JRST NOPGSG
PGSIG1:	HRRZ C,1(G)
PGSIG2:	HLRZ A,1(C)
	JUMPE A,PGSIG3
	ADD A,[POINT 7,1]
	MOVE B,E
	PUSHJ P,SIGMAT
	JRST PGSIG3
	JRST ISPORG		;EQUIVALENT IS CLOSE ENOUGH
	JRST ISPORG

PGSIG3:	HRRZ C,(C)
	JUMPN C,PGSIG2
	HRRZ G,(G)
	JUMPN G,PGSIG1
NOPGSG:	OUTSTR[ASCIZ/NO /]
	OUTSTR 1(E)
	OUTSTR[ASCIZ/ RUN!
/]
	POPJ P,

ISPORG:	HRRZ G,1(G)
ISPOR1:	HLRZ E,(G)
	JUMPE E,ISNPG
	HLRZ A,(E)
	HLRZ B,(A)
	HRRZ A,1(A)
	HLL B,1(A)
	TLNN B,ISPIN	;PINS ONLY!
	JRST ISNPG
	MOVE T,F
	PUSHJ P,UNPLN1
ISNPG:	HRRZ G,(G)
	JUMPN G,ISPOR1
	POPJ P,
>;UML

SETGND:	MOVEI D,2	;DIVIDE BY 2
	MOVEI F,1	;AND SET TO 1 (GROUND PLANE)
	OUTSTR[ASCIZ/CONNECT HALF HIGHEST NUMBERED PIN OF DIP TO GROUND/]
	PUSHJ P,YORN
	JFCL
	CAIA
	PUSHJ P,PWRGND
NOUML,<	POPJ P,>
UML,<	MOVEI E,[<ASCII/GND/>
		ASCIZ/GND/]
	JRST PGSIGS
>;UML

PWRGND:	MOVE T,F
	SKIPE E,PONPNT
	PUSHJ P,PGSET
	SKIPE E,PONPN2
	PUSHJ P,PGSET
	TRO MCHG
	POPJ P,

PGSET:	HLRZ A,(E)
	HLRZ B,(A)
	HRRZ A,1(A)
	HLL B,1(A)
	TLNN B,ISPIN
	JRST NPGPIN
	HLRZ B,(B)
	HRRZ B,1(B)	;POINTER TO TYPE DEFINITION
	HLRZ B,(B)	;NUMBER OF PINS, THIS TYPE
	CAIG B,3	;IS IT BIGGER THAN TRANSISTOR?
	JRST NPGPIN
	IDIV B,D
	HRRZ C,(A)
	HLRZ C,(C)
	CAMN C,B
	PUSHJ P,UNPLN1
NPGPIN:	HRRZ E,(E)
	JUMPN E,PGSET
	POPJ P,
                                                                      ;ROUTING PARAMETERS
ROUTE,<
SETRTE:	PUSHJ P,BITINI
	TLNE M,RDISP
	TRO MCHG
	POPJ P,

SETRDS:	TLNN M,%ROUTE
	PUSHJ P,BITINI		;FORCE INTIALIZATION
	TLOE M,RDISP
	POPJ P,
	TRO MCHG
	POPJ P,

CLRRDS:	TLZE M,RDISP
	TRO MCHG
	POPJ P,

SETRCD:	OUTSTR[ASCIZ/ROUTE CODE = /]
	PUSHJ P,READNC
	CAILE T,3
	JRST PERRET
	MOVEM T,RCODE
	POPJ P,

SETCNR:	MOVEI A,.CNR
	JRST SETRT

SETFED:	MOVEI A,.FED
	JRST SETRT

SETBAK:	MOVEI A,.BAK
	JRST SETRT

SETSID:	MOVEI A,.SID
SETRT:	OUTSTR[ASCIZ/OLD VALUE = /]
	MOVE T,(A)
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
NEW VALUE = /]
	PUSHJ P,SREADN
	CAIE C,12		;ENDING OK?
	JRST INNERR		;NO, GET OUT
	MOVEM T,(A)		;STORE NEW VALUE
	POPJ P,
>;ROUTE
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;SET CARD LOC(D,PC)
SETLOC:	TLNE M,DSKACT!MACACT
	JRST SETLC1
	OUTSTR[ASCIZ/SET CARD LOCATION.
/]
	OUTSTR @SLTCUE
	OUTCHR["?"]
SETLC1:	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
	PUSHJ P,GETSLT
	JRST INNERR
	CAIE C,12
	JRST INNERR
	SKIPN C,LETTER
	JRST [
MD,<		SKIPN CRDLOC		;CRDLOC SET FOR WHOLE CARD?
		JRST CLRLCB		;NO, SET INDIVIDUALLY
>;MD
		SETZM CRDLOC
		TRO MCHG
		POPJ P,]
MPC,<	HLLZ C,LETTER
	MOVEM C,CRDLOC
	TRO MCHG
	POPJ P,
>;MPC
MD,<	OUTSTR[ASCIZ/SHALL I SET THIS AS PERMANENT CARD LOC FOR WHOLE DWG,
OR JUST SPREAD THIS THROUGH BODIES AND CPINS (Y FOR PERM)/]
	PUSHJ P,YORN
	JFCL
	CAIA
	JRST [	MOVE T,LETTER
		MOVEM T,CRDLOC
		SETZM LETTER	;NOW CLEAR CRDLOC'S IN INDIVIDUAL CPINS AND BODIES
		JRST CLRLCB]
	SETZM CRDLOC		;CLEAR GLOBAL CRDLOC
CLRLCB:	MOVEI A,DBODPN
	TRO MCHG
	JRST SETLCB

STLCB1:	HLRZ TTT,(A)
	HLRZ TTT,1(TTT)
	HRRZ T,(TTT)
	JUMPE T,SETLCB
	HLRZ T,(T)
	HLLZ TT,LETTER
	HLLM TT,(T)
	MOVE T,A
	PUSH P,A
	PUSHJ P,OFFBLO
	POP P,A
SETLCB:	HRRZ A,(A)
	JUMPN A,STLCB1
	MOVEI A,PONPNT
	JRST SETLCC

STLCC1:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLNN TT,CPIN
	JRST SETLCC
	HRRZ T,(T)
	HLLZ TT,LETTER
	HLLM TT,(T)
SETLCC:	HRRZ A,(A)
	JUMPN A,STLCC1
	TRO MCHG!NEEDCL
	POPJ P,
>;MD

SETLZ:	SKIPN A,DBODPN
	POPJ P,
	TRO MCHG
SETLZ1:	HLRZ T,(A)
	HLRZ T,1(T)
MD,<	HRRZ TT,(T)
	JUMPE TT,SETLZ2
	HLLZS (T)
	HLRZ TTT,(TT)
	FSTRET(TTT)
	FSTRET(TT)
SETLZ2:
>;MD
MPC,<	HLLZS (T)	>
	HRRZ A,(A)
	JUMPN A,SETLZ1
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                     ;UML STUFF
MPC,<
%LIM__=300/5*2

UMLREL:	SKIPE B,XUMLPN
	PUSHJ P,PUTFS
	SETZM XUMLPN
	SKIPE B,YUMLPN
	PUSHJ P,PUTFS
	SETZM YUMLPN
	POPJ P,

DOUML:	SKIPN DBODPN		;ANYTHING TO DO IT TO?
	JRST PERRET
	PUSHJ P,UMLREL
	OUTSTR[ASCIZ/<SMALLEST L><SMALLEST N>?/]
	PUSHJ P,GETLET
	JRST INNERR
	SKIPG C,L2N-"A"(C)	;GET ITS NUMBER
	JRST INNERR
	MOVEM C,L1
	PUSHJ P,READNC
	JUMPE T,INNERR
	MOVEM T,N1
	MOVE A,DBODPN
DOUML1:	HLLZ T,1(A)		;GET X LOCATION
	MOVEI B,XUMLPN
	PUSHJ P,DOUMLA
	HRLZ T,1(A)
	MOVEI B,YUMLPN
	PUSHJ P,DOUMLA
	HRRZ A,(A)
	JUMPN A,DOUML1
	MOVE A,DBODPN		;TAKE IT FROM THE TOP!
DOUML2:	HLLZ T,1(A)
	MOVEI B,XUMLPN
	PUSHJ P,DOUMLB
	HLRZ D,(A)
	HLRZ D,1(D)
	ADD C,N1
	DPB C,[POINT 6,(D),29]	;STORE NUMBER
	CAILE C,77
	OUTSTR[ASCIZ/NUMBER OVERFLOW!
/]
	HRLZ T,1(A)
	MOVEI B,YUMLPN
	PUSHJ P,DOUMLB
	ADD C,L1
	DPB C,[POINT 6,(D),23]	;AND LETTER
	ANDI C,77		;MAKE SURE WE DON'T GO OFF END OF TABLE
	MOVE C,N2L(C)
	CAIN C,"?"		;ERROR?
	OUTSTR[ASCIZ/LETTER OVERFLOW!
/]
	HRRZ A,(A)
	JUMPN A,DOUML2
	PUSHJ P,UMLREL
                                                                                                                                                                                                                 ;MORE UML
;HERE WE CHECK FOR DUPLICATION OF LOCATION, AND TRY TO FLUSH IT

	MOVE A,DBODPN
DOUML4:	MOVE B,A
	HLRZ B,(A)
	HLRZ B,1(B)
	LDB C,[POINT 6,(B),29]		;NUMBER
	LDB B,[POINT 6,(B),23]		;LETTER
	MOVE D,A
	CAIL B,77
	CAIE C,"Z"-100
	JRST DOUML6
	JRST DOUML7			;LOSE BIG, CAN'T MOVE THIS

DOUML5:	HLRZ E,(D)
	HLRZ E,1(E)
	LDB T,[POINT 6,(E),23]		;LETTER
	LDB TT,[POINT 6,(E),29]		;NUMBER
	CAMN B,T		;SAME LETTER?
	CAME C,TT		;AND NUMBER?
	JRST DOUML6		;NO
	MOVE T,1(A)		;X,Y OF ONE
	TLO T,1
	SUB T,1(D)		;THIS IS DELTA X,Y
	HLRE TT,T
	MOVM TT,TT
	HRRE TTT,T
	MOVM TTT,TTT
	MOVEI F,0
	MOVEI G,2
	TLNE T,400000
	MOVEI F,1		;-DELTA X
	TRNE T,400000
	MOVEI G,3		;-DELTA Y
	CAMG TTT,TT
	CAIGE B,"Z"-100		;IF LETTER IS MAX, FORCE CHANGE OF NUMBER
	CAIA
	EXCH G,F		;(DELTA XDELTA Y)
	XCT PNTAB(G)
	HLRZ T,(D)
	HLRZ T,1(T)
	LDB B,LNTAB(G)
	ADDI B,1		;INC LETTER OR NUMBER
	DPB B,LNTAB(G)		;PUT IT BACK
	MOVE C,B
	MOVE E,DBODPN		;PUSH EVERYONE UP FROM HERE
DOUML7:	HLRZ T,(E)
	HLRZ T,1(T)
	LDB B,LNTAB(G)
	CAML B,C		;IS GREATER OF EQUAL TO ONE WE JUST CHANGED
	CAIN D,(E)		;AND NOT THE ONE WE JUST CHANGED?
	CAIA			;SKIP IT
	ADDI B,1		;INCREASE IT
	DPB B,LNTAB(G)		;STORE IT BACK
	HRRZ E,(E)
	JUMPN E,DOUML7		;LOOP THROUGH ALL OF THEM
	JRST DOUML4		;THEN START OVER (SEE US BE SLOW)
DOUML6:	HRRZ D,(D)
	JUMPN D,DOUML5		;CONTINUE DOWN FROM CURRENT BODY
DOUML8:	HRRZ A,(A)
	JUMPN A,DOUML4		;GET ANOTHER CURRENT BODY
	TRO MCHG
	POPJ P,			;YOU MEAN WE'RE DONE?

PNTAB:	JFCL
	MOVE D,A	;AD INCREASE IT
	JFCL
	MOVE D,A	;AD INCREASE IT

LNTAB:	POINT 6,(T),29		;NUMBER
	POINT 6,(T),29		;NUMBER
	POINT 6,(T),23		;LETTER
	POINT 6,(T),23		;LETTER
                                                                                                                                                                                                                    ;STILL MORE UML
DUMLA1:	MOVE TT,T
	SUB TT,(B)
	MOVE TTT,1(B)
	SUB TTT,T
	JUMPG TT,ABOVEA
	JUMPG TTT,BELOWA
	POPJ P,		;AND RETURN
ABOVEA:	HLLZ TTT,(B)
	SUB TTT,1(B)
	ADD TTT,TT
	CAMLE TTT,[%LIM,,0]
	JRST DUMLA2
	HLLM T,(B)	;STORE NEW TOP
	POPJ P,		;AND RETURN
BELOWA:	HLLZ TT,(B)
	SUB TT,1(B)
	ADD TTT,TT
	CAMLE TTT,[%LIM,,0]
	JRST DOUMLA
	HLLM T,1(B)
	POPJ P,
DOUMLA:	MOVE E,B
	HRRZ B,(B)
	JUMPN B,DUMLA1
DUMLA2:	GETFS(TT)
	HRRM B,(TT)
	HRRM TT,(E)
	HLLM T,(TT)
	HLLZM T,1(TT)
	POPJ P,

DUMLB1:	CAML T,1(B)	;IS THIS THE ONE?
	POPJ P,		;YES
	AOSA C
DOUMLB:	SETZ C,
DUMLB2:	HRRZ B,(B)
	JUMPN B,DUMLB1
	PUSHJ P,FUCKUP
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;COUNT THINGS
DOCNT:
MD,<	SETZM COUNT
	SETZM COUNT2
>;MD
MPC,<	SETZM L1
>;MPC
	SKIPE A,PONPNT
	PUSHJ P,DOCNT1
MPC,<	SETZM COUNT
	SETZM COUNT2
	SKIPE A,PONPN2
	PUSHJ P,DOCNT1
>;MPC
MD,<	MOVE T,COUNT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ POINTS!
/]
	MOVE T,COUNT2
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ CONNECTOR PINS!
/]
>;MD
MPC,<	MOVE T,COUNT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ DIP PADS.
/]
	MOVE T,COUNT2
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ FEEDTHROUGHS.
/]
	MOVE T,L1
	PUSHJ P,MILOUT
	OUTSTR[ASCIZ/ INCHES OF ETCH.
/]
>;MPC
	SKIPE DBODPN
	SKIPN A,BODPNT
	POPJ P,
BDCNT:	MOVE B,DBODPN
	SETZ C,
BDCNT1:	HLRZ T,(B)
	HRRZ T,1(T)
	CAMN T,A
	ADDI C,1
	HRRZ B,(B)
	JUMPN B,BDCNT1
	JUMPE C,BDNONE
	OUTSTR[ASCIZ/
/]
MD,<
	HRRZ T,(A)
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/	/]
>;MD
	MOVE T,C
	PUSHJ P,DECOUT
MD,<	HLRZ B,(A)
	JUMPE B,BDNONE
	PUSHJ P,LIBTAB
	OUTSTR NAMBUF
>;MD
MPC,<	OUTSTR[ASCIZ/	/]
	HLRZ T,(A)
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ PIN DIPS/]
	HLRZ T,(A)
	CAIE T,2		;2 PIN DIPS ARE SPECIAL
	JRST BDNONE
	HRRZ T,1(A)
	MOVE T,1(T)		;1/2 Y VALUE * 2
	IMULI T,5		;CONVERT TO MILS
	OUTSTR[ASCIZ/ SEPERATED BY /]
	PUSH P,T
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ MILS/]
	POP P,T
	CAIN T,=400
	OUTSTR[ASCIZ/ (RESISTORS)/]
	CAIN T,=300
	OUTSTR[ASCIZ/ (CAPACITORS)/]
>;MPC
BDNONE:	HRRZ A,MD,<1>(A)
	JUMPN A,BDCNT
	OUTSTR[ASCIZ/
/]
	POPJ P,

DOCNT1:	HLRZ B,(A)
	HRRZ C,1(B)
	MOVE C,1(C)
MD,<	AOS COUNT		;COUNT A POINT
	TLNE C,CPIN		;THESE ARE CONNECTOR PINS
	AOS COUNT2
>;MD
MPC,<	TLNE C,ISPIN
	AOS COUNT
	TLNE C,FEEDTH
	AOS COUNT2
	MOVE C,1(A)		;GET X,Y FOR COMPARISON
	HLRZ B,1(B)		;NEIGHBOR LIST POINTER
	JUMPE B,DOCNT2		;SKIP IF NONE
DOCNT3:	MOVEI D,2
DOCNT4:	XCT (D)[HLRZ E,(B)
		HLRZ E,1(B)
		HRRZ E,1(B)]
	JUMPE E,DOCNT5
	CAML C,1(E)		;ONLY DO IN ONE DIRECTION
	JRST DOCNT5
	HLRE T,C
	HLRE TT,1(E)
	SUB T,TT
	IMUL T,T
	HRRE TT,C
	HRRE TTT,1(E)
	SUB TT,TTT
	IMUL TT,TT
	ADD T,TT
	PUSHJ P,SQRT
	ADDM T,L1
DOCNT5:	SOJGE D,DOCNT4
	HRRZ B,(B)
	JUMPN B,DOCNT3
DOCNT2:
>;MPC
	HRRZ A,(A)
	JUMPN A,DOCNT1
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;BRIGHTNESS, SCALE
ITBRT:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NORMAL BRIGHTNESS?/]
	MOVEI A,DEFBRT
	PUSHJ P,ITBRTS
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ADDITIONAL BLINKING BRIGHTNESS?/]
	MOVEI A,BLBRT
	PUSHJ P,ITBRTS
MPC,<	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/BOTH SIDES BRIGHTNESS?/]
	MOVEI A,BTHBRT
	PUSHJ P,ITBRTS
>;MPC
	POPJ P,

ITBRTS:	PUSHJ P,GETCHR
	CAIN C,12
	POPJ P,
	CAIN C,ALTMOD
	JRST ITBRTT		;NO CHANGE
	CAIL C,"0"
	CAILE C,"7"		;LEGAL BRIGHTNESS?
	JRST [	PUSHJ P,PERRET	;NO
		OUTSTR[ASCIZ/BRIGHTNESS?/]
		JRST ITBRTS]
	MOVEI T,-60(C)
	CAME T,(A)
	TRO MCHG		;GET IT DONE!
	MOVEM T,(A)		;SET NEW DEFAULT BRIGHTNESS
ITBRTT:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
/]
	POPJ P,

CLRBRT:
NOITS,<NODEC,<	MOVEI T,1	>>
ITS,<	MOVEI T,4	>
DEC,<	MOVEI T,5	>
	CAME T,DEFBRT
	TRO MCHG
	MOVEM T,DEFBRT		;DEFAULT BRIGHTNESS IS 1
STANFO,<	MOVEI T,3	>
NOSTANFO,<	MOVEI T,7	>
	CAME T,BLBRT
	TRO MCHG
	MOVEM T,BLBRT
MPC,<
STANFO,<	MOVEI T,5	>
NOSTANFO,<	MOVEI T,7	>
	CAME T,BTHBRT
	TRO MCHG
	MOVEM T,BTHBRT
>;MPC
	POPJ P,

ITCBRT:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/CURSOR BRIGHTNESS?/]
	PUSHJ P,GETCHR
	CAIL C,"0"
	CAILE C,"7"
	JRST PERRET
	MOVEI T,-60(C)
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/
/]
	JRST CURBRT

CLCBRT:
STANFO,<	MOVEI T,3	>
ITS,<	MOVEI T,7	>
DEC,<	MOVEI T,5	>
	JRST CURBRT		;START CURSOR AT BRIGHTNESS 3

ITSCAL:	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ /SCALE?/]
	PUSHJ P,READNC
	JUMPE T,CPOPJ
	CAMN T,NSCALE
	POPJ P,
	MOVEM T,NSCALE
	JRST CHANG1
                                                                                                                                                                                                                                                                                                                                                                                                        ;SIZE STUFF - ITSET, PICCEN
MD,<
PICCEN:	PUSHJ P,ITSET
	MOVN T,MAXX
	SUB T,MINX
	ASH T,-1
	MOVS T,T
	MOVN TT,MAXY
	SUB TT,MINY
	ASH TT,-1
	HRR T,TT
	TDZ T,[1,,1]
	JUMPE T,CPOPJ
	SKIPE A,PONPNT
	PUSHJ P,PICCN1
	SKIPE A,DBODPN
	PUSHJ P,PICCN1
	SKIPE A,SETPNT
	PUSHJ P,PICCN1
	TRO MCHG!NEEDCL
	JRST HOME		;NOW CENTER PHYSICAL SCREEN

PICCN1:	MOVE TT,1(A)
	ADJUST(ADD,TT,T)
	MOVEM TT,1(A)
	HRRZ A,(A)
	JUMPN A,PICCN1
	POPJ P,
>;MD
	
ITSET:	MOVSI T,400000
	MOVEM T,MAXX
	MOVEM T,MAXY
	SETCAM T,MINX
	SETCAM T,MINY
MD,<	MOVEI T,10			;DISTXT EXPECTS THIS
	MOVEM T,CSCALE
	SKIPE A,DBODPN
	PUSHJ P,CHKBDS
>;MD
	SKIPE A,PONPNT
	PUSHJ P,CHKDIS
MPC,<	SKIPE A,PONPN2
	PUSHJ P,CHKDIS
>;MPC
	HLRES MINX
	HLRES MAXX
	POPJ P,

CHKDIS:	MOVE T,1(A)
	PUSHJ P,MAXMIN
	HLRZ B,(A)
	HRRZ B,1(B)
	TRNE M,NPTEXT			;DOING POINT TEXT?
	JRST CHKDS1
	HLRZ TTT,(B)			;TEXT POINTER
	JUMPE TTT,CHKDS1		;MAYBE NONE
	MOVE T,1(A)			;X,Y AGAIN
	PUSHJ P,DISTXT			;CALC MAX AND MIN
CHKDS1:
MD,<	HLL B,1(B)
	TLNE B,CPIN			;CONNECTOR PIN HERE?
	TLNN M,CLOCS			;YES, DOING THEM?
	JRST CHKDS2			;NO
	MOVE T,1(A)
	HRRZ B,(B)
	HLRE TT,1(B)
	UNSCAL TT
	HRLZ TT,TT
	ADD T,TT
	HRRE TT,1(B)
	UNSCAL TT
	HRRZ TT,TT
	ADD T,TT
	TLZ T,1
	PUSH P,T
	TRNE M,NOCBOX
	JRST CHKDS3
	MOVEI TT,CHGHT
	IMUL TT,CMUL+STDBIG
	ASH TT,-1
	HRLZ TT,TT
	SUB T,TT
CHKDS3:	PUSHJ P,MAXMIN			;LOWER LEFT EXTREMES
	PUSHJ P,CONCAL			;CALC LENGTH OF CONNECTOR SPEC
	IMULI T,CWIDTH
	IMUL T,CMUL+STDBIG
	HRLZ T,T
	POP P,TT
	ADD T,TT
	MOVEI TT,CHGHT
	IMUL TT,CMUL+STDBIG
	ADD T,TT
	TLZ T,1
	TRNE M,NOCBOX
	JRST CHKDS4
	ASH TT,-1
	HRLZ TT,TT
	ADD T,TT
CHKDS4:	PUSHJ P,MAXMIN			;UPPER RIGHT EXTREMES
CHKDS2:
>;MD
	HRRZ A,(A)
	JUMPN A,CHKDIS
	POPJ P,

MAXMIN:	CAMLE T,MAXX
	MOVEM T,MAXX
	CAMGE T,MINX
	MOVEM T,MINX
	HRRES T
	CAMLE T,MAXY
	MOVEM T,MAXY
	CAMGE T,MINY
	MOVEM T,MINY
	POPJ P,

DISTXT:	HLRE TT,1(TTT)
	UNSCAL TT
	HRLZ TT,TT
	ADD T,TT
	HRRE TT,1(TTT)
	UNSCAL TT
	HRRZ TT,TT
	ADD T,TT
	TLZ T,1
	ADD TTT,[POINT 7,1,35]		;MAKE A BYTE POINTER
	HRRZ TT,-1(TTT)
	HLRZ TT,(TT)			;SIZE
	SKIPN TT
	MOVEI TT,STDBIG
	MOVE C,TT			;AND A COPY OF IT
	ANDI TT,377777			;JUST SIZE
	MOVE TT,CMUL(TT)		;GET SIZE MULTIPLIER
	PUSH P,TT
	IMULI TT,CWIDTH
MPC,<	LSH TT,1	>
	EXCH TT,(P)			;SAVE (OFFSET FOR ONE CHAR)
	IMULI TT,CHGHT
MPC,<	LSH TT,1	>
MD,<	UNSCAL TT	>
	TRNE C,400000
	MOVNS TT
	HRRZS TT
	TRNE C,400000
	MOVSS TT
	PUSH P,T			;SAVE IT
	ADJUST(ADD,T,TT)		;UPPER LEFT CORNER OF TEXT
	PUSHJ P,MAXMIN			;CHECK IT
	SETZB T,TT
DSTXT1:	TLNN TTT,760000			;BYTE POINTER OUT?
	JRST DSTXT2
DSTXT3:	ILDB D,TTT		;GET A CHAR
	JUMPE D,DSTXT1
	CAIE D,DBLARR		;CRLF?
	AOJA T,DSTXT1		;NO
	CAILE T,(TT)		;BIGGER THAN LARGEST?
	HRR  TT,T		;YES
	SETZ T,			;NO CHARS ON NEXT LINE YET!
	ADD TT,[1,,0]		;COUNT ANOTHER LINE
	JRST DSTXT1

DSTXT2:	HRR TTT,-1(TTT)		;FOLLOW LINK
	TRNE TTT,-1		;WAS THERE ONE?
	JRST DSTXT3
	CAILE T,(TT)
	HRR TT,T
	HLRZ T,TT
	HRRZS TT
	ASH T,1			;CHARS ARE TWICE AS HIGH AS WIDE
	IMUL T,-1(P)
	IMUL TT,-1(P)
MD,<
	UNSCAL T
	UNSCAL TT
>;MD
	TRNN C,400000
	MOVNS T
	HRL T,TT
	TRNE C,400000
	MOVSS T
	ADJUST(ADD,T,<(P)>)
	PUSHJ P,MAXMIN		;CHECK LOWER RIGHT CORNER OF TEXT
	POP P,(P)
	POP P,(P)
	POPJ P,

MD,<
CHKBDS:	HLRZ B,(A)
	HLRZ F,(B)		;ORIENTATION OF BODY
	HLRZ T,1(B)
	HRRZ T,1(T)
	MOVEM T,BTXLST
	HRRZ B,1(B)
	HLRZ B,1(B)
	HRRZ C,1(B)		;POINTER TO LINES
	JUMPE C,NCHKLN		;ANY?
CHKLN:	MOVE T,1(C)
	PUSHJ P,ORIENT
	ADJUST(ADD,T,<1(A)>)
	PUSHJ P,MAXMIN
	HRRZ C,(C)
	JUMPN C,CHKLN
NCHKLN:	TRNE M,NBTEXT
	JRST NCHKT
	SKIPN BTXLST
	JRST CHKT0
	MOVE B,BTXLST
CHKT1:	HLRZ T,(B)
	JUMPN T,CHKT2
	PUSH P,B
	HRRZ B,1(B)
	PUSHJ P,DSBTXT
	POP P,B
	JRST CHKT3

CHKT2:	PUSHJ P,DSBTXT
CHKT3:	HRRZ B,(B)
	JUMPN B,CHKT1
	JRST NCHKT

CHKT0:	HLRZ B,1(B)		;POINTER TO TEXT
	JUMPE B,NCHKT
CHKT:	PUSHJ P,DSBTXT
	HRRZ B,(B)
	JUMPN B,CHKT
NCHKT:	HRRZ A,(A)
	JUMPN A,CHKBDS
	POPJ P,

DSBTXT:	HLRZ T,(B)
	HRRZ T,(T)
	HLRZ T,(T)
	TLNN M,%IDENT
	JUMPE T,CPOPJ
	MOVE T,1(B)
	TDZ T,[1,,1]
	PUSHJ P,ORIENT
	ADJUST(ADD,T,<1(A)>)
	HLRZ TTT,(B)
	JRST DISTXT
>;MD
                                                                                                                                                                                                                                                                                            ;MORE SIZE STUFF
ITSIZE:	PUSHJ P,ITSET
MD,<
	OUTSTR[ASCIZ/WHAT SCALE WILL YOU USE IN THE PLOT PROG?/]
	PUSHJ P,READNC
	JUMPE T,CPOPJ
	MOVEM T,ITSSCL
>;MD
	MOVE T,MAXX
	SUB T,MINX
	OUTSTR[ASCIZ/WIDTH OF PIC IS /]
	PUSHJ P,DOSIZE
	MOVE T,MAXY
	SUB T,MINY
	OUTSTR[ASCIZ/HEIGHT OF PIC IS /]
MD,<
	PUSHJ P,DOSIZE
	MOVE T,MAXX
	SUB T,MINX
	SCALET(T)
NODEC,<	IMUL T,ITSSCL		;SCALE IT
	ASH T,-3
>;NODEC
DEC,<	ASH T,-2	>	;DEC SCALE LOOKS LIKE 2
	MOVE TT,MAXY
	SUB TT,MINY
	SCALET(TT)
NODEC,<	IMUL TT,ITSSCL		;SCALE IT
	ASH TT,-3
>;NODEC
DEC,<	ASH TT,-2	>
	TRZ TFLG
	MOVSI TTT,-HBXLEN
	PUSHJ P,BOXCHK
	MOVE TTT,[-VBXLEN,,HBXLEN]
	PUSHJ P,BOXCHK
	TRNN TFLG
	OUTSTR[ASCIZ/NO BOX IS BIG ENOUGH.
/]
	POPJ P,

BOXCHK:	CAMG T,WTAB(TTT)
	CAML TT,HTAB(TTT)
	AOBJN TTT,BOXCHK
	JUMPGE TTT,CPOPJ
	TRO TFLG
	OUTSTR[ASCIZ/SIZE /]
	SKIPGE BTAB(TTT)
	OUTCHR["V"]
	OUTCHR BTAB(TTT)
	OUTSTR[ASCIZ/ IS BIG ENOUGH!
/]
	POPJ P,
>;MD

DOSIZE:	JUMPGE T,.+2
	SETZ T,
MD,<	SCALET(T)
	IMUL T,ITSSCL		;SCALE IT!
	ASH T,-3
>;MD
MPC,<	ASH T,-1	>
	IDIVI T,=200
	PUSH P,TT	;SAVE REMAINDER
	PUSHJ P,DECOUT	;PRINT INCHES
	OUTCHR["."]
	POP P,T
	IMULI T,5
	CAIGE T,=100
	OUTCHR["0"]
	CAIGE T,=10
	OUTCHR["0"]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ INCHES.
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;SHOWBOX
MD,<
STANFO,<
C16:	MOVEI D,"C"			;BOX SIZE C
	MOVEI T,=16
	MOVEM T,SSCALE			;SCALE 16
	JRST C16.1
>;STANFO

SHWBOX:	TLNN M,DSKACT!MACACT
NODEC,<	OUTSTR[ASCIZ\<BOX LETTER><DRAWING SCALE>/<PLOT SCALE>?\]>
DEC,<	OUTSTR[ASCIZ\<BOX LETTER><DRAWING SCALE>?\]>
	PUSHJ P,GETLET
	JRST [	CAIE C,12
		JRST INNERR
	CLRSHW:	SKIPN SWIDTH
		POPJ P,
		SETZM SWIDTH
		TRO MCHG
		POPJ P,]
	CAIE C,"V"			;ASKING FOR VERTICAL?
	JRST NXVERT
	PUSHJ P,GETLET
	JRST INNERR
	TLO C,400000			;MARK AS VERTICAL
NXVERT:	MOVE D,C			;SAVE CHAR
	PUSHJ P,READN
	SKIPN T
	MOVE T,NSCALE
	MOVEM T,SSCALE
NODEC,<	SETZ T,
	CAIN C,"/"
	PUSHJ P,READN
>;NODEC
	CAIE C,12
	JRST INNERR
NODEC,<	SKIPN T>
C16.1:	MOVEI T,2
	MOVSI TTT,-BOXLEN
	CAME D,BTAB(TTT)		;THIS LETTER?
	AOBJN TTT,.-1			;NO
	JUMPGE TTT,INNERR		;LOSE, NOT IN TABLE
	HRRZ D,TTT			;SAVE INDEX
	PUSH P,NSCALE
	MOVE TT,SSCALE
	MOVEM TT,NSCALE
	IMULM T,SSCALE
	LSH T,3
	MOVEM T,CSCALE
	PUSH P,D
	PUSHJ P,ITSET
	POP P,D
	POP P,NSCALE			;RESTORE TRUE SCALE
	MOVE T,MAXX
	ADD T,MINX
	ASH T,-1
	MOVE TT,MAXY
	ADD TT,MINY
	ASH TT,-1
	MOVE A,WTAB(D)
	IDIV A,SSCALE
	ASH A,1
	MOVN B,A
	ADD A,T
	ADD B,T
	HRLM A,SWIDTH
	HRRM B,SWIDTH
	MOVE A,HTAB(D)
	IDIV A,SSCALE
	ASH A,1
	MOVN B,A
	ADD A,TT
	ADD B,TT
	HRLM A,SHEIGHT
	HRRM B,SHEIGHT
	TRO MCHG
	POPJ P,

NSHOBX:	SETZM SHEIGHT
	SETZM SWIDTH
	TRO MCHG
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;PBOX
BOXSIZ:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/WHAT BOX SIZE?/]
	PUSHJ P,GETLET
	JRST INNERR
	CAIE C,"V"
	JRST NXVRT1
	PUSHJ P,GETLET
	JRST INNERR
	TLO C,400000
NXVRT1:	MOVE D,C
	PUSHJ P,GETLIN
	CAIE C,12
	JRST INNERR
	MOVSI TTT,-BOXLEN
	CAME D,BTAB(TTT)
	AOBJN TTT,.-1
	JUMPGE TTT,PERRET
	HRRZM TTT,CBOX
	PUSHJ P,ITSET		;FIND MAX X,Y'S
	MOVE C,CBOX		;THIS WAS CLOBBERED
	MOVE T,MAXX
	SUB T,MINX
	MOVE TT,MAXY
	SUB TT,MINY
	ASH T,-2
	ASH TT,-2
	MOVE A,WTAB(C)
	IDIV A,T
	MOVE B,HTAB(C)
	IDIV B,TT
	CAML A,B
	MOVE A,B
DEC,<	ASH A,1	>
	PUSH P,NSCALE
	JUMPN A,.+2
	MOVEI A,1
	MOVEM A,NSCALE
	LSH A,3			;FUDGE TEXT SCALE BY 10
	IDIV A,(P)
	JUMPN A,.+2
	MOVEI A,4
	CAILE A,30		;IF SIZE 3 OR LARGER WILL SHRINK PIC
	JRST [	MOVE A,(P)
		IMULI A,3
		MOVEM A,NSCALE
		MOVEI A,30
		JRST .+1]
	MOVEM A,CSCALE
	OUTSTR[ASCIZ/ SCALING TEXT BY /]
	MOVE T,CSCALE
	ASH T,-4
	PUSHJ P,OCTOUT
	OUTCHR [" "]
	MOVE T,CSCALE
	ASH T,-1
	ANDI T,7
	ADDI T,60
	OUTCHR T
	OUTSTR[ASCIZ %/8
%]
	MOVE T,CSCALE
	CAIGE T,10
	OUTSTR[ASCIZ/SOME OF THIS TEXT WILL BE AWFULLY SMALL!
/]
	PUSHJ P,DPLOT
	POP P,NSCALE
	POPJ P,
                                                                                                                          ;SLICE
DOSLICE:PUSHJ P,SLCSET
	POPJ P,
	SETZM FIND
	SKIPE E,PONPNT
	PUSHJ P,ACLRP
	SKIPN C,PONPNT
	JRST SLEAVE
SLOP:	PUSHJ P,SLOPDO
	JRST SLOPX
	JRST SLOPY
	TRO MCHG		;WILL CHANGE PIC
	MOVE T,[POINT 7,SIGBUF]
	JRST SLOPZ1

SLOPZ2:	TLNE A,760000
	JRST SLOPZ3
	HRRZ TTT,-1(A)
	JUMPN TTT,SLOPZ4
	GETFS(TTT)
	SETZM (TTT)
	SETZM 1(TTT)
SLOPZ4:	HRR A,TTT
SLOPZ3:	IDPB TT,A
SLOPZ1:	ILDB TT,T
	JUMPN TT,SLOPZ2
	CAIA
	IDPB TT,A
	TLNE A,760000
	JRST .-2
	HRRZ B,-1(A)
	HLLZS -1(A)
	PUSHJ P,PUTFS
	HRLM C,(P)
	MOVE A,C
	PUSHJ P,FIXEM		;FIX OFFSETS IF BITS ON
	HLRZ C,(P)
SLOPX:	HRRZ C,(C)
	JUMPN C,SLOP
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,SLEAVE
	SETOM FIND
	TLNE M,DSKACT!MACACT
	JRST SLEAVE
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ EXPRESSION ERRORS FOUND.
/]
SLEAVE:	PUSHJ P,SLCRET
	POPJ P,

SLOPY:	HLRZ A,(C)
	HRRZ A,1(A)
	MOVSI T,FOUNDP
	IORM T,1(A)
	AOS FIND
	JRST SLOPX

CLTSLC:	TLOA WFLAG		;FLAG -
TYPSLC:	TLZ WFLAG
	PUSHJ P,GETCLS
	JRST PERRET
	HLRZ T,(A)
	HRRZ T,1(T)
	HLRZ T,(T)
	JUMPE T,PERRET
	PUSHJ P,SLCSET
	POPJ P,
	MOVE C,CLOSES
	PUSHJ P,SLOPDO
	JRST SLEAVE
	JRST SLEAVE
	PUSHJ P,SLCRET
	TLNE WFLAG
	JRST TYPSL1
	OUTSTR SIGBUF		;PRINT CONVERTED SIGNAL NAME
	POPJ P,

TYPSL1:	PUSHJ P,SETTT
	MOVE T,[POINT 7,SIGBUF]
TYPSL2:	ILDB C,T
	JUMPE C,ITSTUF
	PUTBYT (C)
	JRST TYPSL2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;MORE SLICE STUFF - EXPRESSION SUBRS
SLCSET:	SETOM DOVARS
	SETZM ERRVAR
	MOVNI T,400000
	MOVEM T,LOWER
	MOVEI T,377777
	MOVEM T,UPPER
	MOVEM T,WIDTH
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LOWER BOUND<UPPER BOUND>?/]
	PUSHJ P,SREADN
	CAIE C,74
	JRST NOLOWR
	MOVEM T,LOWER
	PUSHJ P,SREADN
NOLOWR:	CAIN C,12
	JUMPE T,NOUPPR
	CAIE C,76
	JRST [
	SLERR:	PUSHJ P,SCARF
		POPJ P,
		OUTSTR[ASCIZ/BOUNDS ERROR!
/]
		JRST DOSLICE]
	MOVEM T,UPPER
	SUB T,LOWER
	ADDI T,1
	MOVEM T,WIDTH
	PUSHJ P,GETLIN
NOUPPR:	CAIE C,12
	JRST SLERR
VARSET:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SET VARIABLES, LN?/]
VARCON:	PUSHJ P,GETLET
	JRST [	CAIN C,12		;NO VARIABLES?
		JRST CPOPJ1		;YES
	VARERR:	PUSHJ P,SCARF
		JRST SLCRET
		OUTSTR[ASCIZ/VARIABLE INPUT ERROR!
/]
		JRST VARSET]
	MOVE A,C
	SETZM NDIG
	PUSHJ P,SREADN
	CAIE C,12
	CAIN C,","
	CAIA
	JRST VARERR
	GETFS(TT)
	HRL A,NDIG		;SAVE WIDTH WITH VAR
	MOVEM A,1(TT)
	HRLM T,(TT)
	EXCH TT,VARLST
	HRRM TT,@VARLST
	CAIE C,12
	JRST VARCON
	JRST CPOPJ1

SLOPDO:	HLRZ A,(C)
	HRRZ A,1(A)
	HLRZ A,(A)
	JUMPE A,CPOPJ
	AOS (P)		;SKIP TO INDICATE ATTEMPT
	HRRZ A,(A)
	ADD A,[POINT 7,1]
	PUSH P,A
	PUSHJ P,SIGSUB
	JRST [	POP P,(P)
		JRST EXPERR]
	POP P,A
	SKIPN EXPER2		;NO SKIP IF ERROR
	AOS (P)
	POPJ P,

SLCRET:	SKIPE B,VARLST
	PUSHJ P,PUTFS
	SETZM VARLST
	POPJ P,

GETVAR:SKIPN TT,VARLST
	JRST GETVR2		;IGNORE THIS EXPR IF VAR NOT SET
GETVR1:	HLL TTT,1(TT)		;MAKE SURE WIDTH MATCHES
	CAMN TTT,1(TT)		;IS THIS THE VARIABLE?
	JRST ISVAR		;YES
	HRRZ TT,(TT)
	JUMPN TT,GETVR1
	TLZ TTT,-1
GETVR2:	SETOM EXPER2		;FLAG ERROR
	MOVEI TT,1
	LSH TT,-"A"(TTT)
	TDNE TT,ERRVAR		;HAVE WE COMPLAINED ABOUT THIS ONE YET?
	JRST GETVR3
	IORM TT,ERRVAR
	OUTSTR[ASCIZ/NO VALUE FOR VARIABLE "/]
	OUTCHR TTT
	OUTSTR[ASCIZ/".
/]
	POPJ P,

GETVR3:	SETZ TT,
	JRST CPOPJ1		;AND RETURN 0

ISVAR:	HLRZ TTT,TTT
	CAMLE TTT,NDIG
	MOVEM TTT,NDIG
	HRRZ TTT,1(TT)		;GET CHAR BACK
	HLRE TT,(TT)
	JRST CPOPJ1
>;MD

EXPERR:	OUTSTR[ASCIZ/ERROR IN EXPRESSION!
/]
	POPJ P,

SIGGET:TLNN A,760000
	JRST [	TRNN A,-1	;ALREADY AT END?
		JRST ISENDG
		HRR A,-1(A)
		TRNE A,-1
		JRST .+1
	ISENDG:	SETZ TTT,
		POPJ P,]
	ILDB TTT,A
	JUMPN TTT,CPOPJ
	JRST SIGGET		;GET ANOTHER IF NULL
                                                                                                                                                                                                                                                                                         ;CLEAR
CLEAR:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[MD,<ALLEDM!>ANYALT]
	JRST PERRET
	PUSH P,0			;SAVE FLAGS FOR MERGING
	PUSH P,M
	PUSHJ P,RSTDEF			;DEFAULTS FOR RESTART
	POP P,T
	AND T,[XWD DSKFLG!DSKACT!MACACT,0]
	IOR M,T
	POP P,T
	AND T,[XWD DSPACT,0]
	IOR 0,T
NODEC,<	SETZM AUTOSM		;RESET AUTO WRITE AND SAVE COUNTERS
	SETZM AUTOSN
>;NODEC
MD,<
FOR I IN(SITE1,SITE2,TAUTHOR,TIT1,TIT2,TREV,TMODULE,TVARIABLE,TPREFIX,TPROJ,TPAGE,TOF,TDCODE)
<	SKIPE B,I
	PUSHJ P,PUTFS
	SETZM I
>
DEC,<	SKIPE B,TNXTHI
	PUSHJ P,PUTFS
	SETZM TNXTHI
	SETZM DRNNAM
	SETZM CHKNAM
	SETZM ENGNAM
>;DEC
	SETZM SWIDTH			;CLEAR SHOWBOX
>;MD
	SETZM CRDLOC			;CLEAR CARD LOCATION IN BOTH
	SKIPN A,MDPNT
	JRST NCMSAV
	MOVSI B,MSAVE
CMSAVE:	ANDCAM B,(A)		;TURN OFF SMACRO BITS ON CLEAR
	HRRZ A,(A)
	JUMPN A,CMSAVE
NCMSAV:	SKIPE B,BLPNTR
	PUSHJ P,PUTFS
	SETZM BLPNTR
	SETZM MOVED
MPC,<
IFN UMLSW!LAYSW,<
	SETZM UPINS
>;IFN UMLSW!LAYSW
ROUTE,<	SETZM RCL1
	SETZM RCL2
>;ROUTE
SHORT,<	SKIPE A,SHRTER
	PUSHJ P,GIVERR
	SETZM SHRTER
	SETZM SERR1
	SETZM SERR2
>;SHORT
>;MPC
UML,<	PUSHJ P,RELWIR		>	;RELEASE WIRE LIST
	SKIPE B,FBDLST
	PUSHJ P,PUTFS
	SETZM FBDLST
LAY,<	SETZM LAYLOC
	SETZM SAVNAM
>;LAY
	SETZM LSTNAM
	PUSHJ P,FILEUP
	SETZM BID
	SETZM PID
	SKIPE SETPNT
	PUSHJ P,SBLAST
	SKIPE A,DBODPN
	PUSHJ P,BFLUSH
	SETZM DBODPN
	SKIPE A,PONPNT
	PUSHJ P,PFLUSH
	SETZM PONPNT
MPC,<	SKIPE A,PONPN2
	PUSHJ P,PFLUSH
	SETZM PONPN2
	PUSHJ P,CRDREL	;FLUSH PC CARD
>;MPC
MD,<	SKIPE A,BODPNT
	PUSHJ P,DFLUSH
	SETZM BODPNT
	SKIPN A,LIBLST
	POPJ P,
LCLEAR:	HRRZ B,(A)
	HLRZ C,(A)
	FSTRET(A)
	FSTRET(C)
	MOVE A,B
	JUMPN A,LCLEAR
	SETZM LIBLST
>;MD
	POPJ P,

PFLUSH:	MOVE C,A
	HRRZ A,(C)
	HLRZ E,(C)
	HLRZ B,1(E)
	HRRZ D,1(E)
	MOVE T,1(D)
	FSTRET(C)
	FSTRET(E)
	JUMPE B,PFLSH1
MD,<	FSTRET(B)	>
MPC,<	PUSHJ P,PUTFS	>
PFLSH1:	TLNN T,CPIN		;EXTRA BLOCK?
	JRST PFLSH2
	HRRZ B,(D)
	FSTRET(B)
PFLSH2:	HLRZ B,(D)		;TEXT
	SKIPE B
	PUSHJ P,PUTFS
	FSTRET(D)
	JUMPN A,PFLUSH
	POPJ P,

BFLUSH:	MOVE B,A
	HRRZ A,(A)
	HLRZ D,(B)
	HLRZ C,1(D)
MD,<	HRRZ E,(C)
	JUMPE E,BFLSH1
	HLRZ T,(E)
	FSTRET(T)
	FSTRET(E)
BFLSH1:
>;MD
	FSTRET(D)
	FSTRET(B)
MD,<	PUSH P,A
	PUSHJ P,PRPRET
	POP P,A
>;MD
	FSTRET(C)
	JUMPN A,BFLUSH
	POPJ P,

MD,<
DFLUSH:	PUSH P,1(A)		;SAVE NEXT
	PUSHJ P,TYPREL
	POP P,A
	HRRZ A,A
	JUMPN A,DFLUSH
	POPJ P,
>;MD
                                                                                                                                                            ;**C, OFFSET, MOVE, POSIT
CCENTR:	HRL T,XOFF
	HRR T,YOFF
	JRST SETPOS		;PUT CURSOR THERE

PCENTR:	MOVE T,CURSE
PICSET:	HLREM T,XOFF
	HRREM T,YOFF
	JRST CHANGE

HOME:	SETZM XOFF
	SETZM YOFF
	MOVEI T,0
	JRST CHANGE

SETXOF:	PUSHJ P,SETOFF
	JRST PERRET
	MOVEM T,XOFF
	JRST CHANG1

SETYOF:	PUSHJ P,SETOFF
	JRST PERRET
	MOVEM T,YOFF
	JRST CHANG1

SETOFF:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ABSOLUTE OFFSET?/]
	PUSHJ P,SREADN
	CAIE C,12
	POPJ P,		;LOSE
MD,<	ASH T,1
	CAIL T,377777
	POPJ P,		;OOPS!
	JRST CPOPJ1	>
MPC,<	ASH T,1
	IDIVI T,5
	JUMPN TT,ILLSTP
	IDIV T,STPSIZ
	JUMPN TT,ILLSTP
	IMUL T,STPSIZ
	CAIL T,377777
	POPJ P,
	JRST CPOPJ1	>

MPC<
STPERR:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ILLEGAL STEP SIZE!
/]
SETSTP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/MINIMUM STEP IN MILS(DIVISIBLE BY 5 MILS)?/]
	PUSHJ P,READNC
	JUMPE T,INNERR
	IDIVI T,5
	JUMPN TT,STPERR
	JUMPE T,STPERR
	MOVEM T,STPSIZ
	JRST CHANG1
>;MPC


MOVREL:	TLNN M,DSKACT!MACACT
MD,<	OUTSTR[ASCIZ/RELATIVE X,Y?/]		>
MPC,<	OUTSTR[ASCIZ/RELATIVE X,Y(IN MILS)?/]	>
	PUSHJ P,SREADN
	CAIN C,ALTMOD
	POPJ P,
	PUSH P,T
	CAIN C,12
	TDZA T,T		;JUST X
	PUSHJ P,SREADN
	CAIN C,ALTMOD
	JRST [	POP P,(P)
		POPJ P,]
	ASH T,1
MPC,<
	IDIVI T,5
	JUMPN TT,[	POP P,(P)
			JRST ILLSTP]
>;MPC
	POP P,TT
	ASH TT,1
MPC,<
	TRNE M,FLIP
	MOVN TT,TT
	IDIVI TT,5
	JUMPN TTT,ILLSTP
	IDIV TT,STPSIZ
	JUMPN TTT,ILLSTP
	IMUL TT,STPSIZ
	MOVE TTT,TT
	IDIV T,STPSIZ
	JUMPN TT,ILLSTP
	IMUL T,STPSIZ
	MOVE TT,TTT
>;MPC
	HRL T,TT
	ADJUST(ADD,T,CURSE)
	JRST SETPOS

MPC,<
ILLSTP:	OUTSTR[ASCIZ/NOT INTEGRAL # OF STEPS!!!!
/]
	POPJ P,

POSIT:	TLNE M,DSKACT!MACACT
	POPJ P,
	OUTSTR[ASCIZ/CURSOR	/]
	MOVE T,CURSE
	PUSHJ P,PNTXY
	OUTSTR[ASCIZ/
/]
	MOVEI T,1
	LSH T,@MODE
	TDNN T,[1PNTM!1TXTM]
	POPJ P,
	PUSHJ P,GETCLS
	POPJ P,
	MOVE T,1(A)
	CAMN T,CURSE
	POPJ P,
	OUTSTR[ASCIZ/POINT	/]
	PUSHJ P,PNTXY
	OUTSTR[ASCIZ/
/]
	POPJ P,

PNTXY:	HRLM T,(P)
	HLRE T,T
	PUSHJ P,MILOUT
	OUTCHR[11]
	HLRE T,(P)
MILOUT:	SKIPGE T
	OUTCHR["-"]
	MOVM T,T
	IDIVI T,=1000*2/5
	PUSH P,TT
	PUSHJ P,DECOUT
	POP P,T
	OUTCHR["."]
	IMULI T,5
	ASH T,-1
	CAIGE T,=100
	OUTCHR["0"]
	CAIGE T,=10
	OUTCHR["0"]
	JRST DECOUT
>;MPC

;CHECK IF LOC IN T IS ON SCREEN, IF NOT GET IT ON.
;REGARDLESS, MOVE CURSOR THERE
CHKON:	TLNE M,DSKACT!MACACT
	JRST SETPOS
	PUSHJ P,ONSCR
	JRST PICSET
	JRST SETPOS
                                                                                                                              ;BIG, SMALL, SHIFT SCREEN
MAKBIG:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ANYALT]
	JRST PERRET
	MOVE T,NSCALE	;GET CURRENT SCALE
	XCT (A)[CAIA		;INCREMENT SIZE BY ONE
		LSH T,-2	;MULT BY 1,25
		LSH T,-1	;MULT BY 1,5
		JFCL]		;MULT BY 2
	JUMPN T,.+2
	MOVEI T,1
	ADDM T,NSCALE
CHANG1:	MOVE T,CURSE
CHANGE:	PUSH P,T
	PUSH P,TT
	TRO MCHG		;WE ARE CHANGING IT
	TLNN M,XWINDOW	;IF WINDOWING, CLOSEST MAY CHANGE
	TRO NEEDCL
	SETOM CLOSUP		;BIG LETTER WILL MOVE IN ANY CASE
MPC,<	MOVE T,[%RIGHT4]	>
MD,<	MOVE T,[%RIGHT2]	>
	PUSHJ P,TRUNCP
	ADD T,XOFF
	HRLZM T,RIGHT
MPC,<	MOVE T,[%TOP4]		>
MD,<	MOVE T,[%TOP2]		>
	PUSHJ P,TRUNCP
	ADD T,YOFF
	MOVEM T,TOP
MPC,<	MOVE T,[%LEFT4]	>
MD,<	MOVE T,[%LEFT2]	>
	PUSHJ P,TRUNCN
	ADD T,XOFF
	HRLZM T,LEFT
MPC,<	MOVE T,[%BOTTOM4]	>
MD,<	MOVE T,[%BOTTOM2]	>
	PUSHJ P,TRUNCN
	ADD T,YOFF
	MOVEM T,BOTTOM
	POP P,TT
	POP P,T
	JRST SETPOS

TRUNCP:	PUSHJ P,TRUNCD
	SKIPGE TT
	SUBI T,2
	POPJ P,

TRUNCN:	PUSHJ P,TRUNCD
	SKIPLE TT
	ADDI T,2
	POPJ P,

TRUNCD:	MOVE TT,NSCALE
MPC,<	IMUL TT,STPSIZ	>
	ASH TT,1
	IDIV T,TT
MPC,<	IMUL T,STPSIZ	>
	ASH T,1
	POPJ P,

MAKSML:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ANYALT]
	JRST PERRET
	MOVE T,NSCALE	;GET CURRENT SCALE
	LSH T,2
	XCT (A)[SOS T,NSCALE ;DECREMENT BY 1
		IDIVI T,5	;MULT BY 4/5
		IDIVI T,6	;MULT BY 2/3
		ASH T,-3]	;MULT BY 1/2
	SKIPN T		;0?
	MOVEI T,1	;YES, MAKE 1
	MOVEM T,NSCALE
	JRST CHANG1

MAKRIT:	PUSHJ P,GETMAK
	JRST PERRET
MPC,<	TRNE M,FLIP
	MOVN T,T
>;MPC
	EXCH T,XOFF
	SUBM T,XOFF
	JRST CHANG1

MAKLFT:	PUSHJ P,GETMAK
	JRST PERRET
MPC,<	TRNE M,FLIP
	MOVN T,T
>;MPC
	ADDM T,XOFF
	JRST CHANG1

MAKDWN:	PUSHJ P,GETMAK
	JRST ALTDWN
	ADDM T,YOFF
	JRST CHANG1

MAKUP:	PUSHJ P,GETMAK
	JRST ALTUP
	EXCH T,YOFF
	SUBM T,YOFF
	JRST CHANG1

GETMAK:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ANYALT]
	JRST ALTMAK
MD,<	MOVEI T,1	>
MPC,<	MOVEI T,2	>
	ASH T,11(A)
	IDIV T,NSCALE
	SKIPN T
	MOVEI T,1	;NEVER MOVE NONE
MPC,<	ADD T,STPSIZ	;ROUND UP
	SUBI T,1
	IDIV T,STPSIZ
	IMUL T,STPSIZ
	ASH T,1
>;MPC
	JRST CPOPJ1

ALTMAK:	MOVEI T,1
	LSH T,(A)
	POPJ P,

ALTDWN:	MOVN T,T		;DECREASE START LINE, (MOVE TEXT DOWN)
ALTUP:	ADDM T,ALTLIN
	SKIPGE ALTLIN
	SETZM ALTLIN		;AVOID UNDERFLOW
	SETOM LPNTR
	TRO MCHG
	POPJ P,
                                                                                                                                                                                                                                                                      ;MODE SWITCHING
	DEFINE MODC(A)
<	MOVEI T,A
	JRST CHNGMD>

TOP3P:	MODC(PNTM)
TOP3B:	MODC(BODM)
TOP3L:	MODC(LINM)
TOP3S:	MODC(SETM)
TOP3T:	MODC(TXTM)

CMODE:	CLRSET		;S
	CLRPNT		;B
	CLRPNT		;P
	CPOPJ		;L
	CLRPNT		;T
	CPOPJ		;A
	CPOPJ		;MA
	CPOPJ		;SP
MD,<	CLRPNT		;BT
	CPOPJ		;BTA
	CLRPNT		;E
	CLREDI		;EI
	CLRPNT		;ET
	CLRPNT		;EP
	CLRGET		;EG
	CPOPJ		;EA
>;MD
REPEAT NUMODES+<CMODE-.>,<CPOPJ>

;RESTORE MODE AFTER TCHNGM
RCHNGM:	MOVE T,OMODE	;RESET TO OLD MODE
;PERMANENT MODE CHANGE
CHNGMD:	MOVEM T,OMODE
;TEMPORARY MODE CHANGE, LEAVE OMODE A LAST CHNGMD
TCHNGM:	CAMN T,MODE	;ARE WE REALLY CHANGING?
	POPJ P,
	TRO NEEDCL	;MUST CALL FNDCLS
	EXCH T,MODE	;NEW MODE
	JRST @CMODE(T)

CLRSET:	TRZE STBOX	;WERE WE DRAWING A BOX?
	SKIPN B,SETBOX
	JRST CLRPNT	;NO
	PUSHJ P,PUTFS
	MOVEI T,ANGLPG
	PUSHJ P,HYDPOG
	SETZM SETBOX
	JRST CLRPNT

MD,<
CLRGET:	MOVEI T,ANGLPG
	JRST HYDPOG

CLREDI:	SKIPN A,CRPPNT
	JRST CLRPNT
	MOVEI T,1
	AND T,1(A)
	IOR T,CURSE
	MOVEM T,1(A)
>;MD
CLRPNT:	TRZ INLIN!INMOV
	POPJ P,
                                                                                                                                                                                                                          ;SIXBIT, FILEUP
LSIXOUT:
DEC,<	HLRZ T,TT
LSIXOD:	IDIVI T,10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,LSIXOD
	HLRZ T,(P)
	ADDI T,60
	IDPB T,TTT
	POPJ P,
>;DEC
NODEC,<
	TLNN TT,777700
	LSH TT,14
	TLNN TT,770000
	LSH TT,6
>;NODEC
SIXOUT:	JUMPE TT,CPOPJ
	SETZ T,
	LSHC T,6
	ADDI T,40
	IDPB T,TTT
	JRST SIXOUT

FILEUP:	SKIPN ISDPY
	POPJ P,
	MOVEI T,1
	MOVEM T,NAMBUF
	MOVE T,[NAMBUF,,NAMBUF+1]
	BLT T,NAMBUF+NFWRDS-1
	SKIPN TT,LSTNAM
LAY,<	SKIPE SAVNAM
	CAIA
>;LAY
	JRST NOLAST
	MOVE TTT,[POINT 7,NAMBUF]
LAY,<	JUMPE TT,NOFLST	>
	PUSHJ P,SIXOUT
	MOVE TT,LSTPPN
	PUSHJ P,UPPPN
LAY,<
NOFLST:	SKIPN TT,SAVNAM
	JRST NOLAST
	MOVEI T,"&"
	IDPB T,TTT
	PUSHJ P,SIXOUT
	MOVE TT,SAVPPN
	PUSHJ P,UPPPN
>;LAY
	JRST NOLAST

UPPPN:	MOVEI T,"["
	IDPB T,TTT
NOCMU,<
	HRLM TT,(P)
	HRRI TT,0
	PUSHJ P,LSIXOUT
	MOVEI T,","
	IDPB T,TTT
	HLLZ TT,(P)
	PUSHJ P,LSIXOUT
>;NOCMU
CMU,<
	MOVE T,[TT,,PPNBUF]
	DECCMU T,
	JRST [	PUSHJ P,LSIXOUT
		JRST PPNDN2 ]
	SKIPA TT,[POINT 7,PPNBUF]
	IDPB T,TTT
	ILDB T,TT
	JUMPN T,.-2
PPNDN2:
>;CMU
	MOVEI T,"]"
	IDPB T,TTT
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         COMMENT    VALID 00013 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(OUT,7)
C00008 00003	TYPES
C00011 00004			BODIES, CALL POINT SUBR (D,PC)
C00014 00005			POINT SUBR (D,PC)
C00019 00006			SETS, END STUFF (D,PC)
C00026 00007	'WD'	'WPC'	BODIES, CALL WIRE SUBRS
C00033 00008			WIRES, WRITE SIGNAL NAME AND PIN INFO
C00039 00009			WIRES, RECUR
C00043 00010	'DAT'		WRITE FILE FOR INPUT TO WAGNER'S ROUTER SYSTEM
C00049 00011			ROUTER OUTPUT SUBRS
C00056 00012			TABLES FOR ROUTER OUTPUT
C00058 00013	
C00059 ENDMK
C;
                                                                                        VERSION(OUT,7)
;'DRW'	'PC'	LIBRARIES, BODY DEFS (D)

EWRITE:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[MD,<ALLEDM!>ANYALT]
	JRST PERRET
	MOVE T,AUTOWM
	MOVEM T,AUTOWN
	MOVSI T,EXTFIL
	PUSHJ P,SETLST
	JRST DWRITE
	SETZM SETFLG
	JRST WRITEE

DWRITE:	SETZM SETFLG
DWRITS:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[MD,<ALLEDM!>ANYALT]
	JRST PERRET
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM	;READ FILENAME AND STORE IN FILNAM
	POPJ P,		;NONE, LET HIM OUT.
WRITEE:	ENTPPN
	MOVEM P,PERRSAV		;USE THIS TO GET OUT FROM LOWER LEVELS.
	INIT DAT,10
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF	;USE THIS BUFFER SO WE DON'T WASTE SPACE
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF	;PUT .JBFF BACK
MD,<	MOVE B,FILNAM
	HLLZ C,FILEXT
	SKIPN D,FILPPN
	DSKPPN D,
	PUSHJ P,LNAMCK	;CHECK NAME
	JRST LIBUSE
>;MD
	PUSHJ P,EXIST	;DOES IT EXIST?
	POPJ P,		;HE DOESN'T WANT TO OVERWRITE
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<
	SKIPN	THEREXISTS
	JRST	NOBAK
	PJOB	T,		;GET JOB #
	IDIVI	T,=100		;MAKE TMP FILE NAME
	IDIVI	TT,=10
	LSH	T,6
	ADD	T,TT
	LSH	T,6
	ADD	T,TTT
	ADD	T,['DRW000']
	MOVSM	T,TMPNAM
	MOVSI	T,'TMP'
	MOVEM	T,TMPEXT
	MOVSI	T,100000		;MIN PROT.
	MOVEM	T,TMPEXT+1
	MOVE	T,FILPPN
	MOVEM	T,TMPPPN
	ENTER	DAT,TMPNAM
	SKIPA
	JRST	WRITEG		;ALL SET
	CLOSE	DAT,		;ENTER FAILED, TRY WITHOUT BAK
	OUTSTR	[ASCIZ /, /]
	MOVEI	A,TMPNAM
	JSR	FPRINT
	OUTSTR	[ASCIZ / ENTER FAILED.
GO ON WITHOUT BACKUP FILE?/]
	SETZM	THEREXISTS
	CLRBFI
	INCHRW C
	CAIN C,15
	INCHRW C
	OUTSTR	[ASCIZ /
/]
	CAIE	C,"Y"
	CAIN	C,"y"
	JRST	NOBAK
	RELEASE	DAT,
	POPJ	P,
NOBAK:
>;DEC
	MOVE T,FILPPN
	ENTER DAT,FILNAM	;MAKE A FILE
	JRST [	RELEASE DAT,
		OUTSTR [ASCIZ/, ENTER FAILED.
/]
		POPJ P,]
WRITEG:	OUTSTR[ASCIZ/
/]
	MOVEM T,FILPPN
	SKIPE SETFLG			;IF WRITING SET ONLY,
	JRST NLSTUP			;DON'T UPDATE LAST NAME
	MOVEM T,LSTPPN
	MOVE T,FILNAM
	MOVEM T,LSTNAM
	PUSHJ P,FILEUP		;UPDATE DISPLAY
MD,<	DATE T,
	HRLZM T,DRWDAT
	MSTIME T,
	IDIVI T,=1000*=60	;TO MINUTES
	HRRM T,DRWDAT
	MOVE T,FILNAM
	MOVEM T,DRWNAM
	MOVE T,FILPPN
	MOVEM T,DRWPPN
>;MD
NLSTUP:
MPC,<	SETZM MXPADN		;CLEAR MAX PAD # SEEN
	TLNE SID,FRONT		;ALREADY ON FRONT SIDE?
	JRST DOWRT		;YES, GO ON
	SWITCH			;GET THERE
	PUSHJ P,DOWRT		;WRITE FILE
	SWITCH			;BACK WHERE WE WERE
	POPJ P,

DOWRT:
>;MPC
	MOVEI TTT,IOVER		;IOVERSION #
	PUSHJ P,WORDOUT
	PUSHJ P,WRTBRD
MD,<	SKIPN LIBLST		;EASY IF NO LIBRARIES
	JRST PUTLB0
	PUSHJ P,CDFMRK		;CLEAR DEFINITION MARK BITS
	SKIPN A,DBODPN		;NOW LOOK AT BODIES
	JRST PUTLB0
	MOVSI TT,DTMP1		;THIS IS TEMP MARK BIT
UTYP1:	HLRZ T,(A)
	SKIPN SETFLG		;WRITING SET ONLY?
	JRST UTYP4		;NO
	HLRZ TTT,1(T)
	MOVE TTT,1(TTT)		;GET BODY BITS
	TLNN TTT,BTMP1		;IS IT IN THE SET?
	JRST UTYP5		;NO
UTYP4:	HRRZ T,1(T)
	HLRZ T,1(T)
	HLRZ T,(T)
	IORM TT,(T)		;TURN ON MARK BIT
UTYP5:	HRRZ A,(A)
	JUMPN A,UTYP1
	MOVE A,BODPNT
UTYP2:	HLRZ T,(A)
	JUMPE T,UTYP3		;ONLY LIBRARY BODIES
	HLRZ T,1(A)
	JUMPE T,UTYP3		;ONLY ONES ALREADY IN
	HLRZ T,(T)
	HLRZ T,(T)
	TRNN T,DTMP1		;BODY USED?
	JRST UTYP3		;NO
	HRRZ TT,(A)		;TYPE NAME
	PUSHJ P,WSTR
UTYP3:	HRRZ A,1(A)
	JUMPN A,UTYP2
PUTLB0:	PUSHJ P,WRTZERO		;END OF USED TYPE NAMES
	SKIPN A,LIBLST		;ANY LIBRARIES?
	JRST ENDLIB
PUTLIB:	HLRZ T,(A)
	HRRZ TT,(T)
	TRNN TT,TOPLVL		;ONLY WRITE OUT TOP LEVEL POINTERS
	JRST PUTLB1
	MOVE TTT,1(A)
	PUSHJ P,WORDOUT
	MOVE TTT,(T)
	PUSHJ P,WORDOUT
	MOVE TTT,1(T)
	PUSHJ P,WORDOUT
PUTLB1:	HRRZ A,(A)
	JUMPN A,PUTLIB
ENDLIB:	PUSHJ P,WRTZERO		;MARK END OF LIBRARIES
                                                                                                                                                                                                                                                              ;TYPES
	HRRZ T,BODPNT		;POINTER TO TYPES
	JUMPE T,TYPDON
WRTTYP:	HLRZ TT,(T)		;CHECK LIBRARY POINTER
	JUMPN TT,SKPTYP		;SKIP THIS TYPE IF FROM LIBRARY
	HRRZ TT,(T)		;POINTER TO TYPE NAME
	PUSHJ P,WSTR
	HLRZ TT,1(T)		;POINTER TO POINTERS TO PINS,LINES,TEXT.
	HLRZ TTT,(TT)		;DEF LOC OFFSET AND BITS POINTER
	HLLZ TTT,(TTT)		;BITS
	TLZ TTT,DTMP1!FOUNDL	;DON'T WRITE TEMP BITS INTO FILE
	PUSHJ P,WORDOUT		;RIGHT HALF IS UNUSED AS YET
	HLRZ TTT,(TT)
	MOVE TTT,1(TTT)		;DEF LOC OFFSET
	PUSHJ P,WORDOUT
	HLRZ TTT,(TT)
	HRRZ TTT,(TTT)
	SKIPE TTT
	SKIPA TTT,1(TTT)
	MOVEI TTT,400000
	PUSHJ P,WORDOUT
	HRRZ TT,(TT)		;POINTER TO PINS
	JUMPE TT,PNDON		;NONE MAYBE.
TYPPIN:	MOVE TTT,1(TT)		;LOC OF PIN.
	PUSHJ P,WORDOUT		;WRITE IT
	HLRZ TTT,(TT)		;OUT PIN ID
	MOVE TTT,(TTT)		;GET BITS,,PIN ID
	PUSHJ P,WORDOUT
	HLRZ TTT,(TT)
	MOVE TTT,1(TTT)		;NOW PIN POS,,PIN NAME
	PUSHJ P,WORDOUT
	HRRZ TT,(TT)
	JUMPN TT,TYPPIN		;LIST ENDS WITH 0
PNDON:	PUSHJ P,WRTMARK		;MARK END OF PINS
	HLRZ TT,1(T)		;POINTER TO POINTERS TO.....
	HRRZ TT,1(TT)		;POINTER TO LINES
	JUMPE TT,LINDON		;NO LINES MAYBE
TYPLIN:	MOVE TTT,1(TT)		;LOC OF POINT.
	PUSHJ P,WORDOUT		;WRITE IT
	HRRZ TT,(TT)
	JUMPN TT,TYPLIN		;ENDS WITH 0
LINDON:	PUSHJ P,WRTMARK		;MARK END OF LINES
	HLRZ A,1(T)		;POINTER TO POINTERS.......
	HLRZ A,1(A)		;POINTER TO TEXT
	PUSHJ P,WRTPRP
SKPTYP:	HRRZ T,1(T)		;NEXT TYPE
	JUMPN T,WRTTYP
TYPDON:	PUSHJ P,WRTZERO		;MARK END OF TYPES
>;MD
	PUSHJ P,MACOUT		;OUTPUT SPECIAL MACROES TO FILE
                                                                                                                                                                                                                                                                                                                                                                                                                  ;		BODIES, CALL POINT SUBR (D,PC)
	SKIPN T,DBODPN		;POINTER TO BODIES IN DRAWING?
	JRST BODDON		;NONE
WRTBOD:	HLRZ TT,(T)
	SKIPN SETFLG		;WRITING SET ONLY?
	JRST WRTBD1		;NO
	HLRZ TTT,1(TT)
	MOVE TTT,1(TTT)		;BODY BITS
	TLNN TTT,BTMP1		;IN OUR SET?
	JRST WRTBD2
WRTBD1:	MOVE TTT,1(T)		;LOC OF BODY
	PUSHJ P,WORDOUT
MPC,<	PUSH P,TT
	HLRZ TT,1(TT)
	HRRZ TT,1(TT)
	PUSHJ P,TWSTR
	POP P,TT
>;MPC
	HLRZ TTT,(TT)		;ORIENTATION
	ANDI TTT,7
	HLRZ TT,1(TT)
MD,<
	HRRZ TT,(TT)
	JUMPE TT,NLCYET
	TRO TTT,400000		;MARK AS HAVING DIP NUMBER
	PUSHJ P,WORDOUT
	HLRZ TTT,(TT)
	MOVE TTT,(TTT)
	PUSHJ P,WORDOUT
	MOVE TTT,1(TT)
	PUSHJ P,WORDOUT
	HLRZ TTT,(TT)
	MOVE TTT,1(TTT)
NLCYET:	PUSHJ P,WORDOUT
	HLRZ TT,(T)
	HLRZ TTT,1(TT)
	HLL TTT,1(TTT)
	HLR TTT,(TTT)
	TLZ TTT,FOUNDB!BTMP1
	PUSHJ P,WORDOUT		;WRITE BITS AND BID
	HRRZ TT,1(TT)		;TYPE POINTER
	HRRZ TT,(TT)		;POINTER TO NAME OF TYPE
	PUSHJ P,WSTR		;WRITE IT (PHEW!)
	HLRZ A,(T)
	HLRZ A,1(A)
	HRRZ A,1(A)
	PUSHJ P,WRTPRP
>;MD
MPC,<	HRL TTT,(TT)		;NUMBER LETTER
	PUSHJ P,WORDOUT
	HLRZ TTT,(T)		;POINTER TO BODY IN TTT
	HLRZ TTT,1(TTT)
	HLL TTT,1(TTT)
	HLR TTT,(TTT)		;BITS,,ID
	PUSHJ P,WORDOUT		;OUTPUT BODY ID
	HLRZ TT,(T)		;GET BACK POINTER
	HRRZ TT,1(TT)		;POINTER TO TYPE DESCRIPTION
	HLRZ TTT,(TT)		;POINTER TO NUMBER OF PINS IN TYPE
	CAIE TTT,2		;2 PIN DIP?
	JRST ISN2PN
	HRRZ TT,1(TT)
	HRL TTT,1(TT)		;GET PIN SEPERATION (/2)
ISN2PN:	PUSHJ P,WORDOUT		;WRITE IT
>;MPC
WRTBD2:	HRRZ T,(T)		;NEXT BODY
	JUMPN T,WRTBOD		;ENDS WITH 0
BODDON:	PUSHJ P,WRPNTS
MPC,<
	SWITCH
	PUSHJ P,WRPNTS
	SWITCH
>;MPC
	JRST PNTDON
                                                                                                                                                                                                                                                                                                      ;		POINT SUBR (D,PC)
WRPNTS:	PUSHJ P,WRTMARK		;MARK END OF BODIES
	SKIPN T,PONPNT
	POPJ P,
WRTPNT:	MOVEI TTT,(T)		;POINTER TO POINT IN TTT
	PUSHJ P,SCHKID		;CHECK IF POINT SHOULD GO OUT
	JRST WRTPN1		;NOT IN OUR SET
	MOVE TTT,1(T)		;LOC OF POINT
	PUSHJ P,WORDOUT
	MOVEI TTT,(T)
	PUSHJ P,PUTID		;PUT OUT POINT ID
	HLRZ TT,(T)		;POINTER TO POINTERS TO PIN BODY AND UP, LEFT, ETC.
	HLRZ A,1(TT)		;POINTER TO NEIGHBORS
MD,<
	HLRZ TTT,(A)		;UP
	PUSHJ P,SPUTID
	HRRZ TTT,(A)		;DOWN
	PUSHJ P,SPUTID
	HLRZ TTT,1(A)		;LEFT
	PUSHJ P,SPUTID
	HRRZ TTT,1(A)		;RIGHT
	PUSHJ P,SPUTID
>;MD
MPC,<
	JUMPE A,WRTNE4
WRTNE1:	MOVEI B,2
WRTNE2:	XCT (B)[HLRZ TTT,(A)
		HRRZ TTT,1(A)
		HLRZ TTT,1(A)]
	JUMPE TTT,WRTNE3
	PUSHJ P,SPUTID
WRTNE3:	SOJGE B,WRTNE2
	HRRZ A,(A)
	JUMPN A,WRTNE1
WRTNE4:	PUSHJ P,WRTZERO
>;MPC
	HRRZ B,1(TT)
	MOVE TTT,1(B)		;GET BITS AND PIN OR PAD NUMBER
MPC,<	AND TTT,[XWD FRONT!FEEDTH!PLANES!ISPIN!CPIN,-1]		>
MD,<	AND TTT,[XWD FIXTXT!FIXCON!FIXRHT!ISPIN!CPIN!CPNBTS,-1]	>
	PUSHJ P,WORDOUT		;WRITE THEM
MPC,<	HRRZ TTT,TTT
	CAMLE TTT,MXPADN
	MOVEM TTT,MXPADN
>;MPC
	HLRZ TT,(B)
	JUMPE TT,[PUSHJ P,WRTZERO
		JRST NOTEXT]
	HRRZ TTT,(TT)
	HLRZ TTT,(TTT)		;SIZE OF TEXT
	PUSHJ P,WORDOUT
	MOVE TTT,1(TT)
	PUSHJ P,WORDOUT		;CONSTANT OFFSET
	HRRZ TT,(TT)
	PUSHJ P,WSTR
NOTEXT:
MD,<	MOVE TT,1(B)
	TLNN TT,CPIN		;CONNECTOR PIN?
	JRST NOCPIN
	HRRZ TT,(B)		;CPIN BLOCK POINTER
	MOVE TTT,(TT)		;NLNLLN
	PUSHJ P,WORDOUT
	MOVE TTT,1(TT)		;X,Y CONSTANT OFFSET
	PUSHJ P,WORDOUT
NOCPIN:
>;MD
MPC,<	HLRZ TTT,(T)
	HLRZ TTT,(TTT)		;FEED THROUGH POINTER IF ANY
	MOVE B,1(B)
	TLNN B,FEEDTH
	MOVEI TTT,0
	PUSHJ P,SPUTID		>
WRTPN1:	HRRZ T,(T)		;NEXT POINT
	JUMPN T,WRTPNT		;ENDS WITH 0
	POPJ P,

SPUTID:	PUSHJ P,SCHKID		;CHECK IF IN OUR SET (OR WRITING WHOLE DRAWING)
	JRST WRTZERO
PUTID:	JUMPE TTT,WORDOUT
	PUSHJ P,GETID
	JRST WORDOUT

;GETID
;CALL WITH:
;	TTT	POINTER TO POINT
;RETURNS WITH
;	TTT	POINT ID
GETID:	HLRZ TTT,(TTT)
	PUSH P,TT
	HRRZ TT,1(TTT)
	HLL TT,1(TT)
	TLNE TT,ISPIN
	JRST PINID		;PINS ARE HARDER
	POP P,TT
	HRRZ TTT,(TTT)
	POPJ P,

PINID:	HLRZ TTT,(TTT)
	HLRZ TTT,(TTT)
	HLRZ TTT,1(TTT)
	HLRZ TTT,(TTT)
	HRRZ TT,(TT)
MD,<	HLRZ TT,(TT)
	HRL TTT,(TT)		;PIN ID
>;MD
MPC,<	HLL TTT,(TT)	>	;PC PIN ID IS PIN #
	POP P,TT
	POPJ P,

SCHKID:	JUMPE TTT,CPOPJ1
	SKIPN SETFLG
	JRST CPOPJ1		;WRITING WHOLE DRAWING
	PUSH P,T		;GET A REGISTER
	HLRZ T,(TTT)
	HRRZ T,1(T)
	HLL TTT,1(T)
	TLNE TTT,ISPIN		;PIN OR POINT
	JRST SCHKI1
	POP P,T
	TLNE TTT,1
	AOS (P)			;IN OUR SET, SKIP
	POPJ P,

SCHKI1:	HLRZ T,(TTT)
	HLRZ T,(T)		;BODY POINTER
	HLRZ T,(T)
	HLRZ T,1(T)
	HLL TTT,1(T)
	POP P,T
	TLNE TTT,BTMP1		;IS IT IN OUR SET?
	AOS (P)			;YES, SKIP
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;		SETS, END STUFF (D,PC)
PNTDON:	PUSHJ P,WRTMARK		;MARK END OF POINTS
	SKIPN A,SETPNT		;POINTER TO SETS
	JRST NOSETS		;NONE
WRTSET:	SKIPE SETFLG		;WRITING ALL SETS, OR
	CAMN A,SETFLG		;OR IS THIS THE SET WE WANT?
	CAIA			;YES
	JRST WASNUL
	HLRZ B,(A)		;POINTER TO SET
NULCHK:	SKIPE 1(B)		;ANYTHING HERE?
	JRST ISNNUL
	HRRZ B,(B)
	JUMPN B,NULCHK
	JRST WASNUL

ISNNUL:	MOVE TTT,1(A)		;CENTER OF SET
	PUSHJ P,WORDOUT
SETBOD:	HLRZ TTT,1(B)		;POINTER TO BODY
	JUMPE TTT,.+2
	PUSHJ P,BODID		;WRITE BODY ID
	HRRZ B,(B)		;NEXT
	JUMPN B,SETBOD
	PUSHJ P,WRTZERO		;MARK END OF BODIES
	HLRZ B,(A)		;POINTER TO SET
STPNT:	HRRZ TTT,1(B)		;POINTER TO POINT
	JUMPE TTT,NOSPNT	;NONE?
	PUSHJ P,PUTID
NOSPNT:	HRRZ B,(B)		;NEXT
	JUMPN B,STPNT
	PUSHJ P,WRTZERO		;MARK END OF POINTS
WASNUL:	HRRZ A,(A)		;NEXT SET
	JUMPN A,WRTSET		;LOOP
NOSETS:
MD,<
	PUSHJ P,WRTMARK		;END OF SETS
FOR I IN(TAUTHOR,TIT1,TIT2)
<	MOVE TT,I
	PUSHJ P,TWSTR
>
	MOVE TTT,CRDLOC
	PUSHJ P,WORDOUT		;WRITE PERM CARD LOC!
FOR I IN(TREV,TMODULE,TVARIABLE,TPREFIX,TPROJ,TPAGE,TOF,TDCODE,SITE1,SITE2)
<	MOVE TT,I
	PUSHJ P,TWSTR
>
DEC,<
	MOVE TT,TNXTHI
	PUSHJ P,TWSTR
FOR @$ I IN(DRN,CHK,ENG)
<	SKIPN TTT,I$NAM
	JRST NOW$I
	PUSHJ P,WORDOUT
	MOVE TTT,I$NAM+1
	PUSHJ P,WORDOUT
	MOVE TTT,I$NAM+3
NOW$I:	PUSHJ P,WORDOUT
>
>;DEC
>;MD
MPC,<	MOVEI TTT,400001	;END OF SETS (NEW TYPE OF END MARKER)
	PUSHJ P,WORDOUT
	MOVE TTT,CRDLOC		;LOCATION OF CARD
	PUSHJ P,WORDOUT
	MOVE TTT,CRDNAM
	PUSHJ P,WORDOUT
	HLLZ TTT,CRDEXT
	PUSHJ P,WORDOUT
	MOVE TTT,CRDPPN
	PUSHJ P,WORDOUT
	PUSHJ P,MXPADP		;PRINT MAX PAD TYPE
>;MPC
	MOVEI T,20
	PUSHJ P,WRTZERO
	SOJG T,.-1
DEC,<	SKIPN	THEREXISTS		;WRITING TMP FILE?
	JRST BAKXIT
	CLOSE	DAT,		;YES, DO SOME RENAMING
	MOVE	A,FILNAM
	MOVSI	B,'BAK'
	SETZ	C,
	MOVE	D,FILPPN
	LOOKUP	DAT,A
	JRST	BAKDON		;NO BAK FILE TO DELETE
	PUSHJ	P,CHKPPN
	JRST	BAKDON
	SETZ	A,
	RENAME	DAT,A		;DELETE OLD BAK FILE
	OUTSTR	[ASCIZ /CAN'T DELETE BAK FILE!
/]
BAKDON:	CLOSE	DAT,
	MOVE	A,FILNAM
	HLLZ	B,FILEXT
	SETZ	C,
	MOVE	D,FILPPN
	LOOKUP	DAT,A
	JRST	BAKOK		;NO DRW FILE TO RENAME TO BAK
	PUSHJ	P,CHKPPN
	JRST	BAKOK
	AND	C,[77000,,0]	;UNPROTECT THE BAK FILE
	MOVSI	B,'BAK'
	MOVE	D,FILPPN
	RENAME	DAT,A
MD,<	OUTSTR	[ASCIZ /CAN'T RENAME DRW TO BAK!
/]
>;MD
MPC,<	OUTSTR	[ASCIZ /CAN'T RENAME PC TO BAK!
/]
>;MPC
BAKOK:	CLOSE	DAT,
	MOVE	A,TMPNAM
	HLLZ	B,TMPEXT
	SETZ	C,
	MOVE	D,FILPPN
	LOOKUP	DAT,A
	JRST	[OUTSTR [ASCIZ /CAN'T FIND THE TMP FILE!
/]
		JRST .+1]
	RENAME	DAT,FILNAM
	OUTSTR	[ASCIZ /CAN'T RENAME TMP TO DRW!
/]
BAKXIT:
>;DEC
	RELEASE DAT,
	POPJ P,

DEC,<
CHKPPN:	MOVE	TTT,[3,,T]
	MOVEI	T,DAT
	PATH TTT,
	JRST CPOPJ1		;IF NO PATHS, MUST HAVE RIGHT FILE
	CAMN	TTT,FILPPN
	AOS	(P)
	POPJ	P,
>;DEC

WRTBRD:	SKIPGE TT,BRDTYPE	;HERE TO WRIYTE OUT BOARD TYPE
	JRST WRTZERO		;NO BOARD SPECIFIED, WRITE A ZERO
	HRRZ TT,BNAMES(TT)
WASCIZ:	MOVE TTT,(TT)		;HERE WRITE OUT ASCIZ STRING
	PUSHJ P,WORDOUT
	TRNN TTT,376
	POPJ P,
	AOJA TT,WASCIZ

WSTR1:	TRNN TTT,377
	JRST FUCKUP		;CALL FUCKUP, AND DON'T RETURN HERE!
WSTR:	MOVE TTT,1(TT)
	PUSHJ P,WORDOUT
	HRRZ TT,(TT)
	JUMPN TT,WSTR1
	TRNE TTT,377
	PUSHJ P,WRTZERO
	POPJ P,

TWSTR:	JUMPN TT,WSTR		;WRITE STRING
WRTZERO:TDZA TTT,TTT
WRTMARK:MOVEI TTT,400000
WORDOUT:SOSG IOHD+2
	OUT DAT,
	CAIA
	JRST OUTERR
	IDPB TTT,IOHD+1
	POPJ P,

BODID:	HLRZ TTT,(TTT)
	HLRZ TTT,1(TTT)
	HLRZ TTT,(TTT)
	JRST WORDOUT

OUTERR:	OUTSTR [ASCIZ/OUTPUT ERROR.
SHALL I CLOSE THE FILE (Y OR N)?/]
	INCHRW T
	CAIE T,"Y"
	CAIN T,"y"
	RELEASE DAT,
	RELEASE DAT,3
	MOVE P,PERRSAV		;GET BACK GOOD POINTER
NODEC,<	HALT CPOPJ	>
DEC,<	JRST TODDT	>

;WRTPRP - WRITE BODY OR BODY DEF PROPERTIES/TEXT
;CALL WITH BODY OR BODY DEF PROPERTY/TEXT LIST IN A

WPROP1:	HLRZ B,(A)
	JUMPE B,WPROP2
	HRRZ TT,(B)
	SKIPN 1(TT)		;BUG TRAP, DON'T WRITE NULL STRINGS
	JRST WPROP2
	PUSHJ P,WSTR
	HLRZ TT,(B)
	PUSHJ P,TWSTR
	HRRZ TTT,(B)
	HLRZ TTT,(TTT)
	PUSHJ P,WORDOUT
	MOVE TTT,1(A)
	PUSHJ P,WORDOUT
	MOVE TTT,1(B)
	PUSHJ P,WORDOUT
WPROP2:	HRRZ A,(A)
WRTPRP:	JUMPN A,WPROP1
	JRST WRTZERO
                                                                                                                                                                                                                                                                                                                                                           ;'WD'	'WPC'	BODIES, CALL WIRE SUBRS
XLBITS__3		;3 BITS OF SIGNIFICANCE IN X
YLBITS__2		;2 IN Y
			;TO WIRE LISTER TO LOCATE BODY

EWLIST:	MOVSI T,EXTWIR
	PUSHJ P,SETLST		;WILL SKIP IF REMEMBERED NAME
WIRE:	SETZM FILNAM
	MOVEM P,PERRSAV
	SKIPE FILNAM
	JRST GOTWNM
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/WIRE LIST /]
	MOVSI T,EXTWIR
	PUSHJ P,SETNAM		;SET WIRE LIST FILENAME
	POPJ P,			;LET HIM OUT
GOTWNM:	ENTPPN
	INIT DAT,10
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,EXIST		;DOES IT EXIST?
	POPJ P,			;DOESN'T WANT TO OVERWRITE IT
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER DAT,FILNAM
	JRST [	RELEASE DAT,
		OUTSTR[ASCIZ/, ENTER FAILED.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
MD,<	MOVEI TTT,WDVER	>
MPC,<	MOVEI TTT,WPCVER>
	PUSHJ P,WORDOUT		;WRITE WIRE LIST FILE VERSION #
	HLLZ TTT,CRDLOC
	PUSHJ P,WORDOUT
MD,<
DEC,<	PUSHJ P,POLCHK	>	;CALCULATE AND PRINT POLARITY ERRORS
	HRRZ TTT,FNDNUM		;NUMBER OF ERRORS STORED HERE
	PUSHJ P,WORDOUT		;PUT INTO FILE (LH 0)
	MOVE TTT,DRWDAT
	PUSHJ P,WORDOUT
	SKIPN TTT,DRWNAM
	MOVE TTT,FILNAM
	PUSHJ P,WORDOUT
	MOVE TTT,DRWPPN
	PUSHJ P,WORDOUT
FOR I IN(TREV,TMODULE,TVARIABLE,TPREFIX,TAUTHOR,TIT1,TIT2,TPROJ,TPAGE,TOF)
<	MOVE TT,I
	PUSHJ P,TWSTR
>
	PUSHJ P,WRTBRD		;WRITE THE BOARD TYPE
	PUSHJ P,ITSET		;CALC SIZE OF DRAWING
NODEC,<	MOVE T,MAXX
	SUB T,MINX
	LSH T,-XLBITS		;MAKE 8 SECTIONS EACH WAY
	ADDI T,1
	MOVEM T,MAXX
	MOVE T,MINY
	SUB T,MAXY
	ASH T,-YLBITS
	SUBI T,1
	MOVEM T,MINY
>;NODEC
DEC,<
	MOVN T,WTAB+DINDEX	;WIDTH OF D-SIZE DWG
	ASH T,-XLBITS-2		;DIVIDE BY 4, MAKE XLBITS ^^2 SECTIONS
	SUBI T,1
	EXCH T,MAXX
	ADD T,MINX
	MOVE TT,WTAB+DINDEX
	ASH TT,-2
	ADD T,TT
	ASH T,-1
	ADDI T,1
	MOVEM T,MINX		;DEC COORD 0,0 IN LOWER RT
	MOVE T,HTAB+DINDEX
	ASH T,-YLBITS-2
	ADDI T,1
	EXCH T,MINY
	ADD T,MAXY
	MOVE TT,HTAB+DINDEX
	ASH TT,-2
	SUB T,TT
	ASH T,-1
	ADDI T,1
	MOVEM T,MAXY
>;DEC
>;MD
MPC,<	PUSHJ P,WRTBRD	>
	SKIPN A,DBODPN
	JRST NOBODS
WBODLP:
MPC,<
	HLRZ TT,(A)
	HLRZ T,1(TT)
	HRRZ TTT,1(TT)
	MOVE TTT,(TTT)
	HLR TTT,(T)
	PUSHJ P,WORDOUT		;# OF PINS,,BID
	MOVE TTT,1(T)		;BODY BITS IN LH
	HRR TTT,(T)		;LOC IN RH
	PUSHJ P,WORDOUT		;AND WRITE IT
	HRRZ TT,1(T)
	PUSHJ P,TWSTR
>;MPC
MD,<
	HLRZ T,(A)		;BODY DATA BLOCK
	HRRZ T,1(T)		;BODY DEF
	HRRZ T,(T)		;BODY NAME POINTER
	MOVE TT,1(T)		;GET BODY NAME
	CAMN TT,[ASCIZ/GND/]	;GROUND BODIES ARE IGNORED
	JRST FLUBDY
	PUSHJ P,FNDDIP		;FIND DIP TYPE
	JRST NOFLUB		;NONE
	HLRZ T,(T)
	HRRZ T,(T)
	MOVE T,1(T)		;FIRST WORD OF DIP NAME
	CAME T,[NULNAM]		;EITHER KIND OF IGNORED BODY?
	CAMN T,[CABNAM]		;THIS TOO
	JRST FLUBDY
NOFLUB:	PUSHJ P,APPXY		;CALC APPROX X AND Y
	HLRZ TT,(A)
	HLR TTT,1(TT)
	HLR TTT,(TTT)
	PUSHJ P,WORDOUT		;APPROX LOC AND BID
	HLRZ T,1(TT)
	HRRZ TTT,(T)		;LOC BLOCK POINTER
	JUMPE TTT,WDNBLC
	HLRZ TTT,(TTT)
	MOVE TTT,(TTT)
WDNBLC:	PUSHJ P,WORDOUT
	HLLZ TTT,1(T)		;BODY BITS
	PUSHJ P,WORDOUT
	HRRZ TT,1(TT)
	HRRZ TT,(TT)
	PUSHJ P,WSTR		;NAME OF BODY
	HLRZ TT,(A)
	HLRZ B,1(TT)
	HRRZ B,1(B)
	JUMPN B,WLPRP1
	HRRZ B,1(TT)
	HLRZ B,1(B)
	HLRZ B,1(B)
	JUMPE B,NWLPRP
WLPRP1:	HLRZ C,(B)
	SKIPE C
	SKIPA C,B
	HRRZ C,1(B)
	HLRZ T,(C)
	HLRZ TT,(T)
	JUMPE TT,WLPRP2
	PUSHJ P,WSTR
	HRRZ TT,(T)
	PUSHJ P,WSTR
WLPRP2:	HRRZ B,(B)
	JUMPN B,WLPRP1
NWLPRP:	PUSHJ P,WRTZERO
FLUBDY:
>;MD
	HRRZ A,(A)
	JUMPN A,WBODLP
NOBODS:	PUSHJ P,WRTZERO
	SETZM WDOLST		;CLEAR DO LIST
	MOVSI C,3		;DONE BITS
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR THE DONE BIT
MPC,<
	SKIPE A,PONPN2
	PUSHJ P,CLRBTS
	SKIPE A,PONPN2
	PUSHJ P,DOWIRE
>;MPC
	SKIPE A,PONPNT
	PUSHJ P,DOWIRE
	PUSHJ P,WRTZERO		;FLAG END WITH NULL WIRE
	PUSHJ P,WRTZERO		;AND NO PINS
	RELEASE DAT,
	POPJ P,

CLRBTS:	HLRZ B,(A)
	HRRZ B,1(B)
	ANDCAM C,1(B)		;TURN OFF BIT
	HRRZ A,(A)
	JUMPN A,CLRBTS
	POPJ P,

APPXY:	HLRE T,1(A)		;X PART
	SUB T,MINX
	IDIV T,MAXX
	SKIPN MAXX
	MOVEI T,1(XLBITS-1)-1
	SKIPGE T
	SETZ T,
	CAIL T,1XLBITS
	MOVEI T,1XLBITS-1
	HRRE TT,1(A)		;Y PART
	SUB TT,MAXY
	IDIV TT,MINY
	SKIPN MINY
	MOVEI TT,1(YLBITS-1)-1
	SKIPGE TT
	SETZ TT,
	CAIL TT,1YLBITS
	MOVEI TT,1YLBITS-1
	ADDI TT,1
	DPB TT,[POINT 9,TTT,8]	;Y PART IS LETTER(ROW)
	ADDI T,1
	DPB T,[POINT 9,TTT,17]	;X PART IS NUMBER(COLUMN)
	POPJ P,
                                                                                          ;		WIRES, WRITE SIGNAL NAME AND PIN INFO
DOWIRE:	HRLM A,(P)
	SETZM RUNBIT		;CLEAR RUN BITS
	TLZ WFLAG
	MOVE H,[1,,WDOSTR]	;BIT TO TEST, ROUTINE TO CALL
	MOVE T,A
	PUSHJ P,RECUR1		;TEST AND PUT IN LIST
	PUSHJ P,RECCHK		;CHECK FOR RECUR
	TLNE WFLAG		;WRITE 0 IF ANY SIGNALS OUT NOW
	PUSHJ P,WRTZERO
	MOVE H,[2,,WDOPNT]
	HLRZ T,(P)
	PUSHJ P,RECUR1		;TEST AND PUT IN LIST
	PUSHJ P,RECCHK		;CHECK FOR RECUR
	TLNN WFLAG		;IF NOTHING PUT OUT
	JRST NOWRUN		;THEN NO BITS OR END MARK
	PUSHJ P,WRTZERO		;MARK END OF WIRE
	MOVE TTT,RUNBIT		;GET RUN BITS
	PUSHJ P,WORDOUT		;WRITE THEM
NOWRUN:	HLRZ A,(P)
	HRRZ A,(A)
	JUMPN A,DOWIRE
	POPJ P,

WDOSTR:	JFCL			;ALWAYS DO THIS PART
	PUSHJ P,WACSET		;NORMALLY ENTER HERE
MPC,<	LDB TT,[POINT 3,D,6]
	JUMPE TT,WRECUR		;IF NO PLANE CONNEX, JUST RECUR
	MOVE TTT,(TT)[	0
			ASCIZ/GND/
			ASCIZ/VCC/
			ASCIZ/VCC2/
			ASCIZ/VCC3/
			ASCIZ/PLN4/
			ASCIZ/PLN5/
			ASCIZ/PLN6/]
	PUSHJ P,WORDOUT
	TLO WFLAG		;NOTE SOMETHING PUT OUT
	JRST WRECUR
>;MPC
MD,<	TLNN D,ISPIN		;IS THIS ON A BODY?
	JRST NGBODY
	HLRZ TT,(B)		;HERE WE FART AROUND FOR PANOFSKY!!!!
	HLRZ TTT,(TT)
	HRRZ TTT,1(TTT)
	HRRZ TTT,(TTT)
	MOVE TTT,1(TTT)
	CAMN TTT,[ASCIZ/GND/]	;BODIES NAMED GND GENERATE SIGNAL NAME GND
	JRST [	TLO WFLAG
		PUSHJ P,WORDOUT
		JRST NGBODY]
	PUSH P,A
	MOVE A,TT
	PUSHJ P,FNDDIP
	JRST [	POP P,A
		JRST NGBODY]
	POP P,A
	HLRZ T,(T)
	HRRZ T,(T)
	MOVE TTT,1(T)
	CAME TTT,[CABNAM]
	JRST NGBODY
	MOVEI TTT,CABBDY
	IORM TTT,RUNBIT		;TURN ON CABBDY IN RUNBITS
NGBODY:	HLRZ TT,(C)
	JUMPE TT,WRECUR		;ANY TEXT?
	HRRZ TT,(TT)		;SKIP OVER OFFSET
	SKIPN TTT,1(TT)		;REALLY SOMETHING THERE? *** BUG TRAP
	JRST WRECUR		;NO
	AND TTT,[774000,,0]
	CAMN TTT,[ASCIZ/;/]
	JRST WRECUR		;FLUSH SIGNALS THAT ARE JUST COMMENTS
	PUSHJ P,WSTR		;WRITE SIGNAL NAME
	TLO WFLAG
	JRST WRECUR
>;MD

WACSET:	HLRZ B,(A)
	HRRZ C,1(B)
	MOVE D,1(C)
	POPJ P,

WDOPNT:	JRST JRECUR		;THIS IS AN "OTHER" PIN, JUST RECUR ON IT
	PUSHJ P,WACSET
	TLNN D,ISPIN
	JRST WCPIN
MD,<	HLRZ TT,(B)		;HERE WE FART AROUND FOR PANOFSKY!!!!
	HLRZ TTT,(TT)
	HRRZ TTT,1(TTT)
	HRRZ TTT,(TTT)
	MOVE TTT,1(TTT)
	CAMN TTT,[ASCIZ/GND/]
	JRST WRECUR
	PUSH P,A
	MOVE A,TT
	PUSHJ P,FNDDIP
	JRST [	POP P,A
		JRST NCNBDY]
	POP P,A
	HLRZ T,(T)
	HRRZ T,(T)
	MOVE TT,1(T)
	CAME TT,[CABNAM]	;BODIES NAMED CABLE DO THIS
	CAMN TT,[NULNAM]	;IGNORE APPEARANCE BODIES
	JRST WRECUR		;WAS A PIN, BUT WE ARE IGNORING IT
NCNBDY:
>;MD
	TLON WFLAG
	PUSHJ P,WRTZERO		;FINISH SIGNAL NAMES
	HLRZ TT,(B)
	HLRZ TT,(TT)
	HLRZ TT,1(TT)
	HLRZ TTT,(TT)		;BODY ID
	PUSHJ P,WORDOUT		;WRITE BODY ID
MD,<	HRRZ TT,(C)
	HLRZ TT,(TT)
	HRRZ TTT,1(C)
	SKIPN TTT		;DO WE HAVE PIN NAME EXPLICITLY?
	HRRZ TTT,1(TT)		;NO, USE DEFAULT
	HRL TTT,(TT)
	PUSHJ P,WORDOUT		;WRITE PIN ID,,PIN NAME
	MOVE TTT,1(C)
	TRZE TTT,-1		;ANY EXPLICIT PIN?
	TLZA TTT,DEFPIN		;YES, MAKE SURE DEFPIN OFF
	TLO TTT,DEFPIN		;NO, SET DEFAULTED BIT
	PUSHJ P,WORDOUT		;BITS,,0
>;MD
MPC,<	HRRZ TTT,(C)
	HLRZ TTT,(TTT)
	HRL TTT,TTT
	PUSHJ P,WORDOUT		;PIN ID,,PIN NAME
>;MPC
	JRST WRECUR

WCPIN:	TLNN D,CPIN
	JRST WRECUR		;NOTHING TO PUT OUT, JUST RECUR
	TLON WFLAG
	PUSHJ P,WRTZERO
	HRR D,(C)
MD,<	MOVS TTT,(D)	>
MPC,<	HRLZ TTT,(D)	>
	PUSHJ P,WORDOUT
MD,<	PUSHJ P,APPXY		;CALC APPROX X AND Y FOR CONNECTOR PIN
	HLR TTT,(A)
	HRR TTT,(TTT)		;PID
>;MD
MPC,<	HLRZ TTT,(A)
	HRRZ TTT,(TTT)
>;MPC
	PUSHJ P,WORDOUT
MD,<	HLLZ TTT,1(C)		;GET BITS
	PUSHJ P,WORDOUT		;WRITE BITS,,0
>;MD
	JRST WRECUR

JRECUR:	PUSHJ P,WACSET
;	JRST WRECUR		;FALL INTO WRECUR
                                                                                                                                                                                                                                                              ;		WIRES, RECUR
WRECUR:
MD,<	HLRZ B,1(B)		;NEIGHBOR POINTER
	HLRZ T,(B)		;
	JUMPE T,.+2
	PUSHJ P,RECUR1
	HRRZ T,(B)
	JUMPE T,.+2
	PUSHJ P,RECUR1
	HLRZ T,1(B)		;_
	JUMPE T,.+2
	PUSHJ P,RECUR1
	HRRZ T,1(B)		;
	JUMPE T,.+2
	PUSHJ P,RECUR1
	TLNN D,ISPIN		;PIN?
	JRST RECCHK		;NO, DONE
	HRRZ T,(C)
	HLRZ T,(T)
	HRL T,1(T)
	HRR T,(T)		;PIN NAME,,PIN ID
	HLRZ A,(A)		;PIN DATA BLOCK
	HLRZ B,(A)		;BODY POINTER
	HLRZ B,(B)		;BODY DATA BLOCK
	JRST WIRPN1

WIRPIN:	HLRZ B,(A)
	HRRZ C,1(B)
	HRRZ TT,(C)
	HLRZ TT,(TT)
	HRL TT,1(TT)
	HRR TT,(TT)
	XOR TT,T
	JUMPE TT,WIRPN1		;DON'T DO US
	TLNN TT,-1		;SAME PIN NAME?
	JRST WPINFN		;YES
WIRPN1:	HRRZ A,(B)
	JUMPN A,WIRPIN
	JRST RECCHK

WPINFN:	MOVE T,A
	PUSHJ P,RECUR0
>;MD
MPC,<
	HLRZ T,(B)
	TLNN D,ISPIN		;IS IT A BODY PIN?
	JRST TSTFED
	HRRZ TTT,(C)		;YES.  T POINTS TO BODY, TTT TO PIN BLOCK IN TYPE
	JRST WIRPN1

WIRPIN:	CAMN T,A
	JRST WIRPN1
	HLRZ TT,(T)
	HRRZ TT,1(TT)
	HRRZ TT,(TT)
	CAMN TT,TTT
	JRST WPINFN
WIRPN1:	HLRZ T,(T)
	HRRZ T,(T)		;NEXT PIN IN RUN
	JUMPN T,WIRPIN
	OUTSTR[ASCIZ/CAN'T FIND PIN ON OTHER SIDE.
/]
	PUSHJ P,FUCKUP
	JRST NOFED

WPINFN:	PUSHJ P,RECUR0
	JRST NOFED

TSTFED:	TLNE D,FEEDTH
	PUSHJ P,RECUR1
NOFED:	HLRZ B,1(B)
	JUMPE B,RECCHK		;ANY NEIGHBORS?
WIRNE1:	MOVEI C,2
WIRNE2:	XCT(C)[HLRZ T,(B)
		HLRZ T,1(B)
		HRRZ T,1(B)]
	JUMPE T,.+2
	PUSHJ P,RECUR1
	SOJGE C,WIRNE2
	HRRZ B,(B)
	JUMPN B,WIRNE1
>;MPC
RECCHK:	SKIPN T,WDOLST		;ANYTHING LEFT TO DO?
	POPJ P,			;NO
	SKIPN A,1(T)		;IS IT A 1 OR 0 ?
	JRST DORCR0		;0
	HRRZ TT,(T)
	MOVEM TT,WDOLST
	FSTRET(T)
	JRST 1(H)

DORCR0:	HLRZ A,(T)
	HRRZ TT,(T)
	MOVEM TT,WDOLST
	FSTRET(T)
	JRST (H)

RECUR0:	PUSHJ P,RECURB
	HRLM T,(TT)
	POPJ P,

RECUR1:	PUSHJ P,RECURB
	MOVEM T,1(TT)
	POPJ P,

RECURB:	HLRZ TT,(T)
	HRRZ TT,1(TT)
	HLLZ TTT,1(TT)
	TDOE TTT,H		;TEST AND SET BIT FROM LH OF H
	JRST CPOPJ1
	HLLM TTT,1(TT)
	GETFS(TT)
	SETZM 1(TT)
	EXCH TT,WDOLST
	HRRZM TT,@WDOLST
	MOVE TT,WDOLST
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;'DAT'		WRITE FILE FOR INPUT TO WAGNER'S ROUTER SYSTEM
;X VALUE GREATER THAN 256 INDICATES SOLDER SIDE INSTEAD OF COMPONENT SIDE
MPC,<
WAG,<
UML,<
WRTRTE:	RELEASE DAT,
WROUTE:	SKIPN WIRLST
	JRST [	OUTSTR[ASCIZ/NO WIRES FOUND!
/]
		POPJ P,]
WRTRT1:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ROUTER OUTPUT (DAT) /]
	MOVE H,[DATNAM]
	EXCH H,LSTNAM			;TEMPORARILY MAKE THIS  AND SAVE OLD
	MOVSI T,EXTROU
	PUSHJ P,SETNAM
	JRST [	MOVEM H,LSTNAM
		POPJ P,]
	ENTPPN
	MOVEM H,LSTNAM			;RESTORE REAL LSTNAM
	INIT DAT,0
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		JRST WRTRT1]
	PUSHJ P,EXIST			;CHECK IT
	JRST WRTRTE
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED!
/]
		JRST WRTRTE]
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PASS EXISITING WIRES/]
	PUSHJ P,YORN
	JFCL
	TLZA WFLAG
	TLO WFLAG
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PASS CONNECTOR PINS/]
	PUSHJ P,YORN
	JFCL
	TLZA ASK
	TLO ASK
	MOVEI T,ROUYMM*ROUSCL
	MOVEM T,MINY
	MOVEI T,ROUXMM*ROUSCL
	MOVEM T,MINX
	MOVSI C,1		;BIT TO CLEAR
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR ON ONE SIDE
	SKIPE A,PONPN2
	PUSHJ P,CLRBTS		;AND OTHER
	MOVE C,WIRLST
	MOVEI G,1		;START WITH SIGNAL NUMBER OF 1
WRTRT2:	HRRZ D,1(C)
WRTTX1:	MOVEI E,NPASLN		;NUMBER OF ENTRIES IN TABLE
WRTTX4:	HLRZ A,1(D)
	JUMPE A,WRTTX3
	ADD A,[POINT 7,1]
	MOVE B,NOPASS(E)
	PUSHJ P,SIGMAT		;IS ONE OF THEM?
	JRST WRTTX5
	JFCL			;EQUIVALENT IS CLOSE ENOUGH
	OUTSTR @NOPASS(E)
	OUTSTR[ASCIZ/ RUN NOT PASSED!
/]
	JRST WRTTX2

WRTTX5:	SOJGE E,WRTTX4
WRTTX3:	HRRZ D,(D)
	JUMPN D,WRTTX1
	HRRZ B,1(C)
WRTRT3:	HRRZ A,1(B)		;GET CON HACK STUFF
	JUMPE A,WRTNOC		;IS THERE ONE?
	LDB T,[POINT 6,A,23]
	CAILE T,4		;FOONLY BOARDS HAVE 4 PADDLES!
	SKIPA T,[ROUXMB]
	MOVEI T,ROUXMT
	TRNE A,76
	ADDI T,SIDDIF
	PUSHJ P,WRTDEC		;WRITE WHICH EDGE NUMBER!
	MOVEI T,ROUANY		;CODE FOR "ANY" CONNECTOR PIN
	PUSHJ P,WRTDEC
	MOVE T,G		;SIGNAL NUMBER
	PUSHJ P,WRTDEC
	PUSHJ P,WCRLF
WRTNOC:	HLRZ A,(B)
	JUMPE A,.+2		;IS THERE ONE?
	PUSHJ P,WRTXY		;POOT IT OUT
	HRRZ B,(B)
	JUMPN B,WRTRT3
	ADDI G,1		;ANOTHER SIGNAL
WRTTX2:	HRRZ C,(C)
	JUMPN C,WRTRT2
	TLNN ASK
	JRST PREPS3		;IF NO CONNEX, NOTHING TO DO HERE
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PASS PREDETERMINED POWER AND GROUND CONNECTOR PINS/]
	PUSHJ P,YORN
	JRST PREPS2
	JRST PREPS2		;NO
	MOVSI C,-PRECLN
	SETZM NUMBER
	MOVEI G,NEVERC		;SIGNAL # FOR NEVER CONNECT HERE
PREPAS:	MOVE T,PRECON(C)
	MOVEM T,LETTER
	PUSHJ P,LOOK		;FIND CONNECTOR PIN
	JRST PREPS1
	MOVE A,T
	PUSHJ P,WRTXY
PREPS1:	AOBJN C,PREPAS
PREPS2:	TLNN WFLAG		;PASSING EXISTING WIRES?
	JRST PREPS3		;NO
	SKIPE A,PONPNT
	PUSHJ P,WRTUCN
	SKIPE A,PONPN2
	PUSHJ P,WRTUCN
PREPS3:	SETZ G,			;NO SIGNALS ON THESE
	JUMPGE SID,UNUSE1	;OTHER SIDE?
	SKIPE A,PONPNT		;NO, THIS IS THE SIDE THE SIGNALS POINT TO
	PUSHJ P,WRTRT4
	SKIPE A,PONPN2
	PUSHJ P,WRTBCN		;WRITE UNUSED BACK SIDE CONNECTORS
	JRST UNUSE2

UNUSE1:	SKIPE A,PONPN2
	PUSHJ P,WRTRT4
	SKIPE A,PONPNT
	PUSHJ P,WRTBCN
UNUSE2:	SETZ T,
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC		;3 0'S TO END PINS
	PUSHJ P,WCRLF
	TLNN WFLAG		;ARE WE PASSING EXISTING WIRES?
	JRST NOWIRF
	OUTSTR[ASCIZ/PASSING EXISTING WIRES!
/]
	SKIPE A,PONPNT
	PUSHJ P,WRTWRF
	SKIPE A,PONPN2
	PUSHJ P,WRTWIR
NOWIRF:	SETZ T,
	PUSHJ P,WRTDEC		;END WITH 4 ZEROES
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC
	PUSHJ P,WCRLF		;END ALL WIRES
	RELEASE DAT,		;CLOSE OUTPUT
	POPJ P,
                                                                                                                                                                                                                                                  ;		ROUTER OUTPUT SUBRS
WRTUCN:	HLRZ TT,(A)
	HRRZ T,1(TT)
	MOVE T,1(T)
	TLNN T,CPIN		;CONNECTOR PIN?
	JRST WRTUCM
	HLRZ TT,1(TT)		;SEE IF ANY CONNECTIONS
	JUMPE TT,WRTUCM
WRTUCO:	SKIPE 1(TT)
	JRST WRTUCP
	SKIPN TT,(TT)
	JRST WRTUCM
	TLNN TT,-1
	JRST WRTUCO
WRTUCP:	PUSHJ P,WRTXY		;WRITE IT
WRTUCM:	HRRZ A,(A)
	JUMPN A,WRTUCN
	POPJ P,

WRTRT4:	PUSHJ P,WRTXY
	HRRZ A,(A)
	JUMPN A,WRTRT4
	POPJ P,

WRTDEC:	MOVEI TTT,4
WRTDC1:	IDIVI T,=10
	HRLM TT,(P)
	SOJLE TTT,.+2
	PUSHJ P,WRTDC1
	HLRZ TTT,(P)
	ADDI TTT,60
	JRST WORDOUT

WRTBCN:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLON TT,1
	TLNN TT,CPIN			;CONNECTOR PINS ONLY ON THIS SIDE
	JRST WRBCNN
	MOVEM TT,1(T)
	PUSHJ P,GOCON
WRBCNN:	HRRZ A,(A)
	JUMPN A,WRTBCN
	POPJ P,

WRTXY:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLOE TT,1
	POPJ P,				;ALREADY DONE!
	MOVEM TT,1(T)
	TLNN TT,ISPIN			;ONLY PINS FOR NOW
	JRST GOCON
	HLRE T,1(A)
	ADD T,MINX			;ADD OFFSET
	CAIG T,ROUXMB*ROUSCL		;DON'T PASS AS CONNECTOR
	PUSHJ P,UNDERX
	CAIL T,ROUXMT*ROUSCL
	PUSHJ P,OVERX
	IDIVI T,ROUSCL			;SCALE IT!
	TRZN T,1			;MAKE IT ON EVEN LOC
	SKIPE TT
	OUTSTR[ASCIZ/PIN ON ODD X LOC, I MOVED IT LEFT!
/]
	PUSHJ P,WRTDEC
	HRRE T,1(A)
	ADD T,MINY
	IDIVI T,ROUSCL
	TRZN T,1
	SKIPE TT
	OUTSTR[ASCIZ/PIN ON ODD Y LOC, I MOVED IT DOWN!
/]
WCONP:	CAIGE T,ROUYMB
	PUSHJ P,UNDERY
	CAILE T,ROUYMT
	PUSHJ P,OVERY
	PUSHJ P,WRTDEC
	MOVE T,G			;GET WIRE NUMBER
	PUSHJ P,WRTDEC
WCRLF:	MOVE TTT,IOHD+2
	CAIG TTT,2			;TWO OR MORE?
	SETZM IOHD+2			;NO, FORCE OUTPUT
	MOVEI TTT,15			;STUFF A CRLF ON THE END
	PUSHJ P,WORDOUT
	MOVEI TTT,12
	JRST WORDOUT

GOCON:	TLNE ASK
	TLNN TT,CPIN
	POPJ P,				;RANDOM POINT OR NOT DOING CPINS
	HLRE T,1(A)
	SKIPL T				;JUST WANT TO KNOW WHICH END
	SKIPA T,[ROUXMT*ROUSCL]
	MOVEI T,ROUXMB*ROUSCL
	EQV TT,SID
	JUMPL TT,.+2
	ADDI T,SIDDIF*ROUSCL		;OTHER SIDE
	IDIVI T,ROUSCL
;	SKIPE TT
;	OUTSTR[ASCIZ/CONNECTOR PIN ON ODD X LOC, I MOVED IT LEFT.
;/]
	PUSHJ P,WRTDEC
	HRRE T,1(A)
	ADD T,MINY
	IDIVI T,ROUSCL
;	SKIPE TT
;	OUTSTR[ASCIZ/CONNECTOR PIN ON ODD Y LOC, I MOVED IT DOWN!
;/]
	JRST WCONP

OVERX:	MOVEI T,(ROUXMT-1)*ROUSCL
	OUTSTR[ASCIZ/X VALUE OVERFLOW!
/]
	POPJ P,

UNDERX:	MOVEI T,(ROUXMB+1)*ROUSCL
	OUTSTR[ASCIZ/X VALUE UNDERFLOW!
/]
	POPJ P,

OVERY:	MOVEI T,ROUYMT
	OUTSTR[ASCIZ/Y VALUE OVERFLOW!
/]
	POPJ P,

UNDERY:	MOVEI T,ROUYMB
	OUTSTR[ASCIZ/Y VALUE UNDERFLOW!
/]
	POPJ P,

WRTXYC:	HLRE T,1(A)
	ADD T,MINX			;ADD OFFSET
	CAIG T,ROUXMB*ROUSCL
	PUSHJ P,UNDERX
	CAIL T,ROUXMT*ROUSCL		;TOO BIG?
	PUSHJ P,OVERX
	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	EQV TT,SID
	JUMPL TT,WRTXYZ
	ADDI T,ROUSCL*SIDDIF
WRTXYZ:	IDIVI T,ROUSCL			;SCALE IT!
	SKIPE TT
	OUTSTR[ASCIZ/SEGMENT ON ODD X LOC, I MOVED IT LEFT!
/]
	PUSHJ P,WRTDEC
	HRRE T,1(A)
	ADD T,MINY
	IDIVI T,ROUSCL
	SKIPE TT
	OUTSTR[ASCIZ/SEGMENT ON ODD Y LOC, I MOVED IT DOWN!
/]
	CAIGE T,ROUYMB
	PUSHJ P,UNDERY
	CAILE T,ROUYMT
	PUSHJ P,OVERY
	JRST WRTDEC

WRTWRF:	HLRZ B,(A)
	HRRZ T,1(B)
	MOVE T,1(T)
	TLNN T,FEEDTH			;PASS FEED THROUGH?
	JRST WRTWIF
	PUSHJ P,WRTXYC			;X,Y ON COMPONENT SIDE
	PUSH P,A
	HLRZ A,(A)
	HLRZ A,(A)
	PUSHJ P,WRTXYC			;X,Y ON SOLDER SIDE
	POP P,A
	PUSHJ P,WCRLF
WRTWIF:	PUSHJ P,WRTWI0
	HRRZ A,(A)
	JUMPN A,WRTWRF
	POPJ P,

WRTWIR:	HLRZ B,(A)
	PUSHJ P,WRTWI0
	HRRZ A,(A)
	JUMPN A,WRTWIR
	POPJ P,

WRTWI0:	HLRZ B,1(B)
	JUMPE B,CPOPJ
WRTWI3:	MOVEI C,2
WRTWI1:	XCT (C)[HLRZ D,(B)
		HLRZ D,1(B)
		HRRZ D,1(B)]
	JUMPE D,WRTWI2
	MOVE T,1(A)
	CAML T,1(D)			;ONLY DO EACH SEGMENT ONCE
	JRST WRTWI2			;WRONG WAY
	MOVE TT,T			;GET COPY OF X,Y
	ADJUST(SUB,TT,<1(D)>)		;GET DELTAS
	TLNE TT,-1			;EITHER DELTA 0?
	TRNN TT,-1
	JRST NDELTA			;YES, THAT'S OK
	HRRE TTT,TT
	HLRE TT,TT
	CAMN TT,TTT			;SAME?
	JRST NDELTA
	MOVN TT,TT
	CAMN TT,TTT			;HOW ABOUT NOW?
	JRST NDELTA
	OUTSTR[ASCIZ/SORRY, LOSING WAGNER GETS ILL MEM REF'S
IF YOU PASS HIM AN EXISTING DIAGONAL ROUTE THAT
IS NOT A 45 DEGREE ANGLE!
/]
	JRST WRTWI2

NDELTA:	PUSHJ P,WRTXYC			;WRITE X,Y OF A
	PUSH P,A
	MOVE A,D
	PUSHJ P,WRTXYC			;NOW OTHER END
	POP P,A
	PUSHJ P,WCRLF
WRTWI2:	SOJGE C,WRTWI1
	HRRZ B,(B)
	JUMPN B,WRTWI3
	POPJ P,
                                                                                                                                                                                                                                                                ;		TABLES FOR ROUTER OUTPUT
;TABLE OF PRESET POWER AND GROUND CONNECTOR PINS
DEFINE PCON(A,B,C)
<
XX1__IFL "A"-"G"<"A";>IFL "A"-"I"<"A"-1;>IFL "A"-"O"<"A"-2;>IFL "A"-"Q"<"A"-3;>"A"-4
XX1__XX1-100
XX2__IFL "B"-"G"<"B";>IFL "B"-"I"<"B"-1;>IFL "B"-"O"<"B"-2;>IFL "B"-"Q"<"B"-3;>"B"-4
XX2__XX2-100

	BYTE(6)0,0,0,XX1-100,XX2-100,C
>

PRECON:	PCON	A,B,1
	PCON	A,F,1
	PCON	A,L,1
	PCON	A,R,1
	PCON	A,U,1
	PCON	A,U,2
	PCON	A,V,1
	PCON	A,V,2
	PCON	B,A,1
	PCON	B,A,2
	PCON	B,B,1
	PCON	B,B,2
	PCON	B,F,1
	PCON	B,L,1
	PCON	B,R,1
	PCON	B,U,1
	PCON	C,B,1
	PCON	C,F,1
	PCON	C,L,1
	PCON	C,R,1
	PCON	C,U,1
	PCON	C,U,2
	PCON	C,V,1
	PCON	C,V,2
	PCON	D,A,1
	PCON	D,A,2
	PCON	D,B,1
	PCON	D,B,2
	PCON	D,F,1
	PCON	D,L,1
	PCON	D,R,1
	PCON	D,U,1
PRECLN__.-PRECON

;TABLE OF SIGNALS NOT TO PASS TO THE ROUTER
NOPASS:	[<ASCII/VCC/>
		ASCIZ/VCC/]
	[<ASCII/GND/>
		ASCIZ/GND/]
	[<ASCII/HI/>
		ASCIZ/HI/]
NPASLN__.-NOPASS-1

>;UML
>;WAG
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   COMMENT    VALID 00031 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	<DRAW>IN.FAI112, 29-JUL-75 11:19:42, EDIT BY HELLIWELL
C00009 00003	READ CARD, FIX SET, FIX ID'S, FINISH UP
C00015 00004	READ VERSION NUMBER, LIBRARY SUBRS
C00024 00005	LIBRARY SUBRS
C00028 00006	HERE IS WHERE WE READ A NEW LIBRARY IN!
C00036 00007	READ TYPES
C00047 00008	CHECK IF TYPE EXISTS, REPLACE MAYBE
C00051 00009	CALL TYPE READING SUBR, READ INSTANCES OF TYPES
C00056 00010	PLACE INSTANCES OF TYPES
C00061 00011	READ POINT, FIND POINT, D PROG
C00064 00012	MORE READ POINT, LINES, D PROG
C00067 00013	READ POINT, FIND, MAKE LINES, PC PROG
C00071 00014	READ REST OF POINT INFO
C00075 00015	READ SETS
C00077 00016	SET IN, PUT IN STRUCTURE, OR FLUSH -- READ SPECIAL STRINGS -- CARD SUBR
C00084 00017	'DAT'		READ WAGNER'S ROUTER FILES
C00091 00018	'WDR'	'LES'	READ LOGIC WIRE LIST AND MAKE INTERNAL POINTERS
C00098 00019	'DAT'		PARTITION FILE
C00108 00020	WORDIN, CHKLOC
C00110 00021	GSTR, RSTR, FIND.P
C00112 00022	'UML'		READ REDAC PIN ASSIGMENTS
C00115 00023			FIND PIN OR BODY AND SET NEW LOC
C00117 00024			SUBRS FOR READING UML FILE
C00120 00025			READ LOCATION FROM STRING
C00121 00026	INPUT SIGNAL NAME CHANGE FILE
C00124 00027	CHANGE FILE INPUT SUBRS
C00126 00028	INPUT SIGNAL NAME CHANGE FILE
C00129 00029	IMPLEMENT ONE CHANGE LINE
C00131 00030	RDVER TABLES!
C00139 00031	
C00140 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;<DRAW>IN.FAI;112, 29-JUL-75 11:19:42, EDIT BY HELLIWELL
VERSION(IN,15)
;INIT DISK, SET FLAGS, CHECK FOR VIRGIN, ETC.
MD,<
DREADR:	TLO M,TYPNLY!TYPREP	;TYPES ONLY AND ALWAYS REPLACE (SILENTLY)!
	JRST DREAD1
>;MD
DREADT:	TLOA M,TYPNLY	;TYPES ONLY
DREAD:	TLZ M,TYPNLY
	TLZ M,TYPREP		;DON'T REPLACE AUTOMATICALLY!
DREAD1:	MOVEM P,PERRSAV		;FOR ERROR RETURNS
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM
	POPJ P,			;LET HIM OUT THIS WAY
	SETZM WIRDAT		;MAKE SURE WE READ FILE
WIRENT:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	RELEASE DAT,
		OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF		;USE COMPILED IN BUFFER
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
	MOVE T,FILPPN
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
	LDB T,[POINT 11,FILDAT,23]
	HRL T,FILDAT
	LDB TT,[POINT 3,FILEXT,20]
	DPB TT,[POINT 6,T,5]
	CAMGE T,WIRDAT
	JRST [	OUTSTR[ASCIZ/, OLDER THAN WIRE LIST FILE.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
;PATCH TO FIX OLD TEXT OFFSETS WHICH ARE WRONG
	SKIPN LSTNAM		;SKIP ALL THIS IF ALREADY HAVE DEFAULT NAME
	TLNE M,TYPNLY		;IF TYPES ONLY, DON'T UPDATE NAMES
	JRST XNAME
	MOVE T,FILNAM
	MOVEM T,LSTNAM		;REMEMBER LAST NAME
MD,<	MOVEM T,DRWNAM	>	;REMEMBER FOR PLOTS ALSO
	MOVE D,FILPPN
	MOVEM D,LSTPPN
MD,<	MOVEM D,DRWPPN
	LDB T,[POINT 11,FILDAT,23]
	HRL T,FILDAT
	LDB TT,[POINT 3,FILEXT,20]
	DPB TT,[POINT 6,T,5]
	MOVEM T,DRWDAT		;REMEMBER DATE LAST WRITTEN OF DRW FILE
>;MD
	PUSHJ P,FILEUP		;AND UPDATE DISPLAY
XNAME:	SETZM NEWBOD		;LIST OF NEW BODY POINTERS.
	SETZM HASHP
MPC,<	SETZM MXPADN		;CLEAR MAXIMUM PAD # SEEN	>
	MOVE A,[HASHP,,HASHP+1]	;CLEAR OUT HASH TABLES
	BLT A,HASHB+LHASHB
	MOVE A,[HASHP(TT)]
	MOVEM A,PHASHP
MPC,<	MOVE A,[HASHP2(TT)]
	MOVEM A,PHASH2
>;MPC
	MOVE T,BID
	MOVEM T,OLDBID
	MOVEM T,MAXBID
	MOVE T,PID
	MOVEM T,OLDPID
	MOVEM T,MAXPID
	TRO VIRGIN		;ASSUME VIRGIN
MPC,<	SKIPN PONPN2	>;MPC
	SKIPE PONPNT
	TRZ VIRGIN		;NOT VIRGIN
	SKIPE DBODPN
	TRZ VIRGIN
	TRO MAKSET
MD,<
	TLNN M,TYPNLY		;NOW, IF TYPNLY OR
>;MD
	TRNE VIRGIN		;A VIRGIN
	JRST [	TRZ MAKSET	;NO SET GETS MADE
		JRST NOVSET]
	SETZM LSTNAM		;FORGET NAME IF NOT VIRGIN!
MD,<	DATE T,			;SET DATE AND TIME TO CURRENT
	HRLZM T,DRWDAT
	MSTIME T,
	IDIVI T,=1000*=60	;TO MINUTES
	HRRM T,DRWDAT
	SETZB T,DRWNAM
NODEC,<	DSKPPN T,	>
DEC,<	GETPPN T,	>
	MOVEM T,DRWPPN		;INIT PPN
>;MD
LAY,<	SETZM SAVNAM	>
	PUSHJ P,FILEUP		;AND UPDATE THAT
	TRNN MAKSET		;SHALL WE MAKE A SET?
	JRST NOVSET		;NO, NO SET
	SETZM DX1
	SETZM DY1
	SETZM DX3
	SETZM DY3
NOVSET:	PUSH P,CURSE
	PUSH P,MODE
MPC,<
	PUSH P,SID
	TLNE SID,FRONT		;LET'S START ON FRONT
	JRST ISFRNT
	FSWITCH
ISFRNT:
>;MPC
	PUSHJ P,RDFILE		;READ FILE!
	SKIPE B,NEWBOD		;RETURN FREE STORAGE FROM NEWBOD LIST(IF ANY)
	PUSHJ P,PUTFS
	SETZM NEWBOD
MPC,<
	POP P,T
	EQV T,SID
	JUMPL T,ISRITE		;ARE WE ON RIGHT SIDE?
	FSWITCH
ISRITE:
>;MPC
                                                                                                                                                                                                                                        ;READ CARD, FIX SET, FIX ID'S, FINISH UP
	TRO MCHG!NEEDCL
	TRZ INLIN!INMOV!STBOX	;MAKE SURE THESE ARE OFF
	POP P,MODE
	POP P,CURSE		;PUT CURSOR BACK WHERE IT WAS
	TRNE MAKSET		;DID WE TRY TO MAKE A SET?
	SKIPN DY3		;YES, IS THERE ONE?
	JRST NOVST1
	GETFS(T)
	HRL TT,DY3
	HRR TT,SETPNT
	MOVEM TT,(T)
	HRRZM T,SETPNT
	MOVE TT,DX1
	IDIV TT,DX3
MPC,<	ASH TT,-1
	IDIV TT,STPSIZ
	IMUL TT,STPSIZ
	ASH TT,1
>;MPC
MD,<	TRZ TT,1	>
	HRLM TT,1(T)
	MOVE TT,DY1
	IDIV TT,DX3
MPC,<	ASH TT,-1
	IDIV TT,STPSIZ
	IMUL TT,STPSIZ
	ASH TT,1
>;MPC
MD,<	TRZ TT,1	>
	HRRM TT,1(T)
	PUSH P,T
	MOVEI T,SETM
	PUSHJ P,CHNGMD		;GO TO SET MOVING MODE
	POP P,T
	PUSHJ P,SCLOSP	;FIND LAST POINTER, SET CLOSES, MOVE TO CENTER
	PUSHJ P,DOSMOV
	OUTSTR[ASCIZ/YOUR NEW FILE IS NOW A SET
AND YOU ARE MOVING IT!
/]
NOVST1:
MD,<	SKIPE B,UTLIST
	PUSHJ P,RELUTL		;RELEASE TYPE USE LIST
>;MD
	SKIPN RDVER		;**RDVER
	JRST ERCHK		;DO END CHECK
	MOVSI T,-LHASHP
NOVST3:	SKIPN A,HASHP(T)
	JRST NOVST2
	HLRZ B,A
	HLLI A,
	EXCH A,PONPNT
	HRRM A,(B)
NOVST2:	AOBJN T,NOVST3
MPC,<	MOVSI T,-LHASHP
NOVST5:	SKIPN A,HASHP2(T)
	JRST NOVST4
	HLRZ B,A
	HLLI A,
	EXCH A,PONPN2
	HRRM A,(B)
NOVST4:	AOBJN T,NOVST5
>;MPC
	TRNN VIRGIN		;IS THIS A VIRGIN
	JRST NDOVIR		;NO, FIX NEWEST PIN ID'S
	MOVE T,MAXBID		;YES, SET MAX AS LAST ASSIGNED
	MOVEM T,BID
	MOVE T,MAXPID
	MOVEM T,PID
	JRST ERCHK

NDOVIR:	MOVE T,OLDBID
	MOVEM T,BID
	MOVE T,OLDPID
	MOVEM T,PID
	PUSHJ P,REEID		;REASSIGN ID'S
ERCHK:
MPC,<	PUSHJ P,CARDIO		;CHECK AND MAYBE READ CARD
	SKIPE CRDNAM		;DID WE GET A CARD?
	TLO M,CRDISP		;YES, DISPLAY IT!
	PUSHJ P,MXPADP		;PRINT MAX PAD # IF BIG ENOUGH
>;MPC
	RELEASE DAT,		;DONE WITH INPUT FILE
STANFO,<
MD,<	SETZ T,
	GETPPN T,
	HLLI T,
	CAIE T,'DWP'		;IS IT POOLE?
	CAIN T,'H'		;IS IT HOLLOWAY?
	PUSHJ P,C16		;DO A SHOW BOX FOR HIM
>;MD
>;STANFO
DEC,<	MOVE T,RDVER	;**RDVER
	TLNN M,TYPNLY		;SKIP IF ONLY READ TYPES
	CAIL T,14
	JRST OFFOK
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/YOU SHOULD PROBABLY DO AN OFFALL!
/]
OFFOK:
>;DEC
	TRNN VIRGIN
	POPJ P,
	TLNE NOINIT		;SUPPRESS CALL OF INIT MACRO?
	JRST ERCHK		;YES
	TRO TFLG		;FLAG TO CALL ONLY IF JUST READ IN
	PUSHJ P,MACCAL		;NOTE WE ONLY INIT A VIRGIN
	ASCIZ/INIT/		;SETUP INIT MACRO FOR EXECUTION
	POPJ P,

MD,<
RELUTL:	HLRZ A,(B)
	PUSHJ P,PUTFS
	SKIPE B,A
	JRST RELUTL
	SETZM UTLIST
	POPJ P,
>;MD

REEID:	SKIPE A,PONPNT
	PUSHJ P,REEPNT
MPC,<	SKIPE A,PONPN2
	PUSHJ P,REEPNT
>;
	SKIPN A,DBODPN
	POPJ P,
REEBOD:	HLRZ T,(A)
	HLRZ T,1(T)
	HLRZ TT,(T)
	CAMG TT,OLDBID		;WAS THIS A NEW ONE?
	JRST NOREEB
	AOS TT,BID		;YES, ASSIGN NEW ID
	HRLM TT,(T)
NOREEB:	HRRZ A,(A)
	JUMPN A,REEBOD
	POPJ P,

REEPNT:	HLRZ T,(A)
	HRRZ TT,1(T)
	MOVE TT,1(TT)
	TLNE TT,ISPIN		;PINS USE BODY, DON'T DO THEM HERE
	JRST NOREEP
	HRRZ TT,(T)		;GET POINT ID
	CAMG TT,OLDPID		;NEW POINT?
	JRST NOREEP
	AOS TT,PID		;YES, GET NEW ID
	HRRM TT,(T)
NOREEP:	HRRZ A,(A)
	JUMPN A,REEPNT
	POPJ P,

MPC,<
MXPADQ:	MOVE T,MXPADN
	JRST MXPADR

MXPADP:	MOVE T,MXPADN
	CAIG T,STDMAX		;BIGGER THAN STANDARD MAX?
	POPJ P,			;NO
MXPADR:	OUTSTR[ASCIZ/MAXIMUM PAD TYPE IS /]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ;READ VERSION NUMBER, LIBRARY SUBRS
GETVER:	PUSHJ P,REDVER		;READ IO VERSION #
	CAIN TTT,IOVER		;SAME AS CURRENT
	POPJ P,
	OUTSTR[ASCIZ/READING OLD IO VERSION # /]
	MOVE T,TTT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,

REDVER:	PUSHJ P,WORDIN		;GET FIRST WORD OF FILE
	TLNN TTT,-1
	JUMPN TTT,[CAIG TTT,IOVER	;DO WE KNOW ABOUT IT?
		JRST NEWVER
		OUTSTR[ASCIZ/I DON'T KNOW ABOUT THIS IO VERSION #!
/]
		CAIL TTT,IOVER+10	;REASONABLE TO TRY OUR HIGHEST?
		JRST .+1		;NO
		MOVEI TTT,IOVER
		JRST NEWVER]
	AOS IOHD+2
	SOS IOHD+1		;OLD BACKUP TO THIS WORD
	SETZ TTT,		;AND USE IOVER=0
NEWVER:	MOVEM TTT,RDVER
MDPC,<	CAIGE TTT,BRDIOV >	;WHAT SHOULD BRDIOV BE FOR THE PC PROGRAM
	POPJ P,
	PUSHJ P,RDBRD
	MOVE TTT,RDVER
	POPJ P,

TYPIN:	PUSHJ P,GETVER
MD,<	PUSHJ P,DOLBTY		;READ LIBRARY AND LOCAL TYPES
	TRNN FSTLIB		;FIRST LIBRARY?
	TDZA C,C		;NO, DON'T TURN ON MACRO BITS
>;MD				;ALWAYS SAVE IN PC
	MOVSI C,MSAVE		;YES, PUT SAVE BIT ON SO IT WILL GO BACK OUT
	TLO C,MACTMP		;MARK AS JUST READ IN
	MOVE T,RDVER		;**RDVER
	CAILE T,13		;THESE DON'T HAVE MACROES IN THEM
	JRST MACIN		;GET THEM
	POPJ P,

MD,<
DOLBTY:	MOVE T,RDVER		;**RDVER
	CAIGE T,3
	JRST RDTYP		;VERSIONS 3 AND HIGHER HAVE LIBRARIES
	CAIGE T,13		;DO WE HAVE LIST OF LIB TYPE USED?
	JRST FRCLIB		;NO, FORCE MERGING IF ALREADY USED
	TRNE FSTLIB		;ARE WE AT TOP LEVEL?
	JRST RDLTYP		;YES, READ NAMES OF USED TYPES FROM LIB'S
	PUSHJ P,SKPSTR		;NO, JUST SKIP THEM
	JRST GETLIB
	JRST .-2

RDLTYP:	SKIPE B,UTLIST
	PUSHJ P,RELUTL
	SETOM USEFLG		;FLAG USE LIST ACTIVE
RDLTY1:	PUSHJ P,RSTRZ
	JRST GETLIB
	EXCH T,UTLIST
	HRLM T,@UTLIST
	SKIPN C,BODPNT
	JRST RDLTY1
RDLTY2:	HRRZ A,(C)		;BODY NAME
	MOVE B,UTLIST		;NAME WE JUST READ
	PUSHJ P,TXTMAT
	JRST RDLTY3
	HLRZ A,(C)		;LIBRARY POINTER
	JUMPE A,RDLTY1		;ANY?
	HLRZ A,(A)		;SECOND WORD OF LIBRARY NAME BLOCK
	MOVEI T,NEEDMR
	IORM T,(A)		;TURN ON BIT SAYING WE NEED TO READ THIS LIBRARY AGAIN
	JRST RDLTY1

RDLTY3:	HRRZ C,1(C)
	JUMPN C,RDLTY2
	JRST RDLTY1

FRCLIB:	SKIPN C,LIBLST
	JRST GETLIB
FRCLB1:	HLRZ A,(C)
	MOVEI T,NEEDMR
	IORM T,(A)		;FORCE MERGING OF ANY LIBRARIES USED IN THIS DWG
	HRRZ C,(C)
	JUMPN C,FRCLB1
GETLIB:	PUSHJ P,WORDIN
	JUMPE TTT,RDTYP
	GETFS (T)
	MOVEM TTT,1(T)
	MOVE B,TTT
	GETFS (TT)
	HRLZM TT,(T)
	PUSHJ P,WORDIN
	TRZ TTT,DTMP1!TOPLVL
	TRNE FSTLIB
	TRO TTT,TOPLVL
	MOVEM TTT,(TT)
	HLLZ C,TTT
	PUSHJ P,WORDIN
	MOVEM TTT,1(TT)
	MOVE D,TTT
	EXCH T,LIBTMP		;LINK ON FRONT OF LIST
	HRRM T,@LIBTMP
	PUSHJ P,MAPLIB		;LOOK FOR MAP ENTRY
	JRST GETLIB		;READ ANOTHER NAME
	MOVE TT,LIBTMP		;THIS IS THE ENTRY WE JUST MADE
	HLRZ A,(A)
	HRRZ A,(A)
	MOVE TTT,1(A)	;GET NEW NAME
	MOVEM TTT,1(TT)
	HLRZ TT,(TT)
	HLRZ A,(A)
	HLLZ TTT,(A)		;EXT
	HLLM TTT,(TT)
	MOVE TTT,1(A)		;PPN
	MOVEM TTT,1(TT)
	JRST GETLIB

RDTYP:	PUSHJ P,RDTYPX
	JRST GOTYPS
	PUSHJ P,RDTYPY
	JRST RDTYP

GOTYPS:	SKIPN E,LIBTMP
	POPJ P,			;NO LIBRARIES TO DO OR WILL BE DONE HIGHER UP
	SETZM LIBTMP		;MAKE SURE NO ONE DOWN UNDER SEES THESE
	PUSH P,FILNAM
	PUSH P,FILEXT
	PUSH P,FILPPN
LIBIT:	PUSH P,(E)
	MOVE B,1(E)
	MOVEM B,FILNAM
	HLRZ TT,(E)
	HLLZ C,(TT)
	MOVEM C,FILEXT
	MOVE D,1(TT)
	MOVEM D,FILPPN
LIBIT1:	PUSHJ P,LNAMCK		;DO WE ALREADY HAVE THIS LIBRARY?
	JRST LGOTIT		;YES
	MOVEM E,LIBNAM		;POINTER TO LIBRARY DESCRIPTOR
	PUSH P,ALLFLG		;SAVE STATE OF FLAG SAYING WE ARE JUST GETTING THE REST OF SOME DEF'S
LIBIT3:	PUSH P,0		;SAVE CURRENT STATE OF FSTLIB
	TRZ FSTLIB		;NO LONGER FIRST
	AOS DEPTH
	PUSHJ P,LIBRED
	JRST LIBFAI
	SOS DEPTH
	POP P,T			;GET OLD STATE OF FSTLIB
	TRNE T,FSTLIB
	TRO FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES
	POP P,ALLFLG
LIBIT2:	POP P,E
	HRRZ E,E
	JUMPN E,LIBIT
	TRNE FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES?
	SETZM LIBNAM		;YES, BODIES HERE DON'T GET LIBRARY POINTER
	POP P,FILPPN
	POP P,FILEXT
	POP P,FILNAM
	LOOKUP DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/FILE I WAS READING WENT AWAY!
/]
		PUSHJ P,FUCKUP
		MOVE P,PERRSAV
		POPJ P,]	;LOSE BIG
	MOVE T,3(P)		;GET BACK PPN
	MOVEM T,FILPPN
	PUSHJ P,REDVER		;AVOID TYPEOUT
	MOVE T,RDVER		;**RDVER
	CAIGE T,13
	JRST SKPTY1
	PUSHJ P,SKPSTR		;SKIP LIB TYPE NAMES AT FRONT
	JRST SKPTY1
	JRST .-2

LIBIT4:	MOVE E,LIBNAM
	HLRZ TT,(E)
	FSTRET(E)
	FSTRET(TT)
	JRST LIBIT2

SKPTY1:	PUSHJ P,WORDIN		;SKIP LIBRARY FILENAMES
	JUMPE TTT,SKPTY2
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST SKPTY1

SKPTY2:	PUSHJ P,SKPSTR		;SKIP BODY NAME
	POPJ P,			;END OF BODY DEFS
	MOVE T,RDVER
	CAIGE T,10		;**RDVER
	JRST SKPTY3		;NO DIP TYPE NAMES!
	CAIGE T,23		;NOT HERE FOR .GE.23
	PUSHJ P,SKPSTR		;SKIP DIP TYPE NAME
	JFCL
	CAIL T,13		;**RDVER DO WE HAVE BITS,,UNUSED?
	PUSHJ P,WORDIN		;YES, SKIP IT
	CAIGE T,12		;**RDVER DO WE HAVE DEF OFFSET
	JRST SKPTY3		;NO
	PUSHJ P,WORDIN		;YES, GET IT
	CAILE T,23		;**RDVER
	PUSHJ P,WORDIN		;SKIP CHAR OFFSET IF THERE
SKPTY3:	PUSHJ P,WORDIN
	CAIN TTT,400000
	JRST SKPTY4
	PUSHJ P,WORDIN
	CAIL T,17
	PUSHJ P,WORDIN		;SKIP NEW WORD
	JRST SKPTY3

SKPTY4:	PUSHJ P,WORDIN
	CAIE TTT,400000
	JRST SKPTY4
	MOVE C,RDVER
	CAIL C,23
	JRST SKPTY6		;**RDVER
SKPTY5:	PUSHJ P,WORDIN
	CAIN TTT,400000
	JRST SKPTY2
	CAIGE C,2		;**RDVER
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	CAILE C,3		;**RDVER
	PUSHJ P,WORDIN
	PUSHJ P,SKPSTR
	JFCL
	JRST SKPTY5

SKPTY6:	PUSHJ P,SKPPRP
	JRST SKPTY2

SKPPRP:	PUSHJ P,SKPSTR
	POPJ P,
	PUSHJ P,SKPSTR
	JFCL
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST SKPPRP
                                                                                                                                                                                                                                                                                       ;LIBRARY SUBRS
SETMAP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/OLD LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	POPJ P,
	ENTPPN
	MOVE B,FILNAM
	HLLZ C,FILEXT
	MOVE D,FILPPN
	PUSHJ P,MAPLIB			;TRY TO FIND IT
	CAIA
	JRST GOTMAP
	GETFS(A)
	GETFS(T)
	HRL T,MAPLST
	MOVSM T,(A)
	MOVEM A,MAPLST
	MOVEM B,1(A)
	HLLZM C,(T)
	MOVEM D,1(T)
GOTMAP:	HRLM A,(P)
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	JRST MAPKIL
	ENTPPN
	HLRZ A,(P)
	HLRZ T,(A)
	HRRZ TT,(T)
	JUMPE TT,NOMAPD
	HLRZ TTT,(TT)
	FSTRET(TTT)
	FSTRET(TT)
NOMAPD:	GETFS(TT)
	HRRM TT,(T)
	GETFS(TTT)
	HRLZM TTT,(TT)
	MOVE T,FILNAM
	MOVEM T,1(TT)
	HLLZ T,FILEXT
	MOVEM T,(TTT)
	MOVE T,FILPPN
	MOVEM T,1(TTT)
	POPJ P,

MAPKIL:	HLRZ A,(P)
	MOVEI T,MAPLST
	JRST MAPKL1

MAPKL2:	CAIN T,(A)
	JRST MAPKL3
MAPKL1:	MOVE TT,T
	HRRZ T,(T)
	JUMPN T,MAPKL2
	PUSHJ P,FUCKUP
	POPJ P,

MAPKL3:	HRRZ T,(A)
	HRRM T,(TT)
MAPKL0:	HLRZ T,(A)
	HRRZ TT,(T)
	FSTRET(T)
	FSTRET(A)
	JUMPE TT,CPOPJ
	HLRZ TTT,(TT)
	FSTRET(TT)
	FSTRET(TTT)
	POPJ P,

CLRMAP:	SKIPN B,MAPLST
	POPJ P,
CLRMP1:	MOVE A,B
	HRRZ B,(B)
	PUSHJ P,MAPKL0
	JUMPN B,CLRMP1
	SETZM MAPLST
	POPJ P,

MAPLIB:	SKIPN A,MAPLST
	POPJ P,
MAPLB1:	CAME B,1(A)
	JRST MAPLB2
	HLRZ T,(A)
	CAME D,1(T)
	JRST MAPLB2
	HLLZ TT,(T)
	CAMN TT,C
	JRST CPOPJ1
MAPLB2:	HRRZ A,(A)
	JUMPN A,MAPLB1
	POPJ P,

LNAMCK:	SKIPN A,LIBLST
	JRST CPOPJ1
NXTLB1:	CAME B,1(A)
	JRST NXTLIB
	HLRZ T,(A)
	HLLZ TT,(T)
	CAMN C,TT
	CAME D,1(T)
	JRST NXTLIB
	POPJ P,

NXTLIB:	HRRZ A,(A)
	JUMPN A,NXTLB1
	JRST CPOPJ1

LIBUSE:	OUTSTR[ASCIZ/LIBRARY NAME CONFLICT, CHOOSE ANOTHER!
/]
	POPJ P,

LIBFAI:	SOS DEPTH
	POP P,T			;GET OLD STATE OF FSTLIB
	TRNE T,FSTLIB
	TRO FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES
	POP P,ALLFLG
	OUTSTR[ASCIZ/LIKE TO TRY ANOTHER LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	JRST LIBIT4		;HE GAVE UP
	MOVE E,LIBNAM		;UPDATE SAVED NAME
	HLRZ TT,(E)
	MOVE B,FILNAM
	MOVEM B,1(E)
	HLLZ C,FILEXT
	HLLM C,(TT)
	MOVE D,FILPPN
	MOVEM D,1(TT)
	JRST LIBIT1

LGOTIT:	HLRZ TT,(E)
	FSTRET(E)
	FSTRET(TT)
	HRRZ TT,(T)		;GET FLAG BITS FROM FOUND LIBRARY
;	TRZN TT,NEEDMR		;NEED MERGE?
	TRZA TT,NEEDMR		;****** TEMPORARY BUG FIX, ALWAYS RE-READ LIBRARY
	JRST LIBIT2		;NO, SKIP IT
	HRRM TT,(T)		;MAKE SURE WE ONLY MERGE ONCE
	MOVEM A,LIBNAM		;YES, STORE LIBRARY POINTER THAT'S ALREADY IN
	PUSH P,ALLFLG		;YES, SAVE ALLFLG
	SETOM ALLFLG		;AND SET IT
	JRST LIBIT3
                                                                   ;HERE IS WHERE WE READ A NEW LIBRARY IN!
DOLIB:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	POPJ P,			;LET HIM OUT THIS WAY
	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
DEC,<
	SKIPN D,FILPPN		;0 WILL CONFUSE US
	PUSHJ P,[LOOKUP DAT,FILNAM
		JRST NOLUCK
		MOVE A,[3,,B]
		MOVEI B,DAT
		PATH A,		;PATH UUO TO GET REAL PPN
	NOLUCK:	DSKPPN D,	;PATH UUO FAILED, GET OUR PPN
		SETZM FILNAM+2
		CLOSE DAT,
		MOVEM D,FILPPN
		POPJ P,]
>;DEC
NODEC,<	MOVE D,FILPPN	>
	MOVE B,FILNAM
	HLLZ C,FILEXT
	CAMN B,LSTNAM
	CAME C,[EXTFIL,,0]
	JRST NAMOK
	CAME D,LSTPPN
NAMOK:	PUSHJ P,LNAMCK
	JRST LIBUSE
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	GETFS(A)
	MOVEM A,LIBNAM		;CURRENT LIBRARY NAME
	MOVE T,FILNAM
	MOVEM T,1(A)
	GETFS(T)
	HRLZM T,(A)
	HLLZ TT,FILEXT
	HRRI TT,TOPLVL		;SET AS TOP LEVEL LIBRARY
	MOVEM TT,(T)
	MOVE TT,FILPPN
	MOVEM TT,1(T)
	TLO M,TYPREP!TYPNLY	;REPLACE AUTOMATICALLY AND TYPES ONLY
	TRZ FSTLIB		;NOT FIRST LIBRARIES ANY MORE
	SETOM USEFLG		;ENABLE NON-READIN STUFF
	SETZM ALLFLG		;READING LIBRARY AFRESH
	SETZM LIBTMP		;CLEAR THIS FOR LIBRARY READING
	SKIPE B,UTLIST
	PUSHJ P,RELUTL		;RELEASE ALL USE NAMES (WILL BE CAUGHT AT RDTYPY)
	PUSHJ P,CLBMRK		;CLEAR NEEDMR IN LIBLST
	SETZM DEPTH
	AOS DEPTH
	PUSHJ P,LIBRED
	CAIA
	JRST DOLIB1
	MOVE A,LIBNAM
	HLRZ T,(A)
	FSTRET(A)
	FSTRET(T)
DOLIB1:	RELEASE DAT,
	POPJ P,

LIBRED:	MOVE T,DEPTH
	OUTSTR[ASCIZ/  /]
	SOJG T,.-1
	OUTSTR[ASCIZ/LIBRARY /]
	MOVEI A,FILNAM
	JSR FPRINT			;PRINT LIBRARY NAME
	MOVE T,FILPPN
	LOOKUP DAT,FILNAM		;GET LIBRARY FILE
	JRST LOOKER
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
	OUTSTR[ASCIZ/
/]
	AOS (P)				;SUCCESSFUL LOOKUP
	SKIPE ALLFLG			;IF JUST RE-READING
	JRST TYPIN			;ALREADY GIVEN BACK
	MOVE T,LIBNAM
DEC,<	HLRZ TT,(T)
	MOVE TTT,FILPPN
	MOVEM TTT,1(TT)			;STORE REAL PPN
>;DEC
	EXCH T,LIBLST
	HRRM T,@LIBLST
	JRST TYPIN

;GET A BODY FROM LIBRARY
;POINTER TO HEADER BLOCK OF BODY IN A, PREVIOUS IN LEFT HALF
BDYGET:	HLRZ T,(A)		;LIBRARY BLOCK POINTER
	JUMPE T,[OUTSTR[ASCIZ/NON-LIBRARY BODY NOT FULLY READ IN!
/]
		JRST FUCKUP]
	MOVE TTT,1(T)
	MOVEM TTT,FILNAM
	HLRZ T,(T)
	MOVE TTT,(T)
	HLLZM TTT,FILEXT
	MOVE TTT,1(T)
	MOVEM TTT,FILPPN
	HRRZ T,1(A)
	HLRZ TT,A
	HRRM T,1(TT)		;TEMPORARILY LINK THIS ONE OUT
	HRRZ T,(A)
	MOVEM T,LIBTMP		;STORE BODY NAME HERE
	PUSHJ P,PUSHIT		;MAKE THE WORLD SAFE FOR HIGHER UPS
	PUSHJ P,DORBDY
	JRST GTBDYE
	PUSHJ P,POPIT
	MOVE C,A
	MOVE A,BODPNT		;NEW BODY IS HERE (I HOPE).
	HLRZ T,(C)		;LIBRARY POINTER
	HRLM T,(A)		;STORE INTO BODY JUST READ
	HRRZ B,(C)		;NOW GIVE BACK HEADER BLOCK, AND BOTH NAMES
	HLRZ B,(B)
	SKIPE B
	PUSHJ P,PUTFS		;RETURN DIP TYPE NAME
	MOVE B,C
	PUSHJ P,PUTFS		;RETURN BODY NAME
	JRST CPOPJ1		;GIVE SUCCESS RETURN

GTBDYE:	PUSHJ P,POPIT
	HLRZ TT,A
	HRRM A,1(TT)		;LINK BACK IN
	OUTSTR[ASCIZ/SORRY,/]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ NO LONGER IN LIBRARY!
/]
	POPJ P,

RDBODY:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ALLEDM!1EDTAM]		;CANNOT BE IN EDIT MODE!!!
	JRST PERRET
	TRZ INMOV
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE BODY NAME
/]
	PUSHJ P,TREADU
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	MOVEM B,LIBTMP		;SAVE HERE TEMPORARILY
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM		;READ FROM DRAW FILE
	JRST RDLEAV		;LET HIM OUT
	PUSHJ P,DORBDY
	JRST RDLEV1
	JRST RDLEV2

RDLEV1:	OUTSTR[ASCIZ/SORRY,/]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ NOT FOUND!
/]
RDLEV2:	RELEASE DAT,
RDLEAV:	MOVE B,LIBTMP
	JRST PUTFS

DORBDY:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	OUTSTR[ASCIZ/SEARCHING FOR /]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ IN /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	SETZM USEFLG		;MAKE SURE IT IS READ IN
	SETZM ALLFLG
	SETZM LIBNAM		;CLEAR LIBRARY NAME
	TLZ M,TYPREP		;DON'T REPLACE AUTOMATICALLY
	TRZ FSTLIB
	TRO BRDINH		;DON'T CHANGE THE BOARD TYPE
	MOVEM P,PERRSAV		;RETURN UP FROM HERE
	PUSHJ P,GETVER
	TRZ BRDINH
	MOVE T,RDVER
	CAIGE T,3		;**RDVER
	JRST RDTYPZ		;VERSIONS 3 AND ABOVE HAVE LIBRARIES
	CAIGE T,13		;**RDVER
	JRST RDTYPC		;NO LIST OF LIB TYPES TO SKIP
	PUSHJ P,SKPSTR
	JRST RDTYPC
	JRST .-2

RDTYPC:	PUSHJ P,WORDIN
	JUMPE TTT,RDTYPZ	;SKIP OVER LIBRARY NAMES
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST RDTYPC

RDTYPZ:	PUSHJ P,RDTYPX
	POPJ P,
	MOVE A,LIBTMP
	MOVE B,STRING
	PUSHJ P,TXTMAT		;COMPARE NAME HE TYPED WITH BODY NAME
	JRST [	PUSHJ P,RELTYP	;NO, RELEASE TYPE
		JRST RDTYPZ]	;TRY ANOTHER
	PUSHJ P,RDTYPY		;TRY TO GET TYPE INTO STRUCTURE
	TRO MCHG!NEEDCL	;FOUND, COULD BE REPLACING OLD VERSION, SO UPDATE SCREEN
	JRST CPOPJ1

CLBMRK:	SKIPN T,LIBLST
	POPJ P,
	MOVEI TT,NEEDMR
CLBMR1:	HLRZ TTT,(T)
	ANDCAM TT,(TTT)
	HRRZ T,(T)
	JUMPN T,CLBMR1
	POPJ P,
                                                                                    ;READ TYPES
RDTYPX:	PUSHJ P,RSTRZ		;READ TYPE NAME
	POPJ P,			;DONE WITH TYPES!
	MOVEM T,STRING		;SAVE NAME HERE
	SETZM DEFOFF		;CLEAR DIP TYPE POINTER, DEF OFFSET
	SETZM ODIPTYP
	SETZM DEFBTS		;AND BITS,,UNUSED
	MOVE TT,RDVER		;**RDVER
	CAIGE TT,10		;DOES THIS FILE HAVE DIP TYPE?
	JRST NODTYP
	CAIL TT,23
	JRST ISTYPN		;**RDVER
	PUSHJ P,RSTRZ		;READ DIP TYPE
	SETZ T,			;NULL
	MOVEM T,ODIPTYP
ISTYPN:	SETZ TTT,		;CLEAR DEF OFFSET
	MOVE TT,RDVER
	CAIGE TT,12		;**RDVER
	JRST NODTYP
	CAIGE TT,13		;**RDVER
	JRST NODBTS
	PUSHJ P,WORDIN		;READ BITS,,UNUSED
	TLZ TTT,FOUNDL!DTMP1	;CLEAR MARK BITS ON INPUT
	MOVEM TTT,DEFBTS
NODBTS:	PUSHJ P,WORDIN		;READ DEFAULT OFFSET
	MOVEM TTT,DEFOFF
	MOVEI TTT,400000
	MOVE T,RDVER
	CAILE T,23		;**RDVER
	PUSHJ P,WORDIN
	MOVEM TTT,DEFOF1
NODTYP:	SETZM PINS		;INITIALIZE PIN LIST.
	MOVEI T,PINS		;DUMP IN HERE FIRST
RDPIN2:	PUSHJ P,WORDIN		;GET A PIN LOC
RDPINS:	CAIN TTT,400000		;END OF PINS?
	JRST RPINDN		;YES
	MOVE A,RDVER
	CAIG A,10		;**RDVER
	JRST [	ADD TTT,[PXOFF,,PYOFF]
		AND TTT,[PXMASK,,PYMASK]
		JRST .+1]
	GETFS(TT)		;GET PIN X,Y BLOCK
	HRRM TT,(T)		;LINK IT IN
	MOVE T,TT
	GETFS(TT)		;GET PIN ID, PIN NAME, ETC. BLOCK
	HRLZM TT,(T)		;LINK IN
	CAIL A,17
	JRST NWPND1		;**RDVER THIS IS SIMPLE
	PUSH P,TTT
	PXY(TTT)
	MOVEM TTT,1(T)
DEC,<	LDB TTT,[POINT 2,(P),5]
	CAIN TTT,1
	TLO TTT,ASSH
	CAIN TTT,2
	TLO TTT,ASSL
	HLLM TTT,(TT)
>;DEC
	POP P,TTT
	NXY(TTT)
	LSH TTT,=17
	TRZE TTT,400000
	PUSHJ P,NIPCOP
	HLLZM TTT,1(TT)
	PUSHJ P,WORDIN
	HRRM TTT,(TT)
	TRZE TTT,700000
	TRZ TTT,77000		;MAKE (.GE.64) NOT BUSSED THROUGH
	PUSH P,TTT
	ANDI TTT,777
	HRRM TTT,1(TT)
	HRRZ TTT,(P)
	TRNN TTT,777000
	TDZA TTT,TTT
	MOVSI TTT,BUSSED
	IORM TTT,(TT)
	POP P,TTT
	MOVE TT,RDVER
DEC,<	TLNE TTT,1		;MARKER BIT ON?
	CAIG TT,10		;**RDVER
	CAIA
	HLLM TTT,PINS		;FLAG DIP OFFSET IS FIRST PIN
>;DEC
	CAILE TT,2		;**RDVER
	JRST RDPIN2
RDPIN1:	PUSHJ P,WORDIN
	HLRZ TT,TTT
	CAIE TT,400000
	JRST RDPINS
	JRST RDPIN1

NIPCOP:	MOVS TTT,TTT		;GET IN RH FOR INDEX
	TRZ TTT,777770		;AVOID CONFUSING GARBAGE
	MOVE A,NXYTAB(TTT)	;GET OFFSET FOR NIPPLE BIT
	MOVS TTT,TTT
	DPB A,[POINT YOFFW,TTT,YOFFB]
	HLRZ A,A
	DPB A,[POINT XOFFW,TTT,XOFFB]
	POPJ P,

DEC,<NIPOFF__1>
NODEC,<NIPOFF__2>

NXYTAB:	0,,NIPOFF
	0,,NIPOFF
	-NIPOFF,,0
	-NIPOFF,,0
	0,,-NIPOFF
	0,,-NIPOFF
	NIPOFF,,0
	NIPOFF,,0

NWPND1:	MOVEM TTT,1(T)
	PUSHJ P,WORDIN
	TLZ TTT,FOUNDD			;CLEAR MARK BIT
	MOVEM TTT,(TT)
	PUSHJ P,WORDIN
	CAIGE A,20			;NEW PIN POS?
	TLZN TTT,400000			;NO, CLEAR NIPPLE BIT
	CAIA
	PUSHJ P,NIPCOP
	MOVEM TTT,1(TT)
	JRST RDPIN2

RPINDN:	SETZM LINES		;INITIALIZE LINES
	MOVEI T,LINES		;DUMP HERE FIRST
RDLINS:	PUSHJ P,WORDIN		;GET A POINT
	CAIN TTT,400000		;DONE?
	JRST RLINDN		;YES
	GETFS(TT)		;GET A BLOCK FOR HIM
	MOVEM TTT,1(TT)		;STORE LOC
	SETZM (TT)		;CLEAR LINK WORD
	MOVEM TT,(T)		;LINK ON END OF LIST
	MOVE T,TT		;NEW END
	JRST RDLINS		;GET SOME MORE
RLINDN:	SETZM BTEXT		;INITIALIZE BODY TEXT LIST
	MOVE C,RDVER		;GET IOVERSION #
	CAIL C,23		;**RDVER
	JRST RBTXTN
	MOVEI T,BTEXT		;DUMP FIRST POINTER HERE
RBTEXT:	PUSHJ P,WORDIN		;GET LOC OF TEXT
	CAIN TTT,400000		;DONE?
	JRST BTXTDN		;YES
	GETFS(TT)		;GET A BLOCK FOR IT
	SETZM (TT)		;CLEAR LINK
	TLZ TTT,1		;CLEAR MARK BIT
	TRO TTT,1		;SET AUTO OFFSET BIT FOR OLD FORMAT
	MOVEM TTT,1(TT)		;SAVE LOC
	HRRM TT,(T)		;LINK ONTO LIST
	MOVEM T,LOSEPT		;SAVE OLD END IN CASE THIS STRING LOSES
	GETFS(T)		;ANOTHER BLOCK
	HRLM T,(TT)		;LINK TO LEFT POINTER
	CAIGE C,2		;**RDVER
	PUSHJ P,WORDIN		;SKIP REL VECT FROM OLD VERSIONS
	PUSHJ P,WORDIN		;GET LINES, CHARS, AND SIZE
	CAIGE C,4		;**RDVER
	TRZN TTT,10		;OLD VERSIONS INDICATE VERT HERE
	CAIA
	TRO TTT,400000		;MARK VERT FOR OLD VERSIONS
	HRRZ A,TTT
	HRRZ B,A
	ANDI B,377777
	CAILE B,CSIZES		;LEGAL CHAR SIZE?
	JRST [	OUTSTR[ASCIZ/ILLEGAL CHARACTER SIZE READ FOR BODY TEXT.
WILL USE STANDARD TEXT SIZE INSTEAD.
/]
		TRZ A,377777
		TRO A,STDBIG
		JRST .+1]
	CAILE C,3		;**RDVER
	JRST GETCON
	LDB B,[POINT 9,TTT,8]	;GET # OF CHARS
	LDB D,[POINT 9,TTT,17]	;GET # OF LINES-1
	SUBI D,1
	ANDI TTT,377777
	LSH TTT,2		;MAKE IT SCREEN OFFSET
	IMUL B,TTT
	LSH TTT,1		;TIMES 2
	IMUL TTT,D
	MOVNS B
	HRL TTT,B
	TRNN A,400000		;WAS IT VERT?
	JRST GOTCON
	PUSH P,F
	EXCH T,TTT
	MOVEI F,1
	PUSHJ P,ORIENT
	POP P,F
	EXCH T,TTT
	JRST GOTCON
GETCON:	PUSHJ P,WORDIN		;READ CONSTANT OFFSET
GOTCON:	MOVEM TTT,1(T)		;STORE REL VECT
	HRLM A,(P)
	PUSHJ P,RSTRZ		;READ TEXT
	JRST [	HLRZ TTT,(TT)
		FSTRET(TT)
		FSTRET(TTT)
		MOVE T,LOSEPT
		HLLZS (T)
		JRST RBTEXT]
	HLRZ A,(P)
	HRLM A,(T)		;SAVE SIZE IN FIRST WORD OF STRING
	HLRZ TTT,(TT)		;GET BACK POINTER TO REL VEC WORD
	HRRZM T,(TTT)		;LINK IN STRING
	MOVE T,TT		;GET END OF LIST INTO T
	JRST RBTEXT		;ANOTHER ONE

RBTXTN:	PUSHJ P,PROPIN
	JRST BTXTDN

PROPIN:	PUSHJ P,RSTRZ
	POPJ P,
	GETFS(TT)
	HRRZM T,(TT)
	GETFS(TTT)
	HRLZM TT,(TTT)
	EXCH TTT,BTEXT
	HRRM TTT,@BTEXT
	PUSHJ P,RSTRZ
	SETZ T,
	HRLM T,(TT)
	PUSHJ P,WORDIN
	HRRZ T,(TT)
	HRLM TTT,(T)
	PUSHJ P,WORDIN
	MOVE T,BTEXT
	TLZ TTT,1		;CLEAR MARK BIT ON INPUT
	MOVEM TTT,1(T)
	PUSHJ P,WORDIN
	MOVEM TTT,1(TT)
	JRST PROPIN

BTXTDN:	SKIPN T,ODIPTYP		;ANY OLD FORMAT DIPTYPE?
	JRST NODPTY		;NO
	GETFS(TT)
	MOVEI TTT,1
	MOVEM TTT,1(TT)		;INITIALIZE TO AUTO OFFSET
	GETFS(TTT)
	HRLM TTT,(TT)
	HRRM T,(TTT)
	SETZM 1(TTT)
	EXCH TT,BTEXT
	HRRM TT,@BTEXT
	MOVEI TT,[ASCIZ/DIPTYPE/]
	PUSHJ P,ASCCOP
	MOVE A,BTEXT
	HLRZ TT,(A)
	HRLM T,(TT)
	PUSHJ P,EDTTZA
NODPTY:	GETFS(T)		;GET BLOCK FOR POINTERS TO PINS,LINES,BTEXT
DEC,<	SKIPE TT,PINS
	TLNN TT,1		;DIP OFFSET SEEN?
	JRST GOTCO1		;NO
	MOVE TTT,1(TT)		;GET OFFSET
	MOVEM TTT,DEFOFF	;AND STO IT HERE
	HRRZ TTT,(TT)
	MOVEM TTT,PINS
	FSTRET(TT)
GOTCO1:
>;DEC
	GETFS(TT)
	HRLZM TT,(T)
	MOVE TTT,DEFOFF		;DEF LOC OFFSET
	MOVEM TTT,1(TT)
	MOVE TTT,DEFBTS		;BITS,,UNUSED
	HLLZM TTT,(TT)		;CLEAR DIP DEF LIST POINTER
	MOVE TTT,DEFOF1
	CAIN TTT,400000
	JRST NDLCOF
	GETFS(TTT)
	HRRM TTT,(TT)
	SETZM (TTT)
	MOVE TT,DEFOF1
	MOVEM TT,1(TTT)
NDLCOF:	MOVE TT,PINS
	HRRM TT,(T)		;LINK IN PINS
	MOVE TT,LINES
	HRRM TT,1(T)		;LINK IN LINES
	MOVE TT,BTEXT
	HRLM TT,1(T)		;LINK IN BTEXT
	GETFS(TT)		;ANOTHER BLOCK
	HRLZM T,1(TT)		;LINK IN POINTERS
	HRRZ T,STRING		;TYPE NAME
	HRL T,LIBNAM		;YES, GET POINTER TO NAME BLOCK
	MOVEM T,(TT)		;TO FIRST BLOCK
	MOVEM TT,TYPE
	JRST CPOPJ1		;SUCCESS RETURN
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;CHECK IF TYPE EXISTS, REPLACE MAYBE
RDTYPY:	MOVE T,STRING		;ARG IN T
	PUSHJ P,TNAME		;DOES NAME ALREADY EXIST?
	JRST TYPEXI		;YES
	MOVE T,TYPE		;NO, NEW TYPE TO ENTER
	MOVE TT,BODPNT
	HRRM TT,1(T)		;LINK TYPE LIST TO THIS TYPE
	MOVEM T,BODPNT		;MAKE THIS TYPE THE FIRST
CKUBDY:	SKIPN USEFLG		;DO WE HAVE THE USE FEATURE
	POPJ P,
	MOVE T,TYPE
	HLRZ T,(T)
	JUMPE T,CPOPJ		;IF NOT LIBRARY BODY, KEEP IT ALL IN
	MOVE C,STRING
	PUSHJ P,USETYP		;WILL WE USE TYPE?
	POPJ P,			;YES
	MOVE B,TYPE
	HLRZ C,1(B)		;GET POINTER TO THE STUFF WE WANT TO GIVE BACK
	HRRZS 1(B)		;AND CLEAR IT
	PUSHJ P,PARREL		;RELEASE THIS PART OF BODY DEF
	MOVE C,BODPNT
	HRRZ C,(C)
	HLRZ B,(C)
	JUMPE B,CPOPJ
	HRRZS (C)		;CLEAR DIP TYPE POINTER ALSO
	JRST PUTFS		;AND RETURN IT

USETYP:	SKIPN D,UTLIST		;ANY USE LIST?
	JRST CPOPJ1		;NOT USED
USETY1:	MOVE A,D
	MOVE B,C
	PUSHJ P,TXTMAT
	CAIA
	POPJ P,			;MATCH, WILL BE USED
	HLRZ D,(D)
	JUMPN D,USETY1
	JRST CPOPJ1		;NOT USED AT ALL

TYPEXI:	MOVEM C,OLDTYP		;SAVE THIS IN CASE WE WILL REPLACE
	MOVE A,TYPE
	MOVEM A,NEWTYP
	SKIPN ALLFLG		;TRYING TO GET ALL OF DEF?
	JRST TYPEXJ		;NO, DO REG. THING
	HLRZ T,1(C)		;DATA POINTER FOR TYPE
	JUMPN T,RELTYP		;ALL IN, SKIP IT COMPLETELY
	JRST NOREPB		;IF NOT ALL IN, REPLACE WITH FULL DEF

TYPEXJ:	TLNE M,TYPREP
	JRST AUTORP
	TLNE M,DSKACT!MACACT
	JRST NOASKM
	OUTSTR[ASCIZ/SHALL I REPLACE /]
	MOVE B,OLDTYP
	PUSHJ P,OUTIT
	OUTSTR[ASCIZ/ WITH /]
	MOVE B,NEWTYP
	PUSHJ P,OUTIT
NOASKM:	PUSHJ P,YORN
	JRST RELTYP
	JRST RELTYP
	JRST GETMOD

RELTYP:	MOVE A,TYPE
	JRST TYPREL		;RELEASE FREE STORAGE FOR THIS TYPE

GETMOD:	MOVE T,OLDTYP
	HLRZ T,1(T)
	JUMPE T,NOREPB		;DON'T HAVE TO REPLACE IF NOT USED (NOT IN)
	PUSHJ P,REPST1		;SETUP CORRESPONDENCE
	JRST RELTYP		;GIVE UP!
DOREP:	PUSHJ P,REPLOP
NOREPB:	MOVEI A,BODPNT-1
	JRST FNDTP1
FNDTYP:	CAMN A,OLDTYP
	JRST FOUND
FNDTP1:	MOVE B,A
	HRRZ A,1(A)
	JUMPN A,FNDTYP
	PUSHJ P,FUCKUP
	POPJ P,
FOUND:	MOVE C,TYPE
	HRRM C,1(B)
	HRRZ B,1(A)
	HRRM B,1(C)
	HLRZ T,1(A)
	JUMPN T,TYPREL
	PUSHJ P,TYPREL
	JRST CKUBDY		;IF NOT CURRENTLY USED, WE CAN CHECK

AUTORP:	MOVE B,OLDTYP
	PUSHJ P,OUTIT
	OUTSTR[ASCIZ/ BEING REPLACED BY /]
	MOVE B,NEWTYP
	PUSHJ P,OUTIT
	MOVE T,OLDTYP
	HLRZ T,1(T)
	JUMPE T,[OUTSTR[ASCIZ/
/]
		JRST NOREPB]	;NO REPLACE IF BODY NOT USED(NOT IN)
	PUSHJ P,REPCL1		;TRY GEOMETRIC OVERLAY
	JRST RELTYP		;ASK FOR ANOTHER MODE
	OUTSTR[ASCIZ/
/]
	JRST DOREP
>;MD
                                                                                      ;CALL TYPE READING SUBR, READ INSTANCES OF TYPES
RDFILE:	MOVEM P,PERRSAV		;RETURN ONE UP FROM HERE ON INPUT ERRORS
MD,<	SETZM LIBNAM		;NO LIBRARY NAME YET
	SETZM LIBTMP
	SETZM DEPTH
	SETZM USEFLG		;ASSUME USE LIST NOT ACTIVE
	SETZM ALLFLG		;START OUT NORMAL
	TRO FSTLIB		;FIRST LIBRARY LEVEL
	PUSHJ P,CLBMRK		;CLEAR LIBRARY NEEDMR BITS
>;MD
	PUSHJ P,MACCLR		;CLEAR TMP BIT IN MACROS
	PUSHJ P,TYPIN		;GET TYPES IN (MAY RECUR!!!)
	MOVEI F,NEWBOD		;PUT FIRST POINTER HERE
MD,<	TLNE M,TYPNLY		;ONLY TYPES?
	POPJ P,			;GO DIRECTLY TO END DO NOT PASS SETS DO NOT SCREW UP
>;MD
	MOVEI T,[ASCIZ/BODY/]
	MOVEM T,TYPLOC
RDBOD:	PUSHJ P,WORDIN		;LOC OF BODY
	CAIN TTT,400000		;DONE?
MD,<	JRST RDPNT		>
MPC,<	JRST DOPNTX		;YES>
	PUSHJ P,CHKLOC
	MOVEM TTT,CURSE		;SAVE LOC
MPC,<	MOVE TTT,RDVER		;**RDVER
	CAIGE TTT,10		;HAVE DIP TYPE?
	JRST NODTYP
	PUSHJ P,RSTRZ		;DIP TYPE NAME
	SETZ T,			;NULL
	MOVEM T,STRING
NODTYP:
>;MPC
	PUSHJ P,WORDIN		;GET ORIENTATION
	MOVE TT,TTT
MPC,<	ANDI TTT,3	>
MD,<
	MOVE A,RDVER
	XCT %IV6(A)		;**RDVER
>;MD
	MOVEM TTT,CURORT
	SETZM LETTER
	SETZM NUMBER		;NONE SO FAR
	SETZM NUMBR1
MD,<	TRNN TT,400000		;ANY LOCATION?
	JRST NNFORM		;NO
	MOVE A,RDVER
	XCT %IV7(A)		;**RDVER
	SETZ TTT,
	MOVE A,RDVER
	CAILE A,23		;**RDVER
	PUSHJ P,WORDIN
	MOVEM TTT,NUMBR1
>;MD
MPC,<	MOVE A,RDVER
	XCT %IV8(A)		;**RDVER
>;MPC
	MOVE A,RDVER
MD,<	CAILE A,14	>	;**RDVER
MPC,<	CAILE A,15	>	;**RDVER
	JRST NNFORM
	HRRZ A,LETTER		;MAKE SWAPPED 6 BIT BYTES
	DPB A,[POINT 6,A,23]
	LSH A,-6
	DPB A,[POINT 12,LETTER,35];INTO ONE 12 BIT BYTE
NNFORM:	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER
	JRST OLDVR1
	TLZ TTT,FOUNDB!BTMP1
	PUSH P,TTT		;SAVE BODY ID AND BITS
	JRST OLDVR2
OLDVR1:	GETFS (TT)
	MOVEM TT,(F)
	MOVE F,TT
	SETZM (F)
	HRLZM TTT,1(F)		;UNIQUE EXTERNAL NAME FOR BODY INTO NEWBOD LIST
	PUSH P,F		;SAVE NEWBOD LIST POINTER
OLDVR2:
MD,<
	PUSHJ P,RSTR		;NAME OF TYPE
	MOVEM T,STRING		;SAVE FOR GARBAGE COLLECT
	PUSHJ P,TNAME		;FIND LOCATION OF THAT TYPE (POINTER TO STRING IN )
	CAIA			;FOUND (POINTER TO TYPE IN C)
	JRST [	PUSHJ P,OUTTXT
		OUTSTR[ASCIZ/ TYPE NOT FOUND!
BODY WILL BE RELEASED!
/]
		MOVE B,STRING
		PUSHJ P,PUTFS
		POP P,F		;RESTORE NEWBOD LIST POINTER
		MOVE T,RDVER
		CAIL T,23	;**RDVER
		PUSHJ P,SKPPRP	;SKIP OVER PROPERTIESIF NOT PLACING BODY
		JRST RDBOD]	;TRY TO GO ON.
	MOVEM C,CURBOD		;SAVE TYPE POINTER
	MOVE B,STRING
	PUSHJ P,PUTFS
	SETZM BTEXT
	MOVE TT,RDVER
	CAIL TT,23		;**RDVER
	PUSHJ P,PROPIN
>;MD
MPC,<
	PUSHJ P,WORDIN		;NUMBER OF PINS
	HRRZ A,TTT
	CAIG A,2
	JRST [	MOVE T,RDVER
		CAIGE T,10	;**RDVER
		JRST [	CAIN A,1
			MOVEI T,=400/5
			CAIN A,2
			MOVEI T,=200/5
			JRST IS2PNO]
		HLRZ T,TTT
	IS2PNO:	PUSHJ P,G2PIN	;FIND OR MAKE THIS 2 PIN DIP!
		JRST FNDTYP]
FNDT12:	MOVE A,BODPNT
FNDT1:	HLRZ B,(A)
	CAIN B,(TTT)
	JRST FNDTYP
	HRRZ A,(A)
	JUMPN A,FNDT1
	OUTSTR[ASCIZ/TYPE NOT FOUND!
BODY WILL BE RELEASED!
/]
	POP P,F		;RESTORE NEWBOD LIST POINTER
	JRST RDBOD	;TRY TO GO ON.
                                                                                                                                                                          ;PLACE INSTANCES OF TYPES
FNDTYP:	MOVEM A,CURBOD		;SAVE TYPE POINTER
>;MPC
	PUSHJ P,BPYESF		;PLACE BODY(X,Y IN CURSE;TYPE IN CURBOD;ORIENTATION IN CURORT)
	HRRZ T,LSTBOD		;NEWEST BODY
	POP P,F
	SKIPN RDVER		;**RDVER
	HRRM T,1(F)		;STORE INTERNAL POINTER IN NEWBOD LIST
	TRNN MAKSET		;MAKING SET?
	JRST NOBVIR		;NO
	GETFS(TT)
	HRLZM T,1(TT)
	EXCH TT,DY3
	HRRZM TT,@DY3
	HLRE TTT,1(T)
	ADDM TTT,DX1
	HRRE TTT,1(T)
	ADDM TTT,DY1
	AOS DX3
NOBVIR:	HLRZ T,(T)
	HLRZ T,1(T)		;POINTER TO DIPNUM BLOCK
	SKIPN RDVER		;**RDVER
	JRST OLDVR0
	ADD F,OLDBID
	HRLM F,(T)		;SAVE BODY ID FROM FILE
	HLLM F,1(T)		;STO BODY BITS!
	HRRZ F,F
	CAMLE F,MAXBID
	MOVEM F,MAXBID
	ANDI F,LHASHB-1
	HRRZ TT,LSTBOD
	SKIPE TTT,HASHB(F)	;IS THIS BUCKET EMPTY?
	JRST BODLNK
	MOVEM TT,HASHB(F)	;YES MAKE THIS ENTRY
	MOVEI TTT,DBODPN
BODLNK:	HRRZ D,(TTT)		;ADD AFTER FIRST ENTRY IN BUCKET
	HRRM D,(TT)
	HRRM TT,(TTT)
OLDVR0:
MPC,<
	MOVE TT,LETTER
	HRRM TT,(T)
	MOVE TT,STRING
	HRRM TT,1(T)
	JRST RDBOD
>;MPC
MD,<	SKIPN BTEXT
	JRST NXBTXT
	HRRZ A,LSTBOD
	HLRZ A,(A)
	HLRZ B,1(A)
	ADDI B,1
	HRRZ A,1(A)
	HLRZ A,1(A)
	HLRZ A,1(A)
	JUMPE A,NXTTXT
BTLOP1:	HLRZ T,(A)
	HLRZ T,(T)
	JUMPE T,BTLOP2
	MOVE TTT,BTEXT
	PUSHJ P,FPROPX
	JRST BTLOP2
	JRST BTLOP3

BTLOP2:	GETFS(T)
	HRRM T,(B)
	MOVE B,T
	SETZM (B)
	HRRZM A,1(B)
BTLOP3:	HRRZ A,(A)
	JUMPN A,BTLOP1
NXTTXT:	MOVE T,BTEXT
	HRRM T,(B)
NXBTXT:	HRRZ T,LSTBOD
	HLRZ T,(T)
	HLRZ T,1(T)
	HRRZ TT,(T)
	JUMPN TT,GTLCBK
	SKIPN LETTER		;ANY LOC THERE?
	JRST RDBOD		;NO, LOOP NOW
	GETFS(TT)
	HRRM TT,(T)
	GETFS(T)
	HRLZM T,(TT)
GTLCBK:
DEC,<	MOVE T,RDVER		;**RDVER
	CAILE T,14		;OLD LOSING DEC VERSION?
	JRST NLCFUD		;NO, NO FUDGE
	PUSH P,TT
	PUSH P,A
	SETZM CHRCNT
	MOVS A,LETTER
	PUSH P,PUTCHR
	MOVE T,[AOS CHRCNT]
	MOVEM T,PUTCHR
	PUSHJ P,SLTLPN
	POP P,PUTCHR
	MOVE T,CHRCNT
	POP P,A
	IMULI T,CWIDTH/2
	HRLZ T,T
	HRRI T,CHGHT/2
	ADJUST(ADD,T,NUMBER)
	MOVEM T,NUMBER
	POP P,TT
NLCFUD:
>;DEC
	MOVE T,NUMBER		;LOC OFFSET
	MOVEM T,1(TT)
	HLRZ B,(TT)
	MOVE T,LETTER
	MOVEM T,(B)
	MOVE T,NUMBR1
	MOVEM T,1(B)
DEC,<	MOVE T,RDVER
	CAILE T,23		;**RDVER
	JRST NLCOFF
	MOVE A,LSTBOD
	HLRZ A,(A)
	HLRZ A,1(A)
	MOVSI T,FIXBLO
	IORM T,1(A)
	PUSH P,TT
	MOVE T,LSTBOD
	PUSHJ P,OFFBLO
	POP P,TT
NLCOFF:
>;DEC
	MOVE T,RDVER		;**RDVER
	CAIGE T,12		;COMING FROM VERSION WITH NO DEF OFFSET?
	JRST RDBOD		;YES, SKIP IT
	HRRZ A,LSTBOD		;LAST BODY MADE (US)
	HLRZ A,(A)		;DATA BLOCK
	HLRZ T,1(A)		;SECOND DATA BLOCK
	MOVE TTT,1(T)		;BITS
	TLNN TTT,FIXLOC!FIXBLO	;DOES HE WANT THE LOC UPDATED?
	JRST RDBOD		;NO, LEAVE IT ALONE
	MOVE T,CURBOD
	HLRZ T,1(T)
	HLR TTT,(T)
	TLNN TTT,FIXLOC
	JRST FXDBLC
	MOVE T,1(TTT)
	HLRZ F,(A)		;ORIENTATION
	PUSHJ P,ORIENT		;ROTATE IT
	MOVEM T,1(TT)		;SET OFFSET TO DEF FROM TYPE FOR OLD VERSIONS
FXDBLC:	TLNE TTT,FIXBLO
	TLNN TTT,FIXLOC		;ONLY COPY OFFSET FROM DEF IF LOC IS FROM DEF
	JRST RDBOD
	HRRZ TTT,(TTT)
	JUMPE TTT,RDBOD
	MOVE T,1(TTT)
	HLRZ TT,(TT)
	MOVEM T,1(TT)
	JRST RDBOD		;GET ANOTHER ONE
>;MD
                                                                                                                           ;READ POINT, FIND POINT, D PROG
MD,<
RDPNT:	PUSHJ P,WORDIN		;GET LOC OF POINT
	CAIN TTT,400000		;DONE?
	JRST RPNTDN		;YES
	MOVEI T,[ASCIZ/POINT/]
	MOVEM T,TYPLOC
	MOVEM TTT,THSLOC
	PUSHJ P,CHKLOC
	SKIPN RDVER		;**RDVER
	JRST OLDVR3
	PUSH P,TTT		;SAVE LOCATION
	PUSHJ P,WORDIN		;GET PID
	TLNN TTT,-1
	JRST PPIDF		;JUST POINT
	PUSHJ P,FFNDID
	JRST NOBPFN		;BODY PIN NOT FOUND
	POP P,(P)
	JRST OLDVR4

NOBPFN:	JUMPE D,[OUTSTR[ASCIZ/BODY NOT FOUND/]
		JRST PFLSH]
	HLRZ D,(D)
	HRRZ D,1(D)
	MOVEM D,OLDTYP
	OUTSTR[ASCIZ/PIN NOT FOUND ON /]  
	MOVE B,OLDTYP
	PUSHJ P,OUTIT
PFLSH:	OUTSTR[ASCIZ/, PIN WILL BE DELETED!
/]
	POP P,(P)		;LOSE POINT LOC
	MOVEI T,5		;SKIP NEIGHBORS AND END WITH BITS
	PUSHJ P,WORDIN
	SOJG T,.-1
	SKIPN RDVER		;**RDVER ONLY VERY OLD STUFF
	TRNN TTT,400000		;NEW FORMAT?
	JRST NPFLSH		;NO
	PUSHJ P,WORDIN		;SKIP NUMBER WORD
	PUSHJ P,WORDIN		;READ REAL BITS (I HOPE)
NPFLSH:	TLZ TTT,FOUNDP
	MOVE A,TTT		;SAVE BITS
	MOVE T,RDVER		;**RDVER
	CAIL T,3		;THESE HAVE TEXT SIZE IN TTT
	PUSHJ P,WORDIN		;THESE HAVE IT IN NEXT WORD
	TRNN TTT,-1
	JRST NTFLSH
	CAILE T,4		;**RDVER THESE HAVE NO OFFSET
	PUSHJ P,WORDIN		;THESE HAVE
	PUSHJ P,SKPSTR		;SKIP TEXT
	JFCL
NTFLSH:	TLNN A,CPIN		;CONNECTOR PIN?
	JRST RDPNT
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST RDPNT

PPIDF:	EXCH TTT,(P)
	MOVE T,TTT
	PUSHJ P,HSHPUT			;ADD POINT TO HASH LIST
	EXCH TTT,(P)
	ADD TTT,OLDPID
	HRRM TTT,@(P)
	CAMLE TTT,MAXPID	;LARGEST YET?
	MOVEM TTT,MAXPID	;NO, REMEMBER
	MOVE TT,TTT
	ANDI TT,LHASHP-1	;FORM HASH CODE FROM LOW BITS OF PIN ID
	HRRZ TTT,@PHASHP
	HRRM D,@PHASHP
	HRRM TTT,(D)
	SKIPN TTT
	HRLM D,@PHASHP		;NEW END OF BUCKET
	POP P,TTT
	JRST OLDVR4
                                                                                                                                                                                                                ;MORE READ POINT, LINES, D PROG
OLDVR3:	PUSHJ P,FIND.P		;FIND THE POINT (OR MAKE ONE)
OLDVR4:	PUSH P,T
	PUSH P,D
	PUSH P,E
	SETZB D,TT
	MOVE G,RDVER		;FOR INDEXING
	PUSHJ P,WORDIN		;DOWN
	MOVE T,@(P)
	TLNN T,-1
	XCT %IV10(G)		;**RDVER
	JRST NNDOWN
	CAMN TTT,THSLOC
	JRST NNDOWN
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P		;FIND HIM(OR MAKE HIM)
OLDVRD:	MOVE TTT,-1(P)		;THIS POINT
	CAMN TTT,D
	JRST NNDOWN		;NOT TO OURSELVES
	HRRM TTT,(E)		;UP OF DOWN POINT
	HRLM D,@(P)		;SAVE DOWN
	SETZB D,TT
NNDOWN:	PUSHJ P,WORDIN
	MOVE T,@(P)
	TRNN T,-1
	XCT %IV11(G)		;**RDVER
	JRST NNUP
	CAMN TTT,THSLOC
	JRST NNUP
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P		;FIND UP
OLDVRU:	MOVE TTT,-1(P)
	CAMN TTT,D
	JRST NNUP
	HRLM TTT,(E)
	HRRM D,@(P)
	SETZB D,TT
NNUP:	AOS (P)
	PUSHJ P,WORDIN
	MOVE T,@(P)
	TLNN T,-1
	XCT %IV12(G)		;**RDVER
	JRST NNLEFT
	CAMN TTT,THSLOC
	JRST NNLEFT
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P
OLDVRL:	MOVE TTT,-1(P)
	CAMN TTT,D
	JRST NNLEFT
	HRRM TTT,1(E)
	HRLM D,@(P)
	SETZB D,TT
NNLEFT:	PUSHJ P,WORDIN
	MOVE T,@(P)
	TRNN T,-1
	XCT %IV13(G)		;**RDVER
	JRST NNRIGHT
	CAMN TTT,THSLOC
	JRST NNRIGHT
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P
OLDVRR:	MOVE TTT,-1(P)
	CAMN TTT,D
	JRST NNRIGHT
	HRLM TTT,1(E)
	HRRM D,@(P)
NNRIGHT:POP P,E
	POP P,D
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ;READ POINT, FIND, MAKE LINES, PC PROG
MPC<
DOPNTX:	MOVEI T,[ASCIZ/POINT/]
	MOVEM T,TYPLOC
	PUSHJ P,RDPNT
	FSWITCH
	PUSHJ P,RDPNT
	FSWITCH
	JRST RPNTDN

RDPNT:	PUSHJ P,WORDIN		;GET LOC OF POINT
	CAIN TTT,400000		;DONE?
	POPJ P,			;YES
	PUSHJ P,CHKLOC
	SKIPN RDVER		;**RDVER
	JRST OLDVR5
	PUSH P,TTT
	PUSHJ P,WORDIN
	TLNN TTT,-1
	JRST RDPOK
	PUSHJ P,FFNDID
	JRST RPLOSE
	POP P,(P)
	JRST OLDVR6

RDPOK:	EXCH TTT,(P)
	MOVE T,TTT
	PUSHJ P,HSHPUT
	EXCH TTT,(P)
	ADD TTT,OLDPID
	HRRM TTT,@(P)
	CAMLE TTT,MAXPID	;LARGEST YET?
	MOVEM TTT,MAXPID	;NO, REMEMBER
	MOVE TT,TTT
	ANDI TT,LHASHP-1	;FORM HASH CODE FROM LOW BITS OF PIN ID
	HRRZ TTT,@PHASHP
	HRRM D,@PHASHP
	HRRM TTT,(D)
	SKIPN TTT
	HRLM D,@PHASHP		;NEW END OF BUCKET
	POP P,TTT
	JRST OLDVR6
OLDVR5:	PUSHJ P,FIND.P		;FIND THE POINT (OR MAKE ONE)
OLDVR6:	MOVE H,D
	MOVE G,TTT
	PUSH P,T
RDSEG:	PUSHJ P,WORDIN
	SKIPE RDVER		;**RDVER
	JRST [	JUMPN TTT,OLDVR7
		JRST RDSEGN]
	CAIN TTT,400000
	JRST RDSEGN
	PUSHJ P,CHKLOC
OLDVR7:	SKIPE RDVER		;**RDVER
	JRST [	PUSHJ P,FFNDID
		JRST RDSEG		;NOT IN YET
		JRST .+2]
	PUSHJ P,FIND.P
	CAMN D,H
	JRST RDSEG		;NOT TO OURSELVES
	MOVE B,E
	MOVE A,H
	PUSHJ P,FNDLNK		;ALREADY A LINE?
	CAIA			;NO, MAKE ONE
	JRST RDSEG		;YES, NOT AGAIN
	MOVE T,G		;START AT FRONT
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	MOVE T,TTT
	PUSHJ P,FRELNK
	MOVE D,H
	XCT (T)PUTAB
	JRST RDSEG

RPLOSE:	OUTSTR[ASCIZ/PIN OR BODY NOT FOUND!
/]
	PUSHJ P,FUCKUP
	PUSHJ P,WORDIN		;SKIP NEIGHBORS
	JUMPN TTT,.-1
	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER
	TRNN TTT,400000
	JRST NPFLSH
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
NPFLSH:	MOVE T,RDVER
	CAIL T,6		;**RDVER
	PUSHJ P,WORDIN		;TEXT SIZE HERE FOR LATER VERSIONS
	TRNN TTT,-1		;ANY TEXT?
	JRST NTFLSH		;NO
	CAILE T,4		;**RDVER ANY OFFSET?
	PUSHJ P,WORDIN		;YES, SKIP IT
	PUSHJ P,SKPSTR		;SKIP TEXT
	JFCL
NTFLSH:	PUSHJ P,WORDIN		;SKIP FEEDTHROUGH
	JRST RDPNT

RDSEGN:	;FALL INTO CODE ON NEXT PAGE
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;READ REST OF POINT INFO
	POP P,C
	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER ONLY VERY OLD STUFF
	TRNN TTT,400000		;NEW FORMAT?
	JRST NPFORM		;NO
	PUSHJ P,WORDIN		;SKIP NUMBER WORD
	PUSHJ P,WORDIN		;READ REAL BITS (I HOPE)
NPFORM:
	HLLZ TT,TTT
MPC,<	AND TT,[XWD PLANES,0]	;JUST THESE	>
MD,<	AND TT,[XWD CPIN!CPNBTS!FIXTXT!FIXRHT!FIXCON,0]		;JUST THESE
	MOVE T,RDVER
	CAIGE T,12		;**RDVER THESE GUYS HAVE IT
	TLZ TT,FIXTXT!FIXRHT!FIXCON;THESE DON'T
>;MD
	IORB TT,1(C)		;OR IN POWER AND GROUND BITS.
MPC,<	MOVE D,H	>
	TRNE MAKSET		;MAKING SET?
	TLNE TT,MPC,<CPIN!>ISPIN	;YES, PUT THIS ONE IN IT?
	CAIA			;NO
	PUSHJ P,VIRSET
	MOVE T,RDVER
	XCT %IV14(T)		;**RDVER READ PAD OR PIN #, ETC.
	TRNN TTT,-1
	JRST [	SETZ T,
		JRST RNOTXT]
	MOVE T,RDVER				;THIS WAS CLOBBERED BY PBSRC
	CAIGE T,4		;**RDVER
	TRZN TTT,10
	CAIA
	TRO TTT,400000
	HRRZ TT,TTT
	ANDI TTT,377777		;MASK JUST SIZE
	CAILE TTT,CSIZES	;LEGAL?
	JRST [	OUTSTR[ASCIZ/ILLEGAL SIZE IN POINT TEXT.
WILL CHANGE TO STANDARD SIZE.
/]
		TRZ TT,377777
		TRO TT,STDBIG
		JRST .+1]
	CAIG T,4		;**RDVER
	TDZA TTT,TTT
	PUSHJ P,WORDIN
	GETFS (T)
	MOVEM TTT,1(T)
	PUSH P,T
	PUSHJ P,RSTRZ
	JRST [	POP P,T
		FSTRET (T)
		SETZ T,
		JRST RNOTXT]
	HRLM TT,(T)
	HRRZM T,@(P)
	POP P,T
RNOTXT:	HRLM T,(C)
MD,<	MOVE TTT,1(C)
	TLNN TTT,CPIN		;DO WE HAVE TO READ CONNECTOR PIN LOC?
	JRST NRCPIN		;NO
	GETFS (T)
	HRRM T,(C)		;LINK IN NEW BLOCK
	PUSHJ P,WORDIN
	MOVE A,RDVER
	XCT %IV17(A)		;**RDVER
	MOVE A,RDVER
	CAILE A,24		;**RDVER
	JRST NRCPIN
	MOVSI TTT,CPNBTS	;CLEAR BITS IN OLD VERSIONS
	ANDCAM TTT,1(C)
	MOVE T,(T)
	PUSHJ P,CPNBCK		;CHECK FOR U PIN
	HRRZ T,1(C)
	PUSHJ P,CPNBCK		;CHECK THIS ALSO
NRCPIN:
>;MD
MPC,<	PUSHJ P,WORDIN
	CAIN TTT,400000
	JRST RDPNT
	SKIPE RDVER		;**RDVER
	JRST OLDVR8
	PUSHJ P,CHKLOC
	MOVE G,H
	PUSHJ P,RDFEED
	JFCL			;LOSERS LOSE
	JRST RDPNT

OLDVR8:	FSWITCH
	PUSHJ P,FFNDID
	JRST NOOLDV
	MOVE TT,1(T)
	TLNE TT,ISPIN!FEEDTH!CPIN
	JRST NOOLDV
	TLO TT,FEEDTH
	TLNE M,TYPNLY
	TRNE TT,-1
	CAIA
	HRRI TT,1
	MOVEM TT,1(T)
	HLRZ TT,(D)
	HRLM H,(TT)
	HLRZ TT,(H)
	HRLM D,(TT)
	HRRZ TT,1(TT)
	MOVE TTT,1(TT)
	TLO TTT,FEEDTH
	TLNE M,TYPNLY
	TRNE TTT,-1
	CAIA
	HRRI TTT,1
	MOVEM TTT,1(TT)
NOOLDV:	FSWITCH
>;MPC
	JRST RDPNT

VIRSET:	SKIPN T,DY3
	JRST VIRST1
	HRRZ TT,1(T)
	JUMPE TT,VIRST2
	HRRZ T,(T)
	JUMPN T,.-3
VIRST1:	GETFS(T)
	SETZM 1(T)
	MOVE TT,DY3
	HRRZM TT,(T)
	HRRZM T,DY3
VIRST2:	HRRM D,1(T)
	HLRE T,1(D)
	ADDM T,DX1
	HRRE T,1(D)
	ADDM T,DY1
	AOS DX3
	POPJ P,
      ;READ SETS
RPNTDN:	PUSHJ P,WORDIN
	CAIE TTT,400000
	CAIN TTT,400001
	JRST SETDON
	MOVEI G,NEWSET
	SETZM NEWSET
	PUSH P,TTT
RDSBOD:	PUSHJ P,WORDIN
	JUMPE TTT,SBODN		;END OF BODIES IN THIS SET
	SKIPE RDVER		;**RDVER
	JRST [	PUSHJ P,FNDBID
		JRST RDSBOD
		JRST OLDV10]
	MOVE T,TTT
	PUSHJ P,FIND.B
	JRST RDSBOD		;COULDN'T FIND, GO TO NEXT
OLDV10:	GETFS(A)		;GET BLOCK FOR IT
	HRLZM B,1(A)		;SAVE POINTER
	SETZM (A)		;CLEAR LINK
	MOVEM A,(G)		;LINK ON END OF SET
	MOVE G,A		;NEW END
	JRST RDSBOD		;NEXT
SBODN:	MOVEI G,NEWSET
	MOVE H,RDVER
RDSPNT:	PUSHJ P,WORDIN		;READ POINT LOC
	XCT %IV18(H)		;**RDVER
	JRST SPNTDN		;YES
MD,<	PUSHJ P,FIND.P		;FIND POINT>
MPC,<
	SKIPE D,PONPNT
	PUSHJ P,FP1
	CAIA
	JRST [	CHKOTH:	SKIPN A,NEWSET
			JRST THISOK
		CHKLOP:	HRRZ T,1(A)
			CAIN T,(D)
			JRST .+1
			HRRZ A,(A)
			JUMPN A,CHKLOP
			JRST THISOK]
	SKIPE D,PONPN2
	PUSHJ P,FP1
	CAIA
	JRST THISOK
	PUSHJ P,FP3
THISOK:	>;MPC
                                                                                                                                                                                                                                                                                                                                   ;SET IN, PUT IN STRUCTURE, OR FLUSH -- READ SPECIAL STRINGS -- CARD SUBR
OLDV11:
	HRRZ A,(G)
	JUMPN A,GOTIT		;WE HAVE A NEXT BLOCK
	GETFS(A)
	SETZM (A)		;CLEAR LINK
	SETZM 1(A)		;CLEAR DATA
	MOVEM A,(G)
GOTIT:	MOVE G,A
	HRRM D,1(G)		;SAVE POINT POINTER IN SET
	JRST RDSPNT
SPNTDN:	SKIPN NEWSET
	JRST [	OUTSTR[ASCIZ/FLUSHING NULL SET!
/]
		POP P,(P)	;POP OFF SET CENTER
		JRST RPNTDN]
	GETFS(A)
	POP P,1(A)		;SAVE CENTER OF SET
	HRLZ B,NEWSET
	HRR B,SETPNT
	MOVEM B,(A)		;LINK IN SET
	MOVEM A,SETPNT
	JRST RPNTDN		;READ ANOTHER
SETDON:
MD,<	MOVE T,RDVER		;**RDVER
	CAIGE T,4
	JRST NOTIT
FOR I IN(TAUTHOR,TIT1,TIT2)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
	MOVE T,RDVER		;**RDVER
	CAIGE T,10
	JRST NOTIT
	PUSHJ P,WORDIN
	CAMN TTT,CRDLOC
	JRST REVMOD
	JUMPE TTT,REVMOD
	EXCH TTT,CRDLOC		;CARD LOC FOR WHOLE CARD!
	JUMPE TTT,REVMOD
	OUTSTR[ASCIZ/NEW CRDLOC DIFFERENT FROM OLD ONE, WILL USE NEW ONE!
/]
REVMOD:	MOVE T,RDVER		;**RDVER
	CAIGE T,15
	JRST NOTIT
	MOVEI TT,TREV
	PUSHJ P,GSTR
	MOVE T,RDVER
	CAIL T,MODIOV		;**RDVER
	JRST HASMVP		;HAS MODULE, VARIABLE, PREFIX
	PUSHJ P,RSTRZ		;READ OLD MODULE STRING
	JRST NOTMVP		;NONE IS EASY
	PUSH P,T		;SAVE POINTER FOR RETURN
	ADD T,[POINT 7,1]
	PUSHJ P,SETTT7
	MOVEM A,TMODULE
TMODLP:	PUSHJ P,GETTT
	JRST MODEOF
	CAIN C,"-"
	JRST TMODDN
	PUTBYT (C)
	JRST TMODLP

TMODDN:	PUSHJ P,SETTT7
	MOVEM A,TVARIABLE
TVARLP:	PUSHJ P,GETTT
	JRST MODEOF
	CAIN C,"-"
	JRST TVARDN
	PUTBYT (C)
	JRST TVARLP

TVARDN:	PUSHJ P,SETTT7
	MOVEM A,TPREFIX
TPRFLP:	PUSHJ P,GETTT
	JRST MODEOF
	PUTBYT (C)
	JRST TPRFLP

MODEOF:	POP P,B
	PUSHJ P,PUTFS
	JRST NOTMVP

HASMVP:	FOR I IN(TMODULE,TVARIABLE,TPREFIX)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
NOTMVP:	MOVE T,RDVER		;**RDVER
	CAIGE T,16		;NEWEST STRINGS?
	JRST NOTIT		;NO
FOR I IN(TPROJ,TPAGE,TOF,TDCODE,SITE1,SITE2)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
DEC,<	MOVE T,RDVER
	CAIGE T,20
	JRST NOTIT
	MOVEI TT,TNXTHI
	PUSHJ P,GSTR
FOR @$I IN(DRN,CHK,ENG)
<	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM
	JUMPE TTT,NOR$I
	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM+1
	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM+3
NOR$I:
>
;BEGIN BUG FIX  ***********
	SETZM CHKNAM		;FLUSH CHECKED SIGNATURE
;END BUG FIX **************
>;DEC
NOTIT:	MOVE T,RDVER
	CAIN T,BRDIOV		;**RDVER
	PUSHJ P,RDBRD
	POPJ P,
>;MD
MPC,<	CAIE TTT,400001
	POPJ P,
	PUSHJ P,WORDIN
	MOVE T,RDVER
	XCT %IV20(T)		;**RDVER
	POPJ P,

;SEPERATE CALL ON THIS GUY TO AVOID ASSIGNING OLD POINT ID'S AND SCREWING SETS
CARDIO:	MOVE TTT,RDVER		;**RDVER
	CAIGE TTT,17
	JRST OLDCRD
	TRNN VIRGIN
	SKIPN CRDNAM
	CAIA
	JRST NOTNEW		;SKIP CARD IF ALREADY ONE AND NOT VIRGIN
	PUSHJ P,CRDREL
	PUSHJ P,WORDIN
	MOVEM TTT,CRDNAM
	PUSHJ P,WORDIN
	MOVEM TTT,CRDEXT
	PUSHJ P,WORDIN
	MOVEM TTT,CRDPPN
	SKIPN CRDNAM
	POPJ P,
	PUSHJ P,GETCRD
	JRST [	OUTSTR[ASCIZ/ERROR WHILE READING CARD!
/]
		JRST CRDREL]
	POPJ P,

NOTNEW:	PUSHJ P,WORDIN		;SKIP CARD NAME IF WE AREN'T GOING TO USE IT
	PUSHJ P,WORDIN
	JRST WORDIN

OLDCRD:	PUSHJ P,WORDIN
	JUMPE TTT,CPOPJ		;RETURN IF NO OLD CARD #
	OUTSTR[ASCIZ/OLD VERION USED CARD # /]
	MOVE T,TTT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
BUT NOW I NEED A FILENAME.
/]
	JRST DOCARD
>;MPC

;HERE TO READ AND DECODE BOARD TYPE

RDBRD:	MOVEI C,DEFBRD		;DEFAULT FOR OLD STYLE DRAWINGS
	MOVE T,RDVER
	CAIGE T,BRDIOV		;**RDVER
	JRST RDBRD1
	PUSHJ P,RSTRZ		;READ BOARD TYPE, ASCIZ STRING
	POPJ P,			;NO BOARD SPECIFIED
	MOVE B,T		;THE NAME WE JUST READ
	PUSHJ P,FNDBRD
	JRST [	OUTSTR [ASCIZ /UNKNOWN BOARD TYPE: /]
		MOVE T,B
		PUSHJ P,OUTTXT
		OUTSTR[ASCIZ/
/]
		JRST PUTFS]
	PUSHJ P,PUTFS		;PUT THE NAME BACK IN FREE STORAGE
RDBRD1:	TRNE BRDINH		;DON'T SET BOARD TYPE IF SEARCHING LIBRARY FOR BODY
	POPJ P,
	SKIPGE BRDTYP		;IF NO BOARD TYPE YET,
	EXCH C,BRDTYP		;THEN SET THIS
	CAMN C,BRDTYP		;DO BOARD TYPES AGREE?
	POPJ P,			;    YES, NO HASSLE
MD,<	TRNN FSTLIB		;IF TOP LEVEL, ONE MESSAGE
	JRST RDBRD2		;ELSE ANOTHER
>;MD
	JUMPL C,SETBRD		;JUMP IF BOARD PREVIOUSLY UNDEFINED
	OUTSTR [ASCIZ /BOARD TYPES OF FILE AND PROGRAM DISAGREE,
USING BOARD TYPE FROM FILE.
/]
	MOVEM C,BRDTYP
	JRST SETBRD

MD,<
RDBRD2:
NOITS,<
	OUTSTR[ASCIZ/LIBRARY BOARD TYPE DIFFERENT FROM DRAWING.
WILL IGNORE IT AND RETAIN DRAWING BOARD TYPE.
/]
>;NOITS
	POPJ P,
>;MD
                                                                                                                                                                           ;'DAT'		READ WAGNER'S ROUTER FILES
MPC,<
DREADR:
NOWAG,<	JRST PERRET	>
WAG,<
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ROUTER INPUT (DAT) /]
	MOVEI H,' ! '
	ADD H,LASTWR			;LAST WIRE FILE READ!
	EXCH H,LSTNAM			;TEMPORARILY MAKE THIS 
	MOVSI T,EXTROU
	PUSHJ P,SETNAM
	JRST [	MOVEM H,LSTNAM
		POPJ P,]
	MOVEM H,LSTNAM
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEM P,PERRSAV
	MOVE T,FILNAM
	MOVEM T,LASTWR			;SAVE LAST NAME READ SUCCESSFULLY
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVEI T,ROUXMM*ROUSCL
	MOVEM T,MINX
	MOVEI T,ROUYMM*ROUSCL
	MOVEM T,MINY
	MOVEM SID,SIDSAV		;REMEMBER WHICH SIDE WE STARTED ON
ROULP1:	PUSHJ P,GETXY
	JRST ROUDN			;END ON 0,0
	EQV B,SID
	JUMPL B,ROULP3
	SWITCH				;START ON PROPER SIDE
ROULP3:	PUSHJ P,FIND.P			;FIND OR MAKE THIS POINT
	HRL D,TTT
	MOVEM D,MAXY
ROULP2:	PUSHJ P,ATWIRE			;TRY TO ATTACH POINT IN MAXY TO ANY LINE
	PUSHJ P,GETXY
	JRST ROULP1			;END OF THIS WIRE, LOOP
	MOVE D,MAXY
	MOVEM D,MAXX			;BACKUP POINTS
	EQV B,SID			;RIGHT SIDE?
	JUMPGE B,ROUFED			;FEED THROUGH MAYBE?
	CAMN TTT,1(D)			;NULL SEGMENT?
	JRST ROULP2			;YES, LOOP BACK FOR ANOTHER (WAGNER IS A CROCK!!)
	PUSHJ P,FIND.P			;FIND NEXT POINT
	HRL D,TTT
	MOVEM D,MAXY
	HLRZ T,MAXX
	PUSHJ P,FRELNK
	XCT PUTAB(T)
	HLRZ T,MAXY
	PUSHJ P,FRELNK
	HRRZ D,MAXX
	XCT PUTAB(T)
	JRST ROULP2

ROUFED:	PUSH P,TTT
;	PUSHJ P,ATWIRE			;TRY TO ATTACH THIS SIDE
	POP P,TTT
	HRRZ G,MAXX
	CAMN TTT,1(G)			;SHOULD BE AT THE SAME PLACE!
	PUSHJ P,RDFEED			;TRY TO FEED THROUGH
	JRST [	OUTSTR[ASCIZ/COULDN'T FEED THROUGH AT /]
		MOVE TTT,1(G)
		PUSHJ P,CNTFED
		SWITCH
		PUSHJ P,FIND.P
		HRL D,TTT
		MOVEM D,MAXY
		JRST ROULP2]		;TRY TO GO ON
	HRL D,TTT
	MOVEM D,MAXY
	SWITCH
;	PUSHJ P,ATWIRE			;NOW THIS SIDE
	JRST ROULP2

ATWIRE:	PUSH P,CURSE
	HRRZ D,MAXY
	MOVE T,1(D)
	MOVEM T,CURSE
	PUSHJ P,CLSLIN			;SEE IF THERE IS A CLOSEST LINE
	POP P,CURSE
	JUMPE A,CPOPJ			;NO
	MOVE T,DIFSOF
	CAIL T,=10*=10*4/=25		;LESS TEN MILS?
	POPJ P,				;NO
	HRRZ T,A
	HLRZ TT,A
	HRRZ D,MAXY			;THIS WAS CLOBBERED BY CLSLIN
	CAIE T,(D)			;MAKE SURE WE AREN'T EITHER ENDPOINT
	CAIN TT,(D)
	POPJ P,
	PUSH P,A			;SAVE CLOSESTS
	HLRZ B,(A)
	HLRZ B,1(B)
	HLRZ A,(P)
	PUSHJ P,FNDLNK			;FIND THE POINTER
	JRST ROFERR
	HRRZ D,MAXY
	XCT PUTAB(T)			;STORE POINTER TO D INSTEAD
	HLRZ T,MAXY			;DATA BLOCK POINTER
	PUSHJ P,FRELNK
	HRRZ D,(P)
	XCT PUTAB(T)
	HLRZ B,(P)
	HLRZ B,(B)
	HLRZ B,1(B)
	HRRZ A,(P)
	PUSHJ P,FNDLNK
	JRST ROFERR
	HRRZ D,MAXY
	XCT PUTAB(T)
	HLRZ T,MAXY
	PUSHJ P,FRELNK
	HLRZ D,(P)
	XCT PUTAB(T)
NOCLN1:	POP P,(P)
	POPJ P,

ROFERR:	OUTSTR[ASCIZ/MISSING LINE POINTER AT ATWIRE!
/]
	PUSHJ P,FUCKUP
	JRST NOCLN1

ROUDN:	RELEASE DAT,
	TRO MCHG!NEEDCL
	MOVE T,SIDSAV			;GET SIDE WE STARTED ON
	EQV T,SID
	JUMPL T,CPOPJ			;ALREADY ON RIGHT SIDE?
	SWITCH				;NO, CHANGE
	POPJ P,

GETXY:	PUSHJ P,GETN
	JUMPE T,GETZ			;SHOULD BE END
	CAIL T,SIDDIF*ROUSCL
	TLZA B,FRONT			;ON BACK
	TLOA B,FRONT			;ON FRONT
	SUBI T,SIDDIF*ROUSCL		;SUBTRACT SIDE DIF
	CAIL T,SIDDIF*ROUSCL
	PUSHJ P,EVALUE			;TOO LARGE
	CAIN T,ROUXMB*ROUSCL
	MOVEI T,LCEDGE*ROUSCL		;LEFT CONNECTOR EDGE
	CAIN T,ROUXMT*ROUSCL
	MOVEI T,RCEDGE*ROUSCL		;RIGHT	"
	SUB T,MINX
	HRLM T,(P)
	PUSHJ P,GETN
	SKIPE T
	CAIL T,ROUYMT*ROUSCL
	PUSHJ P,EVALUE
	SUB T,MINY
	HLL T,(P)
	MOVE TTT,T
	JRST CPOPJ1

EVALUE:	OUTSTR[ASCIZ/ILLEGAL VALUE AT GETXY.
WILL SUBSTITUTE 1.
/]
	MOVEI T,1
	POPJ P,

GETZ:	PUSHJ P,GETN
	JUMPE T,CPOPJ
	PUSHJ P,FUCKUP
	SETZ T,
	POPJ P,

GETN:	SETZ T,
	MOVEI TT,4
GETN1:	SOSG IOHD+2
	IN DAT,
	CAIA
	JRST [	OUTSTR[ASCIZ/UNEXPECTED EOF!
/]
		MOVEI TTT,"0"
		JRST .+2]
	ILDB TTT,IOHD+1
	JUMPE TTT,GETN1
	CAIE TTT,15
	CAIN TTT,12
	JRST GETN1
	ANDI TTT,17		;MAKE A NUMBER OUT OF IT
	IMULI T,=10
	ADD T,TTT
	SOJG TT,GETN1
	IMULI T,ROUSCL		;MAKE INTO INTERNAL FORMAT
	POPJ P,
>;WAG
>;MPC
                                                                                                                                                                                                                                                                                                                                                                 ;'WDR'	'LES'	READ LOGIC WIRE LIST AND MAKE INTERNAL POINTERS
UML,<
MD,<
IERRS:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LOGIC ERROR SUMMARY (LES) /]
	MOVSI T,EXTLES
	PUSHJ P,SETNAM
	POPJ P,
	TLO WFLAG
	JRST READWA
>;MD

READW:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LOGIC WIRE LIST (FROM WL PROG) (WDR) /]
	MOVSI T,EXTWDR
	PUSHJ P,SETNAM
	POPJ P,				;LET HIM OUT
	TLZ WFLAG
READWA:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,WORDIN
MD,<	TLNN WFLAG
	SKIPA TT,[WDRVER]
	MOVEI TT,LESVER
	CAME TTT,TT			;RIGHT VERSION?
>;MD
MPC,<	CAIE TTT,WDRVER	>
	JRST [	OUTSTR[ASCIZ/, VERSION # MISMATCH!
/]
		RELEASE DAT,
		POPJ P,]
	OUTSTR[ASCIZ/
/]
MD,<	TLNN WFLAG
	JRST GWVER
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/FILENAME OTHER THAN CURRENT DEFAULT?/]
	PUSHJ P,GETWRD
	CAIE C,12
	JRST INNERR			;LOSE
	JUMPN T,.+3
	SKIPN T,LSTNAM			;PICKUP DEFAULT
	JRST [	OUTSTR[ASCIZ/NO DEFAULT NAME!
/]
		RELEASE DAT,
		POPJ P,]
	MOVEM T,PARNAM
GWVER:
>;MD
	PUSHJ P,RELWIR
	SETZM COUNT			;CLEAR UNASSIGNED BODY LOC COUNTER
MPC,<	JRST RWWIR	>
MD,<	SETZM %LAST			;INIT SIGNAL COUNTER
	TLNN WFLAG			;LES FILE?
	JRST RWWIR
TRYCAT:	PUSHJ P,WORDIN
	JUMPE TTT,RWDONE		;THAT'S ALL IF ZERO ERROR CODE
	MOVEM TTT,ERCODE
	PUSHJ P,RSTR
	MOVE B,T
	TLNN M,DSKACT!MACACT
	PUSHJ P,OUTTXT
	PUSHJ P,PUTFS
	PUSHJ P,YORN
	JRST RWDONE			;ALTMODE
	CAIA				;NO, SKIP THIS CATEGORY
	JRST RWWIR			;YES, READ THIS CATEGORY
SKPCAT:	PUSHJ P,SKPSTR
	JRST TRYCAT
SKPCT1:	PUSHJ P,SKPSTR
	JRST SKPCT2
	JRST SKPCT1

SKPCT2:	PUSHJ P,WORDIN
	JUMPE TTT,SKPCAT
	PUSHJ P,WORDIN
	JRST SKPCT2
>;MD

RWWIRX:	JUMPE H,RWWIR
MD,<	TLNE WFLAG			;IERRORS
	SKIPE DX1			;AND NO PINS READ?
	JRST IERSOM			;NOT IERRORS, OR FOUND SOME
	MOVE A,H			;FLUSH WIRES WITH NO PINS
NILERR:	HLRZ B,1(A)
	SKIPE B
	PUSHJ P,PUTFS
	HRRZ A,(A)
	JUMPN A,NILERR
	MOVE B,H
	PUSHJ P,PUTFS
	JRST RWWIR

IERSOM:
>;MD
	GETFS(T)
	HLL H,(P)			;GET ACCUMULATED TYPE BITS
	MOVEM H,1(T)
	EXCH T,WIRLST
	HRRZM T,@WIRLST
RWWIR:	SETZ H,
	HRRZS (P)			;CLEAR ACCUMULATED BITS
RWWIRS:	PUSHJ P,RSTRZ
	JRST [	MOVE G,H
		JUMPN H,RWWIRG
		JRST RWDONE]
	GETFS(TT)
	HRLZM T,1(TT)
	HRRZM H,(TT)
	MOVE H,TT
MD,<	SETZM DX1			;NO PINS FOUND YET>
	JRST RWWIRS

MD,<
RWWIRG:	AOSA %LAST			;INC COUNT OF SIGNALS
>;MD
RWWIR0:	AOS COUNT
MPC,<RWWIRG:>
RWWIR1:	PUSHJ P,WORDIN
	JUMPE TTT,RWWIRX
MD,<	TLNN WFLAG
	JRST RWWIRZ
	MOVE T,TTT
	PUSHJ P,WORDIN
	CAME TTT,PARNAM
	JRST RWWIR1			;NOT THIS FILE, SKIP IT
	MOVE TTT,T
	PUSHJ P,FNDID			;FIND BY PID
	JRST RWWIR0			;LOSE
	AOS DX1				;COUNT A PIN READ
	MOVE T,D
	JRST GWPNT

RWWIRZ:
>;MD
	TLNE TTT,-1
	JRST [	MOVSM TTT,LETTER
MPC,<		HLRZ A,TTT		;ONLY TREAT AZ1,EZ1 SPECIAL IN PC
		PUSHJ P,QUPIN
		CAIA			;NOT WILD
		JRST SAVRND		;SAVE RANDOM CON SPEC
>;MPC
		SETZM NUMBER
		JRST LOKCON]
	PUSHJ P,WORDIN
	HRRZM TTT,NUMBER
	HRRI TTT,
	IORM TTT,(P)			;STO BITS ON STACK
	PUSHJ P,WORDIN
	MOVEM TTT,LETTER
LOKCON:	SKIPN LETTER
	JRST RWWIR0
	PUSHJ P,LOOK			;LOOK FOR IT
	JRST RWNFND
GWPNT:	JUMPN G,RWGFST
	GETFS (G)
	SETZM (G)
	SETZM 1(G)
	MOVE H,G
RWGFST:	HLRZ TT,(G)
	JUMPE TT,RWGFS1
	HRRZ TT,(G)
	JUMPE TT,RWGFS2
	MOVE G,TT
	JRST RWGFST

RWGFS2:	GETFS (TT)
	HRRM TT,(G)
	MOVE G,TT
	SETZM (G)
	SETZM 1(G)
RWGFS1:	HRLM T,(G)
	JRST RWWIR1

MPC,<
SAVRND:	JUMPN G,RWGFXT
	GETFS (G)
	SETZM (G)
	SETZM 1(G)
	MOVE H,G
RWGFXT:	AOS 1(G)
	JRST RWWIR1
>;MPC

RWNFND:	PUSH P,PUTCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	MOVS A,LETTER
	SKIPN NUMBER 			;CON PIN?
	JRST RWNFNC			;YES
	PUSHJ P,SLTLPN
	MOVE A,NUMBER
	PUSHJ P,BPINPN
RWNFN1:	POP P,PUTCHR
	OUTSTR[ASCIZ/ NOT FOUND.
/]
	JRST RWWIR1

RWNFNC:	PUSHJ P,CSLTLP
	JRST RWNFN1

RWDONE:	RELEASE DAT,			;RELEASE INPUT FILE
	SKIPN T,COUNT
	POPJ P,
	PUSHJ P,DECOUT
MD,<	TLNE WFLAG
	OUTSTR[ASCIZ/ PINS OR CPINS NOT FOUND BY FNDID!
/]
	TLNN WFLAG
>;MD
	OUTSTR[ASCIZ/ PINS ON BODIES WITH NO ASSIGNED LOCATIONS!
/]
	POPJ P,

RELWIR:	SKIPN A,WIRLST
	POPJ P,
RELWR1:	HRRZ C,1(A)
RELWR2:	HLRZ B,1(C)
	PUSHJ P,PUTFS
	HRRZ C,(C)
	JUMPN C,RELWR2
	HRRZ B,1(A)
	PUSHJ P,PUTFS
	HRRZ A,(A)
	JUMPN A,RELWR1
	MOVE B,WIRLST
	SETZM WIRLST
	JRST PUTFS
>;UML
                            ;'DAT'		PARTITION FILE
PART,<
INPINS:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PARTITION INPUT (DAT) /]
	MOVE H,[IPNNAM]
	EXCH H,LSTNAM
	MOVSI T,EXTPAR
	PUSHJ P,SETNAM
	JRST [	MOVEM H,LSTNAM
		POPJ P,]
	MOVEM H,LSTNAM
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/FILENAME OTHER THAN CURRENT DEFAULT?/]
	PUSHJ P,GETWRD
	CAIE C,12
	JRST INNERR			;LOSE
	JUMPN T,.+3
	SKIPN T,LSTNAM			;PICKUP DEFAULT
	JRST [	OUTSTR[ASCIZ/NO DEFAULT NAME!
/]
		RELEASE DAT,
		POPJ P,]
	MOVEM T,PARNAM			;SAVE HERE FOR TESTS LATER
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SKIP CONNECTOR PINS/]
	PUSHJ P,YORN
	JRST [	RELEASE DAT,
		POPJ P,]
	TLZA WFLAG
	TLO WFLAG
	TRO MCHG
DPART1:	PUSHJ P,I5IN
	JRST PARLOS
	JUMPE T,[PUSHJ P,SKPLIN
		JRST PARLOS
		TLNE WFLAG		;SKIPPING CONNECTORS?
		JRST PARDON		;YES
		JRST CPART]
	MOVEM T,DX1			;X POS
	PUSHJ P,I5IN
	JRST PARLOS
	MOVEM T,DY1			;Y POS
	PUSHJ P,SKPLIN			;SKIP TO EOL
	JRST PARLOS
DPART2:	PUSHJ P,O6IN			;READ SLICE #
	JRST PARLOS
	MOVE B,T			;DO NOTHING WITH IT FOR NOW
	PUSHJ P,O6IN			;READ BODY ID
	JRST PARLOS
	JUMPE T,[JUMPN B,.+1
		PUSHJ P,SKPLIN
		JRST PARLOS
		JRST DPART1]		;END OF THIS DIP
	MOVE B,T			;SAVE BID
	PUSHJ P,FILCHK			;CHECK IF THIS FILE?
	JRST PARLOS
	JRST BSKIP			;NO, SKIP THIS BODY
	MOVE TTT,B
	PUSHJ P,FNDBID
	JRST BSKIPE
	HLRZ T,(B)
	HLRZ T,1(T)
	HRRZ TT,(T)
	JUMPN TT,DPARTL
	GETFS(TT)
	GETFS(F)
	HRLZM F,(TT)
	SETZM 1(F)
	HRRM TT,(T)
	MOVSI F,FIXLOC!FIXBLO
	IORM F,1(T)			;CONTINUE FIXING LOC
	HLRZ T,(B)
	HLRZ F,(T)			;SAVE ORIENTATION
	HRRZ T,1(T)			;TYPE POINTER
	HLRZ T,1(T)
	HLRZ T,(T)
	MOVE T,1(T)			;INITIAL LOC OFFSET FROM TYPE
	PUSHJ P,ORIENT			;ORIENT IT
	MOVEM T,1(TT)			;INTIALIZE OFFSET
DPARTL:	HLRZ TT,(TT)
	SETZM (TT)			;CLEAR OUT ANY OLD CRUFT THERE
	MOVE T,DX1
	DPB T,[POINT 12,(TT),35]	;THIS IS NUMBER PART
	MOVE T,DY1
	DPB T,[POINT 6,(TT),23]		;THIS IS LETTER PART
	PUSH P,B
	MOVE T,B
	PUSHJ P,OFFBLO
	POP P,B
	PUSHJ P,SKPLIN
	JRST PARLOS
	SETZ G,
	MOVEI F,G
DPARTN:	PUSHJ P,I5INC
	JRST DPARTI
	JRST [
	GIVLOS:	MOVE B,G
		PUSHJ P,PUTFS
		JRST PARLOS]
	GETFS(TT)
	HRRM TT,(F)
	MOVE F,TT
	HRLZM T,(F)
	SETZM 1(F)
	JRST DPARTN

DPARTI:	JUMPE G,DPART2			;NO PINS? GET ANOTHER BODY
	MOVE F,G
DPARTJ:	PUSHJ P,O6INC
	JRST [	OUTSTR[ASCIZ/TOO LITTLE DATA ON PIN ID LINE!
/]
		JRST DPART6]
	JRST GIVLOS
	MOVEM T,1(F)
	HRRZ F,(F)
	JUMPN F,DPARTJ
	PUSHJ P,F4CIN
	JRST GIVLOS
	CAIN TTT,12
	JRST DPART6
	OUTSTR[ASCIZ/EXTRA DATA ON PIN ID LINE!
/]
	PUSHJ P,SKPLIN
	JRST GIVLOS

DPART6:	SKIPN T,1(G)
	JRST DPART7
	MOVEM T,DX3
	HLRZ A,(G)
	HLRZ T,(B)
	TRZ TFLG			;FLAG NONE FOUND YET
	JRST DPART4			;NOW FIND PIN ID

DPART5:	HLRZ T,(T)
	HRRZ TT,1(T)
	HRRZ TTT,(TT)
	HLRZ TTT,(TTT)
	HRRZ TTT,1(TTT)			;PIN NAME FOR THIS
	CAME TTT,DX3			;SAME PIN?
	JRST DPART4
	HRRM A,1(TT)			;STO PIN #
	TRO TFLG			;FLAG THAT WE FOUND ONE
DPART4:	HRRZ T,(T)
	JUMPN T,DPART5
	TRNN TFLG
	OUTSTR[ASCIZ/PIN ID NOT FOUND AT DPART5!
/]
DPART7:	MOVE T,G
	HRRZ G,(G)
	FSTRET(T)
	JUMPN G,DPART6
	JRST DPART2

BSKIPE:	OUTSTR[ASCIZ/BODY NOT FOUND AT DPART2!
/]
BSKIP:	PUSHJ P,SKPLIN			;SKIP REST OF BODY LINE
	JRST PARLOS
	PUSHJ P,SKPLIN			;SKIP PIN # LINE
	JRST PARLOS
	PUSHJ P,SKPLIN			;SKIP PIN ID LINE
	JRST PARLOS
	JRST DPART2			;TRY ANOTHER

CPART0:	PUSHJ P,SKPLIN			;SKIP TO NEXT LINE
	JRST PARLOS
CPART:	PUSHJ P,O6IN
	JRST PARDON			;DO THIS FOR NOW, WAGNER DOESN'T END WITH A 0
	JUMPE T,PARDON			;DONE ON 0
	MOVE B,T			;SAVE POINT ID
	PUSHJ P,FILCHK
	JRST PARLOS
	JRST CPART0
	SKIPN T,PONPNT
	JRST CPARTL
	MOVSI A,ISPIN			;FOR TEST
CPART1:	HLRZ TT,(T)
	HRRZ TTT,1(TT)
	TDNE A,1(TTT)
	JRST CPART2
	HRRZ TT,(TT)
	CAMN TT,B
	JRST CPART3			;SAME ID, THIS IS IT
CPART2:	HRRZ T,(T)
	JUMPN T,CPART1
CPARTL:	OUTSTR[ASCIZ/CONNECTOR PIN NOT FOUND AT CPART1!
/]
	JRST CPART0

CPART3:	HRLM T,(P)			;SAVE POINT POINTER HERE
	MOVE T,1(TTT)
	TLNN T,CPIN
	JRST [	OUTSTR[ASCIZ/FOUND POINT AT CPART1, BUT IT ISN'T A CONNECTOR PIN ANY MORE!
/]
		JRST CPART0]
	MOVE A,TTT
	SETZM LETTER
	PUSHJ P,F4CIN			;GET PADDLE DIGIT
	JRST PARLOS
	ANDI TTT,17
	DPB TTT,[POINT 6,LETTER,23]
	PUSHJ P,F4CIN
	JRST PARLOS
	MOVE B,TTT
	ANDI B,17
	PUSHJ P,F4CIN
	JRST PARLOS
	ANDI TTT,17
	IMULI B,=10
	ADD B,TTT
	AOS LETTER			;AT LEAST 1
	TRNN B,1
	AOS LETTER			;ANOTHER ONE
	ADDI B,1
	LSH B,-1
	DPB B,[POINT 6,LETTER,29]
	PUSH P,C
	PUSH P,D
	MOVE D,A
	MOVE C,A
	HRRZ A,(A)
	MOVE B,A
	PUSHJ P,UBACK			;CHECK FOR UPIN BACKUP
	POP P,D
	MOVE B,LETTER
	MOVEM B,(A)
	MOVE T,B
	PUSHJ P,CPNBCK
	POP P,C
	JRST CPART0

PARLOS:	OUTSTR[ASCIZ/UNEXPECTED END OF FILE, I QUIT!
/]
PARDON:	RELEASE DAT,
	POPJ P,

FILCHK:	PUSHJ P,O12IN
	POPJ P,
	AOS (P)
	CAMN T,PARNAM
	AOS (P)			;RIGHT FILENAME, SKIP
	POPJ P,

SKPLIN:	PUSHJ P,F4CIN
	POPJ P,
	CAIE TTT,12
	JRST SKPLIN
	JRST CPOPJ1

O12IN:	PUSHJ P,O6IN
	POPJ P,
	HRLM T,(P)
	PUSHJ P,O6IN
	POPJ P,
	HLL T,(P)
	JRST CPOPJ1

I5INC:	PUSHJ P,F4CIN
	JRST CPOPJ1
	CAIN TTT,12
	POPJ P,
	MOVEI TT,5
	PUSH P,[=10]
	SETZ T,
	AOS -1(P)
	JRST GETN2

I5IN:	MOVEI TT,5
	PUSH P,[=10]
	JRST DIN

O6INC:	PUSHJ P,F4CIN
	JRST CPOPJ1
	CAIN TTT,12
	POPJ P,
	MOVEI TT,6
	PUSH P,[10]
	SETZ T,
	AOS -1(P)
	JRST GETN2

O6IN:	MOVEI TT,6
OIN:	PUSH P,[10]
DIN:	SETZ T,
GETN1:	PUSHJ P,F4CIN		;READ A CHARACTER
	JRST [	POP P,(P)
		POPJ P,]
GETN2:	CAIN TTT,40
	TDZA TTT,TTT		;SPACES ARE ZEROES
	SUBI TTT,60
	JUMPL TTT,F4LOSE
	CAML TTT,(P)		;LESS THAN RADIX?
	JRST F4LOSE
	IMUL T,(P)
	ADD T,TTT
	SOJG TT,GETN1
	POP P,(P)
	JRST CPOPJ1

F4LOSE:	OUTSTR[ASCIZ/INPUT LOSSAGE AT GETN2, NON-DIGIT SEEN!
/]
	MOVSI TTT,70000		;BACK UP SO WILL GET IT AGAIN
	ADDM TTT,IOHD+1
	AOS IOHD+2
	POP P,(P)
	SETZ T,
	JRST CPOPJ1		;TRY TO HOBBLE ON!

F4CIN:	SOSG IOHD+2
	IN DAT,
	CAIA
	POPJ P,
	ILDB TTT,IOHD+1
	JUMPE TTT,F4CIN
	CAIE TTT,14
	CAIN TTT,15
	JRST F4CIN
	JRST CPOPJ1
>;PART
                                                                                                                                     ;WORDIN, CHKLOC
WORDIN:	SOSG IOHD+2
	IN DAT,
	CAIA
	JRST INERR
	ILDB TTT,IOHD+1
	POPJ P,

INERR:	OUTSTR [ASCIZ/INPUT ERROR.
SHALL I CLOSE THE FILE AND RETURN(Y OR NO)?/]
	INCHRW TTT
	CAIE TTT,"Y"
	CAIN TTT,"y"
	CAIA
NODEC,<	HALT .+1	>
DEC,<	PUSHJ P,TODDT	>
	RELEASE DAT,
	MOVE P,PERRSAV
	POPJ P,


CHKLOC:	HLRE T,TTT
	MOVMS T
MPC,<	CAILE T,20000	>	;+ OR - 50 INCHES?
MD,<	CAILE T,20000	>	;+ OR - ???
	JRST WAYOFF
	HRRE T,TTT
	MOVMS T
MPC,<	CAIG T,20000	>	;+ OR - 50 INCHES?
MD,<	CAIG T,20000	>	;+ OR - ???
	POPJ P,			;OK
WAYOFF:	OUTSTR @TYPLOC		;WHAT IS IT
	OUTSTR[ASCIZ/, WAY OFF SCREEN AT /]
CNTFED:	HLRE T,TTT
	JUMPGE T,.+2
	OUTCHR["-"]
	MOVMS T
MPC,<	IMULI T,5	>
	ASH T,-1
	PUSHJ P,DECOUT
	OUTCHR[","]
	HRRE T,TTT
	JUMPGE T,.+2
	OUTCHR["-"]
	MOVMS T
MPC,<	IMULI T,5	>
	ASH T,-1
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                   ;GSTR, RSTR, FIND.P
MD,<
GSTR:	PUSHJ P,RSTRZ
	POPJ P,
	EXCH T,(TT)
	JUMPE T,CPOPJ
	MOVE B,T
	JRST PUTFS
>;MD

RSTRZ:	PUSHJ P,WORDIN
	JUMPE TTT,CPOPJ
	AOSA (P)		;SKIP WORDIN AND SKIP RETURN
RSTR:	PUSHJ P,WORDIN		;GET SOME OF THE STRING
	MOVEI A,T
RS1:	GETFS(B)		;NO, NEED ANOTHER BLOCK
	MOVEM B,(A)		;LINK IN
	MOVE A,B		;POINT TO IT
	MOVEM TTT,1(A)		;SAVE WORD
	SETZM (A)		;CLEAR LINK
	TRNN TTT,377		;DONE?
	POPJ P,			;YES
	PUSHJ P,WORDIN		;ANOTHER PIECE
	JUMPN TTT,RS1		;DONE?
	POPJ P,

SKPSTR:	PUSHJ P,WORDIN
	JUMPN TTT,SKPST1
	POPJ P,

SKPST2:	PUSHJ P,WORDIN
SKPST1:	TRNE TTT,376
	JRST SKPST2
	JRST CPOPJ1

;FIND.P
;CALL WITH:
;	TTT	X,Y OF DESIRED POINT
;RETURNS WITH:
;	D	POINTER TO POINT
;	TTT	DATA BLOCK
;	T	TEXT AND BODY POINTER
;	E	NEIGHBORS

FIND.P:				;FIND A POINT (IF NONE FOUND MAKE ONE)
	SKIPE D,PONPNT
	PUSHJ P,FP1		;SEARCH ON SCREEN POINTS
	JRST FP3
	JRST FP2

FP1:	CAMN TTT,1(D)		;IS THIS THE ONE?
	JRST CPOPJ1		;YES
	HRRZ D,(D)		;NO, NEXT ONE
	JUMPN D,FP1
	JRST CPOPJ

FP3:	MOVE T,TTT
	JRST PNTPUT		;MAKE A POINT(POINTERS WILL BE RIGHT)
FP2:	HLRZ TTT,(D)		;POINTER TO DATA BLOCK
	HRRZ T,1(TTT)		;POINTER TO ^_
	HLRZ E,1(TTT)
	POPJ P,
                                                                ;'UML'		READ REDAC PIN ASSIGMENTS
MD,<
INUML:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/UML INPUT /]
	MOVSI T,EXTUML
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
ASKCRD:	SETZM PARNAM			;IF GLOBAL CARD LOC, ZERO FOR MATCH
	SKIPE T,CRDLOC
	JRST ASKCR1
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/CARD LOCATION (<CR> IF ONLY ONE IN DRAWING).
^/]
	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
	PUSHJ P,GETSLT
	CAIA
	CAIE C,12
	JRST [	PUSHJ P,INNERR
		JRST ASKCRD]
	MOVE T,LETTER
	HLLZM T,PARNAM		;USE THIS CELL
ASKCR1:	MOVEM P,ERRP
	MOVE D,[ANDCAM C,1(T)]	;CLEAR BITS
	PUSHJ P,STBITA		;IN BODIES AND POINTS
	SETZ D,			;D=0:NOTHING YES, D=1 PINS, D=2 BODIES
INUML1:	PUSHJ P,UMLIN
	MOVE T,1(B)
	CAMN T,[ASCIZ/END/]
	JRST INUML2
	CAMN T,[ASCII/BODIE/]
	JRST INUML3
	CAMN T,[ASCIZ/PINS/]
	JRST INUML4
INUML6:	HRRZ A,B
	ADD A,[POINT 7,1]
	MOVE T,[PUSHJ P,UREAD]
	MOVEM T,GTCHRX
	XCT URDTAB(D)
	JRST INUML5		;ERROR
	JRST INUML5		;CRLF ONLY (BLANK)
MD,<	CAIA			;LOC OK
	JRST INUML5		;BRS SEEN, LOSE
>;MD
	CAIE C,11
	JRST INUML5
	MOVE T,LETTER
	MOVEM T,NUMBER
	XCT URDTAB(D)
	JRST INUML5
	JRST INUML5
MD,<	CAIA
	JRST INUML5
>;MD
	JUMPN C,INUML5
	PUSH P,B
	XCT URDFND(D)
	POP P,B
	PUSHJ P,PUTFS
	JRST INUML1

INUML3:	HRRZ T,(B)
	JUMPE T,INUML6
	MOVE T,1(T)
	CAME T,[ASCIZ/S/]
	JRST INUML6
	PUSHJ P,PUTFS
	MOVEI D,2
	JRST INUML1

INUML4:	PUSHJ P,PUTFS
	MOVEI D,1
	JRST INUML1
                                                                                                                                                                                                                             ;		FIND PIN OR BODY AND SET NEW LOC
URDFND:	JFCL		;OH WELL, JUST IN CASE
	PUSHJ P,UFNPIN
	PUSHJ P,UFNBOD

UFNPIN:	SKIPN A,PONPNT
	POPJ P,
UFNPN1:	HLRZ C,(A)
	HRRZ C,1(C)
	MOVE T,1(C)
	TLNE T,CPIN
	TLNE T,1
	JRST UFNPN2
	HRRZ B,(C)
	MOVE TT,(B)
	XOR TT,PARNAM
	CAME TT,NUMBER
	JRST UFNPN2
	PUSH P,D
	MOVE D,C
	PUSHJ P,UBACK			;CHECK FOR WILD PIN BACKUP
	MOVE TT,LETTER
	HRRM TT,(B)
	MOVSI T,1
	IORM T,1(C)
	PUSHJ P,FIXEM		;FIX OFFSET IF NEEDED
	POP P,D
UFNPN2:	HRRZ A,(A)
	JUMPN A,UFNPN1
	POPJ P,

UFNBOD:	SKIPN A,DBODPN
	POPJ P,
UFNBD1:	HLRZ C,(A)
	HLRZ C,1(C)
	MOVE T,1(C)
	TLNE T,BTMP1
	JRST UFNBD2
	HRRZ B,(C)
	JUMPE B,UFNBD2
	HLRZ B,(B)
	MOVE TT,(B)
	XOR TT,PARNAM
	CAME TT,NUMBER
	JRST UFNBD2
	MOVE TT,LETTER
	HRRM TT,(B)
	TLO T,BTMP1
	MOVEM T,1(C)
UFNBD2:	HRRZ A,(A)
	JUMPN A,UFNBD1
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                             ;		SUBRS FOR READING UML FILE
INUML5:	OUTSTR[ASCIZ/FORMAT ERROR, /]
	OUTSTR @(D)[[ASCIZ/PINS OR BODIES NOT SELECTED /]
		[ASCIZ/PIN LOC /]
		[ASCIZ/BODY LOC /]]
	OUTSTR[ASCIZ/IN LINE:
/]
	SETZ TT,
	SKIPN TTT,B
	JRST INUMLY
INUMLZ:	MOVE T,1(TTT)
	OUTSTR T
	HRRZ TTT,(TTT)
	JUMPN TTT,INUMLZ
INUMLY:	OUTSTR[ASCIZ/
/]
	PUSHJ P,PUTFS
	JRST INUML1

UMLIN:	GETFS (B)
	SETZM (B)
	SETZM 1(B)
	MOVE T,B
	ADD T,[POINT 7,1]
UMLIN1:	PUSHJ P,UWDIN
	CAIE C,15
	CAIN C,14
	JRST UMLIN1
	CAIN C,12
	JRST UMLIN4
	CAIL C,"a"
	CAILE C,"z"
	SKIPA
	SUBI C,40
	CAIE C,11	;MAKE ANY CONTIGUOUS BLANK CHARS,
	CAIN C,40	;LOOK LIKE A SINGLE TAB
	JRST [	MOVEI C,11
		LDB TT,T
		CAIE TT,11
		JUMPN TT,.+1
		JRST UMLIN1]
	TLNN T,760000
	JRST UMLIN2
UMLIN3:	IDPB C,T
	JRST UMLIN1

UMLIN2:	GETFS (TT)
	SETZM (TT)
	SETZM 1(TT)
	HRRM TT,-1(T)
	HRR T,TT
	JRST UMLIN3

UMLIN4:	SKIPN 1(B)
	JRST UMLIN1
	SETZ C,
	LDB TT,T
	CAIN TT,11		;IF END OF LINE IS BLANK CHAR,
	DPB C,T			;THEN MAKE IT NULL
	POPJ P,

UWDIN:	SOSG IOHD+2
	IN DAT,
	JRST UWDIN1
	GETSTS DAT,C
	TLNE C,740000
	OUTSTR[ASCIZ/DISK ERROR
/]
	TLNE C,20000
	OUTSTR[ASCIZ/PREMATURE END OF FILE
/]
	MOVE P,ERRP
INUML2:	RELEASE DAT,
	TRO MCHG
	JRST PUTFS

UWDIN1:	ILDB C,IOHD+1
	JUMPE C,UWDIN
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;		READ LOCATION FROM STRING
URDTAB:	JFCL
	PUSHJ P,GTCONP
	PUSHJ P,GTSLTL

UREAD:	TLNN A,760000
	JRST [	TRNE A,-1
		HRR A,-1(A)
		TRNE A,-1
		JRST .+1
		SETZ C,
		POPJ P,]
	ILDB C,A
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ;INPUT SIGNAL NAME CHANGE FILE
ISIGCH:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SIGNAL NAME CHANGE (CHG) INPUT /]
	MOVSI T,EXTCHG
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVE E,PONPNT
	PUSHJ P,ACLRP
	SETZM FIND
	MOVSI C,17
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS
ISIGC1:	PUSHJ P,RSTRC
	JRST ISIGCF		;OK EOF, DONE
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGLE		;NULL, SKIP LINE
	CAIE TTT,11
	JRST ISIGLF
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
	POP P,B
	PUSHJ P,PUTFS
	PUSHJ P,RSTRC
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGLE		;NULL SIGNAL, LINE ERROR
	CAIE TTT,12
	JRST ISIGLF		;NOT EOL, LINE ERROR
	MOVEM B,DX1
	SKIPE H,PONPNT
	PUSHJ P,SIGCDO
	MOVE B,DX1
	PUSHJ P,PUTFS
	JRST ISIGC1

ISIGLF:	PUSHJ P,PUTFS
ISIGLE:	PUSHJ P,CHGSKP
	JRST ISIGCE
	OUTSTR[ASCIZ/ERROR IN INPUT LINE, SKIPPING LINE.
/]
	JRST ISIGC1

ISIGCE:	OUTSTR[ASCIZ/EOF WHERE NOT EXPECTED.
/]
ISIGCF:	RELEASE DAT,
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,.+2
	SETOM FIND
	SKIPN T,FNDNUM
	JRST [	OUTSTR[ASCIZ/NO/]
		JRST ISIGC2]
	PUSHJ P,DECOUT
ISIGC2:	OUTSTR[ASCIZ/ SIGNAL NAME/]
	MOVE T,FNDNUM
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/ CHANGED.
/]
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                 ;CHANGE FILE INPUT SUBRS
CHGSKP:	CAIN TTT,12
	JRST CPOPJ1
	PUSHJ P,ICHG
	POPJ P,
	JRST CHGSKP

ICHG:	SOSG IOHD+2
	IN DAT,
	JRST ICHG1
	GETSTS DAT,TTT
	TRNE TTT,740000
	OUTSTR[ASCIZ/INPUT IO ERROR.
/]
	POPJ P,			;ALWAYS GIVE EOF RETURN

ICHG1:	ILDB TTT,IOHD+1
	CAIN TTT,15
	JRST ICHG
	JUMPN TTT,CPOPJ1
	JRST ICHG

RSTRC:	PUSHJ P,ICHG
	POPJ P,
	CAIN TTT,11
	JRST RSTRC		;SKIP OVER TABS
	AOS (P)			;DIRECT RETURN IS FOR IMMEDIATE EOF
	CAIN TTT,12
	JRST CPOPJ1		;INDICATE NULL STRING
	GETFS(B)
	PUSH P,B
	ADD B,[POINT 7,0,34]
RSTRC1:	SETZM (B)
	SETZM 1(B)
RSTRC2:	IDPB TTT,B
	PUSHJ P,ICHG
	JRST RSTRCE
	CAIE TTT,11
	CAIN TTT,12
	JRST RSTRCF
	TLNE B,760000
	JRST RSTRC2
	PUSH P,TTT
	GETFS(TTT)
	HRRM TTT,-1(B)
	HRR B,TTT
	POP P,TTT
	JRST RSTRC1

RSTRCF:	POP P,B
	JRST CPOPJ2

RSTRCE:	POP P,B
	JRST PUTFS		;RETURN STRING AND INDICATE EOF
                                                                                                                                                                                                                                                                                                                                                                                                         ;INPUT SIGNAL NAME CHANGE FILE
ICPNCH:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/CONNECTOR PIN (CPN) INPUT /]
	MOVSI T,EXTCPN
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVE E,PONPNT
	PUSHJ P,ACLRP
	SETZM FIND
	MOVSI C,1		;MARK BIT
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR IT
ICPNC1:	PUSHJ P,RSTRC
	JRST ICPNCF		;OK EOF, DONE
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNLE		;NULL, SKIP LINE
	CAIE TTT,11
	JRST ICPNLF
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	MOVE T,[PUSHJ P,UREAD]
	MOVEM T,GTCHRX
	PUSHJ P,GTCONP
	JRST ICPNLF
	JRST ICPNLF
	CAIA			;LOC OK
	JRST INUML5		;BRS SEEN, LOSE
	JUMPN C,ICPNLF		;ERROR IF NOT EOS
	POP P,B
	PUSHJ P,PUTFS		;RETURN STRING
	PUSHJ P,RSTRC		;NOW GET SIGNAL NAME
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNLE		;NULL SIGNAL, LINE ERROR
	CAIE TTT,12
	JRST ICPNLF		;NOT EOL, LINE ERROR
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
	POP P,B
	PUSHJ P,PUTFS
	SKIPE H,PONPNT
	PUSHJ P,CPNDO		;DO THIS LINE
	JRST ICPNC1

ICPNLF:	PUSHJ P,PUTFS
ICPNLE:	PUSHJ P,CHGSKP
	JRST ICPNCE
	OUTSTR[ASCIZ/ERROR IN INPUT LINE, SKIPPING LINE.
/]
	JRST ICPNC1

ICPNCE:	OUTSTR[ASCIZ/EOF WHERE NOT EXPECTED.
/]
ICPNCF:	RELEASE DAT,
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,.+2
	SETOM FIND
	SKIPN T,FNDNUM
	JRST [	OUTSTR[ASCIZ/NO/]
		JRST ICPNC2]
	PUSHJ P,DECOUT
ICPNC2:	OUTSTR[ASCIZ/ CONNECTOR PIN/]
	MOVE T,FNDNUM
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/ SET.
/]
	POPJ P,
                                                                                                                           ;IMPLEMENT ONE CHANGE LINE
CPNDO:	HLRZ G,(H)
	HRRZ G,1(G)
	MOVE T,1(G)
	TLNE T,CPIN!1		;DON'T DO IF ALREADY CONNECTOR PIN, OR PEVIOUSLY LOOKED AT
	JRST CPNDO1
	HLRZ A,(G)
	JUMPE A,CPNDO1		;ALSO IF NO TEXT
	HRRZ A,(A)
	ADD A,[POINT 7,1]
	MOVEI B,SIGTAB
	PUSHJ P,SIGMAT		;COMPARE TO PREVIOUSLY READ STRING
	JRST CPNDO1		;NO MATCH
	JFCL			;EQUIVALENT IS CLOSE ENOUGH
	MOVE T,H		;GET PIN
	PUSH P,H
	MOVE H,[1,,CPNCHK]
	PUSHJ P,RECUR1		;SETUP WDOLST
	SKIPN WDOLST		;ANYTHING IN LIST
	JRST CPNDO2
	TLZ WFLAG
	PUSHJ P,RECCHK
	TLNE WFLAG
	JRST CPNDO2
	MOVE A,(P)
	PUSHJ P,SETLET		;PUT CONNECTOR PIN HERE
	POP P,H
	HLRZ TT,(H)
	HRRZ TT,1(TT)
	MOVSI T,FOUNDP
	IORM T,1(TT)
	AOSA FIND
CPNDO2:	POP P,H
CPNDO1:	HRRZ H,(H)
	JUMPN H,CPNDO
	POPJ P,

CPNCHK:	JFCL
	HLRZ T,(A)
	HRRZ T,1(T)
	HLL T,1(T)
	TLNN T,CPIN
	JRST JRECUR
	TLO WFLAG
	SKIPE B,WDOLST
	PUSHJ P,PUTFS
	SETZM WDOLST
	POPJ P,
>;MD
                                                                                                                                                                                                                                                                                                                                                              ;RDVER TABLES!
MD,<
%IV6:	ANDI TTT,3
	ANDI TTT,3
	ANDI TTT,3
REPEAT IOVER-2,<ANDI TTT,7>
;**RDVER

%IV7:	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNNEW0
	PUSHJ P,LNNEW
REPEAT IOVER-6,<PUSHJ P,LNNEWS>
;**RDVER

LNOLD:	LDB A,[POINT 6,TT,8]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 12,LETTER,11]
	HLRZ A,TT
	DPB A,[POINT 6,LETTER,23]
	PUSHJ P,WORDIN
	DPB TTT,[POINT 6,LETTER,29]
	HLRZ TTT,TTT
	DPB TTT,[POINT 6,LETTER,17]
	JRST LNNEWB

LNNEW0:	PUSHJ P,WORDIN
	LDB TT,[POINT 6,TTT,5]
	DPB TT,[POINT 4,TTT,3]
	LDB TT,[POINT 6,TTT,11]
	LSH TT,3
	SKIPE TT
	TRO TT,3
	DPB TT,[POINT 8,TTT,11]
	PUSHJ P,LNNEWT
	JRST LNNEWB

LNNEW:	PUSHJ P,LNNEWS
	JRST LNNEWB

LNNEWS:	PUSHJ P,WORDIN
LNNEWT:	MOVEM TTT,LETTER
	PUSHJ P,WORDIN
	MOVEM TTT,NUMBER
	POPJ P,
>;MD

LNNEWB:
MD,<	LDB TT,[POINT 5,LETTER,8]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 5,LETTER,8]
>;MD
	LDB TT,[POINT 6,LETTER,23]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 6,LETTER,23]
	POPJ P,

MPC,<
%IV8:	PUSHJ P,LNOLD0
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNNEW
	PUSHJ P,LNNEW
	PUSHJ P,LNNEWS
REPEAT IOVER-7,<HLRZM TT,LETTER		;STORE LOC, NO MORE OFFSET>
;**RDVER

LNOLD0:	TRNN TT,400000		;VERY OLD VERSION?
	JRST LNOLD		;NO, GO TO LNOLD
	HLRZ TT,TT
	DPB TT,[POINT 6,LETTER,23]
	PUSHJ P,WORDIN
	DPB TT,[POINT 6,LETTER,29]
	JRST LNNEWB

LNOLD:	LSH TT,-9
	DPB TT,[POINT 6,LETTER,23]
	LSH TT,-9
	DPB TT,[POINT 6,LETTER,29]
	JRST LNNEWB

LNNEW:	PUSHJ P,LNNEWS
	JRST LNNEWB

LNNEWS:	HLRZM TT,LETTER
	PUSHJ P,WORDIN		;GET X,Y OFFSET
	MOVEM TTT,NUMBER
	POPJ P,
>;MPC

MD,<
%IV10:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3D>
;**RDVER

RDV3D:	PUSHJ P,FFNDID
	JRST NNDOWN
	JRST OLDVRD

%IV11:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3U>
;**RDVER

RDV3U:	PUSHJ P,FFNDID
	JRST NNUP
	JRST OLDVRU

%IV12:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3L>
;**RDVER

RDV3L:	PUSHJ P,FFNDID
	JRST NNLEFT
	JRST OLDVRL

%IV13:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3R>
;**RDVER

RDV3R:	PUSHJ P,FFNDID
	JRST NNRIGHT
	JRST OLDVRR
>;MD

%IV14:		JFCL		;DON'T CHANGE OLD PIN #'S
		JFCL
		JFCL
MPC,<		PUSHJ P,PADPIN
		PUSHJ P,PADPIN
		PUSHJ P,PADPIN
>;MPC
REPEAT IOVER-2,<	PUSHJ P,GPADPN	>
;**RDVER

MPC,<
PADPIN:	TLNE TT,FEEDTH	;PINS WERE DEFAULTED BY BPYES
	AOS 1(C)	;TYPE 1 PAD FOR FEEDTHROUGHS
	TLNE TT,2000	;OLD UNPADDED FEEDTHROUGH BIT!
	HLLZS 1(C)	;IN WHICH CASE 0
	JRST WORDIN
;	POPJ P,
>;MPC

GPADPN:
MPC,<	TLNE TT,ISPIN		;IS IT A HOLE?
	TLNN M,TYPNLY		;AND SPECIAL INPUT MODE
	JRST NPDCNG		;NO
	TRNN TTT,-1		;PAD TYPE ALREADY?
	HRRI TTT,1		;NO PAD IT
NPDCNG:	HLLI TTT,
	CAMLE TTT,MXPADN
	MOVEM TTT,MXPADN
>;MPC
	HRRM TTT,1(C)		;STO PIN OR PAD NUMBER
	JRST WORDIN

MD,<
%IV17:	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD0
	PUSHJ P,LNNEW1
REPEAT IOVER-6,<PUSHJ P,LNNWS1>
;**RDVER

LNOLD1:	DPB TTT,[POINT 6,(T),23]
	LDB A,[POINT 6,TTT,26]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 12,(T),11]
	HLRZ TTT,TTT
	ROT TTT,-1
	ADDI TTT,1
	DPB TTT,[POINT 6,(T),35]	;USE THIS AS NUM
	ROT TTT,1
	ANDI TTT,1
	ADDI TTT,1
	DPB TTT,[POINT 6,(T),29]	;AND THIS AS LET
	PUSHJ P,WORDIN
	HLRZ TTT,TTT
	DPB TTT,[POINT 6,(T),17]
	SETZM 1(T)
	JRST LNNEWC

LNOLD0:	LDB A,[POINT 6,TTT,5]
	DPB A,[POINT 4,TTT,3]
	LDB A,[POINT 6,TTT,11]
	LDB TT,[POINT 6,TTT,23]		;THIS IS TO CATCH POOR LOSERS
	JUMPE TT,[DPB A,[POINT 24,TTT,23]
		JRST LNNEW1]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 8,TTT,11]
LNNEW1:	PUSHJ P,LNNWS1
	JRST LNNEWC

LNNWS1:	MOVEM TTT,(T)
	PUSHJ P,WORDIN
	MOVEM TTT,1(T)
	POPJ P,
>;MD
LNNEWC:	LDB TT,[POINT 6,(T),29]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 6,(T),29]
MD,<	LDB TT,[POINT 5,(T),8]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 5,(T),8]
>;MD
	LDB TT,[POINT 6,(T),23]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 6,(T),23]
	POPJ P,

%IV18:	CAIN TTT,400000		;DONE?
REPEAT IOVER,<JUMPN TTT,RDV3S>
;**RDVER

RDV3S:
MPC,<	PUSHJ P,FFNDID
	CAIA
	JRST OLDV11		;FOUND IT
	FSWITCH
>;MPC
	PUSHJ P,FFNDID		;TRY THIS SIDE!
	JRST RDSPNT		;LOSE
	JRST OLDV11

MPC,<
%IV20:	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO0
	PUSHJ P,CLOCOS
REPEAT IOVER-6,<MOVEM TTT,CRDLOC>
;**RDVER

CLOCO:	DPB TTT,[POINT 6,CRDLOC,17]	;NUMBER
	HLRZ TTT,TTT
	ANDI TTT,77
	LSH TTT,3
	SKIPE TTT
	TRO TTT,3
	DPB TTT,[POINT 12,CRDLOC,11]
	JRST CLOCOT

CLOCO0:	MOVEM TTT,CRDLOC
	LDB TTT,[POINT 6,CRDLOC,5]
	DPB TTT,[POINT 4,CRDLOC,3]
	LDB TTT,[POINT 6,CRDLOC,11]
	LSH TTT,3
	SKIPE TTT
	TRO TTT,3
	DPB TTT,[POINT 8,CRDLOC,11]
	JRST CLOCOT

CLOCOS:	MOVEM TTT,CRDLOC
CLOCOT:	LDB TTT,[POINT 5,CRDLOC,8]
	MOVE TTT,L2N-1(TTT)
	DPB TTT,[POINT 5,CRDLOC,8]
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            COMMENT    VALID 00013 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(IOSUB,4)
C00011 00003	VIROR DIRECTORY STRING TO PPN CONVERTER
C00014 00004	DSKIN
C00018 00005	DKSOUT
C00021 00006	PC CARD
C00025 00007	MORE PC CARD
C00029 00008	THERE EXISTS CHECK
C00031 00009	FIND THIS, THAT, AND THE OTHER THING
C00035 00010	SOME OUTPUT PRINTERS
C00041 00011	MORE OUTPUT ROUTINES
C00044 00012	DECOUT:	SKIPL T
C00045 00013	
C00046 ENDMK
C;
                                                                                                                                                                               VERSION(IOSUB,4)
;FILENAME SCANNER, ENTER WITH DEFAULT EXTENSION IN T

;CHANGE REMEMBERED NAME
CENAME:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW REMEMBERED /]
	SETZ T,
	PUSHJ P,SETNAM
	SETZM FILNAM		;CLEAR IF CR ALONE
	ENTPPN			;GET SOME PPN
	MOVE T,FILNAM
	MOVEM T,LSTNAM
	MOVE T,FILPPN
	MOVEM T,LSTPPN
	JRST FILEUP

ZENAME:	SETZM LSTNAM
	POPJ P,

SETWRT:	MOVEM T,FILEXT
	MOVE T,LSTPPN
	MOVEM T,FILPPN
	JRST SETLS1

SETLST:
NODEC,<	SETZ TT,
	DSKPPN TT,
	MOVEM TT,FILPPN
>;NODEC
DEC,<	SETZM FILPPN	>	;WRITE ON CURRENT AREA
	MOVEM T,FILEXT
SETLS1:	SKIPN T,LSTNAM
	POPJ P,
	MOVEM T,FILNAM
	MOVSI T,(<BYTE(9)DEFPRO>)
	MOVEM T,FILDAT
	SETOM THEREXISTS
	JRST CPOPJ1

SETNAM:	MOVEM T,SAVEXT
NAMCON:	MOVE T,SAVEXT
	MOVEM T,FILEXT
	SETZM THEREXISTS
	MOVSI T,(<BYTE(9)DEFPRO>)
	MOVEM T,FILDAT
	SETZ T,			;CLEAR THIS WORD
NODEC,<	DSKPPN T,		;HIS OWN PPN
	MOVEM T,FILPPN
>;NODEC
DEC,<	SETZM FILPPN	>
	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ/FILENAME?/]
	PUSHJ P,GETNAM		;SCAN FILENAME
	CAIN C,12
	JUMPE T,CPOPJ		;LET HIM OUT IF HE TYPES NOTHING
VIROS,<
	SETZM VSTBUF
	CAIE C,74
	JRST NOVDIR
	JUMPN T,NOVDIR
	PUSHJ P,VSTPPN		;CONVERT STRING TO PPN
	JRST ILLNAM
	MOVEM T,FILPPN
	PUSHJ P,GETNAM		;NOW GET FILENAME
NOVDIR:
>;VIROS
	JUMPN T,NOLSTG
	CAIE C,TEXIST		;DOES HE WANT SAME AS INPUT?
	JRST NOLSTG
	PUSHJ P,GETNAM
	JUMPN T,ILLNAM
	MOVE T,LSTPPN
	MOVEM T,FILPPN
	SKIPN T,LSTNAM		;YES, GET IT(WILL LOSE IF 0)
	JRST [	PUSHJ P,SCARF
		OUTSTR[ASCIZ/NO REMEBERED NAME!
/]
		JRST NAMCON]
	SETOM THEREXISTS
NOLSTG:
NOITS,<
	MOVEM T,FILNAM		;SAVE FILENAME
	CAIN C,"["		;ANY EXTENSION?
	JRST NOEXT		;NO
	CAIN C,12
	JRST NOEXT		;NO
	CAIE C,"."
	JRST [	ILLNAM:	PUSHJ P,INNERR
			JRST NAMCON]
	PUSHJ P,GETWRD		;SCAN EXTENSION
	HLLZM T,FILEXT		;SAVE IT.
	SETZM THEREXISTS	;RE-ENABLE EXIST CHECK
NOEXT:	CAIN C,12		;HERE TO SCAN PPN
	JRST [	SETOM NOPPNF	;HE DIDN'T TYPE A PPN OR HE TYPED THEREEXISTS
		JRST CPOPJ1]	;LEAVE NOW
	SETZM THEREXISTS	;RE-ENABLE EXIST CHECK
VIROS,<	SKIPN VSTBUF	>	;DID WE USE <DIRECTORY> FORMAT?
	CAIE C,"["
	JRST ILLNAM		;MUST BE [
NOCMU,<
	PUSHJ P,GETPPN
	JRST ILLNAM
	HRLM T,FILPPN		;AND SAVE
	CAIE C,","		;BETTER BE COMMA
	JRST NOPRG
	PUSHJ P,GETPPN
	JRST ILLNAM
	HRRM T,FILPPN		;AND SAVE
>;NOCMU
CMU,<	SETZM PPNBUF		;CLEAR OUT A BUFFER FOR THE PPN
	SETZM PPNBUF+1
	SETZM PPNBUF+2
	MOVE A,[POINT 7,PPNBUF]
	MOVEI TTT,=13		;13 CHARACTERS AT MOST!
CMUPP1:	PUSHJ P,GETLIN		;GET A CHAR
	CAIL C,"0"		;0-9 ARE LEGAL IN PPN'S
	CAILE C,"9"
	CAIN C,","		;SO IS COMMA
	JRST CMUPP2		;SO GO STORE IT
	CAIL C,"a"		;CONVERT LOWER CASE TO UPPER CASE
	CAILE C,"z"
	JRST .+2
	SUBI C,40		;CONVERT IT
	CAIL C,"A"		;IS IT A LETTER
	CAILE C,"Z"
	JRST CMUPP3		;NO, MUST BE THE END
CMUPP2:	IDPB C,A
	SOJG TTT,CMUPP1		;AND GO GET ANOTHER CHAR UNLES WE HAVE 13
	PUSHJ P,GETLIN		;IN WHICH CASE WE GET THE "]" (WE HOPE!)
CMUPP3:	MOVE A,[XWD FILPPN,PPNBUF]
	CMUDEC A,		;CONVERT THE PPN TO DEC FORMAT
	JRST ILLNAM		;WHOOPS, BAD PPN
>;CMU
NOPRG:	SETZ T,
	CAIN C,"]"		;BETTER END WITH THIS
	PUSHJ P,GETNAM		;MAKE SURE HE DIDN'T TYPE TO MUCH
	JUMPN T,ILLNAM		;LOSE IF HE DID
	CAIE C,12
	JRST ILLNAM		;DIDN'T END WITH LF
	SETZM NOPPNF		;HE TYPED A PPN!
	JRST CPOPJ1
>;NOITS
ITS,<
	SETOM NOPPNF
	CAIE C,";"
	JRST NOLST1
	SETZM NOPPNF
	MOVEM T,FILPPN
	PUSHJ P,GETNAM
	JUMPE T,CPOPJ	;STILL NOT REASONABLE
NOLST1:	CAIE C,40
	CAIN C,12
	SKIPA
	JRST [	ILLNAM:	PUSHJ P,INNERR
			JRST NAMCON]
	MOVEM T,FILNAM
	CAIN C,12
	JRST CPOPJ1	;DONE
	PUSHJ P,GETNAM	;GET SECOND FILE NAME
	CAIE C,12
	JRST ILLNAM	;EXTRA GARBAGE AT END
	JUMPE T,ILLNAM
	MOVEM T,FILEXT
	JRST CPOPJ1
>;ITS

DEC,<
GETPPN:	PUSHJ P,GETOCT
	JUMPE T,CPOPJ
	CAIG T,777777
	AOS (P)
	POPJ P,

GETOCT:	SETZ T,
GETNU1:	PUSHJ P,GETLIN
	CAIE C,15
	CAIN C,40
	JRST GETNU1
	CAIL C,"0"
	CAILE C,"7"
	POPJ P,
	LSH T,3
	ADDI T,-"0"(C)
	JRST GETNU1
>;DEC

STANFO,<
GETPPN:	PUSHJ P,GETWRD
	JUMPE T,CPOPJ
	TRNE T,-1
	POPJ P,
	HLRZ T,T		;ONLY 3 LETTERS
	TRNN T,7777
	LSH T,-14
	TRNN T,77
	LSH T,-6
	JRST CPOPJ1
>;STANFO
	
NOITS,<GETNAM:>
GETWRD:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
CHRGET:	PUSHJ P,GETLIN		;READ A CHAR
ISCHRX:	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST CHRGET
	CAIL C,"0"		;NUMBERS ARE LEGAL
	CAILE C,"9"
	CAIA
	JRST CHROK
	CAILE C,"z"
	POPJ P,			;BREAK CHAR.
	CAIL C,"a"
	SUBI C,40		;CHANGE LOWER CASE TO UPPER
	CAIL C,"A"		;NOW ONLY UPPER CASE LETTERS ARE LEGAL
	CAILE C,"Z"
	POPJ P,			;BREAK
CHROK:	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST CHRGET

;ITS NAME SCANNER
ITS,<
GETNAM:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
GETNM1:	PUSHJ P,GETLIN		;READ A CHAR
	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST GETNM1
	SKIPA
GETNM2:	PUSHJ P,GETLIN
	CAIN C,15
	JRST GETNM2
	CAIL C,"a"
	CAILE C,"z"
	CAIA
	SUBI C,40		;LOWERCASE
	CAILE C,40		;BREAK ON SPACE
	CAILE C,"_"
	POPJ P,			;NOT SIXBIT CHARACTER
	CAIE C,";"
	CAIN C,":"
	POPJ P,
	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST GETNM2
>;ITS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ;VIROR DIRECTORY STRING TO PPN CONVERTER

VIROS,<
VSTPPN:	MOVE T,[POINT 7,VSTBUF]
VSTPP1:	PUSHJ P,GETLIN
	CAIL C,"A"+40
	CAILE C,"Z"+40
	CAIA
	SUBI C,40
	CAIN C,240
	JRST RECOGN
	CAIN C,76
	JRST EXACTM
	CAIE C,ALTMOD
	CAIN C,12
	POPJ P,
	CAMN T,[VSTEND]
	POPJ P,
	IDPB C,T
	JRST VSTPP1

EXACTM:	SETZ TT,
	IDPB TT,T
	PUSH P,1
	PUSH P,2
	SETZ 1,
	HRROI 2,VSTBUF
	STDIR
	JRST VSTPPX
	JRST VSTPPX
	POP P,2
	POP P,1
	JRST VSTWIN

RECOGN:	MOVEI C,ALTMOD		;IF ERROR, WE PRINT, NOT INNERR
	SETZ TT,
	MOVE TTT,T
	IDPB TT,TTT
	SETOM TYPFLG
	TLNE M,DSKACT!MACACT
	SETZM TYPFLG
	PUSH P,1
	PUSH P,2
	PUSH P,T
	MOVNI 1,1
	HRROI 2,VSTBUF
	STDIR
	JRST VSTPPY
	JRST VSTPPW
	POP P,1
	SKIPN TYPFLG
	JRST VSTPPB
	PUSH P,3
VSTPPZ:	CAMN 1,2	;DONE YET?
	JRST VSTPPA
	ILDB 3,1
	OUTCHR 3
	JRST VSTPPZ

VSTPPA:	POP P,3
	OUTCHR[76]
VSTPPB:	POP P,2
	POP P,1
	JRST VSTWIN

VSTPPW:	POP P,(P)
	POP P,2
	POP P,1
	SKIPE TYPFLG
	OUTCHR[7]
	JRST VSTPP1

VSTPPY:	POP P,(P)
	SKIPE TYPFLG
	OUTSTR[ASCIZ/? /]
VSTPPX:	POP P,2
	POP P,1
	POPJ P,

VSTWIN:	MOVE T,[POINT 7,VSTBUF]
	MOVEM T,STPTR
	MOVE T,[3,,STPPN]
	SETZM USRPPN
	COMPT. T,
	JRST [	OUTSTR[ASCIZ/COMPT. UUO FAILED ON PREVIOUSLY RECOGNIZED DIRECTORY NAME.
/]
		POPJ P,]
	MOVE T,USRPPN
	JRST CPOPJ1
>;VIROS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;DSKIN
DSKIN:	PUSHJ P,GETDSK
	POPJ P,
	POPJ P,

DSKINH:	PUSHJ P,GETDSK
	POPJ P,
	JRST IBREAK			;NOW TURN IT OFF

GETDSK:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/DISK INPUT /]
	MOVSI T,EXTDSK
	PUSHJ P,SETNAM
	POPJ P,
	INIT IDSK,0
	'DSK   '
	DSKHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!!!
/]
	CDSK:
	NOLAY,<TLZ M,DSKACT!DSKFLG>
	LAY,<MOVSI T,DSKACT!DSKFLG
		TDZ M,T
		ANDCAM T,LAYM
	>;LAY
	SETOM DSKEND
		JRST DSPSET]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP IDSK,FILNAM
	JRST [	PUSHJ P,LOOKER
		RELEASE IDSK,
		JRST CDSK]
DEC,<	JSR IDSK,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,DSKBUF
	EXCH T,.JBFF
	INBUF IDSK,1
	MOVEM T,.JBFF
NOLAY,<TLO M,DSKACT!DSKFLG>
LAY,<MOVSI T,DSKACT!DSKFLG
	TDO M,T
	IORM T,LAYM
>;LAY
	SETZM DSKEND
	SETZM BRKCHR
	AOS (P)
	JRST DSPSET





DSKCHR:	SOSG DSKHD+2
	IN IDSK,
	CAIA
	JRST DSKREL
	IBP DSKHD+1
	MOVE C,@DSKHD+1
	TRNE C,1
	JRST [	MOVNI C,5
		ADDM C,DSKHD+2
		AOS DSKHD+1
		JRST DSKCHR]
	LDB C,DSKHD+1
	JUMPE C,DSKCHR
	CAIE C,15
	CAIN C,14
	JRST DSKCHR
IFN ALTMOD-ALTCHR,<
NODEC,<	CAIN C,ALTCHR
	MOVEI C,ALTMOD
>;NODEC
>;IFN ALTMOD-ALTCHR
	CAME C,BRKCHR
	JRST CPOPJ1
MAKBRK:
NOLAY,<TLZ M,DSKACT>		;BREAK INPUT
LAY,<MOVSI C,DSKACT
	TDZ M,C
	ANDCAM C,LAYM
>;LAY
	MOVEI C,200+":"		;GENERATE END OF ;T
	JRST CPOPJ1

IBREAK:		;ENTER HERE TO GENERATE INPUT BREAK FOR ERROR
NOLAY,<TLZ M,DSKACT>
LAY,<MOVSI C,DSKACT
	TDZ M,C
	ANDCAM C,LAYM
>;LAY
	TLNE M,MACACT		;STILL IN MACRO?
	POPJ P,			;YES, SKIP PRINTOUT
	OUTSTR[ASCIZ/DISK INPUT BREAK!
/]
	JRST PLEVEL

DSKREL:	STATO IDSK,1B22
	JRST EFLUSH
	PUSHJ P,IFLUSH		;FLUSH INPUT FILE IN NORMAL MANNER
	JRST MAKBRK		;MAKE A <CTRL>:

EFLUSH:	OUTSTR[ASCIZ/DISK INPUT FILE ERROR FINISH!!
/]
IFLUSH:		;ENTER HERE JUST TO FLUSH DSKINPUT
NOLAY,<TLZ M,DSKACT!DSKFLG>
LAY,<MOVSI C,DSKACT!DSKFLG
	TDZ M,C
	ANDCAM C,LAYM
>;LAY
	SETOM DSKEND
	OUTSTR[ASCIZ/END OF DISK INPUT FILE!!
/]
	RELEASE IDSK,
PLEVEL:	PUSHJ P,DSPSET
	PUSH P,T
	HRRZ T,MACPNT
	SUBI T,MACPDL-1
	JUMPE T,NOLEVL
	IDIVI T,5
	OUTSTR[ASCIZ/YOUR ARE NOW AT MACRO LEVEL /]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/.
/]
NOLEVL:	POP P,T
	JRST ENDDSP
                                                                                                                                                                                                                                                                                                                                                     ;DKSOUT
PUTDSK:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/DISK OUTPUT /]
	MOVSI T,EXTDSK
	PUSHJ P,SETNAM
	POPJ P,
	ENTPPN
DEC,<	RELEASE ODSK,	>
	INIT ODSK,0
	'DSK   '
	DSKOHD,,0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
	DSKCLR:	SETZM DSKOPN
		RELEASE ODSK,
NODEC,<		POPJ P,	>
DEC,<		JRST LOGINI>
				]
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER ODSK,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED!
/]
		JRST DSKCLR]
	OUTSTR[ASCIZ/
/]
	MOVEI T,DSKOBF
	EXCH T,.JBFF
	OUTBUF ODSK,1
	MOVEM T,.JBFF
	SETOM DSKOPN
	POPJ P,

DSKOCHR:
	PUSH P,C	;SAVE CHAR.
DEC,<	CAIN C,ALTMOD
	TRO C,600	;MAKE SURE WE GET 4 ALTMODES
>;DEC
	LSH C,-7
	ANDI C,3
	JUMPE C,NOCM
NODEC,<	MOVE C,BITTAB-1(C)
	PUSHJ P,DCHR1
>;NODEC
DEC,<	MOVN C,C
	JRST .+1+3(C)
	PUSHJ P,PUTALT
	PUSHJ P,PUTALT
	PUSHJ P,PUTALT
>;DEC
NOCM:	MOVE C,(P)
	PUSHJ P,DCHR1
	POP P,C
	POPJ P,

NODEC,<
BITTAB:	CTRL
	META
	CTLMTA
>;NODEC

DEC,<
PUTALT:	MOVEI C,ALTMOD
>;DEC
DCHR1:	ANDI C,177	;ONLY THIS
IFN ALTMOD-ALTCHR,<
NODEC,<	CAIN C,ALTMOD	;ALTMODE?
	MOVEI C,ALTCHR	;YES
>;NODEC
>;IFN ALTMOD-ALTCHR
DEC,<	CAIN C,10
	MOVEI C,177
>;DEC
	CAIE C,12
	JRST DCHR2
	MOVEI C,15
	PUSHJ P,DCHR2
	MOVEI C,12
DCHR2:	SKIPN DSKOPN	;INSIDE ERROR MAYBE?
	POPJ P,		;YES
	SOSG DSKOHD+2
	OUT ODSK,
	JRST DCHR4	;ALL OK, DEPOSIT CHAR
	OUTSTR[ASCIZ/DISK OUTPUT ERROR!
/]
	JRST DSKCLR
DCHR4:	IDPB C,DSKOHD+1
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;PC CARD
MPC,<
DOCARD:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PC CARD (CRD) /]
	MOVSI T,EXTCRD
	PUSHJ P,SETNAM
	POPJ P,
	PUSHJ P,CRDREL
	MOVE T,FILNAM
	MOVEM T,CRDNAM
	MOVE T,FILEXT
	MOVEM T,CRDEXT
DEC,<	SKIPN T,FILPPN
	MOVE T,LIBPPN
>;DEC
NODEC,<	SKIPE NOPPNF		;SKIP IF PPN TYPED
	SKIPE THEREXISTS	;NO PPN TYPED--FALL THRU IF THEREXISTS WAS TYPED
	SKIPA T,FILPPN		;PPN OR THEREXSISTS TYPED-USE PPN FROM SETNAM
	MOVE T,LIBPPN		;NO " - USE LIBRARY
>;NODEC
	MOVEM T,CRDPPN
	PUSHJ P,GETCRD
	JRST [	PUSHJ P,ZCARD
		JRST PERRET]
	TRO MCHG
	TLO M,CRDISP
	POPJ P,

ZCARD:	PUSHJ P,CRDREL
	TLZ M,CRDISP
	TRO MCHG
	POPJ P,

GETCRD:	MOVEM P,PERRSAV
	INIT ICARD,10
	'DSK   '
	CARDHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!!
/]
		POPJ P,]
CRDRD:	OUTSTR[ASCIZ/READING CARD FROM /]
	MOVEI A,CRDNAM
	JSR FPRINT
	MOVE T,CRDPPN
	LOOKUP ICARD,CRDNAM
	JRST [	PUSHJ P,LOOKER
		TLNN M,DSKACT!MACACT
		OUTSTR[ASCIZ/TRY ANOTHER TAB /]
		PUSHJ P,GCRDNM		;GET FILE NAME
		JRST [	RELEASE ICARD,
			POPJ P,]
		SETZM CRDDAT
		JRST CRDRD]
DEC,<	JSR ICARD,LOOKCK	>
NODEC,<	MOVEM T,CRDPPN	>
	OUTSTR[ASCIZ/
/]
	MOVEI TT,CRDBUF
	EXCH TT,.JBFF
	INBUF ICARD,2
	MOVEM TT,.JBFF
	PUSHJ P,CARDIN
	CAIE TTT,CRDVER		;CORRECT VERSION OF FILE?
	JRST [	OUTSTR[ASCIZ/IMPROPER VERSION NUMBER FOR PC CARD DEFINITION FILE.
/]
		POPJ P,]
	PUSHJ P,CRDLP2		;READ CARD OUTLINE INTO CRDLST
	PUSH P,SID
	JUMPL SID,CRDLP5
	SWITCH
CRDLP5:	PUSHJ P,CRDLPP
CRDLP6:	SWITCH			;GET TO BACK SIDE
	PUSHJ P,CRDLPP
	SWITCH			;BACK TO FRONT SIDE
	PUSHJ P,RSHORT		;READ SHORTING BARS
	SWITCH			;AND BACK SIDE
	PUSHJ P,RSHORT
	POP P,T
	EQV T,SID
	JUMPL T,CRDLP7
	SWITCH
CRDLP7:	MOVSS CRDLST
	PUSHJ P,CRDLP2		;PUT TARGET LOCS IN LEFT HALF OF CRDLST
	MOVSS CRDLST
	RELEASE ICARD,
	JRST CPOPJ1

GCRDNM:	MOVSI T,EXTCRD
	PUSHJ P,SETNAM
	POPJ P,
	MOVE T,FILNAM
	MOVEM T,CRDNAM
	MOVE T,FILEXT
	MOVEM T,CRDEXT
	JRST CPOPJ1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ;MORE PC CARD
RSHORT:	SKIPA G,[BARLST]
CRDLP2:	MOVEI G,CRDLST
CRDLP3:	PUSHJ P,CARDIN
	CAIE TTT,400000
	CAMN TTT,[(400000)]	;END OF BOARDER?
	POPJ P,			;YES
	GETFS(B)
	HRRM B,(G)
	MOVE G,B
	MOVEM TTT,1(B)
	SETZM (B)		;CLEAR LINK
	JRST CRDLP3

CRDLPP:	PUSHJ P,CARDIN
	CAMN TTT,[(400000)]
	POPJ P,
	TDZ TTT,[(1)1]
	PUSHJ P,FIND.P		;ATTEMPT TO ATTACH TO EXISTING POINT IF ANY
	MOVE TT,1(T)
	TLNE TT,ISPIN!FEEDTH!CPIN
	PUSHJ P,[MOVE T,1(D)
		JRST PNTPUT]
	PUSHJ P,CARDIN
	TDZ TTT,[(1)1]
	GETFS (TT)
	MOVEM TTT,1(TT)
	HRRM TT,(T)
	MOVSI TTT,CPIN
	IORM TTT,1(T)
	PUSHJ P,CARDIN
	MOVEM TTT,(TT)
	MOVE B,D
	PUSHJ P,REMPNT			;CPIN'S CAN'T BE IN ANY SETS!
	JRST CRDLPP

CRDREL:SETZM CRDNAM	;CLEAR CARD NAME
	HRRZ B,CRDLST
	PUSHJ P,PUTFS
	HLRZ B,CRDLST
	PUSHJ P,PUTFS
	SETZM CRDLST
	HRRZ B,BARLST
	PUSHJ P,PUTFS
	HLRZ B,BARLST
	PUSHJ P,PUTFS
	SETZM BARLST
	MOVEI B,PONPNT
	PUSHJ P,FNGDEL
	MOVEI B,PONPN2
	JRST FNGDEL

FNGDL3:	PUSH P,A		;SAVE LAST POINTER
	HLRZ T,(B)
	HRRZ TT,1(T)
	MOVE A,1(TT)
	TLNN A,CPIN		;CONNECTOR PIN?
	JRST NOCDL1		;NO, SKIP
	TRNE A,-1		;ANY PAD?
	JRST NOCDEL
	HLRZ T,1(T)		;NEIGHBOR POINTER
	JUMPE T,FNGDL2		;OK IF NO NEIGHBORS
FNGDL1:	SKIPE 1(T)		;ANY?
	JRST NOCDEL		;YES, LEAVE HIM
	SKIPN T,(T)		;NEIGHBOR OR NEXT POINTER
	JRST FNGDL2		;NO, PROCEDE
	TLNN T,-1		;NEIGHBOR?
	JRST FNGDL1		;NO, JUST POINTER
	JRST NOCDEL

FNGDL2:	HLRZ T,(TT)		;TEXT POINTER
	JUMPN T,NOCDEL		;YES, NO DELETY
	TRO TFLG		;DELETE PINS OK!
	MOVE A,(P)		;SETUP LAST POINTER
	PUSHJ P,DELPNT
	POP P,B
	JRST FNGDEL

NOCDL1:	POP P,B
	HRRZ B,(B)
FNGDEL:	MOVE A,B
	HRRZ B,(B)
	JUMPN B,FNGDL3
	TRZ TFLG		;NO DELETY PINS NO MORE
	POPJ P,

NOCDEL:	MOVSI T,CPIN		;TURN OFF CPIN
	ANDCAM T,1(TT)		;PUT BACK WITHOUT POINTER TO END BLOCK
	HRRZ A,(TT)		;GET POINTER TO END BLOCK
	HLLZS (TT)		;THEN CLEAR IT
	FSTRET (A)		;AND GIVE BACK BLOCK
	JRST NOCDL1

CARDIN:	SOSG CARDHD+2
	IN ICARD,
	CAIA
	JRST [	OUTSTR[ASCIZ/INPUT ERROR ON CARD!
/]
		MOVE P,PERRSAV
		JRST ZCARD]
	ILDB TTT,CARDHD+1
	POPJ P,
>;MPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ;THERE EXISTS CHECK
EXIST:	PUSH P,FILEXT
	PUSH P,FILPPN
	LOOKUP DAT,FILNAM
	SKIPA T,FILEXT
	SETO T,
	CLOSE DAT,	;GODDAMN BAG-BITING MOTHER-FUCKING CRETINOUS SYSTEM
	POP P,FILPPN
	POP P,FILEXT
	MOVSI TT,777000		;MASK OUT ALL BUT PROTECTION
	ANDM TT,FILDAT
	HRRES T
	JUMPE T,CPOPJ1		;DOESN'T EXIST
	JUMPL T,ITDOES
	HRRM T,FILEXT		;PUT HERE FOR PRINT
	OUTSTR[ASCIZ/SAFETY LOOKUP OF /]
	MOVEI A,FILNAM
	JSR FPRINT
	PUSHJ P,LOOKER
	OUTSTR[ASCIZ/WRITE ANYWAY?/]
	INCHRW C
	CAIN C,15
	INCHRW C
	JRST ITDONT

ITDOES:	SKIPE THEREXISTS
	JRST CPOPJ1
DEC,<	PUSHJ P,CHKPPN		;REALLY SAME PPN?
	JRST CPOPJ1		;NO, TAKE NOT FOUND RETURN
>;DEC
	TLNN M,DSKACT!MACACT
	OUTSTR [ASCIZ/FILE ALREADY EXISTS; REPLACE IT?/]
	PUSHJ P,GETCHR
ITDONT:	OUTSTR [ASCIZ/
/]
	CAIE C,"Y"
	CAIN C,"y"
	AOSA (P)
	RELEASE DAT,
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                          ;FIND THIS, THAT, AND THE OTHER THING
FFNDID:	TLNE TTT,-1		;PIN?
	JRST FFNDPID		;YES
	ADD TTT,OLDPID		;ADD OFFSET
	MOVE TT,TTT
	ANDI TT,LHASHP-1
	HRRZ D,@PHASHP		;LOOK IN HASH BUCKET
	JUMPN D,FNDID1
	POPJ P,

FNDID:	TLNE TTT,-1		;PIN?
	JRST FNDPID		;YES
	ADD TTT,OLDPID		;ADD OFFSET
	SKIPN D,PONPNT
	POPJ P,
FNDID1:	HLRZ TT,(D)
	HRRZ T,(TT)
	CAIE T,(TTT)
	JRST FNDID2
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	TLNN TT,ISPIN		;IF IS PIN, NO MATCH
	JRST [	AOS (P)
		JRST FP2]	;PICK VARIABLES
FNDID2:	HRRZ D,(D)
	JUMPN D,FNDID1
	POPJ P,

FFNDPI:	ADD TTT,OLDBID
	HLRZ TT,TTT
	PUSH P,B
	PUSHJ P,FFNDBID
	JRST FBLOS
	JRST FNDBI2

FNDPID:	ADD TTT,OLDBID
	HLRZ TT,TTT
	PUSH P,B
	PUSHJ P,FNDBID
	JRST FBLOS
FNDBI2:	HLRZ D,(B)
	HRRZ D,(D)
	JUMPE D,FBLOS
FNDB1:	HLRZ C,(D)
	HRRZ T,1(C)
MPC,<	MOVE TTT,1(T)
	EQV TTT,SID
	JUMPGE TTT,NOTPID	;SKIP IF WRONG SIDE
>;MPC
	HRRZ T,(T)
	HLRZ T,(T)
MD,<	HRRZ T,(T)	>
	CAIN T,(TT)
	JRST GOTPID
NOTPID:	HRRZ D,(C)
	JUMPN D,FNDB1
	SKIPA D,B
FBLOS:	SETZ D,
FBLOS1:	POP P,B
	POPJ P,

GOTPID:	PUSHJ P,FP2
	AOS -1(P)
	JRST FBLOS1

FFNDBI:	MOVE B,TTT
	ANDI B,LHASHB-1
	SKIPN B,HASHB(B)
	POPJ P,
	JRST FNDBD1

FNDBID:	SKIPN B,DBODPN
	POPJ P,
FNDBD1:	HLRZ T,(B)
	HLRZ T,1(T)
	HLRZ T,(T)
	CAIN T,(TTT)
	JRST CPOPJ1
	HRRZ B,(B)
	JUMPN B,FNDBD1
	POPJ P,
MD,<
TNAME:	PUSH P,T		;SAVE STRING POINTER ON STACK
	MOVEI D,BODPNT-1	;SIMULATE NORMAL LINK
	HRRZ C,BODPNT		;TYPE POINTER
	JUMPE C,RET21		;NONE YET?
TN1:	HRRZ A,(P)		;POINTER TO NAME (ARG)
	HRRZ B,(C)		;POINTER TO TYPE NAME
	PUSHJ P,TXTMAT		;COMPARE
	CAIA			;NOT THE SAME
	JRST RET2		;FOUND IT (POINTER TO TYPE IN C)
	MOVE D,C		;LAGS ONE BEHIND C
	HRRZ C,1(C)		;NEXT TYPE.
	JUMPN C,TN1
RET21:	AOS -1(P)
RET2:	POP P,T
	POPJ P,
>;MD

FIND.B:				;FIND POINTER CROSS-REFERENCE
	HRRZ C,NEWBOD		;POINTER TO NEW BODY CROSS-REFERENCE LIST
	JUMPE C,CPOPJ		;NOT FOUND
FB1:	HLRZ A,1(C)		;EXTERNAL REPRESENTATION
	CAIN A,(T)		;IS THIS THE ONE
	JRST [	HRRZ B,1(C)	;INTERNAL REPRESENTATION
		JRST CPOPJ1]	;SKIP RETURN
	HRRZ C,(C)		;NEXT
	JUMPN C,FB1
	POPJ P,			;NOT FOUND
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ;SOME OUTPUT PRINTERS
OUTTX1: MOVE TT,1(T)
	MOVEM TT,TTBUF
	OUTSTR TTBUF
	HRRZ T,(T)
OUTTXT:	JUMPN T,OUTTX1
	POPJ P,

OUTTCR:	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/
/]
	POPJ P,

MD,<
TTYPE:	SETZ C,			;BLANK ONES FIRST
	OUTSTR[ASCIZ/
/]
	SETZM NNAMES
	PUSHJ P,TTYPEW
	SKIPN C,LIBLST
	POPJ P,
TTYPEY:	MOVE B,C
	OUTSTR[ASCIZ/
/]
	PUSHJ P,LIBTYP
	OUTSTR NAMBUF
	SETZM NNAMES
	PUSHJ P,TTYPEW
	HRRZ C,(C)
	JUMPN C,TTYPEY
	OUTSTR[ASCIZ/
/]
	POPJ P,

TTYPEW:	SKIPN A,BODPNT
	POPJ P,
TTYPEX:	HLRZ T,(A)		;LIBRARY POINTER
	CAME T,C		;SAME LIBRARY
	JRST TTYPEZ
	SOSGE NNAMES
	JRST [	MOVEI T,8
		MOVEM T,NNAMES
		OUTSTR[ASCIZ/
/]
		JRST .+2]
	OUTCHR[11]
	HRRZ T,(A)
	PUSHJ P,OUTTXT
TTYPEZ:	HRRZ A,1(A)
	JUMPN A,TTYPEX
	POPJ P,

LIBOUT:	SKIPN LIBPPN
	JRST LBNOPP
	MOVE TTT,[POINT 7,NAMBUF]
ITS,<	MOVE TT,LIBPPN
	PUSHJ P,SIXOUT
>;ITS
NOITS,<	HLLZ TT,LIBPPN
	PUSHJ P,LSIXOUT
	MOVEI TT,","
	IDPB TT,TTT
	HRLZ TT,LIBPPN
	PUSHJ P,LSIXOUT
>;NOITS
	SETZ TT,
	IDPB TT,TTT
	OUTSTR[ASCIZ/LIBRARY AREA: /]
	OUTSTR NAMBUF
	OUTSTR[ASCIZ/
/]
LBNOPP:	SKIPN A,LIBLST
	JRST MAPP0
LIBOU1:	MOVE B,A
	PUSHJ P,LIBTYP
	OUTSTR NAMBUF
	OUTSTR[ASCIZ/
/]
	HRRZ A,(A)
	JUMPN A,LIBOU1
MAPP0:	SKIPN A,MAPLST
	POPJ P,
	OUTSTR[ASCIZ/LIBRARY MAPPINGS:
/]
MAPP1:	MOVE B,A
	PUSHJ P,LIBTYP
	OUTSTR NAMBUF
	HLRZ B,(A)
	HRRZ B,(B)
	PUSHJ P,LIBTAB
	OUTSTR NAMBUF
	OUTSTR[ASCIZ/
/]
	HRRZ A,(A)
	JUMPN A,MAPP1
	POPJ P,

;CALL WITH B POINTING TO BODY DEF
OUTIT:	HRRZ T,(B)		;BODY NAME
	OUTCHR[42]
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/" /]
	HLRZ B,(B)		;LIBRARY POINTER
	JUMPE B,CPOPJ
	PUSHJ P,LIBTYP
	OUTSTR NAMBUF
	POPJ P,

LIBTYP:	MOVE TTT,[POINT 7,NAMBUF]
	JRST LIBTY1
LIBTAB:	MOVE TTT,[POINT 7,NAMBUF]
	MOVEI T,11
	IDPB T,TTT
LIBTY1:
ITS,<	HLRZ TT,(B)
	MOVE TT,1(TT)
	PUSHJ P,SIXOUT
	MOVEI T,";"
	IDPB T,TTT
>;ITS
	MOVE TT,1(B)
	PUSHJ P,SIXOUT
	HLRZ B,(B)
	HLLZ TT,(B)
	JUMPE TT,NOLEXT
NOITS,<	MOVEI T,".">
ITS,<	MOVEI T," ">
	IDPB T,TTT
	PUSHJ P,SIXOUT
NOLEXT:
NOITS,<	MOVEI T,"["
	IDPB T,TTT
NOCMU,<
	HLLZ TT,1(B)
	PUSHJ P,LSIXOUT
	MOVEI T,","
	IDPB T,TTT
	HRLZ TT,1(B)
	PUSHJ P,LSIXOUT
>;NOCMU
CMU,<
	SKIPN TT,1(B)
	DSKPPN TT,
	MOVE T,[TT,,PPNBUF]
	DECCMU T,
	JRST [	PUSHJ P,LSIXOUT
		JRST PPNDN3 ]
	SKIPA TT,[POINT 7,PPNBUF]
	IDPB T,TTT
	ILDB T,TT
	JUMPN T,.-2
PPNDN3:
>;CMU
	MOVEI T,"]"
	IDPB T,TTT
>;NOITS
	HRRZ T,(B)
	MOVEI TT,"^"
	TRNN T,TOPLVL
	IDPB TT,TTT
	SETZ T,
	IDPB T,TTT
	POPJ P,

TYPREL:	HRRZ B,(A)
	PUSH P,B
	HLRZ B,(B)
	PUSHJ P,PUTFS		;GIVE BACK DIP TYPE NAME (MAYBE)
	POP P,B
	PUSHJ P,PUTFS		;PUT BACK NAME
	HLRZ C,1(A)		;POINTER TO DATA BLOCK
	FSTRET (A)		;GIVE BACK HEAD
;ENTER HERE TO RELEASE PART OF A BODY DEFINITION
PARREL:	JUMPE C,CPOPJ		;QUIT IF NO DEF HERE
	HLRZ B,(C)
	PUSHJ P,PUTFS		;RETURN BITS,,DIP DEF LIST AND LOC OFFSET
	HRRZ B,1(C)		;POINTER TO LINES
	PUSHJ P,PUTFS		;PUT THEM BACK
	HRRZ B,(C)
	JUMPE B,NGIVPN		;SKIP IF NO PINS
GIVPIN:	HLRZ A,(B)		;GET BITS, NAME, ETC. BLOCK
	FSTRET(A)		;GIVE IT BACK
	HRRZ B,(B)
	JUMPN B,GIVPIN
	HRRZ B,(C)		;GET PIN POINTER
	PUSHJ P,PUTFS		;GIVE BACK PIN LIST
NGIVPN:	MOVE B,C
	HLRZ C,1(C)
	FSTRET(B)
	JUMPE C,CPOPJ		;DONE IF NO TEXT
	MOVE A,C
GIVTXT:	HLRZ B,(A)
	HLRZ B,(B)
	JUMPE B,GVTXT1
	HLRZ B,(B)
	SKIPE B		;CHECK DIP DEF IN CASE THIS IS "DIPTYPE"
	PUSHJ P,PUTFS
	HLRZ B,(A)
	HLRZ B,(B)
	PUSHJ P,PUTFS
GVTXT1:	HLRZ B,(A)		;POINTER TO TEXT
	JUMPE B,.+2
	PUSHJ P,PUTFS		;GIVE IT BACK
	HRRZ A,(A)		;NEXT
	JUMPN A,GIVTXT
	MOVE B,C		;NOW LIST
	JRST PUTFS		;THAT'S ALL
                                                                                                                                                                                                                                                                ;MORE OUTPUT ROUTINES
LOUTX:	ADD T,[POINT 7,1]
LOUTY:	TLNE T,760000
	JRST LOUTZ
	HRR T,-1(T)
	TRNN T,-1
	POPJ P,
LOUTZ:	ILDB TTT,T
	JUMPE TTT,LOUTY
	PUSHJ P,WORDOUT
	JRST LOUTY

LOUT:	PUSHJ P,LOUTX
LCRLF:	MOVEI TTT,15
	PUSHJ P,WORDOUT
	MOVEI TTT,12
	JRST WORDOUT

LTYPE:	MOVEM P,PERRSAV
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/BODY DEF LISTING /]
	MOVSI T,EXTBDL
	PUSHJ P,SETNAM
	POPJ P,
	ENTPPN
	INIT DAT,0
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DSK!!
/]
		POPJ P,]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,EXIST
	POPJ P,
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER DAT,FILNAM
	JRST [	RELEASE DAT,
		OUTSTR[ASCIZ/, ENTER FAILED.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
FOR I IN(SITE1,SITE2,TAUTHOR,TIT1,TIT2,TMODULE,TVARIABLE,TPREFIX,TREV,TPROJ,TPAGE,TOF,TDCODE)
<	SKIPE T,I
	PUSHJ P,LOUT
>
	MOVE B,[D,,B]		;POINT HIM AT HIMSELF AND D
	SKIPN C,LSTNAM
	JRST LTYPEN
	SETZ D,
	MOVE E,LSTPPN
	PUSHJ P,LTYPEF
	PUSHJ P,LCRLF
LTYPEN:	MOVEI A,BODPNT-1
	JRST LTYPE1
LTYPE2:	HRRZ T,(A)
	PUSHJ P,LOUTX
	HLRZ B,(A)
	JUMPE B,LTYPE4
	PUSHJ P,LTYPET
LTYPE4:	PUSHJ P,LCRLF
LTYPE1:	HRRZ A,1(A)
	JUMPN A,LTYPE2
	RELEASE DAT,
	POPJ P,

LTYPET:	PUSHJ P,LIBTAB
	CAIA
LTYPEF:	PUSHJ P,LIBTYP
	MOVE T,[POINT 7,NAMBUF]
	ILDB TTT,T
	JUMPE TTT,CPOPJ
	PUSHJ P,WORDOUT
	JRST .-3
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     DECOUT:	SKIPL T
	JRST DECOU1
	MOVM T,T
	OUTCHR ["-"]
DECOU1:	IDIVI T,=10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,DECOU1
	HLRZ T,(P)
	ADDI T,60
	OUTCHR T
	POPJ P,

OCTOUT:	IDIVI T,10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,OCTOUT
	HLRZ T,(P)
	ADDI T,60
	OUTCHR T
	POPJ P,

SIXPNT:	JUMPE TT,CPOPJ
	SETZ T,
	LSHC T,6
	ADDI T,40
	OUTCHR T
	JRST SIXPNT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                COMMENT    VALID 00011 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	<WIRELIST>SIGSUB.FAI112, 29-JUL-75 12:11:35, EDIT BY HELLIWELL
C00004 00003	DATA AREA
C00005 00004	TOP LEVEL CONTROL OF EXPRESSION EVALUATION
C00007 00005	BRACKET AND CONDITIONAL INTERPRETER
C00011 00006	EXPRESSION SUBRS
C00017 00007	PERMUT STORAGE
C00020 00008	PERMUT
C00036 00009	HANDLE QUALIFIER LETTERS AND WIRE RULE NUMBERS
C00041 00010	SIGONE, PUTIT, EPUTIT, AND SPTAB
C00043 00011	ALPHA
C00049 ENDMK
C;
                                                                                                                                    ;<WIRELIST>SIGSUB.FAI;112, 29-JUL-75 12:11:35, EDIT BY HELLIWELL
SUBTTL	SIGNAL NAME PROCESSOR
MDPC,<VERSION(SIGSUB,1)>
BEGIN SIGSUB

MD,<DEFINE MDWL <IFE 0>>
MPC,<DEFINE MDWL <IFN 0>>
MWL,<DEFINE MDWL <IFE 0>>

MDPC,<
OPDEF PUTSTR[OUTSTR]
OPDEF PUTSIG[OUTSTR]
OPDEF PUTBYT[OUTCHR]
>;MDPC

COMMENT  CALLING SEQUENCE

PUSHJ P,SIGSUB
<ERROR IN SOME EXPRESSION>
<EXPRESSIONS PARSED OK>

CLOBBERS T, TT, TTT


EXTERNAL SUBRS

PUSHJ P,SIGGET
<CHAR IN TTT, 0 IF END OF STRING>

PUSHJ P,GETVAR
<NO SUCH VARIABLE>
<VALUE OF VARIABLE FROM TTT IN TT>

EXTERNAL VARIABLES
UPPER	UPPER BOUND ON RESULTANT EXPRESSIONS (INCLUSIVE)
LOWER	LOWER BOUND ON RESULTANT EXPRESSIONS (INCLUSIVE)
MXSTLN	MAX STRING LENGTH (FOR SIGBUF)


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ;DATA AREA

MDPC,<STORAGE(IMPURE)>

TNDIG:		0
SELCHR:		0
ERRORP:		0
^SIGEND:	0
^SIGBUF:	BLOCK MXSTLN
MDWL,<
^^DOVARS:	-1
>;MDWL

MDPC,<STORAGE(PURE)>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;TOP LEVEL CONTROL OF EXPRESSION EVALUATION
^SIGSUB:
MDWL,<	SETZM EXPER2		;NO VARIABLE ERRORS YET>
	SETZM SELCHR		;NOT IN SELECT TO START WITH
	MOVE T,[POINT 7,SIGBUF]
	MOVEM P,ERRORP		;FOR ERROR RETURN
	PUSHJ P,SIGS		;START AS NORMAL SIGNAL
	AOS (P)
SIGE1:	SETZ TTT,
	IDPB TTT,T		;DON'T CALL SPUTIT,
	TLNE T,760000		;WE ARE ONLY FILLING OUT WORD
	JRST .-2		;FILL OUT LAST WORD
	HRRZM T,SIGEND		;STORE END FOR LOSER
	POPJ P,

SIGE:	MOVE P,ERRORP
	JRST SIGE1

SIG0:	PUSHJ P,SPUTIT
SIGS:
SIG1:	PUSHJ P,SIGONE		;GET A CHAR
	POPJ P,			;FINI
SIG2:	CAMN TTT,SELCHR		;END OF SELECTOR?
	JRST SIGSEL		;YES
	CAIN TTT,";"		;IF COMMENT
	JRST SIGC		;JUST COPY REST
	CAIN TTT,"]"		;END OF BRACKET GROUP?
	JRST SIGECK		;YES, EITHER END OF "," GROUP OR ERROR
	CAIE TTT,"["
	JRST SIG0
	PUSHJ P,BRACKET		;BRACKET SCANNER
	JRST SIG1

SIGC:	PUSHJ P,SPUTIT
	PUSHJ P,SIGONE
	POPJ P,
	JRST SIGC

;SKIP TO ] (END OF SELECTOR EXPRESSION)
SIGSEL:	SETZ TT,
SIGSL1:	PUSHJ P,SIGONE
	JRST SIGE
	CAIN TTT,"["
	AOJA TT,SIGSL1
	CAIN TTT,"]"
	SOJL TT,CPOPJ
	JRST SIGSL1

SIGECK:	EXCH TTT,SELCHR		;SAVE US AND GET SELCHR
	CAIE TTT,","		;ARE WE IN "," GROUP?
	JRST SIGE		;NO, ERROR
	EXCH TTT,SELCHR		;YES, RESTORE CHARS
	POPJ P,			;AND RETURN TO BRACKET ROUTINE
;BRACKET AND CONDITIONAL INTERPRETER
BRACKET:SETZM NDIG		;NO WIDTH FROM VARS YET
	PUSHJ P,EXPR
	CAIE TTT,"]"		;IS IT NORMAL EXPRESSION?
	JRST SELCHK		;NO, CHECK FOR SELECTOR
MDWL,<	SKIPN DOVARS
	JRST SIGN0
	CAMG TT,UPPER
	JRST SIGN1
	SUB TT,UPPER
	SUBI TT,1
	IDIV TT,WIDTH
	MOVE TT,TTT
	ADD TT,LOWER
	JRST SIGN0

SIGN1:	CAML TT,LOWER
	JRST SIGN0
	SUB TT,LOWER
	ADDI TT,1
	IDIV TT,WIDTH
	MOVE TT,TTT
	ADD TT,UPPER
SIGN0:
>;MDWL
	MOVEI TTT,"-"
	SKIPGE TT
	PUSHJ P,SPUTIT
	MOVM TT,TT
	PUSHJ P,PUTNUM
	POPJ P,			;ALL DONE

PUTNUM:	MOVE TTT,NDIG
	MOVEM TTT,TNDIG		;THIS IS HOW MANY DIGITS TO PRINT, MIN.
PUTNM1:	IDIVI TT,=10
	HRLM TTT,(P)
	SOSG TNDIG		;ENOUGH DIGITS YET?
	JUMPE TT,.+2
	PUSHJ P,PUTNM1
	HLRZ TTT,(P)
	ADDI TTT,60
SPUTIT:	CAMN T,[POINT 7,SIGBUF+MXSTLN-1,27]
	JRST [	PUTSTR[ASCIZ/EXPRESSION BUFFER OVERFLOW - SIGNAL IS:
/]
		SETZ TTT,
		IDPB TTT,T
		TLZ T,7700	;STOP DEPOSITING BYTES AND SUPPRESS ERROR
		PUTSTR SIGBUF
		JRST SIGE]
	IDPB TTT,T
	POPJ P,

;SELECTOR CHECK
SELCHK:	CAIE TTT,173		;STANDARD CASE (=0)?
	JRST COMCHK		;CHECK FOR "," CONSTRUCT
	JUMPE TT,SELNOK		;NOT THIS ONE IF NOT TRUE (0)
	PUSH P,SELCHR		;SAVE OLD SELECT END
	MOVEI TTT,176		;THIS IS NEW ONE
SELDO:	MOVEM TTT,SELCHR
	PUSHJ P,SIGS
	POP P,SELCHR		;RESTORE  OLD SELCHR
	CAIE TTT,"]"
	JRST SIGE
	POPJ P,

SELNOK:	SETZ TT,
SELNK1:	PUSHJ P,SIGONE
	JRST SIGE
	CAIN TTT,173
	AOJA TT,SELNK1
	CAIN TTT,176
	SOJL TT,BRACKET		;BACK TO BRACKET ROUTINE IF AT RIGHT LEVEL
	JRST SELNK1

COMCHK:	CAIE TTT,","		;CASE EXPR?
	JRST SIGE		;NO, LOSE
	JUMPLE TT,SIGSEL	;- IS AUTO NOTHING
	PUSH P,[0]		;MAKE A MATCHING [] COUNT
	JRST COMCK2		;SEEN ONE ","

COMCK1:	PUSHJ P,SIGONE
	JRST SIGE
	CAIN TTT,"["
	AOS (P)
	CAIN TTT,"]"
	SOS (P)
	SKIPGE (P)		;END OF SELECTOR GROUP?
	JRST [	POP P,(P)	;YES
		POPJ P,]
	SKIPG (P)		;ARE WE AT RIGHT LEVEL TO CHECK ","?
	CAIE TTT,","		;YES
	JRST COMCK1		;NO COMMA, OR NO CHECK
COMCK2:	SOJG TT,COMCK1		;THERE YET?
	POP P,(P)		;LOSE COUNT
	PUSH P,SELCHR		;YES, SAVE OLD SELCHR
	MOVEI TTT,","		;THIS IS NEW ONE
	JRST SELDO		;REST IS SAME AS  OTHER GUY
                                                                                                                                                                                                                                                                                                                                                                                                                             ;EXPRESSION SUBRS

;CURRENT PRECEDENCE ORDER FOR EXPRESSIONS (HIGHEST TO LOWEST BINDING POWER)
;	"
;	
;	&!
;	*/'
;	+-
;	=<>
;	


EXPR:
LANDOR:	PUSHJ P,BOOL
LNDOR1:	CAIN TTT,""
	JRST EXPLAND
	CAIN TTT,"
"
	JRST EXPLOR
	POPJ P,

EXPLAND:PUSH P,TT
	PUSHJ P,BOOL
	SKIPE TT
	SETO TT,
	ANDM TT,(P)
	POP P,TT
	JUMPE TT,LNDOR1
	SETO TT,
	JRST LNDOR1

EXPLOR:	PUSH P,TT
	PUSHJ P,BOOL
	IORM TT,(P)
	POP P,TT
	JUMPE TT,LNDOR1
	SETO TT,
	JRST LNDOR1

BOOL:	PUSHJ P,ADDSUB
BOOL1:	CAIN TTT,"="
	JRST BOOLE
	CAIN TTT,""
	JRST BOOLN
	CAIN TTT,74
	JRST BOOLL
	CAIN TTT,76
	JRST BOOLG
	CAIN TTT,""
	JRST BOOLLE
	CAIN TTT,""
	JRST BOOLGE
	POPJ  P,

FOR @$ I IN(E,N,L,G,LE,GE)
<BOOL$I:PUSH P,TT
	PUSHJ P,ADDSUB
	MOVEM TT,1(P)
	POP P,TT
	CAM$I TT,2(P)
	TDZA TT,TT
	SETO TT,
	JRST BOOL1
>

ADDSUB:	PUSHJ P,DIVMUL		;FIRST OPERAND (WILL RETURN IF NOT */&!)
ADSUB1:	CAIN TTT,"+"
	JRST EXPADD
	CAIN TTT,"-"
	JRST EXPSUB
	POPJ P,			;NOT + OR - OR HIGHER OP, RETURN UP LEVEL

EXPADD:	PUSH P,TT		;SAVE SUM
	PUSHJ P,DIVMUL		;CHECK FOR HIGHER PRECEDENCE OP
	ADD TT,(P)
	POP P,(P)
	JRST ADSUB1

EXPSUB:	PUSH P,TT
	PUSHJ P,DIVMUL
	EXCH TT,(P)
	SUB TT,(P)
	POP P,(P)
	JRST ADSUB1

DIVMUL:	PUSHJ P,ANDOR		;WILL RETURN WHEN NO &! SEEN
DVML1:	CAIN TTT,"/"
	JRST EXPDIV
	CAIN TTT,"*"
	JRST EXPMUL
	CAIN TTT,"'"
	JRST EXPMOD
	POPJ P,			;NOT / OR * OR ' RETURN UPLEVEL

EXPDIV:	PUSH P,TT
	PUSHJ P,ANDOR
	JUMPE TT,SIGE		;DIVIDE CHECK
	EXCH TT,(P)
	IDIVM TT,(P)
	POP P,TT
	JRST DVML1

EXPMUL:	PUSH P,TT
	PUSHJ P,ANDOR
	IMULM TT,(P)
	POP P,TT
	JRST DVML1

EXPMOD:	PUSH P,TT
	PUSHJ P,ANDOR
	EXCH TTT,(P)
	IDIV TT,TTT
	MOVE TT,TTT
	POP P,TTT
	JRST DVML1

ANDOR:	PUSHJ P,PRIMRY
ANDOR1:	CAIN TTT,"&"
	JRST EXPAND
	CAIN TTT,"!"
	JRST EXPOR
	POPJ P,

EXPAND:	PUSH P,TT
	PUSHJ P,PRIMRY
	ANDM TT,(P)
	POP P,TT
	JRST ANDOR1

EXPOR:	PUSH P,TT
	PUSHJ P,PRIMRY
	IORM TT,(P)
	POP P,TT
	JRST ANDOR1

PRIMRY:	PUSHJ P,SIGONE
	JRST SIGE		;LEAVE ON EOF
	CAIE TTT," "
	CAIN TTT,""
	JRST PRIMRY		;IGNORE THESE
	CAIE TTT,"("
	JRST NOPARN
	PUSHJ P,EXPR
	CAIN TTT,")"
	PUSHJ P,SIGONE
	JRST SIGE
	POPJ P,

NOPARN:	CAIE TTT,"["		;START OF ANOTHER BRACKETS CONSTRUCT?
	JRST NOBRAK		;NO
	PUSH P,T		;SAVE CURRENT DEPOSIT POINTER
	PUSHJ P,BRACKET
	SETZ TTT,
	PUSHJ P,SPUTIT
	MOVE T,(P)		;GET TO FRONT OF IT
	ILDB TTT,T
	JUMPE TTT,SIGE
BRKEXP:	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST SIGE
	IMULI TT,=10
	ADDI TT,-60(TTT)
	ILDB TTT,T
	JUMPN TTT,BRKEXP
	POP P,T			;NOW BACK TO ORIGNINAL DEPOSIT POINTER
	PUSHJ P,SIGONE		;GOBBLE CHAR AFTER []
	JRST SIGE
	POPJ P,

NOBRAK:	CAIE TTT,""
	JRST NONOT
	PUSHJ P,EXPR		;THIS GIVES  LOWEST PRECEDENCE
	SKIPE TT		;DO LOGICAL INVERSION
	TDZA TT,TT
	SETO TT,
	POPJ P,

NONOT:	CAIE TTT,"-"
	JRST NMINUS
	PUSHJ P,PRIMRY
	MOVN TT,TT
	POPJ P,

NMINUS:	CAIN TTT,"+"
	JRST PRIMRY
	CAIE TTT,'"'+40
	JRST NQUOTE
	PUSHJ P,SIGONE
	JRST SIGE
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	CAIA
	JRST ISQUOT
	CAIL TTT,"A"
	CAILE TTT,"Z"
	JRST SIGE
ISQUOT:	MOVE TT,TTT
	PUSHJ P,SIGONE
	JRST SIGE
	POPJ P,

NQUOTE:
MDWL,<	CAIL TTT,"A"
	CAILE TTT,"Z"
	CAIA
	JRST GVAR		;LOOKUP VARIABLE
>;MDWL
	SETZ TT,
	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST SIGE		;DOESN'T EVEN START WITH A DIGIT
PRIM1:	IMULI TT,=10
	ADDI TT,-60(TTT)
	PUSHJ P,SIGONE
	JRST SIGE
	CAIL TTT,"0"
	CAILE TTT,"9"
	POPJ P,
	JRST PRIM1

MDWL,<
GVAR:	SKIPE DOVARS
	PUSHJ P,GETVAR
	JRST SIGE		;UNKNOWN VARIABLE
	PUSHJ P,SIGONE
	JRST SIGE
	POPJ P,
>;MDWL
                                                                                                                                                                                                                                                                     SUBTTL	PERMUT STORAGE

COMMENT 
CALLING SEQUENCE

	<INITIAL BYTE POINTER USED BY SIGONE IN A>
	PUSHJ P,PERMUT
	<PERMUTED STRING RETURNED IN CMPWRD+PERMTB>

CLOBBERS T, TT, TTT, A, B, C, D

;GLOBAL AND ONLY GLOBAL CHARACTER
^GLBCHR__"^"

;FLAG REGISTER, USE H FROM BOTH D AND WL
SFLAG_H

;CONTROL FLAGS FOR PERMUT (RH OF SFLAG)
MDPC,<
EXTRA1__1		;EXTRACT CONSTANT LEADER
EXTRA2__2		;EXTRACT CONSTANT TRAILER
EXTRAS__4		;EXTRACT NON-CONSTANT SIGNAL NAME
SAW01__10		;SAW A (0) OR (1) CONSTRUCT
LEADN__20		;LEADING NOT SEEN
>;MDPC

BSSEEN__100000		;SEEN DIFFERENCES IN BS CONSTRUCT
TBSGTR__200000		;BS IN T IS GREATER
PRMTMP__400000		;TEMP FLAG

;FLAGS USED BY PERMUT (LH OF SFLAG)
GLB1SN__1
GLB2SN__2
EXPERR__4
WHERR__10
NFLAG1__100000
NFLAG2__200000
DEC,<POLFLG__400000>

;EXTERNAL SYMBOLS NEEDED
;ALL THESE ARE RIGHT HALF BITS STORED IN SAVBIT
	;GLB1	COPIED FROM GLB1SN
	;GLB2	COPIED FROM GLB2SN
	;SGND	SPECIAL SIGNAL BIT
	;SPWR		"
	;SHI		"
	;SNC		"
;SIGGET		ROUTINE TO GET CHAR INTO TTT
;MXSTLN		MAX STRING LENGTH (FOR PERMTB)
;EXPER2		ZEROED BY PERMUT AND SIGSUB,
;		SHOULD BE SET TO 0,,-1 FOR VAR NOT FOUND

;MAX EXTRACTED SIGNAL LENGTH
ESGTLN__MXSTLN	;SAME AS MAX SIGNAL NAME FOR NOW

MDPC,<STORAGE(IMPURE)>
^SAVBIT:	0
^WQNWRD:	0
WQNTMP:		0
WQNTM1:		0
^VOLTAGE:	0

^CMPWRD:	0
^PERMTB:	BLOCK MXSTLN
MDPC,<
^SIGTAB:	0
^SIGSTR:	BLOCK MXSTLN
ESGPTR:		0
ESGSAV:		0
^ESGTAB:	BLOCK ESGTLN
>;MDPC
GETSIG:		HALT		;GET A CHARACTER
SIGPTR:		0		;SAVED POINTER TO BEGINNING OF STRING
FLGSAV:		0		;SAVE SFLAG HERE
MDPC,<
^POLAR:		0		;POLARITY INDICATOR
^OPOLAR:	0		;OLD POLAR FOR PERMES
>;MDPC
IFN PERMTB-CMPWRD-1,<PRINTS /CMPWRD DOES NOT IMMEDIATELY PRECEED PERMTB.
/>
MDPC,<STORAGE(PURE)>
                                                                                                                                                            SUBTTL	PERMUT
MDPC,<
^SIGMAA:SETZM VARLST		;NO VARS HERE
	PUSH P,C
	PUSH P,D
	PUSHJ P,PERMUT
	MOVE T,[CMPWRD,,SIGTAB]
	BLT T,SIGSTR+MXSTLN-1
	POP P,D
	POP P,C
	POPJ P,

^PERME1:MOVEM SFLAG,FLGSAV
	MOVEI SFLAG,EXTRA1
	JRST PERMEA

^PERME2:MOVEM SFLAG,FLGSAV
	MOVEI SFLAG,EXTRA2
	JRST PERMEA

^PERMES:MOVEM SFLAG,FLGSAV
	MOVEI SFLAG,EXTRAS
PERMEA:	MOVE T,[POINT 7,ESGTAB]
	MOVEM T,ESGPTR
	SETZM VARLST
	JRST PERMT1
>;MDPC

;SOME HANDY MACROS FOR EXTRACTING

DEFINE EPUT1<
MDPC,<TRNE SFLAG,EXTRA1
	PUSHJ P,EPUTIT
>;MDPC
>

DEFINE EPUT2<
MDPC,<TRNE SFLAG,EXTRA2
	PUSHJ P,EPUTIT
>;MDPC
>

DEFINE EPUTS<
MDPC,<TRNE SFLAG,EXTRAS
	PUSHJ P,EPUTIT
>;MDPC
>

^PERMUT:
	MOVEM SFLAG,FLGSAV
	SETZ SFLAG,			;CLEAR ALL FLAGS
PERMT1:	MOVEM A,SIGPTR			;SAVE POINTER TO FRONT OF STRING
	SETZM EXPER2
	SETZM VOLTAGE
MDPC,<	SETZM WQNWRD			;CLEAR HERE FOR DWG PROG
DEC,<	SETZM POLAR	>
>;MDPC
MWL,<	TRNE ISBACK			;CAUSE FIRST ^ TO TURN ON GLB2
	TLO SFLAG,GLB1SN
>;MWL
	SKIPN VARLST			;ANY VARS?
	JRST PERM0			;NO, SKIP THIS
	SETO TTT,			;FLAG NO EOS YET
	PUSHJ P,SIGSUB			;MUNG STRING
	TLO SFLAG,EXPERR		;ERROR, COPY ORIGINAL
	SKIPN EXPER2			;VARIABLE ERROR?
	TLNE SFLAG,EXPERR		;IF ANY ERROR, DON'T USE RESULT
	JRST PERM0			;YES, COPY ORIGINAL STRING
	MOVE A,[POINT 7,SIGBUF]
	MOVE T,[PUSHJ P,[ILDB TTT,A
			JUMPN TTT,CPOPJ1
			POPJ P,]]
	JRST PERM0A

PERM0:	MOVE A,SIGPTR			;READ STRING AGAIN
	MOVE T,[PUSHJ P,SIGONE]		;GET CHAR FROM A INTO TTT.  SKIP RET IF NOT EOS
PERM0A:	MOVEM T,GETSIG			;  CONVERTS TAB AND  TO SPACE
	MOVE B,[POINT 7,PERMTB]
	JRST PERMS0

PERMSP:	EPUT1
PERMS0:	XCT GETSIG
	JRST LEAVED
	CAIN TTT," "
	JRST PERMSP
	CAIE TTT,GLBCHR		;GLOBAL CHAR?
	JRST NOGLOB
	TLOE SFLAG,GLB1SN	;TURN ON AND CHECK GLB1SN
	TLOA SFLAG,GLB2SN	;WE GET BOTH
	JRST PERMSP		;TRY FOR ANOTHER
GGLOB2:	EPUT1
	XCT GETSIG
	JRST LEAVED
	CAIN TTT," "
	JRST GGLOB2
NOGLOB:
NODEC,<
	CAIE TTT,NOTCHR
	JRST PERMNT
PRMSP1:	EPUTS
	XCT GETSIG
	JRST [	MOVEI TTT,NOTCHR
		PUSHJ P,PUTIT
		JRST LEAVED]
	CAIN TTT," "
	JRST PRMSP1
	CAIE TTT,NOTCHR		;CATCH CASE OF DOUBLE NOT
	CAIN TTT,32
	JRST PERM2		;TILDA AND NOT, FLUSH
	JRST PRMNT1

PERMNT:	CAIE TTT,32
	JRST PERM1		;STARTUP HERE
PRMSP2:	EPUTS
	XCT GETSIG
	JRST [	MOVEI TTT,32
		PUSHJ P,PUTIT
		JRST LEAVED]
	CAIN TTT," "
	JRST PRMSP2
	CAIN TTT,NOTCHR
	JRST PERM2
PRMNT1:	MOVE T,TTT
	MOVEI TTT,NOTCHR
	PUSHJ P,PUTIT
	MOVE TTT,T
	JRST PERM1
>;NODEC
DEC,<	CAIE TTT,NOTCHR		;REMEMBER IF WE SAW A -
	JRST PERM1
	EPUTS
MDPC,<	TRO SFLAG,LEADN	>	;SAW LEADING NOT
	XCT GETSIG		;GET NEXT CHAR ALSO
	JRST [	MOVEI TTT,NOTCHR
		PUSHJ P,PUTIT
		JRST LEAVED]
	CAIN TTT,NOTCHR		;DOUBLE - ?
	JRST PERM2		;YES, THEY CANCEL
	TLO SFLAG,NFLAG1	;NO, REMEBER INITIAL ONE
	MOVE T,TTT
	MOVEI TTT,NOTCHR
	PUSHJ P,PUTIT
	MOVE TTT,T
	JRST PERM1
>;DEC

PERM2:	EPUTS
	XCT GETSIG
	JRST BACKSP
PERM1:
MWL,<	TRNE ISBACK	>	;DON'T EXTRACT QN UNLESS BP AND WL
	CAIE TTT,"\"		;QN ESCAPE?
	JRST NOQN
	PUSHJ P,GETQN		;YES
	JRST BACKSP
NOQN:	CAIN TTT,";"		;; IS SPECIAL
	JRST BACKSP
	PUSHJ P,PUTIT		;CHECKS FOR STRING TOO LONG, THEN IDPB TTT,B
	JRST PERM2

BACKSP:	MOVE C,B
	LDB D,C			;GET LAST CHAR STORED
BACKS1:	MOVE B,C		;SKIP SPACES SO FAR
	CAIE D," "		;BACK UP OVER SPACES
	JRST STRTHL
	PUSHJ P,GETREV
	JRST NBACK
	JRST BACKS1

STRTHL:
DEC,<	MOVEI T," "		;THIS IS DEFAULT ASSERTION
	TLZ SFLAG,NFLAG2
	MOVE C,B		;GET COPY OF DEPOSIT POINTER
	LDB D,C			;GET LAST CHAR DEPOSITED
	CAIN D,"L"
	TLOA SFLAG,NFLAG2!POLFLG
	CAIN D,"H"
	JRST DOHL
	PUSHJ P,CHK01
	JRST NOHL
	MOVE B,C
	JRST END01

DOHL:	PUSHJ P,GETREV
	JRST NBACK
	CAIE D," "
	JRST DOHL1
DOHL0:	PUSHJ P,GETREV
	JRST NBACK
	CAIN D," "
	JRST DOHL0
	MOVE B,C
	PUSHJ P,CHK01
	JRST ENDHL
END01A:	MOVE B,C
END01:
MDPC,<	TRO SFLAG,SAW01	>
	TLNN SFLAG,NFLAG2!NFLAG1	;BOTH OFF?
	JRST ENDHL			;YES, NO CHANGE
	TLC SFLAG,NFLAG2!NFLAG1
	TLCN SFLAG,NFLAG2!NFLAG1	;OR BOTH ON?
	JRST ENDHL			;YES, STILL NO CHANGE
	TLC SFLAG,NFLAG2		;INVERT SENSE OF -
	TRC T,1				;AND 0 OR 1
ENDHL:	TLNN SFLAG,NFLAG2		;ARE WE CHANGING SENSE OF MINUS?
	JRST ENDHLA			;NO, GO ON
	SETZ TTT,			;TERMINATE STRING SO WE CAN SHIFT IT
	PUSHJ P,PUTIT
	MOVE B,[POINT 7,PERMTB]
	TLCN SFLAG,NFLAG1	;YES, INVERT SENSE OF MINUS AND SEE IF WE MUST INSERT OR REMOVE IT
	JRST [	MOVEI TT,NOTCHR	;MUST INSERT ONE
		MOVE C,[POINT 7,PERMTB];GET STRING FROM HERE
		JRST ENDHLB]
	MOVE C,[POINT 7,PERMTB,6];MUST REMOVE -, START HERE
	ILDB TT,C		;START WITH THIS CHAR
	JUMPE TT,ENDHLA		;UNLIKELY, BUT CAN HAPPEN
ENDHLB:	ILDB TTT,C		;MAKE SURE WE STAY AHEAD OF IT
	EXCH TT,TTT
	PUSHJ P,PUTIT
	JUMPN TT,ENDHLB
ENDHLA:	MOVEI TTT,11
	PUSHJ P,PUTIT
	MOVE TTT,T		;" ", "0", OR "1"
	PUSHJ P,PUTIT
	MOVEI TTT,"H"
	PUSHJ P,PUTIT
MDPC,<	MOVEI TTT,"H"
	TLNE SFLAG,POLFLG
	MOVEI TTT,"L"
	HRROM TTT,POLAR
>;MDPC
	JRST NBACK

DOHL1:	CAIE D,"0"		;H OR L PRECEEDED BY 0?
	CAIN D,"1"		;OR 1?
	JRST DOHL2		;YES
	PUSHJ P,CHK01		;NO, CHECK () VERSION
	JRST NBACK
	JRST END01A

DOHL2:	MOVE TTT,D		;REMEMBER 0 OR 1
	PUSHJ P,CHK01S		;SKIP PAREN CHECK
	JRST NBACK		;NO SPACE(S)
	JRST END01A		;OK

CHK01:	CAIE D,")"
	POPJ P,
	PUSHJ P,GETREV
	POPJ P,
	MOVE TTT,D
	TRZ D,1
	CAIE D,"0"
	POPJ P,
	PUSHJ P,GETREV
	POPJ P,
	CAIE D,"("
	POPJ P,
CHK01S:	PUSHJ P,GETREV
	POPJ P,
	CAIN D," "
	JRST CHK01S
	MOVE T,TTT
	JRST CPOPJ1

NOHL:
MDPC,<	CAIN D,"!"
	PUSHJ P,GETREV
	JRST NBACK
	CAIN D," "
	AOS POLAR	;INDICATE " !" AT END OF STR
>;MDPC
>;DEC
NBACK:	MOVE TTT,SIGCHR		;GET LAST CHAR
	JUMPE TTT,LEAVED	;END IF EOL
STOCOM:	PUSHJ P,PUTIT
	EPUT2
	XCT GETSIG
	JRST LEAVED
	JRST STOCOM

GETREV:	CAMN C,[POINT 7,PERMTB,6]		;CAN WE BACKUP?
	POPJ P,					;NO
	ADD C,[70000,,0]
	JUMPGE C,.+2
	SUB C,[430000,,1]
	LDB D,C
	JRST CPOPJ1

MDPC,<
GETRVS:	CAME C,[POINT 7,ESGTAB]
	CAMN C,[POINT 7,ESGTAB,6]		;CAN WE BACKUP?
	POPJ P,					;NO
	ADD C,[70000,,0]
	JUMPGE C,.+2
	SUB C,[430000,,1]
	LDB D,C
	JRST CPOPJ1
>;MDPC

LEAVED:	SETZ TTT,			;YES, FINISH OUT WORD
PERM8:	IDPB TTT,B			;CAN'T OVERFLOW TABLE
	TLNE B,760000
	JRST PERM8
MDPC,<	TRNN SFLAG,EXTRA1!EXTRA2!EXTRAS
	JRST PERMEC
	MOVE B,ESGPTR
PERMEB:	IDPB TTT,B
	TLNE B,760000
	JRST PERMEB
	MOVEM B,ESGPTR
	TRNN SFLAG,EXTRAS
	JRST PERMEC
	SKIPGE TTT,POLAR
	CAMN TTT,OPOLAR
	JRST PERMEC			;NEW HAS NO POLARITY OR IS SAME AS OLD
	SKIPL OPOLAR			;DID OLD HAVE POLARITY?
	JRST PERMEC			;NO
	MOVE C,ESGPTR			;GET EXTRACT POINTER
PERMED:	PUSHJ P,GETRVS
	JRST PERMEC
	CAIE D,"L"
	CAIN D,"H"
	CAIA
	JRST PERMED
	CAIE D,"L"
	SKIPA D,["L"]
	MOVEI D,"H"
	DPB D,C			;CHANGE SENSE OF POLARITY
	TRNE SFLAG,LEADN	;LEADING NOT?
	JRST PERMEE		;YES, DELETE IT
	TRNN SFLAG,SAW01	;DID WE PASS OVER A 0 OR 1?
	JRST PERMEF		;NO, INSERT NOT
PERMEG:	PUSHJ P,GETRVS
	JRST [	PUTSTR[ASCIZ/ERROR IN PERMES, 0 OR 1 NOT FOUND IN SIGNAL:
/]
		PUTSTR ESGTAB
		PUTSTR[ASCIZ/
/]
		JRST PERMEF]
	CAIE D,"0"
	CAIN D,"1"
	TRCA D,1		;FOUND 0 OR 1, COMPLEMENT AND SKIP
	JRST PERMEG
	DPB D,C			;STORE BACK
	JRST PERMEC

PERMEE:	MOVE A,[POINT 7,ESGTAB]
PERMEH:	ILDB TTT,A
	CAIE TTT,NOTCHR
	JUMPN TTT,PERMEH
	JUMPE TTT,[PUTSTR[ASCIZ/ERROR IN PERMES, "-" NOT FOUND IN SIGNAL:
/]
		PUTSTR ESGTAB
		PUTSTR[ASCIZ/
/]
		JRST PERMEC]
	MOVE B,A
	ILDB TTT,A
	DPB TTT,B
PERMEI:	ILDB TTT,A
	IDPB TTT,B
	JUMPN TTT,PERMEI
	JRST PERMEC

PERMEF:	MOVE A,[POINT 7,ESGTAB]
	MOVE B,A
	MOVEI TTT,NOTCHR
PERMEJ:	ILDB TT,A
	IDPB TTT,B
	SKIPE TTT,TT
	JRST PERMEJ
PERMEK:	IDPB TTT,B
	TLNE B,760000
	JRST PERMEK
PERMEC:
>;MDPC
	SETZM CMPWRD
	MOVE A,[POINT 7,CMPWRD]
	MOVE B,[POINT 7,PERMTB]
	TLZ SFLAG,NFLAG1
	PUSHJ P,ENDGET
	JRST CKERR
	CAIN T,NOTCHR
	TLOA SFLAG,NFLAG1
	JRST PRM10A
PERM10:	PUSHJ P,ENDGET
	JRST CKERR		;EOL OR ";"
PRM10A:	IDPB T,A
	TLNE A,760000			;ENOUGH FOR CMPWRD?
	JRST PERM10
CKERR:	TLNN SFLAG,WHERR		;WAS THERE AN ERROR?
	JRST CKERR0
	PUTSTR[ASCIZ/CAUSED BY SIGNAL - /]
	PUTSIG PERMTB
	PUTSTR[ASCIZ/
/]
CKERR0:	TLNN SFLAG,EXPERR		;WAS THERE AN ERROR?
	JRST CKSIG
	PUTSTR[ASCIZ/ERROR IN EXPRESSION(S) - /]
	PUTSIG PERMTB
	PUTSTR[ASCIZ/
/]
CKSIG:	MOVE B,[POINT 7,PERMTB]		;PREPARE TO SCAN SIGNAL
	PUSHJ P,ENDGET
	JRST NCKPWR
	CAIN T,"-"
	JRST [	TRO SFLAG,PRMTMP
		JRST CKPWR1]
	CAIE T,"+"
	JRST NCKPWR
	TRZ SFLAG,PRMTMP
CKPWR1:	SETZ A,				;CLEAR NUMBER ACCUMULATOR
CKPWR2:	PUSHJ P,ENDGET
	JRST NCKPWR
	CAIL T,"0"
	CAILE T,"9"
	JRST CKPWR3
	IMULI A,=10
	ADDI A,-"0"(T)
	JRST CKPWR2

CKPWR3:	CAIE T,"."
	JRST NCKPWR
	IMULI A,=100		;WILL ADD 2 MORE DIGITS
	PUSHJ P,ENDGET
	JRST NCKPWR
	CAIL T,"0"
	CAILE T,"9"
	JRST NCKPWR		;FIRST MUST BE DIGIT
	SUBI T,"0"
	IMULI T,=10
	ADDI A,(T)
	PUSHJ P,ENDGET
	JRST NCKPWR
	CAIL T,"0"
	CAILE T,"9"
	JRST CKPWR4
	ADDI A,-"0"(T)
	PUSHJ P,ENDGET
	JRST NCKPWR
CKPWR4:	CAIE T,"V"
	JRST NCKPWR
	TRNE SFLAG,PRMTMP
	MOVN A,A
	PUSHJ P,CKSIGE
	JRST NCKPWR
	MOVEM A,VOLTAGE
	MOVEI T,SPWR
	JRST CKSIG5

NCKPWR:	MOVSI C,-SPLEN
CKSIG1:	MOVE A,SPTAB(C)
	HRLI A,(<POINT 7,0>)
	MOVE B,[POINT 7,PERMTB]
CKSIG2:	ILDB TT,A
	JUMPE TT,CKSIG3
	PUSHJ P,ENDGET
	JRST CKSIG4
	CAMN TT,T
	JRST CKSIG2
CKSIG4:	AOBJN C,CKSIG1
	SETZ T,
CKSIG5:	TLNE SFLAG,GLB1SN
	TRO T,GLB1
	TLNE SFLAG,GLB2SN
	TRO T,GLB2
	MOVEM T,SAVBIT		;RETURN BITS HERE
	MOVE SFLAG,FLGSAV
	POPJ P,

CKSIG3:	PUSHJ P,CKSIGE
	JRST CKSIG4
	HLRZ T,SPTAB(C)
	JRST CKSIG5

CKSIGE:	PUSHJ P,ENDGET
	JRST CPOPJ1
	CAIN T,40
	AOS (P)
	POPJ P,

ENDGET:	ILDB T,B
PERM13:	JUMPE T,CPOPJ		;END OF STRING
	CAIE T,"\"
	JRST PERM12
	PUSH P,TT		;SAVE THIS
	MOVEI TTT,B		;GET POINTER TO BYTE POINTER
	PUSHJ P,SKIPBS		;SKIP BS STUFF
	SKIPA T,TT		;NO SKIP IF NOTHING THERE
	JRST [	MOVE T,TT
		POP P,TT
		JRST PERM13]	;WAS BS, LOOP BACK FOR CHECK
	POP P,TT
PERM12:	CAIE T," "
	JRST PERM11
MWL,<	TRNN PETIT	>
MDPC,<	TRNN M,SPACES	>
	JRST ENDGET
PERM11:
DEC,<	CAIN T,11
	POPJ P,
>;DEC
	CAIE T,";"
	AOS (P)
	POPJ P,
                                                                                                                                                                                                                                       ;HANDLE QUALIFIER LETTERS AND WIRE RULE NUMBERS
GETQN:
MDPC,<	MOVE C,ESGPTR
	MOVEM C,ESGSAV
	EPUT2
>;MDPC
	SETZM WQNTMP		;CLEAR TMP CELLS
	MOVE C,A		;SAVE CURRENT GET POINTER IN CASE OF ERROR
	XCT GETSIG
	JRST QNERR
	EPUT2
	CAIN TTT,"#"
	JRST DON
	SKIPN TTT,QL2N(TTT)	;GET CODE FOR LETTER
	JRST QNERR		;NO CODE
	HRLM TTT,WQNTMP		;STORE CHARACTER CODE
	XCT GETSIG
	JRST QNERR
	EPUT2
	CAIE TTT,"#"
	JRST DONE
DON:	SETZ T,
DON1:	XCT GETSIG
	JRST QNERR
	EPUT2
	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST DOQ
	IMULI T,=10
	ADDI T,-60(TTT)
	CAILE T,777777		;FIT IN HALFWORD?
	JRST QNERR
	JRST DON1

DOQ:	HRRM T,WQNTMP
DONE:	CAIE TTT,"\"
	JRST QNERR
	HRRZ T,WQNTMP
	HRRZ TT,WQNWRD
	PUSHJ P,WHCHRN
	TLO SFLAG,WHERR
	HRRM T,WQNWRD
	HLRZ T,WQNWRD
	HLRZ TT,WQNTMP
	PUSHJ P,WHCHQ
	TLO SFLAG,WHERR		;GET SIGNAL PRINTED
	HRLM T,WQNWRD
	JRST SIGONE

QNERR:	MOVE A,C
MDPC,<	MOVE C,ESGSAV
	MOVEM C,ESGPTR
>;MDPC
	PUSH P,TTT
	MOVEI TTT,"\"
	EPUTS
	PUSHJ P,PUTIT
	POP P,TTT
	JRST CPOPJ1

^WHCHQ:	JUMPE TT,CPOPJ1
	EXCH T,TT
	JUMPE TT,CPOPJ1
	CAMN T,TT
	JRST CPOPJ1
	HRL T,TTT
	PUSH P,T
	PUTSTR[ASCIZ/MULTIPLE QUALIFIER LETTERS "/]
	PUTBYT @QN2L(T)
	PUTSTR[ASCIZ/" AND "/]
	PUTBYT @QN2L(TT)
	PUTSTR[ASCIZ/"
/]
	POP P,T
	HLRZ TTT,T
	POPJ P,

^WHCHRN:JUMPE TT,CPOPJ1
	EXCH T,TT
	JUMPE TT,CPOPJ1
	CAMN T,TT
	JRST CPOPJ1
	PUSH P,TTT
	IDIVI TT,=100		;SEPERATE NUMBER PART FROM BIT PART
	MOVEM TT,1(P)		;SAVE BIT PART
	IDIVI T,=100		;SEPERATE OTHER ONE
	IOR T,1(P)		;OR BITWISE STUFF TOGETHER
	IMULI T,=100		;PREPARE TO ADD NUMBER PART BACK
	JUMPE TTT,WHRNOK	;IF EITHER NUMBER PART 0, THEN OK
	EXCH TT,TTT
	JUMPE TTT,WHRNOK
	CAMN TT,TTT		;NUMBER PARTS THE SAME?
	JRST WHRNOK		;YES, THEN ON ERROR MESS
	CAMG TT,TTT		;USE LARGER OF NUMBER PARTS
	EXCH TT,TTT
	ADD T,TT
	HRL T,(P)		;SAVE OLD TTT IN T
	MOVEM T,(P)		;THEN BOTH ON STACK
	PUTSTR[ASCIZ/MULTIPLE WIRE RULE NUMBERS /]
	PUSH P,TT
	MOVE T,TTT
	PUSHJ P,DECOUT
	PUTSTR[ASCIZ/ AND /]
	POP P,T
	PUSHJ P,DECOUT
	PUTSTR[ASCIZ/
/]
	POP P,T
	HLRZ TTT,T
	POPJ P,

WHRNOK:	ADD T,TT
	POP P,TTT
	JRST CPOPJ1

;WHEN THESE TABLES ARE CHANGED, BACVER MUST BE INCREMENTED.
;ALSO IF MORE THAN 37 (OCTAL) CHARS ARE IMPLEMENTED, QBITS MUST BE INCREASED
^QL2N:
FOR I_0,"+"-1
<	0
>
	"Z"-"A"+1+1		;USE CODE AFTER Z FOR +
FOR I_"+"+1,"A"-1
<	0
>
FOR I_"A","Z"
<	I-"A"+1
>
FOR I_"Z"+1,"A"+40-1
<	0
>
FOR I_"A"+40,"Z"+40
<	I-40-"A"+1
>
FOR I_"Z"+40+1,177
<	0
>
IFN .-QL2N-200,<PRINTS /QL2N TABLE SCREWED UP.
/>

^QN2L:	"?"
FOR I_"A","Z"
<	I
>
	"+"
REPEAT 40+QN2L-.,<	"?"	>
MWL,<
IFN QBITS-37,<PRINTS/QBITS NOT EQUAL TO 37
/>
>;MWL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;SIGONE, PUTIT, EPUTIT, AND SPTAB
SIGONE:	PUSHJ P,SIGGET		;(ILDB TTT,A IN WLFST.FAI[WL,DRW])
	MOVEM TTT,SIGCHR
	JUMPE TTT,CPOPJ
	CAIE TTT,11
	CAIN TTT,""
	MOVEI TTT,40
	JRST CPOPJ1

PUTIT:	CAMN B,[POINT 7,PERMTB+MXSTLN-1,27]
	JRST [	PUTSTR[ASCIZ/EXPANDED STRING TOO LONG, TRUNCATED TO:
/]
		HRLZ TTT,TTT
		IDPB TTT,B
		TLZ B,7700
		HLRZ TTT,TTT
		PUTSTR PERMTB
		PUTSTR[ASCIZ/
/]
		POPJ P,]
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40			;CONVERT LOWER CASE TO UPPER CASE
	IDPB TTT,B
	POPJ P,

MDPC,<
EPUTIT:	EXCH TTT,ESGPTR
	CAMN TTT,[POINT 7,ESGTAB+ESGTLN-1,34]
	JRST [	EXCH TTT,ESGPTR
		PUTSTR[ASCIZ/EXTRACTED STRING TOO LONG, TRUNCATED TO:
/]
		HRLZ TTT,TTT
		IDPB TTT,ESGPTR
		HLRZ TTT,TTT
		EXCH TTT,ESGPTR
		TLZ TTT,7700
		EXCH TTT,ESGPTR
		PUTSTR ESGTAB
		PUTSTR[ASCIZ/
/]
		POPJ P,]
	EXCH TTT,ESGPTR
	IDPB TTT,ESGPTR
	POPJ P,
>;MDPC

SPTAB:	SGND,,[ASCIZ/GND/]
	SNC,,[ASCIZ/NC/]
DEC,<	SHI,,[ASCIZ/+3/]	>
NODEC,<	SPWR,,[ASCIZ/VCC/]
	SHI,,[ASCIZ/HI/]
	SHI,,[ASCIZ/HIGH/]
>;NODEC
SPLEN__.-SPTAB
                                                                                                                                                                                                                           SUBTTL	ALPHA
^ALPHA:	MOVEM SFLAG,FLGSAV
	SETZ SFLAG,			;INITIALIZE FLAGS
	MOVE TTT,(T)			;COMPARE WORD
	CAME TTT,(TT)			;EQUAL?
	JRST ALPHA1			;NO, THIS IS EASY
	ADD T,[POINT 7,1,6]
	ADD TT,[POINT 7,1,6]
	MOVEM T,TPTRP
	MOVEM TT,TTPTRP
	LDB T,TPTRP
	LDB TT,TTPTRP
	TLO SFLAG,NFLAG1!NFLAG2			;ASSUME BOTH NOT'S
	CAIE T,NOTCHR
	TLZA SFLAG,NFLAG1
	ILDB T,TPTRP
	CAIE TT,NOTCHR
	TLZA SFLAG,NFLAG2
	ILDB TT,TTPTRP
	JRST BEGCOM			;GO CHECK FOR SPACES FIRST

ALPHA2:	CAIN T,";"			;CONVERT THESE
	SETZ T,				;TO END OF STRING SO WE WILL GET TO OTHER LOOP
	CAIN TT,";"
	SETZ TT,
	CAME T,TT
	JRST ALPHAN
	JUMPE T,CHKEND
	ILDB TT,TTPTRP
	ILDB T,TPTRP
BEGCOM:	CAIN T," "
MWL,<	TRNE PETIT	>
MDPC,<	TRNE M,SPACES	>
	JRST SKIPM1
	ILDB T,TPTRP
	JRST BEGCOM

SKIPM1:	CAIN TT," "
MWL,<	TRNE PETIT	>
MDPC,<	TRNE M,SPACES	>
	JRST SKIPM2
	ILDB TT,TTPTRP
	JRST SKIPM1

SKIPM2:	EXCH T,TT
	MOVEI TTT,TPTRP
	CAIN TT,"\"
	PUSHJ P,SKIPBS
	JRST SKIPM4
	JRST SKIPM3

SKIPM4:	EXCH T,TT
	MOVEI TTT,TTPTRP
	CAIN TT,"\"
	PUSHJ P,SKIPBS
	JRST ALPHA2
	TRO SFLAG,BSSEEN	;SET BS SEEN FLAG
	JRST BEGCOM		;(IF FIRST TIME, TBSGTR WILL BE OFF)

SKIPM3:	MOVE TTT,WQNTMP		;SAVE THIS
	MOVEM TTT,WQNTM1
	EXCH T,TT
	MOVEI TTT,TTPTRP
	CAIN TT,"\"
	PUSHJ P,SKIPBS
	JRST [	TRNE SFLAG,BSSEEN;SEEN BS DIF ALREADY?
		JRST BEGCOM
		JRST SKIPM5]	;NO, NO BS SET TBSGTR
	MOVE TTT,WQNTMP		;GET TT BS
	TRNN SFLAG,BSSEEN	;SEEN BS DIF ALREADY?
	CAMN TTT,WQNTM1		;NO, DIFFERENT?
	JRST BEGCOM		;NO, GO CHECK SPACES AGAIN
	CAMG TTT,WQNTM1		;COMPARE TO T BS
SKIPM5:	TRO SFLAG,TBSGTR	;T BS .GT. TT BS
	TRO SFLAG,BSSEEN	;FLAG DIFFERENCE SEEN
	JRST BEGCOM		;GO CHECK SPACES AGAIN

CHKEND:	TLNN SFLAG,NFLAG1
	JRST CHKEN1
	TLNN SFLAG,NFLAG2
	JRST FLAGJ1		;TT LESS THAN T
	JRST CHKEN2

CHKEN1:	TLNE SFLAG,NFLAG2
	JRST FLAGJ		;T LESS THAN TT
CHKEN2:	MOVEI T,2		;AT LEAST EQUIVALENT
	ADDM T,(P)
	TRNE SFLAG,BSSEEN	;DIFFERNCE IN BS?
	JRST CHKBSE		;YES
	LDB T,TPTRP
	LDB TT,TTPTRP		;GET REAL CHARS BACK
SEMCHK:	CAME T,TT
	JRST ALPHAN
	JUMPE T,FLAGJ2		;EXACTLY EQUAL
	ILDB T,TPTRP
	CAIN T," "
	JRST .-2		;ALWAYS IGNORE SPACES IN COMMENTS
	ILDB TT,TTPTRP
	CAIN TT," "
	JRST .-2
	JRST SEMCHK

CHKBSE:	TRNE SFLAG,TBSGTR	;T BS GREATER THAN TT BS?
	JRST FLAGJ1		;YES, SKIP
	JRST FLAGJ		;NO, NO SKIP

FLAGJ2:	AOSA (P)
ALPHAN:	CAML T,TT
FLAGJ1:	AOS (P)
FLAGJ:	MOVE SFLAG,FLGSAV
	POPJ P,

ALPHA1:	LSH TTT,-1
	MOVE TT,(TT)
	LSH TT,-1
	CAML TTT,TT
	JRST FLAGJ1			;UNEQUAL TT LESS THAN T
	JRST FLAGJ			;UNEQUAL T LESS THAN TT


SKIPBS:	SETZM WQNTMP
	PUSH P,(TTT)			;SAVE BYTE POINTER
	ILDB TT,(TTT)
	CAIN TT,"#"			;NUMBER ONLY?
	JRST SKPBS3
	SKIPN TT,QL2N(TT)		;LEGAL LETTER?
	JRST SKPBSE			;NO
	HRLM TT,WQNTMP			;STORE HERE FOR COMPARE
	ILDB TT,(TTT)			;YES, NEXT CHAR
	CAIE TT,"#"			;NOW NUMBER?
	JRST SKPBS4
SKPBS3:	PUSH P,T
	SETZ T,
SKPBS6:	ILDB TT,(TTT)
	CAIL TT,"0"
	CAILE TT,"9"
	JRST SKPBS5
	IMULI T,=10
	ADDI T,-"0"(TT)
	CAIG T,777777
	JRST SKPBS6
	POP P,T
SKPBSE:	POP P,(TTT)
	LDB TT,(TTT)
	POPJ P,

SKPBS5:	HRRM T,WQNTMP
	POP P,T			;LEGAL NUMBER
SKPBS4:	CAIE TT,"\"		;END WITH \ ?
	JRST SKPBSE		;NO
	ILDB TT,(TTT)		;GET FOLLOWING CHAR
	POP P,(P)		;LOSE SAVED POINTER
	JRST CPOPJ1		;NON-SKIP RETURN TO INDICATE BS CONSTRUCT

BEND SIGSUB
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           COMMENT    VALID 00021 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	LOCS.FAI: ROUTINES WITH KNOWLEDGE OF BOARD LOCATIONS
C00012 00003	SUBTTL	DISPATCH TABLE DEFINITIONS
C00014 00004	THIS IS THE TRANSFER VECTOR WHICH IS SETUP BY THE BOARD TYPE SETTING COMAND
C00016 00005	SUBTTL	L2N,N2L -- LETTER/NUMBER CONVERSION TABLES
C00017 00006	STORAGE(PURE)
C00018 00007	THESE ROUTINES SET UP THE BOARD TYPE
C00022 00008	PUT PIN ON END OF BODY LOCATION
C00023 00009	SUBTTL	LOCPIN -- PRINTS LOCATION AND PIN #
C00025 00010	SUBTTL	TP8LOC,NETPIN
C00027 00011	MORE WL ROUTINES
C00031 00012	SUBTTL	CSLTLT,LOCPNC,LOCPNW,PRCNPN -- CONNECTOR PIN PRINTING STUFF
C00032 00013	SUBTTL	DETECT IF THIS PIN NAME IS "WILD"
C00036 00014	SUBTTL	SLTOUT -- PRINTS DIP BAY/RACK/SLOT #
C00038 00015	SUBTTL	CSLTOUT -- PRINTS CONNECTOR PIN BAY/RACK/SLOT #
C00041 00016	CHKLET TWOLET TWOTAB SLTLN
C00047 00017	GETSLT -- READS A BAY/RACK/SLOT #
C00050 00018	SUBTTL	PUTDEC,NPUTDEC -- DECIMAL OUTPUT ROUTINES
C00051 00019
C00055 00020	DISTANCE CALCULATOR FOR ROUTER STUFF
C00060 00021	NOW INSERT ALL OF THE APPROPRIATE BOARD FILES
C00061 ENDMK
C;
                                                                                                                                    SUBTTL	LOCS.FAI: ROUTINES WITH KNOWLEDGE OF BOARD LOCATIONS

DEFINE FOO ! (A,B)<PRINTS \A!B\>

DEFINE CHECK(TAG,LENGTH)<
IFN .-TAG-LENGTH,<PRINTS /TAG LOSES, .-TAG  /
FOO(<>,\<.-TAG>)
FOO(<, LENGTH = >,\LENGTH)
PRINTS /
/>
>;CHECK

DEFINE ALLBRDS
<
NOSTAN,<BRDNAM(DECPC,L940TV,WDECPC,W940)>
STANFO,<BRDNAM(DECPC,L940TV,WDECPC,<W940[WL,DRW]>)
	BRDNAM(INTEL,LINTTV,WINTTV,<INTEL[WL,DRW]>)
	BRDNAM(AUGU1,AUGU1,WAUGU1,<AUG4[wl,drw]>)	;AUGAT	8136-UG1
	BRDNAM(AUGU6,AUGU6,WAUGU6,)		;AUGAT  8136-UG6
	BRDNAM(AUGCMU,AUGCMU,WAUCMU,)		;AUGAT  AX118-75-[G]
	BRDNAM(AUGHEX,AUGHEX,WAUHEX,)		;AUGAT  8136-LG498-49
	BRDNAM(8136-UG1,AUGU1,WAUGU1,)		; same as AUGU1
	BRDNAM(8136-UG6,AUGU6,WAUGU6,)		; same as AUGU6
	BRDNAM(AX118-75,AUGCMU,WAUCMU,)		; same as AUGCMU
	BRDNAM(8136-LG498,AUGHEX,WAUHEX,)	; same as AUGHEX
	BRDNAM(8136-UG157,AUGDBL,WAUDBL,)	; new "Lang" board
	BRDNAM(UNIVERSAL,LUNITV,WUNITV,<UNIBRD[WL,DRW]>)  ; ROB's universe
>;STANFO
	BRDNAM(W940,L940TV,W940TV,)
	BRDNAM(W941,L940TV,W941TV,)
	BRDNAM(W942,L940TV,W940TV,)
	BRDNAM(W943,L940TV,W941TV,)
NODEC,<
	BRDNAM(W946,L940TV,W946TV,)
ITS,<	BRDNAM(LEBEL,LEBLTV,WEBLTV,LEBEL)>

MWL,<
STANFO,<
	BRDNAM(PG20,LP20TV,WP20TV,<PG20[WL,DRW]>)
	BRDNAM(MSCH1,LMSC1V,MSC1TV,<MSCH1[WL,DRW]>)
;	BRDNAM(LG411,LG411V,WLG411,<ZLG411[WL,DRW]>)
	BRDNAM(LG411,LG411V,WLG411,<LG411[WL,DRW]>)
	BRDNAM(LG434,LG434V,WLG434,)		;IN LG411 FILE
	BRDNAM(LG487,LG487V,WLG487,)		;IN LG411 FILE
	BRDNAM(MDB,LMDBTV,WMDBTV,<MDB[WL,DRW]>)
	BRDNAM(MPG21,LMP21V,MP21TV,<MPG21[WL,DRW]>)
>;STANFO
>;MWL
MD,<
STANFO,<
	BRDNAM(PG20,LP20TV,WP20TV,<PG20[WL,DRW]>)
	BRDNAM(MSCH1,LMSC1V,MSC1TV,<MSCH1[WL,DRW]>)
	BRDNAM(LG411,LG411V,WLG411,<LG411[WL,DRW]>)
	BRDNAM(LG434,LG434V,WLG434,)		;IN LG411 FILE
	BRDNAM(LG487,LG487V,WLG487,)		;IN LG411 FILE
	BRDNAM(MDB,LMDBTV,WMDBTV,<MDB[WL,DRW]>)
	BRDNAM(MPG21,LMP21V,MP21TV,<MPG21[WL,DRW]>)
	BRDNAM(S1MEM,LS1MTV,WS1MTV,<S1MEM[WL,DRW]>)
>;STANFO
>;MD
ITS,<
	BRDNAM(LG411,LG411V,WLG411,LG411)
	BRDNAM(LG434,LG434V,WLG434,)		;IN LG411 FILE
	BRDNAM(PG21,LP21TV,WP21TV,PG21)
	BRDNAM(PG21-60,LP21TV,WP21TV,)
	BRDNAM(PG21-180,LP21TV,WP21TV,)
	BRDNAM(MPG21,LMP21V,MP21TV,MPG21)
>;ITS
>;NODEC
>;DEFINE ALLBRDS

MWL,<DEFINE STORAGE(A)<>>

MDPC,<	VERSION(LOCS,3)	>

COMMENT 

THIS SOURCE FILE (&WWC.FAI) CONTAINS ALL ROUTINES WITH KNOWLEDGE OF
THE EXTERNAL (PRINTED) REPRESENTATION OF LOCATIONS.

THE FOLLOWING ARE THE ONLY CONSTRAINTS ON PICKING LOCATION FORMATS

1)	A BOARD LOCATION (BAY/RACK/SLOT # FOR DEC PDP-10 LIKE STUFF)
	IS 18 BITS, NON-ZERO

2)	A DIP LOCATION IS 18 BITS, OF WHICH AT LEAST THE LOW ORDER
	12 MUST BE NON-ZERO (THE WIRE LISTER USES A DIP LOCATION
	WITH THESE 12 BITS ZERO AS A CONNECTOR BODY.  THIS HACK ASSOCIATES
	CONNECTOR PINS ON THE SAME PADDLE OR JACK)

3)	A DIP PIN # IS 6 BITS, NON-ZERO

4)	A CONNECTOR PIN LOCATION IS 6 BITS OF PADDLE/JACK, NON-ZERO

5)	A CONNECTOR PIN # IS 12 BITS, NON-ZERO (DEC SUBDIVIDES THIS INTO 2
	6-BIT FIELDS, FOR INSTANCE)

ROUTINES KNOWN TO THE OUTSIDE WORLD

FNDBRD		TAKES POINTER TO STRING IN B AND SKIP RETURN WITH BNAMES INDEX IN C
GETBRD		READS BOARD SPECIFICATION AND RETURNS BOARD TYPE IN B
SETBRD		SETS BOARD TYPE IN B (SETS UP TRANSFER VECTOR AND CALLS INITIALIZATION)
BPINPN	DPC	PRINTS PIN # AFTER BODY LOC
SLTLPN	DPC	PRINTS CARD SLOT FOLLOWED BY BODY LOC
PINPLS	DPC	PRINTS DIP PIN # IN + FORMAT
LOCPIN	WL	PRINTS DIP LOCATION AND PIN #
LOCPNP	WL	PRINTS DIP LOCATION AND PIN # IN + FORMAT
LOCPNM	WL	PRINTS DIP LOCATION AND PIN # IN - FORMAT
CSLTLT
PRBCN
QUPIN		CHECKS FOR WILD PIN NAME
SEQLOC	WL	CHECKS FOR SEQUENTIAL LOCATIONS
CONGIN
UGIN
UGINSET
SLTOUT		PRINTS CARD SPEC (BAY/RACK/SLOT)
GETSLT		READS CARD SPEC (BAY/RACK/SLOT)
RPNAM	DPC	READS DEFAULT PIN ID

ROUTINES WHICH ARE A FUNCTION OF THE BOARD TYPE

LCINIT		BOARD INITIALIZATION
LOCOUT		PRINTS DIP LOC ON CARD
CSLTLP	DPC	PRINTS CARD SPEC (IF SPECIFIED) AND CONNECTOR PIN
GTSLTL	DPC	READS CARD SPEC (IF SPECIFIED) AND DIP LOC
GTCONP	D	READS CARD SPEC (IF SPECIFIED) AND CONNECTOR PIN
CSLTLD	D	PRINTS ONLY CONNECTOR PIN (NO CARD LOC) (NOT CALLED BY OUTSIDE)
WLOCOUT	WL	PRINTS WILD/FRONT/BACK CONNECTOR (IF SPECIFIED) AND DIP LOC
LOCPNC	WL	PRINTS CONNECTOR PIN USING CONNECTOR-BODY/PIN-# FORMAT
LOCPNW	WL	  "	   "	  "    "       "       "   "    (CHECKS FOR WILD PINS)
PRCNPN	WL	PRINTS CONNECTOR PIN WITHOUT PADDLE SPEC
GETLOC	WL	READS DIP OR CONNECTOR PIN SPEC
PADPRT	WL	PRINTS PADDLE NAME
RAYDIP	WL	PRINTS DIP LOC FOR RAYTHEON OUTPUT (PADS #'S WITH LEADING ZEROES)
RAYCON	WL	PRINTS CONNECTOR LOC FOR RAYTHEON OUPUT( "     "     "       "  )

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      SUBTTL	DISPATCH TABLE DEFINITIONS

;HERE WE DEFINE INDICIES FOR SPECIAL BOARD TYPES

DEFINE MAKDEF(BOARD,INDEX)
<
DEFINE BRDNAM(NAME,LOCS,WWC,INSERT)
<IFIDN<BOARD><NAME><INDEX__...TMP	MWL,<^INDEX__INDEX>>
...TMP__...TMP+1
>
...TMP__0
ALLBRDS
>

MDPC,<

DEC,<	MAKDEF(DECPC,DEFBRD)
MD,<	MAKDEF(DECPC,INIBRD)	>
MPC,<	MAKDEF(DECPC,INIBRD)	>
>;DEC

NODEC,<	MAKDEF(W940,DEFBRD)
	INIBRD__-1
>;NODEC

>;MDPC

MWL,<
DEC,<MAKDEF(DECPC,INIBRD)>
NODEC,<INIBRD__-1>
>;MWL

DEFINE BRDNAM (NAME,LOCS,WWC,INSERT)
<	POINT 7,[ASCIZ \NAME\]
>

	POINT 7,[ASCIZ \BOARD NOT SPECIFIED\]
BNAMES:	ALLBRDS
MWL,<^BNAMES_BNAMES>
NBRDS__.-BNAMES

DEFINE BRDNAM (NAME,LOCS,WWC,INSERT)
<	LOCS
>

	LNOBRD				;BOARD TYPE -1 IS "BOARD UNSPECIFIED"
LOCTVV:	ALLBRDS
CHECK LOCTVV,NBRDS

MWL,<
DEFINE BRDNAM (NAME,LOCS,WWC,INSERT)
<	WWC
>

	WNOBRD				;BOARD TYPE -1 AGAIN
WWCTVV:	ALLBRDS
CHECK WWCTVV,NBRDS
>;MWL
                                                                                                                                                                                                                                                                                                                                                          ;THIS IS THE TRANSFER VECTOR WHICH IS SETUP BY THE BOARD TYPE SETTING COMAND
;THERE IS A SIMILAR OBJECT IN WWC

STORAGE(IMPURE)

LOCSTV__.

LCINIT:	JRST NBOARD
MWL,<^LCINIT_LCINIT>
LOCOUT:	JRST NBOARD
MWL,<^LOCOUT_LOCOUT>

MDPC,<
CSLTLP:	JRST NBOARD
MWL,<^CSLTLP_CSLTLP>
GTSLTL:	JRST NBOARD
MWL,<^GTSLTL_GTSLTL>

MD,<
^GTCONP:	JRST NBOARD
 CSLTLD:	JRST NBOARD	;I LEFT THE UP ARROW OUT ON PURPOSE
>;MD
>;MDPC

MWL,<
^WLOCOUT:	JRST NBOARD
^LOCPNC:	JRST NBOARD
^LOCPNW:	JRST NBOARD
^PRCNPN:	JRST NBOARD
^GETLOC:	JRST NBOARD
^PADPRT:	JRST NBOARD
^RAYDIP:	JRST NBOARD
^RAYCON:	JRST NBOARD
PJ,<
^WSCDIP:	JRST NBOARD
^WSCCON:	JRST NBOARD
>;PJ
>;MWL
LTVLNJ__.-LOCSTV		;LENGTH OF PART WITH JRST'S
SLTCUE:	[0]
MWL,<^SLTCUE_SLTCUE>
MDPC,<
CPCUE:	[0]
MWL,<^CPCUE_CPCUE>
BODCUE:	[0]
MWL,<^BODCUE_BODCUE>
>;MDPC
MWL,<
^WBDCUE:	[0]
^CBCUE:		[0]
>;MWL

LTVLEN__.-LOCSTV

BRDTYP:INIBRD			;INDEX INTO BNAMES
MWL,<^BRDTYP_BRDTYP>
BRDTMP:	0			;FLAG USED IN BOARD NAME SEARCH

STORAGE(PURE)

PINCUE:	[ASCIZ/#/]
MWL,<^PINCUE_PINCUE>
NBOARD:
MWL,<^NBOARD_NBOARD>
	OUTSTR [ASCIZ /SORRY - NO BOARD TYPE
/]
	POPJ P,

;TRANSFER VECTOR FOR UNSPECIFIED BOARD

LNOBRD:	REPEAT LTVLNJ
<	JRST NBOARD
>
	REPEAT LTVLEN-LTVLNJ
<	[0]
>
   SUBTTL	L2N,N2L -- LETTER/NUMBER CONVERSION TABLES

STORAGE(IMPURE)

L2NLEN__100	;LETTER/NUMBER CONVERSION TABLE LENGTHS
N2LLEN__100

L2N:	BLOCK L2NLEN		;LEAVE CONTIGUOUS AND IN THIS ORDER
MWL,<^L2N_L2N>
N2L:	BLOCK N2LLEN
MWL,<^N2L_N2L>
MAXN2L:	0
MWL,<^MAXN2L_MAXN2L>

DEFINE L2N2L (I,J) <
	ORG L2NSUB+"I"-"A"
	MDPC,<J+>NNN
	ORG N2LSUB+NNN
	"I"
NNN__NNN+1
>
                                                                                                                                                                                                                                                                   STORAGE(PURE)
DEFINE CHKBRD
<	SKIPGE BRDTYP
	JRST NBOARD
>

MWL,<
	CHRREG__TTT
	NUMREG__A
	DEFINE DESTIN <SLICEL>
	DEFINE GETCH <	XCT GETCHR
			 JFCL
>
	DEFINE GETNUM <	PUSHJ P,DECIN
			 JFCL
>
	DEFINE TGETNUM < PUSHJ P,TDECIN
			  JFCL
>
>;MWL

MDPC,<	CHRREG__C
	NUMREG__T
	DEFINE DESTIN <LETTER>

DEFINE GETCH <	XCT GTCHRX
>

DEFINE GETNUM <	PUSHJ P,GETDEC
>


GETDEC:	SETZ NUMREG,
GTDEC1:	GETCH
	CAIL CHRREG,"0"
	CAILE CHRREG,"9"
	POPJ P,
	IMULI NUMREG,=10
	ADDI NUMREG,-"0"(CHRREG)
	JRST GTDEC1

RPNAM:	CHKBRD
MWL,<^RPNAM_RPNAM>
	GETNUM
	JRST CPOPJ1
>;MDPC
                            ;THESE ROUTINES SET UP THE BOARD TYPE

;TAKES POINTER TO STRING IN FREE STORAGE IN B
;AND SKIP RETURN WITH BNAMES INDEX IN C

FNDBRD:
MWL,<^FNDBRD_FNDBRD>
	PUSH P,B
	SETOM BRDTMP		;CLEAR PARTIAL MATCH STORAGE
	MOVSI C,-NBRDS		;LENGTH OF TABLE
FNDBR1:	MOVE T,BNAMES(C)	;GET BYTE POINTER
	MOVE B,(P)		;AND POINTER TO STRING
	ADD B,[POINT 7,1]
FNDBR2:	ILDB TT,T		;NEXT CHAR OF BOARD NAME
	TLNE B,760000		;END OF WORD?
	JRST FNDBR3		;NO
	HRR B,-1(B)
	TRNN B,-1
	JRST FNDBR4		;END OF SOURCE STRING
FNDBR3:	ILDB TTT,B		;NEXT CHAR OF SOURCE STRING
	JUMPE TTT,FNDBR4	;END OF SOURCE STRING?
	CAMN TTT,TT		;STILL MATCH?
	JRST FNDBR2		;YES, CONTINUE
FNDBR5:	AOBJN C,FNDBR1		;NO, TRY NEXT BOARD
	HRRE C,BRDTMP
	SKIPL C
FNDBR7:	AOS -1(P)
FNDBR6:	POP P,B
	POPJ P,

FNDBR4:	JUMPE TT,[HRRZ C,C
		JRST FNDBR7]	;EXACT MATCH
	SKIPL BRDTMP		;PREVIOUS PARTIAL MATCH?
	JRST [	SETOM BRDTMP
		HRRZS BRDTMP	;FLAG MULTIPLE PARTIAL MATCHES
		JRST FNDBR5]	;TRY FOR EXACT MATCH
	HRRZM C,BRDTMP
	JRST FNDBR5
;GETS BOARD NAME FROM TTY, LOOKS IT UP, AND SETS IT UP

GETBRD:
MWL,<^GETBRD_GETBRD>
MDPC,<	TLNN M,DSKACT!MACACT	>
	OUTSTR [ASCIZ /BOARD TYPE?/]
	PUSHJ P,TREADU				;DOES CASE CONVERSION
	    POPJ P,				;ALTMODE
MDPC,<	    JRST [	MOVE B,BRDTYP		;NULL
			OUTSTR @BNAMES(B)
			POPJ P,]
>;MDPC
MWL,<	    POPJ P,	>
	PUSHJ P,FNDBRD				;FIND THAT BOARD TYPE
	 JRST [	PUSHJ P,PUTFS
		OUTSTR [ASCIZ /BOARD NOT FOUND
/]
		POPJ P,]
	PUSHJ P,PUTFS
	HRRZM C,BRDTYP
MDPC,<	TLNN M,DSKACT!MACACT	>
	OUTSTR @BNAMES(C)		;TYPE THE BOARD NAME FOR THE PEOPLE
MWL,<	OUTSTR[ASCIZ/
/]
>;MWL
	JRST SETBRD

;GIVEN THE BOARD TYPE IN BRDTYP, SETS UP TRANSFER VECTORS AND CONVERSION TABLES

CLRBRD:
MWL,<^CLRBRD_CLRBRD>
	MOVE B,[INIBRD]
	MOVEM B,BRDTYPE
SETBRD:
MWL,<^SETBRD_SETBRD>
	MOVE B,BRDTYP
	HRL C,LOCTVV(B)		;SET UP LOCS TRANSFER VECTOR
	HRRI C,LOCSTV
	BLT C,LOCSTV+LTVLEN-1
	SKIPL BRDTYP		;NO SPECIFIC BOARD?
	PUSHJ P,LCINIT		;SET UP LETTER/NUMBER CONVERSION TABLES
MWL,<
	HRL C,WWCTVV(B)		;SET UP WWC TRANSFER VECTOR
	HRRI C,WWCTV
;;;;;ASSEMBLER BUG WANTS TO BE:	 BLT C,WWCTV+WTVLEN-1
	MOVEI B,WWCTV
	PUSHJ P,WWCBLT		;GETS AROUND ASSEMBLER BUG (WTVLEN DEFINED IN WWC)
;;;;;END ASSEMBLER BUG FIX
	MOVE B,BRDTYP
	SKIPN ISWW		;ONLY WIRE WRAP BOARDS HAVE WWINIT
	POPJ P,
	MOVEI T,=1000
	IDIV T,FRACTN	;CALCULATE SMALLEST POSSIBLE DISTANCE BETWEEN WW PINS
	MOVEM T,SMALL
	PUSHJ P,WWINIT		;WIRE WRAP INITIALIZATION

>;MWL
	POPJ P,
                                                                               ;PUT PIN ON END OF BODY LOCATION

MDPC,<
BPINPN:
MWL,<^BPINPN_BPINPN>
	CHKBRD
	PUTBYT "("
	MOVE T,A
	PUSHJ P,PUTDEC
	PUTBYT ")"
	POPJ P,

SLTLPN:
MWL,<^SLTLPN_SLTLPN>
	CHKBRD
	PUSHJ P,SLTOUT
	HLRZ A,A
	JRST LOCOUT

PINPLS:
MWL,<^PINPLS_PINPLS>
	CHKBRD
	HLRZ T,A
	PUSHJ P,PUTDEC
MD,<	TRNE A,R1416
	JRST [	CAML A,[8,,0]
		PUTSTR [ASCIZ/+2/]
		POPJ P, ]
	TRNE A,L1416
	PUTBYT "+"
>;MD
	POPJ P,
>;MDPC
                                                                                                                                                                                                                SUBTTL	LOCPIN -- PRINTS LOCATION AND PIN #
MWL,<

^LOCPIN:CHKBRD
	PUSHJ P,LOCOUT
	PUTBYT "("
	HLRZ T,A
	PUSHJ P,PUTDEC
	PUTBYT ")"
	POPJ P,

;LOCPNM -- PRINTS ABSOLUTE PIN LOCATION ON WIRE-WRAP SIDE

^LOCPNM:CHKBRD
	PUSH P,T
	PUSHJ P,LOCOUT
	PUTBYT "("
	HLRZ T,A
	MOVE TT,(P)
	TRNE TT,R1416
	JRST [	CAIL T,8
		ADDI T,2
		JRST LCPNM3 ]
	TRNE TT,L1416
	ADDI T,1
LCPNM3:	PUSHJ P,PUTDEC
	POP P,T

STANFO,<
MDPC,<	TRNE T,R1416
	JRST [	CAML A,[8,,0]
		PUTSTR [ASCIZ/-2/]
		JRST LCPNM2 ]
	TRNE T,L1416
	PUTBYT "-"
>;MDPC
>;STANFO
NOSTAN,<TRNE T,R1416
	JRST [	CAML A,[8,,0]
		PUTSTR [ASCIZ/-2/]
		JRST LCPNM2 ]
	TRNE T,L1416
	PUTBYT "-"
>;NOSTAN
LCPNM2:	PUTBYT ")"
	POPJ P,

^LOCPNP:CHKBRD
	PUSH P,T
	PUSHJ P,LOCOUT
	PUTBYT "("
	HLRZ T,A
	PUSHJ P,PUTDEC
	POP P,T
	TRNE T,R1416
	JRST [	CAML A,[8,,0]
		PUTSTR [ASCIZ/+2/]
		JRST LCPNP2 ]
	TRNE T,L1416
	PUTBYT "+"
LCPNP2:	PUTBYT ")"
	POPJ P,
                                                                                                                                                                                                                                                                                                                                               SUBTTL	TP8LOC,NETPIN
DEC,<
;PRINTS LOCATION AND PIN # FOR TAPR-8 OUTPUT
;NUMBER OF PIN ON DIP IN T
;BODY BITS IN TT
;LOCATION (DIP,,PIN) IN A
^TP8LOC:CHKBRD
	TRNE TT,CBODY		;CONNECTOR?
	JRST TP8CON		;YES
	LDB TT,[POINT 6,A,5]
	MOVE TT,N2L(TT)		;GET LOC LETTER IN CASE NON-STANDARD
	CAIN T,=14
	MOVEI TT,"E"		;STANDARD FOR 14 PIN
	CAIN T,=16
	MOVEI TT,"F"		;16 PIN
	CAIN T,=24
	MOVEI TT,"G"		;24 PIN
	PUTBYT (TT)
	LDB T,[POINT 12,A,17]
	CAILE T,=99
	JRST TP8ERR
	MOVEI TT,2
	MOVEM TT,NDIG
	PUSHJ P,NPUTDEC
	HRRZ T,A
	CAILE T,=99
	JRST TP8ERR
	MOVEI TT,2
	MOVEM TT,NDIG
	JRST NPUTDEC

TP8CON:	LDB T,[POINT 6,A,5]
	PUTBYT @N2L(T)
	LDB T,[POINT 6,A,29]
	PUTBYT @N2L(T)
	MOVEI T,2
	MOVEM T,NDIG
	LDB T,[POINT 6,A,35]
	JRST NPUTDEC

TP8ERR:	OUTSTR[ASCIZ\ILLEGAL DIP AND/OR PIN #
\]
	POPJ P,

;PRINT PIN NUMBER FOR CS FILE
^NETPIN:
	MOVE T,A
	JRST DECOUT

;PRINT BP PIN FOR CS
^PRCSBP:
	LDB T,[POINT 5,A,26]
	LDB TT,[POINT 6,A,5]
	ADDI T,-1(TT)
	PUTBYT @N2L(T)
	LDB T,[POINT 6,A,35]
	MOVEI TT,2
	MOVEM TT,NDIG
	PUSHJ P,NDECOUT
	PUTBYT 40
	LDB T,[POINT 6,A,17]
	SUBI T,1
	IMULI T,=18
	LDB TT,[POINT 6,A,11]
	ADD T,TT
	MOVEI TT,2
	MOVEM TT,NDIG
	JRST NDECOUT
>;DEC
                                                      ;MORE WL ROUTINES

;SEPARATE CONNECTOR PIN BODY LOC (PADDLE) FROM PIN # (PIN, SIDE)
^CPNSEP:CHKBRD
	MOVE TT,T
	ANDI T,770000
	ANDI TT,7777
	POPJ P,

;MERGE CONNECTOR PIN BODY LOC WITH PIN #
^CPNMER:CHKBRD
	DPB TT,[POINT 12,T,35]
	POPJ P,

;PRINT CONNECTOR PIN NAME AS SEEN FROM BACK PANEL
^BPNPIN:CHKBRD
	PUSH P,T	;SAVE OFFSET HERE
	LDB T,[POINT 4,A,3]
	SKIPE T		;CONVERT 0 TO SPACE
	ADDI T,20	;ALL THE REST TO DIGITS
	ADDI T,40
	PUTBYT (T)
	LDB T,[POINT 5,A,8]
	LDB TT,[POINT 6,A,23]
	ADDI T,-1(TT)
	CAILE T,77
	SETZ T,
	PUTBYT @N2L(T)
	MOVEI T,2
	MOVEM T,NDIG
	LDB T,[POINT 6,A,17]
	POP P,TT
	JUMPE TT,NOOFFS
	ADD T,TT
	JUMPLE T,[OUTSTR[ASCIZ/OFFSET CAUSED SLOT NUMBER TO BE ZERO OR NEGATIVE.
/]
		SETZ T,
		JRST NOOFFS]
	CAIG T,=99
	JRST NOOFFS
	OUTSTR[ASCIZ/OFFSET CAUSED SLOT NUMBER TO BE MORE THAN 2 DIGITS.
/]
	MOVEI T,=99
NOOFFS:	PUSHJ P,NDECOUT
	LDB T,[POINT 6,A,29]
	PUTBYT @N2L(T)
	LDB T,[POINT 6,A,35]
	JRST DECOUT

;OUTPUT EDGE PIN TO PARTITION FILE AS NUMBER
^CPARTP:CHKBRD
	LSH T,-14
	PUTBYT "0"(T)
	MOVEI T,2
	MOVEM T,NDIG
	MOVE T,TT
	LSH T,-5
	TRNE TT,1
	SUBI T,1
	JRST NDECOUT

DEC,<
;PRINT PIN NUMBER FOR REDAC
^RDCBPN:CHKBRD
	HLRZ T,A
	JRST DECOUT

;PRINT PIN(A-V) AS NUMBER FOR REDAC
^RDCCPN:CHKBRD
	LDB T,[POINT 6,A,11]
	HLRZ TT,B
	CAILE TT,3
	SETZ TT,
	ADD T,(TT)[	0		;CASE 0 (??)
			0		;CASE 1 (1-18)
			=18		;CASE 2 (19-36)
			2*=18]		;CASE 3 (37-54)
	JRST DECOUT

;PRINT PADDLE ("U") AND NUMBER FOR WILD PIN
^RDCUCN:CHKBRD
	LDB T,[POINT 5,A,23]
	PUTBYT @N2L(T)
	LDB T,[POINT 11,A,17]
	JRST DECOUT

;PRINT CONNECTOR PADDLE AND SIDE
^RDCCPD:CHKBRD
	LDB T,[POINT 5,A,23]
	PUTBYT @N2L(T)
	LDB T,[POINT 6,A,17]
	JRST DECOUT

;PRINT NUMBER FOR CONNECTOR IN A FOR SR FILE
^SRCPNM:CHKBRD
	LDB T,[POINT 6,A,23]
	SUBI T,1
	TLNN A,4000	;WILD PIN?
	CAILE T,5	;OR ILLEGAL PADDLE?
	JRST SRCPER
	LDB TT,[POINT 6,A,17]
	CAIL TT,1
	CAILE TT,2
	JRST SRCPER
	SUBI TT,1
	LDB TTT,[POINT 5,A,11]
	SUBI TTT,1
	TRNE TT,1		;SIDE 2?
	TRO TTT,40		;YES, LOOK THERE
	SKIPGE SRPTAB(TTT)
	JRST SRCPER
	IMULI T,=33
	ADD T,SRPTAB(TTT)
	JRST PUTDEC

SRPTAB:
FOR I_4,=18
<	I		;A1-S1
>
	-1		;T1
FOR I_=19,=20
<	I		;U1-V1
>
REPEAT 40-<.-SRPTAB>,<-1>
	-1		;A2
	=21		;B2
	-1		;C2
FOR I_=22,=36		;D2-V2
<	I
>
REPEAT 100-<.-SRPTAB>,<-1>

SRCPER:	PUTSTR[ASCIZ/***/]
	POPJ P,
>;DEC
>;MWL
                                                                                                                                                        SUBTTL	CSLTLT,LOCPNC,LOCPNW,PRCNPN -- CONNECTOR PIN PRINTING STUFF

CSLTLT:
MWL,<^CSLTLT_CSLTLT>
MD,<	CHKBRD
	PUSHJ P,SLTOUT
	JRST CSLTLD
>;MD

MWL,<
^PRBCN:	CHKBRD
	PUSH P,A
	TRZ A,7777
	PUSHJ P,LOCOUT
	POP P,A
	JRST PRCNPN
>;MWL
                                                                                                                                                                                                                                                                                                                                                                                                       SUBTTL	DETECT IF THIS PIN NAME IS "WILD"
;CALL WITH PIN NAME IN RH(A)
QUPIN:
MWL,<^QUPIN_QUPIN>
	CHKBRD
	PUSH P,A
	LSH A,-14
	ANDI A,77
	MOVE A,N2L(A)
	CAIE A,"U"
	JRST [	POP P,A
		POPJ P,]
	POP P,A
	ANDI A,3777
	PUSH P,B
	IDIVI A,=200
	POP P,B
	CAILE A,2
	TDZA A,A
	ADDI A,1
	JRST CPOPJ1

MWL,<
;THESE ROUTINES SHOULD BE MOVED EVENTUALLY, THEY ARE A FUNCTION OF THE BOARD TYPE

;CALL WITH LESSER OF TWO LOCS IN T
;GREATER IN TT
^SEQLOC:CHKBRD
	XOR T,TT
	TRNE T,770000		;LETTERS SHOULD BE THE SAME
	POPJ P,			;ELSE NOT IN SEQUENCE
	XOR T,TT
	SUB TT,T
	CAIN TT,1
	AOS (P)
	POPJ P,

^CONGIN:CHKBRD
	PUSH P,A
	HRRZ A,A
	JUMPE A,CONG1
	TRNN A,2
	JRST [	TRC A,3
		JRST CONG3]
	LSH A,-6
	ANDI A,77
	ADDI A,1
	CAIG A,=18
	JRST [	LSH A,6
		TRO A,1
		DPB A,[POINT 12,(P),35]
		POP P,A
		JRST CPOPJ1]
	LDB A,[POINT 6,(P),23]
	ADDI A,1
	PUSH P,T
	LDB T,[POINT 3,-1(P),11]		;GET EXTENT
	CAIG A,1(T)			;DOES THIS PADDLE EXIST?
	JRST [	POP P,T
		JRST CONG2]
	POP P,T
	POP P,A
	POPJ P,

;VARIOUS FLAVORS OF RETURN FOR CONGIN

CONG1:	HRRZ A,L2N-"A"+"A"
CONG2:	LSH A,6
	IOR A,L2N-"A"+"A"
	HRRZ A,A		;CLEAR ANY LH GARBAGE
	LSH A,6
	TRO A,1
CONG3:	HRRM A,(P)
	POP P,A
	JRST CPOPJ1

;CALL WITH C(A) POINTER TO LAST PIN GENERATED
DEC,<
^UGIN:	CHKBRD
	TRNE A,OUTLD
	JRST [	MOVEI A,UGINP2
		JRST UGIN1]
	TRNE A,TERM
	JRST [	MOVEI A,UGINP3
		JRST UGIN1]
	MOVEI A,UGINP1
UGIN1:	SKIPGE (A)
	POPJ P,			;RAN OUT
	PUSH P,T
	HLRZ T,(A)
	ADDI T,1
	CAMLE T,1(A)			;OVERFLOW?
	JRST UGINER
	HRLM T,(A)
	POP P,T
	MOVE A,(A)
	JRST CPOPJ1

UGINER:	POP P,T
	SETOM (A)
	OUTSTR[ASCIZ/RAN OUT OF GENERATED "U" PINS IN THE RANGE /]
	OUTSTR 2(A)
	OUTSTR[ASCIZ/.
NO MORE PINS WILL BE GENERATED IN THIS RANGE.
/]
	POPJ P,

^UGINSET:CHKBRD
	HRRZ T,L2N-"A"+"U"
	LSH T,14
	HRLI T,4000+0
	MOVEM T,UGINP1
	HRLI T,4000+=199
	MOVEM T,UGINP2
	HRLI T,4000+=399
	MOVEM T,UGINP3
	POPJ P,

UGINP1:	0
	4000+=199
	ASCIZ/U100-U199/

UGINP2:	0
	4000+=399
	ASCIZ/U200-U399/

UGINP3:	0
	4000+=599
	ASCIZ/U400-U599/
>;DEC
>;MWL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                SUBTTL	SLTOUT -- PRINTS DIP BAY/RACK/SLOT #

COMMENT 

|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|				   
|       3         8    11          17                    		|
|   4   |    5    |  3  |     6     |               18                  |
|_______|_________|_____|___________|___________________________________|
    |	     |	     |	      |			     |
    |	     |	     |	      |			     |
<   |	     |	     |	      |			     |>NOT USED
    |	     |	     |	      |
<   |        |       |        |------------------------------------------># SLOT
    |        |       |
<   |        |       |--------------------------------------------------->L +RACK
    |        |
<   |        |----------------------------------------------------------->L RACK
    |
<   |--------------------------------------------------------------------># BAY


SLTOUT:
MWL,<^SLTOUT_SLTOUT>
	CHKBRD
	LDB T,[POINT 4,A,21]
	JUMPE T,.+2
	PUSHJ P,PUTDEC
	LDB TT,[POINT 5,A,26]
MDPC,<	JUMPE TT,CPOPJ	>
	PUTBYT @N2L(TT)
	LDB TTT,[POINT 3,A,29]
	JUMPE TTT,SLTOU1
	ADD TT,TTT
	PUTBYT @N2L(TT)
SLTOU1:	MOVEI T,2
	MOVEM T,NDIG
	LDB T,[POINT 6,A,35]
	JRST NPUTDEC
                                                                  SUBTTL	CSLTOUT -- PRINTS CONNECTOR PIN BAY/RACK/SLOT #

COMMENT 

|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|
|	    |			   18      21        26    29          35
|     6     |          12	    |   4   |    5    |  3  |     6     |
|___________|_______________________|_______|_________|_____|___________|
      |			|		|	 |	 |	  |
<     |			|		|	 |	 |	  |------># SLOT
      |			|		|	 |	 |
<     |			|		|	 |	 |--------------->L +RACK
      |			|		|	 |
<     |			|		|	 |----------------------->L RACK
      |			|		|
<     |			|		|--------------------------------># BAY
      |			|
<     |			|------------------------------------------------># PIN
      |
<     |------------------------------------------------------------------>L LOCATION

MD,<
CSLTOUT:
	JRST SLTOUT			;DO SAME AS BODY LOC.
IFN 0,<;REMOVE BY R HELLIWELL 31 MAR 75
;CONFUSING BECAUSE DISPLAYED AND PLOTTED CONNECTOR PIN DESIGNATOR
;WERE DIFFERENT FROM TYPEIN AND TYPEOUT.
	TRNN A,-1
	POPJ P,
	LDB T,[POINT 3,A,29]
	LDB TT,[POINT 6,A,5]
DEC,<	TLNN A,4000	>		;"U" PIN?
	CAILE TT,1(T)			;ON BACK PANEL?
	JRST SLTOUT			;NO, TREAT LIKE A BODY
	LDB T,[POINT 4,A,21]		;SHOW ACTUAL BACKPANEL RACK LETTER
	SKIPE T
	PUSHJ P,PUTDEC
	LDB TT,[POINT 5,A,26]
	LDB T,[POINT 6,A,5]
	ADDI TT,-1(T)
	PUTBYT @N2L(TT)
	LDB T,[POINT 6,A,35]
	JRST PUTDEC
>;IFN 0
>;MD
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;CHKLET TWOLET TWOTAB SLTLN

;CHKLET
;CHECK TO MAKE SURE CHRREG IS A LETTER (CONVERTS LOWER CASE)
;ENTER WITH CHARACTER IN CHRREG
;CALL
;	PUSHJ P,CHKLET
;	JRST NOT.A.LETTER
;	JRST GOT.LETTER.IN.CHRREG
;
CHKLET:CAIL CHRREG,"a"		;CHECK FOR LOWER CASE
	CAILE CHRREG,"z"
	CAIA			;NOT LOWER CASE
	SUBI CHRREG,<"a"-"A">	;CONVERT TO UPPER CASE
	CAIL CHRREG,"A"
	CAILE CHRREG,"Z"
	POPJ P,
	JRST CPOPJ1		;ITS LEGAL

TWOLET:ROT CHRREG,-7*2	;MAKE IT ASCII
	MOVSI NUMREG,-TWOLEN
TWOLT1:	CAME CHRREG,TWOTAB(NUMREG)
	AOBJN NUMREG,TWOLT1
	JUMPGE NUMREG,CPOPJ
	MOVEI NUMREG,40(NUMREG)
	JRST CPOPJ1

TWOTAB:	ASCII/BT/
	ASCII/CB/
	ASCII/CR/
	ASCII/DL/
	ASCII/FC/
	ASCII/TP/
REPEAT 40-<.-TWOTAB>,<ASCII/??/>
TWOLEN__.-TWOTAB

MDPC,<
;THE CANONICAL DIP LOC READER WHERE DIP LOC IS OF FORM L#
;SLTLN -- READS A BAY/RACK/SLOT/DIPLOC OR JUST A DIPLOC
;CALL IS:
;	PUSHJ P,SLTLN
;	JRST ERROR
;	JRST CRLF.ONLY
;MD,<	JFCL	>	;LOC ONLY
;	(BRS,,LOC IN DESTIN)

SLTLN:	SETZM DESTIN
MPC,<	GETCH	>
MD,<	GETNUM
	CAIL NUMREG,20
	POPJ P,
	DPB NUMREG,[POINT 4,DESTIN,3]
>;MD
	CAIN CHRREG,12
	JUMPE NUMREG,CPOPJ1
	PUSHJ P,CHKLET
	POPJ P,
MD,<	PUSH P,D
	SKIPN D,L2N-"A"(CHRREG)
	JRST POPDJ
	DPB D,[POINT 5,DESTIN,8]
	GETNUM
	PUSHJ P,CHKLET
	JRST SLTLN1
	JUMPL D,SLTLN3		;GIOQ ILLEGAL FOR BRS
	POP P,D
	JUMPN NUMREG,SLTLN2
	LDB NUMREG,[POINT 5,DESTIN,8]
	SKIPN CHRREG,L2N-"A"(CHRREG)
	POPJ P,
	JUMPL CHRREG,[SUB CHRREG,NUMREG
		JRST SLTLN4]
	SUB CHRREG,NUMREG
	JUMPLE CHRREG,SLTLN4
	CAILE CHRREG,7	
	JRST SLTLN4
	DPB CHRREG,[POINT 3,DESTIN,11]
	GETNUM
	JUMPE NUMREG,CPOPJ
	PUSHJ P,CHKLET
	JRST SLTLN8
SLTLN2:	CAILE NUMREG,77
	POPJ P,
	DPB NUMREG,[POINT 6,DESTIN,17]
>;MD
	SKIPN CHRREG,L2N-"A"(CHRREG)
	POPJ P,
	DPB CHRREG,[POINT 6,DESTIN,23]
	GETNUM
	JUMPE NUMREG,SLTLN5
SLTLN7:	CAILE NUMREG,7777
	POPJ P,
	DPB NUMREG,[POINT 12,DESTIN,35]
MD,<	HLRZ NUMREG,DESTIN
	JUMPN NUMREG,CPOPJ3	;THIS RETURN IF BRS TYPED
>;MD
	JRST CPOPJ2		;THIS RETURN IF PC OR NO BRS

SLTLN5:	LDB NUMREG,[POINT 6,DESTIN,23]
	MOVE NUMREG,N2L(NUMREG)
	LSH NUMREG,7
	IOR CHRREG,NUMREG
	PUSHJ P,TWOLET
	POPJ P,
	DPB NUMREG,[POINT 6,DESTIN,23]
	GETNUM
	JUMPN NUMREG,SLTLN7
	POPJ P,

MD,<
SLTLN1:	POP P,D
	JUMPE NUMREG,CPOPJ
	CAILE NUMREG,7777
	POPJ P,
	DPB NUMREG,[POINT 12,DESTIN,35]
	LDB NUMREG,[POINT 9,DESTIN,8]
	CAIL NUMREG,40
	POPJ P,
	DPB NUMREG,[POINT 24,DESTIN,23]
	JRST CPOPJ2

SLTLN3:	MOVE D,N2L(D)		;GET LETTER BACK
	LSH D,7
	IOR CHRREG,D		;PUT 2 LETTERS IN CHRREG
	POP P,D			;RESTORE D
	PUSHJ P,SLTLN6
	POPJ P,
	JRST SLTLN9

SLTLN4:	PUSHJ P,SLTLN0
	POPJ P,
SLTLN9:	GETNUM
	JUMPN NUMREG,SLTLN7
	POPJ P,

SLTLN8:	PUSH P,NUMREG
	PUSH P,CHRREG
	LDB NUMREG,[POINT 5,DESTIN,8]
	LDB CHRREG,[POINT 3,DESTIN,11]
	PUSHJ P,SLTLN0
	JRST [	POP P,CHRREG
		POP P,NUMREG
		POPJ P,]
	POP P,CHRREG
	POP P,NUMREG
	JRST SLTLN7

SLTLN0:	ADD CHRREG,NUMREG	;GET NUMBER BACK
	MOVE NUMREG,N2L(NUMREG)	;GET FIRST LETTER BACK
	MOVE CHRREG,N2L(CHRREG)	;GET SECOND LETTER BACK
	LSH NUMREG,7
	IOR CHRREG,NUMREG
SLTLN6:	LDB NUMREG,[POINT 4,DESTIN,3]
	JUMPN NUMREG,CPOPJ
	PUSHJ P,TWOLET
	POPJ P,
	DPB NUMREG,[POINT 24,DESTIN,23]
	JRST CPOPJ1

POPDJ:	POP P,D
	POPJ P,
>;MD
>;MDPC
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ;GETSLT -- READS A BAY/RACK/SLOT #

;CALL IS:
;	PUSHJ P,GETSLT
;	JRST ERROR
;	JUMPE TT,CRLF.ONLY	;THIS IS OPTIONAL, OBVIOUSLY
;	MOVEM TT,BRS

MWL,<
^GTSLTT:
	CHKBRD
	SETZM DESTIN
	TGETNUM
	JRST GTSLT1
>;MWL

GETSLT:
MWL,<^GETSLT_GETSLT>
	CHKBRD
	SETZM DESTIN
	GETNUM
GTSLT1:	DPB NUMREG,[POINT 4,DESTIN,3]
	PUSHJ P,CHKLET
	JRST [	JUMPE NUMREG,CPOPJ1
		POPJ P,]
	SKIPG CHRREG,L2N-"A"(CHRREG)
	POPJ P,
	DPB CHRREG,[POINT 5,DESTIN,8]
	GETNUM
	JUMPN NUMREG,GTSLT2
	PUSHJ P,CHKLET
	POPJ P,
	SKIPG CHRREG,L2N-"A"(CHRREG)
	POPJ P,
	LDB NUMREG,[POINT 5,DESTIN,8]
	SUB CHRREG,NUMREG
	JUMPL CHRREG,CPOPJ
	CAILE CHRREG,7
	POPJ P,
	DPB CHRREG,[POINT 3,DESTIN,11]
	GETNUM
GTSLT2:	DPB NUMREG,[POINT 6,DESTIN,17]
	JRST CPOPJ1
MD,<
;	PUSHJ P,RDLLN
;	    ERROR RETURN
;	    SUCCESS RETURN

RDLLN:	PUSHJ P,CHKLET	;LOWER TO UPPER CASE
	POPJ P,
	SKIPG CHRREG,L2N-"A"(CHRREG)	;LEGAL LETTER HERE?
	POPJ P,				;NO, FLUSH
	DPB CHRREG,[POINT 12,DESTIN,29]	;ASSUME ITS ONE LETTER
	GETNUM
	JUMPN NUMREG,CKCR		;NUMBER TYPED?
	PUSHJ P,CHKLET			;NO, LEGAL LETTER?
	POPJ P,				;NO, FLUSH
	LDB TT,[POINT 6,DESTIN,29]	;YES, MOVE PREVIOUS LETTER LEFT ONE
	DPB TT,[POINT 6,DESTIN,23]
	SKIPG CHRREG,L2N-"A"(CHRREG)	;NEW LETTER LEGAL?
	POPJ P,				;NO, FLUSH
	DPB CHRREG,[POINT 6,DESTIN,29]	;YES, NESTLE IT NEXT TO PREVIOUS LETTER
	GETNUM				;NEXT CHARACTER
	JUMPE NUMREG,CPOPJ		;COMPLAIN IF ITS NOT A NUMBER
CKCR:
DEC,<	LDB TT,[POINT 12,DESTIN,29]
	XOR TT,L2N+"U"-"A"
	TRNN TT,-1			;SAME LETTER?
	JRST [	CAILE NUMREG,3777	;YES, LEGAL NUMBER?
		POPJ P,			;NO
		HRRZ TT,L2N+"U"-"A"
		DPB TT,[POINT 6,DESTIN,23]
		TRO NUMREG,4000
		DPB NUMREG,[POINT 12,DESTIN,35]
		JRST CPOPJ1]
>;DEC
	CAILE NUMREG,77
	POPJ P,
	DPB NUMREG,[POINT 6,DESTIN,35]
	JRST CPOPJ1
>;MD
                                                                                                                      SUBTTL	PUTDEC,NPUTDEC -- DECIMAL OUTPUT ROUTINES

PUTDEC:
MWL,<^PUTDEC_PUTDEC>
	SETZM NDIG
NPUTDEC:
MWL,<^NPUTDEC_NPUTDEC>
	SKIPGE T
	PUTBYT "-"
	MOVM T,T
NPUTD1:	IDIVI T,=10
	HRLM TT,(P)
	SOSG NDIG
	JUMPE T,.+2
	PUSHJ P,NPUTD1
	HLRZ TT,(P)
	MOVEI TTT,"0"(TT)
	XCT PUTCHR
	POPJ P,

MWL,<
	^DECOUT_PUTDEC
	^NDECOUT_NPUTDEC
>;MWL
                                                                                                                                                                                                                                                                                               
MWL,<

DEFINE SETPAD(NPADS)
<	IFL MAXPAD-<NPADS>,<PRINTS /MAXPAD NOT LARGE ENOUGH.
/>
	NPADS
>

^^WIRGND:	-1		;DEFAULT WIRE GROUNDS FOR DEC BOARDS
^^LNGRID:	0		;-1 ENABLES LETTER NUMBER GRID

^WWCTV__.

^ISWW:		0		;FLAGS IF WIRE WRAP OR PC BOARD
^WWINIT:	JRST NBOARD	;THE WIRE WRAP TRANSFER VECTOR
^MAPRC:		JRST NBOARD
^MAPPAD:	JRST NBOARD
^PINMAP:	JRST NBOARD
^PINBIT:	JRST NBOARD
^VGCON:		JRST NBOARD
^DSTCLC:	JRST NBOARD
^FPWR:		JRST NBOARD
^FGND:		JRST NBOARD
^PGPRTM:	JRST NBOARD
^PGPRNT:	JRST NBOARD
^GNDCLR:	JRST NBOARD
^WAGGND:	JRST NBOARD
^GNDOUT:	JRST NBOARD
^VCCOUT:	JRST NBOARD
^RAYGEN:	JRST NBOARD	;RAYTHEON PRINT GENERATED PIN
PJ,<
^WSCGEN:	JRST NBOARD	;WSC PRINT GENERATED PIN
>;PJ
	NWBLEN__.-WWINIT
^NROWS:		0
^NCOLS:		0
^NCLPRG:	0
DIPSLT:	0		;SHOULD NOT NEED TO BE UP ARROWED
^NPADS:		0
^PADLET:	0
^PADPIN:	0
^FRACTN: 	0		;WIRE LENGTH FRACTION
^WRAPMG:	0		;ADDITIONAL WIRE LENGTH FOR INSULATION AROUND POST
^POSTMG:	0		;ADDITIONAL WIRE LENGTH FOR BARE WIRE  AROUND POST
NEXTR:		0		;CLEARANCE BETWEEN PINS IN ADJACENT SOCKET ROWS--
;(USED ONLY BY BOARDS WHICH HAVE PINS AND DIPS ON SAME SIDE-DEC,DOUGLAS,MDB,CDP)
	NW0LEN__.-WWINIT-NWBLEN
WTVLEN__.-WWCTV

^SMALL:		0	;SMALLEST DISTANCE BETWEEN WW PINS-CALCULATED IN SETBRD IN

^WNOBRD:	0
		REPEAT NWBLEN
<		JRST NBOARD
>
		REPEAT NW0LEN
<		0
>
		CHECK(WNOBRD,WTVLEN)

;;;;ASSEMBLER BUG FIX
^^WWCBLT:	BLT C,WTVLEN-1(B)
		POPJ P,
;;;;END OF ASSEMBLER BUG FIX

ISPC:	OUTSTR [ASCIZ /THIS IS A PC CARD
/]
	JRST ERRET

;SOME HANDY BYTE POINTERS

DEFINE LOW12<[POINT 12,A,35]>		;LOW ORDER 12 BITS OF A
DEFINE B6AT23<[POINT 6,A,23]>
DEFINE B6AT17<[POINT 6,A,17]>
DEFINE B6AT29<[POINT 6,A,29]>

SQRT:	JFFO T,.+2		;GET LOC OF FIRST BIT
	POPJ P,
	MOVNI TTT,(TT)
	ADDI TTT,=35
	ASH TTT,-1
	MOVEI TT,1
	ASH TT,(TTT)
	MOVEI TTT,=3		;3 ITERATIONS FOR NOW
SQRTLP:	MOVE TTTT,TT
	IDIVM T,TTTT
	ADD TT,TTTT
	ASH TT,-1
	SOJG TTT,SQRTLP
	MOVE T,TT
	POPJ P,

NUMPNT:	IDIVI T,=10
	ADDI TT,60
	JUMPE T,.+3
	ADDI T,60
	OUTCHR T
	OUTCHR TT
	POPJ P,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;DISTANCE CALCULATOR FOR ROUTER STUFF
;CALLS WITH ONE PIN IN A,B OTHER IN C,D RETURNS DISTANCE IN G

;CITY BLOCK DISTANCE FOR W940 STUFF

DISTCB:PUSHJ P,PINMAP		;MAP ONE OF THEM
	JRST DSTERR
	HRLM A,(P)
	MOVE A,C		;MOVE IN OTHER POINT
	MOVE B,D
	MOVE C,T		;SAVE X,Y
	MOVE D,TTT		;AND DIST
	PUSHJ P,PINMAP
	JRST DSTERR
	CAMLE TTT,D		;FIND SMALLEST DISTANCE-TO-END-OF-DIP
	SKIPA G,D
	MOVE G,TTT
	ASH G,1			;DOUBLE IT (MUST GO TO END AND BACK!)
	HLRE TT,T
	HLRE TTT,C
	SUB TT,TTT
	MOVM TT,TT
	HRRE T,T
	HRRE C,C
	SUB T,C
	MOVM T,T		;THIS IS Y PART.
	JUMPE G,DSTCLX		;IF THERE IS NO DISTANCE TO END OF DIP,
	CAMG T,NEXTR		; OR IF PINS ARE ALONG A ROW BORDER (Y=NEXTR)
	JRST DSTCLX		; THEN END-AROUND FUDGE ISN'T NEEDED
	SKIPE LNGRID		;EAF IS EASIER IF LNGRID IS TRUE
	JRST [	LDB C,[POINT 6,(P),5]	;GET ONE COLUMN LETTER
		LDB D,[POINT 6,A,23]	;GET OTHER COLUMN LETTER
		CAMN C,D	;SAME COLUMN?
		ADD T,G		;YES, ADD FUDGE
		JRST DSTCLX]

	LDB C,[POINT 12,(P),17]
	LDB D,[POINT 12,A,35]
	SUB C,D
	IDIV C,NCOLS
	JUMPN D,DSTCLX		;IF REMAINDER, THEN DIF COLUMNS, AND NO FUDGE
	ADD T,G			;SAME COLUMN, BUT NOT CLOSE ENOUGH, FUDGE AROUND END OF DIP
DSTCLX:	ADD T,TT		;ADD IN X PART
	CAIN T,			;ZERO LENGTH RUN?
	JRST DSTERR		;THEN DON'T ADD MARGINS
STANFO,<JRST DSTRND>		;STANFORD USES PRECUT WIRE
NOSTAN,<CAILE T,=8000		;LONGER THAN 8 INCHES?
	ADDI T,=250		;YES, ADD 1/4 INCH
	CAME T,SMALL		;DON'T ADD WRAPMG IF PINS ARE ADJACENT
	ADD T,WRAPMG		;INSULATED WIRE TO WRAP AROUND POST
	ADD T,POSTMG		;BARE WIRE TO WRAP AROUND POST
	IDIV T,SMALL		;MODULO SMALLEST POSSIBLE SPACING
ITS,<	ASH TT,1
	CAML TT,SMALL	>	;ITS LIKES THE WELL ROUNDED APPROACH
NOITS,<	SKIPE TT	>	;OVERFLOW?
	ADDI T,1		;YES, ADD 1
	MOVE G,T
	POPJ P,

>;NOSTAN

DSTERR:	SETZ G,
	POPJ P,


;CALCULATE POINT TO POINT DISTANCE

DISTPP:
	PUSHJ P,PINMAP		;MAP ONE OF THEM
	JRST DSTERR
	MOVE A,C		;GET OTHER POINT
	MOVE B,D
	MOVE C,T		;SAVE X,Y
	PUSHJ P,PINMAP
	JRST DSTERR
	HLRE TT,T
	HLRE TTT,C
	SUB TT,TTT		;GET VERTICAL DISTANCE
	IMUL TT,TT		;SQUARE IT
	HRRE T,T
	HRRE C,C
	SUB T,C			;HORIZONTAL DISTANCE
	IMUL T,T		;SQUARE IT
	ADD T,TT
	JUMPE T,DSTIS0		;DON'T WASTE TIME ON 0 LENGH RUNS
	PUSHJ P,SQRT		;SQUARE ROOT = HYPOTENUSE
DSTRND:	CAILE T,=8000		;LONGER THAN 8 INCHES?
	ADDI T,=250		;YES, ADD 1/4 INCH

NOSTAN,<	CAME T,SMALL		;DON'T ADD WRAPMG IF PINS ARE ADJACENT
	ADD T,WRAPMG		;ADD INSULATION WRAP
	ADD T,POSTMG		;ADD BARE WRAP
	IDIV T,SMALL		;MODULO SMALLEST POSSIBLE DISTANCE BETWEEN PINS
	SKIPE TT		;REMAINDER?
	ADDI T,1		;YES, ROUND UP
>;NOSTAN

STANFO,<	;QUANTIZE FOR PRECUT WIRES::
	CAMN T,SMALL		;ADJACENT PINS?
	JRST [	ADD T,POSTMG	;YES, ADD BARE WRAP ONLY
		JRST DSTIS1 ]
	ADD T,POSTMG
	ADD T,WRAPMG
	MOVEI TTT,=500		;SET TTT TO INCREMENT FOR WIRES FROM 3 TO 8 INCHES
	CAILE T,=8000		;OVER 8" ?
	MOVEI TTT,=1000		;YES, SET TTT TO INCREMENT FOR WIRES OVER 8 INCHES
	IDIV T,TTT
	SKIPE TT
	ADDI T,1
	IMUL T,TTT		;ROUND UP TO APPROPRIATE INCREMENT
DSTIS1:	IDIV T,SMALL
>;STANFO

DSTIS0:	MOVE G,T
	POPJ P,
>;MWL

                                                                                                     ;NOW INSERT ALL OF THE APPROPRIATE BOARD FILES

DEFINE BRDNAM (NAME,LOCS,WWC,INSERT)
<IFDIF <> <INSERT> <.INSERT INSERT
>
>;DEFINE BRDNAM

ALLBRDS

PURGE ALLBRDS,CHECK
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             COMMENT    VALID 00024 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	<DRAW>DECSUB.FAI145, 30-JUL-75 15:25:07, EDIT BY HELLIWELL
C00004 00003	SETPOL - INSERT DEFAULT POLARITY INTO BODY DEFINITION
C00006 00004	CHECK POLARITY OF ALL PINS AND SIGNALS ON A WIRE
C00013 00005	SIGMAT - SIGNAL NAME MATCHING WITH DEC-STYLE H & L, (1) & (0)
C00016 00006	DTRAIL:	PUSHJ	P,GETITA
C00019 00007	SIGMA7:	SKIPE	TTT,SPCNT	H OR L PRECEEDED BY SPACE?
C00021 00008	SIGM13:	MOVE	A,B		WHERE TO GO IF NO (0) FOUND
C00023 00009	UUO ROUTINES
C00025 00010	UUO DISPATCH TABLE
C00027 00011	DECGO, DCLAIM
C00041 00012	HERE IS THE DISPLAY START/STOP CODE
C00048 00013	MAKBRI:	MUL	T,NILEV			SCALE BY PGP CAPABILITY
C00049 00014	APR AND CTRL C TRAPS
C00052 00015	INTIALIZE LOG FILE
C00055 00016	TODDT:	RELEAS	ODSK,0
C00056 00017	VB10C INSTRUCTION COMPILER
C00057 00018	COMPAR:	PUSHJ	P,STASH
C00058 00019	CHKPR3:	PUSH	P,B
C00075 00020	CHRTBL:
C00077 00021	DISPNT:	TRNE	A,34000			
C00083 00022	GT,<					JB IF GT40, ASSEMBLE IN THE FOLLOWING.
C00084 00023	PGP,<				PGP CODE
C00092 00024	COME HERE TO PUT DEFAULT PPN IN AC OF THE UUO
C00093 ENDMK
C;
                                                                                                                            ;<DRAW>DECSUB.FAI;145, 30-JUL-75 15:25:07, EDIT BY HELLIWELL
VERSION(DECSUB,6)
;THIS FILE CONTAINS ALL SPECIAL SUBROUTINES FOR THE DEC ASSEMBLY
DEC,<
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ;SETPOL - INSERT DEFAULT POLARITY INTO BODY DEFINITION
;EDIT-PIN MODE ONLY

MD,<
SETPOL:	PUSHJ	P,GETCLS	;GET NEAREST PIN
	JRST	PERRET
	TLNN	M,DSKACT!MACACT
	OUTSTR	[ASCIZ /POLARITY (H OR L OR <CR>)?/]
	PUSHJ	P,GETCHR
	CAIN	C,ALTMOD
	POPJ	P,
	SETO	B,
	CAIN	C,12		;BLANK?
	SETZ	B,
	CAIE	C,"H"
	CAIN	C,"h"
	MOVEI	B,ASSH
	CAIE	C,"L"
	CAIN	C,"l"
	MOVEI	B,ASSL
	JUMPL	B,PERRET	;INVALID!
	HLRZ	A,(A)
	HLRZ	T,(A)
	TRZ	T,ASSH!ASSL
	TRO	T,(B)
	HRLM	T,(A)
	TLNE M,PINIDS		;IF PINIDS
	TRO MCHG		;THEN UPDATE SCREEN
	POPJ	P,

;DEFPOL - TRACE A LINE, STOP AT THE FIRST BODY POINT WITH A DEFAULT
;POLRITY DEFINITION

DEFPOL:	JFCL			;DON'T BEHAVE DIFFERENTLY FOR BUSSED THORUGH
	HLRZ	B,(A)		;A HAS PTR TO POINT
	HRRZ	C,1(B)
	MOVE	D,1(C)		;BITS
	TLNN	D,ISPIN		;BODY POINT?
	JRST	WRECUR		;NO
	HRRZ	T,(C)		;YES, GET POLARITY BITS
	HLRZ T,(T)
	HLRZ T,(T)
	TRNN T,ASSH!ASSL
	JRST WRECUR
	MOVE A,T		;RETURN BITS IN A
	SKIPE B,WDOLST
	PUSHJ P,PUTFS
	SETZM WDOLST
	JRST CPOPJ1
                                                                                                                                                                                                                                                                                     ;CHECK POLARITY OF ALL PINS AND SIGNALS ON A WIRE
POLCHK:	SKIPN PONPNT
	JRST PERRET
	MOVSI C,17
	MOVE A,PONPNT
	PUSHJ P,CLRBTS
	MOVE E,PONPNT
	PUSHJ P,ACLRP
	SETZM WDOLST
	SETZM FIND
	MOVE T,PONPNT
POLCK1:	HRLM T,(P)
FOR I IN(DX1,DX2,DX3,DY1,DY2)
<	SETZM I
>
	MOVE H,[1,,POLPSA]
	PUSHJ P,RECUR1
	PUSHJ P,RECCHK
	SETZM DY3		;ASSUME H
	SKIPE T,DY1		;ANY H PINS?
	JRST POLCK3		;YES
	SKIPE T,DY2		;NO, ANY L PINS?
	JRST POLCK4		;YES
	SKIPE T,DX1		;NO PINS, ANY H SIGS?
	JRST POLCK5		;YES
	SKIPN DX2		;NO, ANY L SIGS?
	JRST POLCK2		;NO, NO CHECK
	SKIPN DX3		;L SIGS, ANY BLANK SIGS?
	JRST POLCK2		;NO, NO CHECK
	JRST POLCKL		;YES, CHECK FOR L

POLCK3:	SKIPE TT,DY2		;H PINS, ANY L PINS?
	JRST POLCKM		;YES, COMPARE NUMBER
	SKIPE DX2		;H PINS ONLY, ALWAYS CHECK IF ANY L SIGS
	JRST POLCKH		;CHECK FOR H
	SKIPE DX1		;IF ONLY H,
	SKIPN DX3		;OR BLANK SIGS
	JRST POLCK2		;THEN NO CHECK
	JRST POLCKH		;ELSE CHECK FOR H

POLCK4:	SKIPE DX1		;L PINS ONLY, ANY H SIGS?
	JRST POLCKL		;YES, CHECK FOR L
	SKIPE DX2		;IF ONLY L,
	SKIPN DX3		;OR BLANK SIGS
	JRST POLCK2		;THEN NO CHECK
	JRST POLCKL		;ELSE CHECK FOR L

POLCK5:	SKIPE TT,DX2		;H SIGS (NO PINS), ANY L SIGS?
	JRST POLCKM		;YES, CHECK NUMBER
	SKIPN DX3		;NO H SIGS, ANY BLANK SIGS?
	JRST POLCK2		;NO
	JRST POLCKH		;YES, CHECK FOR H

POLCKM:	CAMGE T,TT		;IF <#OF H'S>.LT.<#OF L'S>,
POLCKL:	AOS DY3			;THEN CHECK FO L'S
POLCKH:	MOVE H,[2,,POLPSB]	;ELSE CHECK FOR H'S
	HLRZ T,(P)
	PUSHJ P,RECUR1
	PUSHJ P,RECCHK
POLCK2:	HLRZ T,(P)
	HRRZ T,(T)
	JUMPN T,POLCK1
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,CPOPJ
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/ POLARITY CHECK ERRORS.
/]
	SETOM FIND
	POPJ P,

POLPSB:	JFCL
	PUSHJ P,WACSET
	TLNN D,ISPIN
	JRST POLPS4
	HRRZ T,(C)
	HLRZ T,(T)
	HLRZ T,(T)
	MOVE TT,DY3
	XCT (TT)[TRNN T,ASSL	;SAW H, SKIP ON L
		TRNN T,ASSH]	;SAW L, SKIP ON H
	JRST POLPS4
	MOVE T,1(C)
	TLON T,FOUNDP
	AOS FIND
	MOVEM T,1(C)
	JRST POLPS4

POLPSA:	JFCL			;LOOK AT EVERYONE
	PUSHJ P,WACSET		;SETUP REGS
POLPS4:	HLRZ T,(C)
	JUMPE T,PRECUR
	HRLM A,(P)
	HRRZ A,(T)
	ADD A,[POINT 7,1]
	PUSHJ P,PERMUT		;CREATE CONONICAL FORM OF SIGNAL
	SKIPL T,POLAR		;WHICH SETS UP POLAR
	AOS DX3			;NO H OR L, COUNT BLANK
	HRRZ T,T
	CAIN T,"H"
	AOS DX1			;COUNT H
	CAIN T,"L"
	AOS DX2			;COUNT L
	HLRZ A,(P)
	PUSHJ P,WACSET
	TLNE H,1		;IS PASS 1,
	JRST PRECUR		;THEN DON'T DO ERROR TEST
	MOVE TT,DY3
	XCT (TT)[CAIN T,"H"	;SAW SIGNAL H, MUST BE H
		CAIN T,"L"]	;SAW SIGNAL L, MUST BE L
	JRST PRECUR
	MOVE T,1(C)
	TLON T,FOUNDP
	AOS FIND
	MOVEM T,1(C)
PRECUR:	HLRZ B,1(B)		;NEIGHBOR POINTER
	HLRZ T,(B)		;
	JUMPE T,.+2
	PUSHJ P,RECUR1
	HRRZ T,(B)
	JUMPE T,.+2
	PUSHJ P,RECUR1
	HLRZ T,1(B)		;_
	JUMPE T,.+2
	PUSHJ P,RECUR1
	HRRZ T,1(B)		;
	JUMPE T,.+2
	PUSHJ P,RECUR1
	TLNE D,ISPIN		;PIN?
	TLNE D,10		;PREVIOUS ERROR?
	JRST RECCHK		;NO, DONE
	HRRZ T,(C)
	HLRZ T,(T)
	HLRZ E,(T)		;GET BITS
	TRNE E,ASSL
	AOS DY2
	TRNE E,ASSH
	AOS DY1
	ANDI E,ASSL!ASSH
	SKIPN E
	TRO E,DPTMP1
	HRL F,1(T)
	HRR F,(T)		;PIN NAME,,PIN ID
	PUSH P,A
	HRLM E,(P)
	PUSHJ P,POLPR0
	  PUSHJ P,POLPCK
	POP P,A
	TRC E,DPTMP1!ASSL!ASSH
	JUMPN E,POLPS2
	MOVE T,1(C)
	TLON T,FOUNDP
	AOS FIND
	MOVEM T,1(C)
	JRST POLPS1

POLPS2:	HLRZ E,A
POLPS1:	PUSHJ P,POLPR0
	  PUSHJ P,POLPCR
	JRST RECCHK

POLPR0:	HLRZ A,(A)		;PIN DATA BLOCK
	HLRZ B,(A)		;BODY POINTER
	HLRZ B,(B)		;BODY DATA BLOCK
	JRST POLPR1

POLPR2:	HLRZ B,(A)
	HRRZ D,1(B)
	HRRZ TT,(D)
	HLRZ TT,(TT)
	HRL T,1(TT)
	HRR T,(TT)
	XOR T,F
	JUMPE T,POLPR1		;DON'T DO US
	TLNN T,-1		;SAME PIN NAME?
	XCT @(P)		;YES, CALL SUBR
POLPR1:	HRRZ A,(B)
	JUMPN A,POLPR2
	JRST CPOPJ1

POLPCK:	HLRZ TT,(TT)		;GET BITS
	ANDI TT,ASSL!ASSH
	SKIPN TT
	MOVEI TT,DPTMP1
	IOR E,TT		;COLLECT THEM ALL
	POPJ P,

POLPCR:	JUMPE E,POLPC1
	TRNE E,DPTMP1		;IF WE ARE BLANK
	JRST POLPC2		;THEN WE DO ALL
	HLRZ TT,(TT)		;GET BITS
	ANDI TT,ASSL!ASSH
	JUMPE TT,POLPC2		;ALWAYS DO IF NO ASSERTION
	XOR TT,E
	JUMPN TT,CPOPJ		;BUT DON'T DO IF DIFFERENT ASSERTION
POLPC2:	MOVE T,A
	JRST RECUR0

POLPC1:	MOVSI T,10
	IORM T,1(C)		;MARK ORIGINAL PIN IN ERROR
	MOVE T,1(D)
	TLON T,FOUNDP
	AOS FIND
	MOVEM T,1(D)
	POPJ P,
>;MD
                                                                                                                                                                                                                          ;SIGMAT - SIGNAL NAME MATCHING WITH DEC-STYLE H & L, (1) & (0)
;ENTER WITH PTR TO SIGNAL NAME IN A, COMPARE STRING IN B
;SKIP RETURN IF EQUAL

IFN 0,<
SIGMAT:	PUSH	P,B		;SAVE COMPARE STRING
	PUSHJ	P,SIGMAA	;CREATE COMPARE STRING
	POP	P,A
	PUSH	P,B		;SAVE PTR FOR RETURNING TO FREE STG
	PUSHJ	P,TXTMAT	;COMPARE
	CAIA
	AOS	-1(P)		;SKIP IF TXMAT SKIPS
	POP	P,B
	JRST	PUTFS		;RETURN COMPARE STRING

;SIGMAA - COMPARE STRING GENERATOR FOR SIGMAT
;CALL WITH PTR TO STRING IN A, RETURNS WITH PTR TO COMPARE STRING IN B
;TAKES CARE OF MULTIPLE SPACES, ^W, LEADING "-", (0), (1), H, AND L

SIGMAA:	GETFS	(B)		;INIT THE COMPARE STRING
	SETZM	(B)
	SETZM	1(B)
	ADD	A,[POINT 7,1]	;BYTE PTR FOR GETTING INPUT STRING
	PUSH	P,B
	ADD	B,[POINT 7,1]	;BYTE PTR FOR MAKING COMPARE STRING
	SETZM	SPCNT
	TRZ	TFLG		;FLAG FOR LEADING "-"
SPFLUS:	PUSHJ	P,GETITA	;FLUSH LEADING SPACES
	JRST	SIGMA5		;EMPTY
	CAIE	T,DBLARR	;^W EQV TO SPACE
	CAIN	T," "
	JRST	SPFLUSH
	CAIN	T,"-"		;LEADING "-"?
	TROA	TFLG		;YES
	JRST	SIGMA6		;NO, PUT INTO COMPARE STRING

NONOT:	PUSHJ	P,GETITA
	JRST	SIGMA5		;END
	CAIE	T,DBLARR	;SPACES?
	CAIN	T," "
	JRST	DTRAIL		;FLUSH TRAILING OR MULTIPLE SPACES
	AOS	SPCNT		;COUNT NON-SPACES
SIGMA6:	PUSHJ	P,CPUTIT	;PUT INTO COMPARE STRING
	JRST	NONOT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          DTRAIL:	PUSHJ	P,GETITA
	JRST	SIGMA5		;FLUSH TRAILING SPACES
	CAIE	T,DBLARR
	CAIN	T," "
	JRST	DTRAIL		;FLUSH MULTIPLE SPACES
	PUSH	P,T
	MOVEI	T," "
	TRNE	M,SPACES	;PUT IN A SPACE IF SIGNIFICANT
	PUSHJ	P,CPUTIT
	POP	P,T
	SETZM	SPCNT		;JUST SAW A SPACE
	JRST	SIGMA6

CPUTIT:	TLNE	B,760000
	JRST	CPUTI1
	HRRZ	TTT,-1(B)	;GOT THE NEXT BLOCK ALREADY?
	JUMPN	TTT,[HRR B,TTT	;YES, SO USE IT
		JRST CPUTI1]
	GETFS	(TTT)		;NO, GET ONE
	HRRM	TTT,-1(B)	;LINK
	HRLZM	B,(TTT)		;BACK PTR
	HRR	B,TTT
	SETZM	1(TTT)
CPUTI1:	IDPB	T,B
	POPJ	P,

SIGMA5:	SETZM	POLAR		;HAVEN'T SEEN POLARITY YET
	LDB	T,B		;GET LAST CHR
	CAIE	T,"H"		;H OR L?
	CAIN	T,"L"
	JRST	SIGMA7		;YES, CHECK FORMAT
	CAIN	T,")"		;MAYBE (0) OR (1)?
	JRST	SIGMA8		;YES, CHECK IT OUT
	CAIN T,"!"
	SKIPE SPCNT		;PRECEEDED BY SPACE?
	JRST SIGM16		;NO
	AOS POLAR		;INDICATE EXPLICIT NON-POLARITY
SIGMX:	PUSHJ P,GETREV		;BACK UP OVER SPACES
	JRST SIGMY
	CAIN T," "
	JRST SIGMX
SIGMY:	TRNN TFLG
	JRST SIGM19		;NO - NEEDED, JUST PAD OUT WITH NULLS
	PUSHJ P,SIGM18		;TAB
	MOVEI T,"-"
	PUSHJ P,CPUTIT		;-
	JRST SIGM19		;AND PAD OUT WITH NULLS

SIGM16:	TRNN	TFLG		;SEEN "-"
	JRST	SIGMA9		;NO, JUST CLEAN UP AND GO
	PUSHJ	P,SIGM18	;YES, PUT IN <TAB>-
	MOVEI	T,"-"
	PUSHJ	P,CPUTIT
	JRST	SIGMA9

GETREV:	ADD	B,[70000,,0]	;BACK UP PTR & GET ONE CHR
	JUMPGE	B,GETRE1	;OVER WORD BOUNDARY?
	HLRZ	T,-1(B)		;YES, GET BACK PTR
	JUMPE	T,CPOPJ		;AT BEGINNING
	HRRZ	B,T		;MAKE NEW PTR
	HRLI	B,10700
GETRE1:	LDB	T,B
	JRST	CPOPJ1
                                                                                                                                                                                                                                                                                                                                                                                                                      SIGMA7:	SKIPE	TTT,SPCNT	;H OR L PRECEEDED BY SPACE?
	JRST	SIGM12		;NO, CHECK FOR 0H OR (0)H ETC.
	HRROM	T,POLAR		;LIVE POLARITY
	CAIN	T,"L"
	TRC	TFLG		;CONVERT EVERYTHING TO "H" FORM
SIGM15:	PUSHJ	P,GETREV	;CHECK FOR "(1) H" ETC.
	JRST	SIGM11		;AT END
	CAIN	T," "		;IGNORE SPACES
	JRST	SIGM15
	CAIN	T,")"
	JRST	SIGM13		;MAY BE (0) ETC
SIGM11:	PUSHJ	P,SIGM18	;JUST H OR L, NO FF OUTPUT
	MOVEI	T," "
	TRNE	TFLG		;"-" OR "L" SEEN?
	MOVEI	T,"-"
SIGMA0:	PUSHJ	P,CPUTIT	;PLUG IN ASSERTION CHR
	MOVEI	T,"H"
SIGM19:	PUSHJ	P,CPUTIT
	SETZ	T,		;CHECK FOR SHRINKING STRING
SIGMA3:	TLNN	B,760000
	JRST	SIGMA4
	IDPB	T,B		;CLEAR THE REST OF THE LAST WORD
	JRST	SIGMA3

SIGMA4:	HRRZ	TTT,-1(B)	;RETURN ANY EXTRA BLOCKS
	HLLZS	-1(B)
	SKIPE	B,TTT
	PUSHJ	P,PUTFS
SIGMA9:	POP	P,B		;PTR TO COMPARE STRING
	POPJ	P,

SIGM12:	MOVE	A,B		;WHERE TO GO IF NO (0)H ETC
	MOVE	TT,T		;SAVE H OR L
	PUSHJ	P,GETREV
	HALT			;CANT HAPPEN!?!?
	CAIN	T,")"
	JRST	SIGM13		;COULD BE (0)H ETC!
	CAIE	T,"0"
	CAIN	T,"1"
	CAIE	TTT,1		;CHECK FOR " 0H" ETC
	JRST	SIGM14		;GIVE UP
	HRROM	TT,POLAR		;LIVE POLARITY
	CAIN	TT,"L"
	TRC	TFLG		;CONVERT ALL TO "H"
	MOVE	TT,T		;SAVE 0 OR 1
	JRST	SIGM20		;FLUSH PRECEEDING SPACE
                                                              SIGM13:	MOVE	A,B		;WHERE TO GO IF NO (0) FOUND
	HRROM	TT,POLAR		;LIVE POLARITY
	CAIN	TT,"L"
	TRC	TFLG		;CONVERT TO "H" FORM
	PUSHJ	P,GETREV
	JRST	SIGM10		;AT END
	CAIL	T,"0"
	CAILE	T,"1"		;0 OR 1 SEEN?
	JRST	SIGM10		;NO
	MOVE	TT,T
	PUSHJ	P,GETREV
	JRST	SIGM10		;AT END
	CAIE	T,"("
	JRST	SIGM10
SIGM20:	PUSHJ	P,SIGM17	;FLUSH PRECEEDING SPACE, PLUG IN A <TAB>
	TRNE	TFLG		;"-" OR "L" SEEN?
	TRC	TT,1		;YES, CHANGE 0 TO 1 & VICE VERSA
	MOVE	T,TT
	JRST	SIGMA0		;PLUG IN ASSERTION/POLARITY

SIGM10:	MOVE	B,A		;REVERT
	JRST	SIGM11		;PLUG IN " H" OR "-H"

SIGM14:	MOVE	B,A		;REVERT
	JRST	SIGM16		;PLUG IN "-" OR NOTHING

SIGM17:	PUSHJ	P,GETREV	;BACK UP ON CHR
	JRST	SIGM18		;AT BEGINNING
	CAIN	T," "		;SKIP OVER SPACES
	JRST	SIGM17
SIGM18:	MOVEI	T,11		;PUT IN A <TAB>
	JRST	CPUTIT

SIGMA8:	MOVE	A,B		;WHERE TO GO IF NO (0) OR (1)
	PUSHJ	P,GETREV
	JRST	SIGM14
	CAIL	T,"0"
	CAILE	T,"1"
	JRST	SIGM14
	MOVE	TT,T		;SAVE 0 OR 1
	PUSHJ	P,GETREV
	JRST	SIGM14
	CAIE	T,"("
	JRST	SIGM14
	PUSHJ	P,SIGM17	;WIN, FLUS PRECEEDING SPACE, INSERT <TAB>
	MOVE	T,TT		;GET 0 OR 1
	TRNE	TFLG		;"-" SEEN?
	TRC	T,1		;YES, CHANGE 0 TO 1 ETC
	JRST	SIGM19		;INSERT ASSERTION, NO POLARITY
>;IFN 0
                                                                    ;UUO ROUTINES
%UUOCON:
NOPGP,<	PUSH	P,0
	PUSH	P,1
	PUSHJ	P,PUSHIT	;SAVE ALL AC'S SO HANDLER HAS ALL AC'S
>;NOPGP
PGP,<	PUSHJ	P,PUSHAL >	;SAVE ALL AC'S SO HANDLER HAS ALL AC'S
	MOVE	A,40		;PUT UUO IN "A" FOR SUBHANDLER
	MOVE	B,.JBUUO
	LSH	B,-=27
	CAILE	B,37		;UUO IN CORRECT RANGE ?
	JRST	$UUOER		;NO
	PUSHJ	P,@UUODIS(B)	;UUO DISPATCH INSTRUCTION

;UUO EXIT ROUTINE

UUOEXT:
NOPGP,<	PUSHJ	P,POPIT
	POP	P,1
	POP	P,0		;RESTORE ALL ORIGINAL AC'S
>;NOPGP
PGP,<	PUSHJ	P,POPALL >	;RESTORE ALL ORIGINAL AC'S
	POPJ	P,
;ILLEGAL OR UNCODED UUO ROUTINE

$UUOER:	OUTSTR	[ASCIZ/
ILLEGAL UUO EXECUTED
/]
	PUSHJ	P,TODDT		;GO TRY DDT
	JRST	UUOEXT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ;UUO DISPATCH TABLE

;TABLE TO UUO HANDLER ROUTINES
;POINTERS EITHER POINT TO A UUO HANDLER
;OR TO THE ERROR ROUTINE (WHICH WILL ENTER DDT IF AROUND).

UUODIS:	$UUOER			;ILL UUO, 0
	PTBYT			;PUTBYT
	PTSTR			;PUTSTR
	DPOUT			;DPYOUT
	%DPCLR			;DPYCLR
	$UUOER			;UUO 5
	$UUOER			;UUO 6
	$UUOER			;UUO 7
	%DSKPN			;DSKPPN
	$UUOER			;UUO 11
	$UUOER			;UUO 12
	$UUOER			;UUO 13
	$UUOER			;UUO 14
	$UUOER			;UUO 15
	$UUOER			;UUO 16
	$UUOER			;UUO 17
	$UUOER			;UUO 20
	$UUOER			;UUO 21
	$UUOER			;UUO 22
	$UUOER			;UUO 23
	$UUOER			;UUO 24
	$UUOER			;UUO 25
	$UUOER			;UUO 26
	$UUOER			;UUO 27
	$UUOER			;UUO 30
	$UUOER			;UUO 31
	$UUOER			;UUO 32
	$UUOER			;UUO 33
	$UUOER			;UUO 34
	$UUOER			;UUO 35
	$UUOER			;UUO 36
	$UUOER			;UUO 37
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ;DECGO, DCLAIM
DECGO:	MOVEI	TT,REENTER
	MOVEM	TT,.JBREN
	MOVEI	T,INTBLK
	MOVEM	T,.JBINT
	SETZM	INTBLK+2
	MOVEI	T,DECAPR	;ENABLE FOR PDL OVFL & ILL MEM REF
	MOVEM	T,.JBAPR
	MOVEI	T,620000
	APRENB	T,		;APRENB
	POPJ P,

;COME HERE TO INITIALLY CLAIM DISPLAY
DCLAIM:
VB10,<	SETO T,
	GETLIN T
	ANDI T,177777
	CAME T,VBCON		;IS HE AT THE RIGHT CONSOLE?
	JRST SETWRN		;NO
DTRY:	SKIPE DONTDPY		;DO WE WANT DISPLAY?
	JRST SETWRN		;NO
NOVIROS,<
	OPEN DISCHN,[	15
			'DIS   '
			0	]
	JRST NODIS		;NO CAN DO
>;NOVIROS
VIROS,<
	PUSH P,1
	PUSH P,2
	PUSH P,3
	SKIPGE 1,VBCJFN
	JRST NOJREL
	GTSTS
	TLNN 2,(1B10)
	JRST NOJREL
	DVCHR
	MOVE 3,1
	HRROI 1,[ASCIZ/VBC/]
	STDEV
	JRST NOJREL		;FOO
	CAMN 2,3		;VBC ON THIS JFN?
	PUSHJ P,VBCREL
NOJREL:	MOVSI 1,1
	HRROI 2,[ASCIZ/VBC:/]
	GTJFN
	JRST [	PUSHJ P,JSYSE
		JRST PNODIS]
	HRRZM 1,VBCJFN
	SETZ 2,
	OPENF
	JRST [	PUSHJ P,JSYSE
		JRST CNODIS]
	MOVEI 2,VBLOCK		;VB10C LOCK CODE
	MOVEI 3,=64		;TRY FOR THIS MANY PAGES
	MTOPR
	SOJG 3,.-1		;TRY FOR LESS ON ERROR
	SKIPN 3			;NO PAGES?
	PUSHJ P,JSYSE		;YES, MOBY ERROR
	LSH 3,9
	TRO 3,777		;LAST WORD
	SUBI 3,1
	CAML 3,.JBFF		;ENOUGH FOR MIN DISPLAY?
	CORE 3,			;LET HURLEY KNOW ABOUT CHANGE
	JRST [	OUTSTR[ASCIZ/NOT ENOUGH PAGES AVAILABLE FROM SYSTEM FOR DISPLAY.
/]
		JRST CNODIS]
	POP P,3
	POP P,2
	POP P,1
>;VIROS
	HRRZ	TT,.JBFF
	MOVEM	TT,FBUF
	HRLM	TT,ENDPG1
	MOVEI T,1(TT)
	CAMG T,.JBREL
	JRST BUFOK
	CORE T,
	JRST [	OUTSTR[ASCIZ/NO CORE FOR DISPLAY BUFFER.
/]
		JRST XNODIS]
BUFOK:	MOVE	T,[XWD 10200,160000]
	MOVEM	T,(TT)
	MOVEI	T,FBUF+2
	MOVEM	T,1(TT)
	MOVE T,['VBD   ']
>;VB10
GT,<
NODLX,<
DTRY:	SKIPE DONTDPY
	JRST SETWRN
>;NODLX
DLX,<
	SETOM DLXFLG			;TRY DL10 FIRST
DTRY:	SKIPE DONTDPY
	JRST SETWRN
	PUSH P,1
	PUSH P,2
	PUSH P,3
	HRROI 1,[ASCIZ/DLX0/]
	STDEV				;USE THIS TO GET DEVICE #
	JRST [	SKIPN DLXFLG		;IF NOT TRYING DL10, LIMP ON
		JRST NORLDL
		PUSHJ P,JSYSE		;FOO
		JRST NODIS]
	HLLZM 2,DLDVDS			;SAVE HERE
	SKIPGE 1,DLXJFN			;SEE IF MAYBE WE ALREADY HAVE IT
	JRST NORLDL
	GTSTS				;GET JFN STATUS
	TLNN 2,(1B10)			;JFN ACTIVE?
	JRST NORLDL			;NO
	DVCHR				;GET DEVICE DESIGNATOR
	XOR 1,DLDVDS			;COMPARE WITH DEVICE PART OF DLX0
	TLNN 1,-1			;IS IT A DL10?
	PUSHJ P,DLREL			;YES, RELEASE IT
NORLDL:
>;DLX
	OPEN DISCHN,[	700
			'TTY   '
			0	]
	JRST NODIS
	IONEOU	[375]		;TICKLE THE GT40 IF THERE
	PUSHJ P,WAIT
	TTYUUO 2,T
	JRST PNODIS		;NO RESPONSE, NOBODY HOME
	CAIN T,33		;SOME MODES SEND THIS INSTEAD OF 175
	MOVEI T,175
	CAIE T,175		;GTPROG THERE?
	JRST PNODIS		;NO
DLX,<	SKIPN DLXFLG
	JRST SKPDLX
	MOVE T,[POINT 8,[BYTE(8)60,60,60,60,205,122,0]]
	PUSHJ P,GTSEND		;WHO ARE YOU
	TTYUUO 2,T		;GET RESPONSE
	JRST PNODIS		;NONE, FOO
	CLRBFI
	SUBI T,101		;CONVERT TO PORT #
	JUMPL T,PNODIS		;ERROR CHECK A LITTLE
	CAILE T,3
	JRST PNODIS
	HRRM T,DLDVDS		;STORE WITH DEVICE DESIGNATOR
	HRROI 1,DLXBUF
	MOVE 2,DLDVDS
	DEVST			;PUT STRING NAME OF CORRECT DEVICE IN DLXBUF
	JRST [	PUSHJ P,JSYSE
		JRST PNODIS]
	MOVEI 2,":"
	IDPB 2,1		;MAKE IT A DEVICE NAME
	MOVSI 1,1
	HRROI 2,DLXBUF
	GTJFN
	JRST [	PUSHJ P,JSYSE
		JRST PNODIS]
	HRRZM 1,DLXJFN		;STORE JFN HERE
	MOVE 1,DLXJFN
	MOVE 2,[100000,,300000]		;8 BIT BYTES, READ/WRITE
	OPENF
	JRST [	PUSHJ P,JSYSE
		PUSHJ P,DLREL
		JRST PNODIS]
SKPDLX:	POP P,3
	POP P,2
	POP P,1
	SKIPE DLXFLG		;IS WE GOT THE DL10?
	JRST GOTDLX		;YES
>;DLX
	MOVE T,[POINT 8,[BYTE(8)60,60,60,60,143,122,0]]
	PUSHJ P,GTSEND
	CLRBFI			;FLUSH ALL INPUT NOW
GOTDLX:	SETSTS DISCHN,0
	RELEASE DISCHN,
	PUSH P,[JBTABL]
	PUSHJ P,GTINIT		;SEND TITLE LINE, CURSOR, ETC.
	HRLZ T,JBCURX		;GET X VALUE WE JUST PUT CURSOR AT
	HRR T,JBCURY		;AND Y VALUE
	MOVEM T,JBCUR		;AND STORE AS CURRENT POS
	SETZM JBREDY		;MAKE SURE READY CHAR IS RETRANSMITTED.
	TRNE M,CURSOR		;ARE WE BULLSEYE TRACKING?
	PUSHJ P,CURSN1		;YES, SEND X,Y COORDS
	MOVE T,['GTD   ']
>;GT
PGP,<
	MOVSI	T,'PGP'		;GET PGP CHARACTERISTICS
	CALLI	T,4
	JUMPE	T,SETWRN	;DOES IT EXIST FROM THIS TERMINAL?
DTRY:	SKIPE	DONTDPY		;YES, TRYING TO DISPLAY?
	JRST	SETWRN		;NO
	SKIPN	T,PGPJBF	;ALREADY SET UP PGP BUFFER?
	MOVE	T,.JBFF		;NO, GET CURRENT FIRST FREE
	MOVEM	T,PGPJBF	;SET LOC OF PGP BUFFER
	EXCH	T,.JBFF		;INFORM THE SYSTEM
	PUSHJ	P,PUSHAL	;SAVE ACS
	SETZM	$VAL		;INIT ERROR CELL
	RTNCAL	(PGPINIT)	;CALL PGP INIT SUBR
	PUSHJ	P,POPALL	;RESTORE ACS
	CAMGE	T,.JBFF		;JUST TOOK SOME CORE?
	MOVEM	T,.JBFF		;NO, RESTORE JOBFF
	SETZM	GOING		;INIT NIL DISPLAY FLAG
	SKIPE	$VAL		;RETURN VALUE = SUCCESS?
	JRST	NODIS		;NO
	SETZM	BLNKIT		;INIT BLINK FLAG
	MOVE	T,['PGPD  ']	;NAME TO USE
>;PGP
	SETNAM T,
	SETOM ISDPY
	JRST DSPOUT

GT,<
GTSND1:	IONEOU TT
GTSEND:	ILDB TT,T
	JUMPN TT,GTSND1		;FALL INTO WAIT ON NULL
WAIT:	MOVE T,[4,,=2000]	;HIBERNATE FOR 2 SECONDS
	MOVEI TT,2		;OR SLEEP FOR 2 SECOND
	HIBER T,		;TRY HIBERNATE
	SLEEP TT,		;CAN'T, DO A SLEEP INSTEAD
	POPJ P,
>;GT
VIROS,<
..TEMP__0
NOGT,<..TEMP__-1>
DLX,<..TEMP__-1>
IFN ..TEMP,<
JSYSE:	PUSH P,1
	PUSH P,2
	PUSH P,3
	MOVEI 1,101
	HRLOI 2,400000
	MOVEI 3,400000
	ERSTR
	OUTSTR[ASCIZ/ERSTR: UNKNOWN ERROR LAST./]
	JFCL			;THIS CAN'T HAPPEN
	OUTSTR[ASCIZ/
/]
	POP P,3
	POP P,2
	POP P,1
	POPJ P,
>;..TEMP
>;VIROS

VB10,<
XNODIS:
NOVIROS,<RELEASE DISCHN,>
VIROS,<
	PUSH P,1
	PUSH P,2
	PUSH P,3
CNODIS:	SKIPGE 1,VBCJFN
	JRST PNODIS
	CLOSF
	PUSHJ P,JSYSE
PNODIS:	SETOM VBCJFN
	POP P,3
	POP P,2
	POP P,1
>;VIROS
>;VB10
GT,<
PNODIS:	SETSTS DISCHN,0
	RELEASE DISCHN,
	CLRBFI
>;GT
NODIS:
DLX,<	POP P,3
	POP P,2
	POP P,1
	SKIPE DLXFLG			;WAS THAT THE DL10?
	JRST [	SETZM DLXFLG		;YES, TRY WITHOUT IT
		OUTSTR[ASCIZ/NO DL10, TRYING TTY.
/]
		JRST DTRY]
>;DLX
	OUTSTR[ASCIZ/
DISPLAY NOT AVAILABLE
/]
SETWRN:	SETZM ISDPY
	MOVE T,['WIRES ']
	SETNAM T,
	JRST DSPSET

GT,<
RDLPEN:	PUSH P,13
	PUSH P,14
	PUSH P,15
	PUSH P,16
	MOVEM P,STCHPS
	PUSH P,[1]			;PICTURE # 1 IS CURSOR
	MOVE 16,P
	PUSH P,[JBCURX-PIC1]		;OFFSET OF X VALUE (FOLLOWED BY Y)
	PUSH P,[2]			;2 WORDS
	ADD P,[2,,2]			;LEAVE SPACE FOR 2 WORDS ON STACK
	PUSHJ P,BREADM
	EXCH P,STCHPS
	POP P,16
	POP P,15
	POP P,14
	POP P,13
	MOVE T,STCHPS			;GET BACK POINTER TO ARGS
	MOVE TT,-1(T)			;GET X
	HRLM TT,JBCUR			;STORE INTO CURRENT CURSOR CELL
	MOVE T,(T)			;AND Y
	HRRM T,JBCUR
	SUB T,[GTY]
	SUB TT,[GTX]
	LSH T,=36-=22
	DPB TT,[POINT 11,T,10]
	TRO T,1
	POPJ P,
>;GT
VB10,<
VIROS,<
RDLPEN:	PUSH P,1
	PUSH P,2
	PUSH P,3
	PUSH P,4
	MOVEI 2,VBSTAT
	MOVEI 3,1
	MOVEI 4,1
	SKIPGE 1,VBCJFN
	JRST NOLPEN
	MTOPR
	JRST [	PUSHJ P,JSYSE
		JRST NOLPEN]
	CAMN 1,[-1]
	JRST NOLPEN
	HLRZ 2,1
	SUBI 2,1000
	SUBI 1,1000
	LSH 1,=36-=11
	DPB 2,[POINT 11,1,21]
	TROA 1,1
NOLPEN:	MOVE 1,SAVWR2
	POP P,4
	POP P,3
	POP P,2
	EXCH 1,(P)
	POP P,T
	POPJ P,
>;VIROS

VBCON:
NOVIROS,<	16	>	;VB10 CONSOLE
VIROS,<		10	>	;ON VIROS
>;VB10
PGP,<
RDLPEN:	PUSHJ	P,PUSHAL	;SAVE ACS
	RTNCAL	(ERRACK)	;JUST TO BE SAFE
	RTNCAL	(INTERA,<[PLIT RDLPRG],[PLIT NULARG]>)	;SEND TRACKING SYMBOL XY
	PUSHJ	P,CHCINT	;MAKE IT HAPPEN
	RTNCAL	(INPUTW,<[=30],[PLIT TSXDAT]>)	;PICKUP TSX
	RTNCAL	(INPUTW,<[=31],[PLIT TSYDAT]>)	;PICKUP TSY
	PUSHJ	P,POPALL	;RESTORE ACS
	MOVE	T,TSXDAT	;FORMAT PROPERLY
	DPB	T,[POINT 11,TSYDAT,24]
	MOVE	T,TSYDAT
	LSH	T,=14
	POPJ	P,

	ERDLPG-.-1
RDLPRG:	ASCIZ	!BEGIN
	ON HCA
	 OUTT=TSXY;
	 END,
	END!
	0
	ERDLPG__.
>;PGP

DPYREL:	SKIPN ISDPY
	POPJ P,
	DPYCLR
VB10,<
NOVIROS,<
	RELEASE DISCHN,
>;NOVIROS
VIROS,<	SKIPGE VBCJFN
	JRST NORJFN
VBCREL:	PUSH P,1
	PUSH P,2
	PUSH P,3
	PUSH P,4
	PUSH P,5
	PUSH P,6
	MOVE 1,VBCJFN
	CLOSF
	PUSHJ P,JSYSE
	SETOM VBCJFN
	MOVE 1,.JBFF
CORUP:	MOVEI 2,777(1)		;GET US ONE MORE PAGE THAN WE WILL NEED
	CORE 2,
	JRST [	OUTSTR[ASCIZ/CORE UUO FAILURE AT DPYREL.
CONTINUE TO TRY AGAIN.
/]
		EXIT 1,
		JRST CORUP]
	MOVEI 5,-1(1)
	ANDCMI 5,777
	MOVEI 4,1000(5)
LOPPAG:	MOVE 6,4
	HRL 6,5
	BLT 6,777(4)
	SETO 1,
	MOVE 2,5
	LSH 2,-9
	HRLI 2,400000
	SETZ 3,
	PMAP			;FLUSH PAGE
	MOVE 6,5
	HRL 6,4
	BLT 6,777(5)
	SUBI 5,1000
	JUMPGE 5,LOPPAG
CORDWN:	MOVEI 1,-1(4)		;LAST ADDRESS WE REALLY WANT
	CORE 1,
	JRST [	OUTSTR[ASCIZ/CORE DOWN FAILURE AT DPYREL.
CONTINUE TO TRY AGAIN.
/]
		EXIT 1,
		JRST CORDWN]
	POP P,6
	POP P,5
	POP P,4
	POP P,3
	POP P,2
	POP P,1
NORJFN:
>;VIROS
>;VB10
GT,<	PUSHJ P,GTRESET		;RESET GT40 NOW
DLX,<	SKIPGE DLXJFN		;DO WE HAVE DL10?
	JRST NORJFN		;NO
DLREL:	PUSH P,1
	MOVE 1,DLXJFN
	CLOSF
	PUSHJ P,JSYSE
	SETOM DLXJFN
	POP P,1
NORJFN:
>;DLX
>;GT
PGP,<	RTNCAL	(PGPSTOP)	>
	SETZM ISDPY
	POPJ P,
                                                                                                                                                                                                                                                                                                                                               ;HERE IS THE DISPLAY START/STOP CODE
VB10,<
DSTART:	SKIPGE	GOING
	POPJ	P,
NOVIROS,<
	PUSH	P,TT
LOCKF:	MOVEI	TT,1		;DO LOCK
	LOCK	TT,
	JRST	[CAMN TT,GOING
		JUMPN TT,LOCKW
		MOVEM TT,GOING
		CAIN TT,2
		JRST [	OUTSTR[ASCIZ/
WAITING TO LOCK IN CORE
/]
			JRST LOCKW]
		CAIN TT,3
		JRST [	OUTSTR[ASCIZ/
GET THE OPERATOR TO "SET CORMIN 0"
/]
		LOCKW:	MOVEI TT,5
			SLEEP TT,	;SLEEP
			JRST LOCKF]
		OUTSTR	[ASCIZ/
?CAN'T LOCK IN CORE/]
		SETZM	GOING
		PUSHJ	P,TODDT
		JRST	LOCKF]
	POP	P,TT		;RESTORE TT
	OUTPUT DISCHN,FBUF
>;NOVIROS
VIROS,<	SKIPGE VBCJFN
	JRST NOVJFN
	PUSH P,1
	PUSH P,2
	PUSH P,3
	MOVE 3,FBUF
	MOVEI 2,VBSTRT
	MOVE 1,VBCJFN
	MTOPR
	PUSHJ P,JSYSE
	POP P,3
	POP P,2
	POP P,1
NOVJFN:
>;VIROS
	SETOM	GOING
	POPJ P,

DSTOP:	SKIPL GOING
	POPJ P,
VIROS,<	SKIPGE VBCJFN
	JRST NOSJFN
	PUSH P,1
	PUSH P,2
	MOVE 1,VBCJFN
	MOVEI 2,VBSTOP
	MTOPR			;STOP DISPLAY
	PUSHJ P,JSYSE
	POP P,2
	POP P,1
NOSJFN:
>;VIROS
NOVIROS,<
	CLOSE DISCHN,
 	PUSH	P,0		;SAVE 0
UNLOK1:	HRRZI	0,1		;UNLOCK LOW SEGMENT
	UNLOK.			;UNLOCK
	JRST	[OUTSTR	[ASCIZ/
?UNLOCK UUO FAILED/]
		PUSHJ	P,TODDT
		JRST	UNLOK1]
	POP	P,0		;RESTORE 0.
>;NOVIROS
	SETZM GOING
	POPJ	P,

>;VB10
PGP,<
DSTART:	SKIPGE	GOING
	POPJ	P,
	SETZM	SAVWRD					;INIT CURSOR LOC
	SETZM	LOCAT					;INIT LOCAT POSITION
	RTNCAL	(ERRACK)				;JUST IN CASE
	RTNCAL	(GETNI,[PLIT NILEV])
	SOS	NILEV
	RTNCAL	(STPIC)
	RTNCAL	(MRU,<[0],[1],[-2]>)			;10-MIL UNITS
	RTNCAL	(WINDO,<[-1000],[-1000],[1000],[1000]>)	;FULL SCREEN
	RTNCAL	(OSEG,[=100])				;ROOT
	SETZM	PGPBRI+1				;INIT PARAMS
	MOVE	T,[XWD PGPBRI+1,PGPBRI+2]
	BLT	T,PGPBRI+5
	MOVE	T,NILEV					;SET FOLLOW BRIGHTNESS
	MOVEM	T,PGPBRI
	RTNCAL	(PARAMS,[PLIT PGPBRI])
	RTNCAL	(AMOV2,<[=113],[0],[0]>)		;DUMMY FOLLOW 1
	RTNCAL	(ALIN2,<[=113],[0],[0]>)
	RTNCAL	(AMOV2,<[=114],[0],[0]>)		;DUMMY FOLLOW 2
	RTNCAL	(ALIN2,<[=114],[0],[0]>)
	RTNCAL	(CSEG,[=100])
	RTNCAL	(MRU,<[0],[1],[-2]>)			;10-MIL UNITS
	RTNCAL	(WINDO,<[-1000],[-1000],[1000],[1000]>)	;FULL SCREEN
	RTNCAL	(REFPT,<[0],[SCRTOP-TITBIG*CHGHT]>)	;INFO LINE Y
	MOVEI	T,TITBRT				;TITLE BRIGHTNESS
	PUSHJ	P,MAKBRI
	RTNCAL	(PARAMS,[PLIT PGPBRI])
	RTNCAL	(OSEG,[=200])
	RTNCAL	(REFPT,<[%LEFT+5*CWIDTH*TITBIG],[0]>)		;MODE
	RTNCAL	(OSEG,[=201])
	MOVNI	B,5*CWIDTH*TITBIG
	MOVEI	A,[ASCIZ /MODE=/]
	PUSHJ	P,DRWDE0
	MOVE	A,[XWD =101,MODWRD]
	PUSHJ	P,DRWDEM
	RTNCAL	(CSEG,[=201])
	RTNCAL	(REFPT,<[%LEFT+14*CWIDTH*TITBIG],[0]>)		;SCALE
	RTNCAL	(OSEG,[=202])
	MOVNI	B,4*CWIDTH*TITBIG
	MOVEI	A,[ASCIZ /SCL=/]
	PUSHJ	P,DRWDE0
	MOVE	A,[XWD =102,SCLWRD]
	PUSHJ	P,DRWDEM
	RTNCAL	(CSEG,[=202])
	RTNCAL	(REFPT,<[%LEFT+24*CWIDTH*TITBIG],[0]>)		;MACRO LEVEL
	RTNCAL	(OSEG,[=203])
	MOVNI	B,4*CWIDTH*TITBIG
	MOVEI	A,[ASCIZ /LVL=/]
	PUSHJ	P,DRWDE0
	MOVE	A,[XWD =103,LVLWRD]
	PUSHJ	P,DRWDEM
	RTNCAL	(CSEG,[=203])
	RTNCAL	(REFPT,<[%LEFT+31*CWIDTH*TITBIG],[0]>)		;FILE
	RTNCAL	(OSEG,[=204])
	MOVNI	B,2*CWIDTH*TITBIG
	MOVEI	A,[ASCIZ /=/]
	PUSHJ	P,DRWDE0
	MOVE	A,[XWD =104,FILWRD]
	PUSHJ	P,DRWDEM
	RTNCAL	(CSEG,[=204])
	RTNCAL	(REFPT,<[%RIGHT-30],[-20]>)			;READY
	RTNCAL	(OSEG,[=205])
	MOVE	A,[XWD =105,[ASCIZ /*/]]
	PUSHJ	P,DRWDEM
	RTNCAL	(CSEG,[=205])
	RTNCAL	(CSEG,[=200])
	RTNCAL	(MRU,<[0],[1],[-2]>)			;10-MIL UNITS
	RTNCAL	(WINDO,<[-1000],[-1000],[1000],[1000]>)	;FULL SCREEN
	MOVE	T,FBRT					;CURSOR BRIGHTNESS
	PUSHJ	P,MAKBRI
	RTNCAL	(PARAMS,[PLIT PGPBRI])			;CURSOR BRIGHTNESS
	RTNCAL	(OSEG,[=300])				;CURSOR STUFF
	RTNCAL	(AMOV2,<[=110],[14],[14]>)		;CURSOR ITSELF
	RTNCAL	(ALIN2,<[=110],[-14],[-14]>)
	RTNCAL	(AMOV2,<[=110],[14],[-14]>)
	RTNCAL	(ALIN2,<[=110],[-14],[14]>)
	MOVEI	T,2					;DOTTED LINE
	MOVEM	T,PGPBRI+1
	RTNCAL	(PARAMS,[PLIT PGPBRI])
	RTNCAL	(OSEG,[=301])				;CLOCATE
	RTNCAL	(AMOV2,<[=111],[-1000],[0]>)
	RTNCAL	(ALIN2,<[=111],[1000],[0]>)
	RTNCAL	(AMOV2,<[=112],[0],[-1000]>)
	RTNCAL	(ALIN2,<[=112],[0],[1000]>)
	RTNCAL	(CSEG,[=301])
	SOS	PGPBRI+1				;DASHED LINES
	RTNCAL	(PARAMS,[PLIT PGPBRI])
	RTNCAL	(OSEG,[=302])				;LOCATE
	RTNCAL	(AMOV2,<[=115],[-1000],[0]>)
	RTNCAL	(ALIN2,<[=115],[1000],[0]>)
	RTNCAL	(AMOV2,<[=116],[0],[-1000]>)
	RTNCAL	(ALIN2,<[=116],[0],[1000]>)
	RTNCAL	(CSEG,[=302])				;WILL BE BLANKED
	RTNCAL	(CSEG,[=300])
	SETZM	PGPBRI+1
	RTNCAL	(ENDPIC)
	RTNCAL	(TSROOT,[=100])
	RTNCAL	(INTERA,<[PLIT BEGPRG],[PLIT %CLOC]>)
	SETOM	GOING
	PUSHJ	P,CHCINT
	JRST	CURSO1				;SET CURSOR TRACKING
                                       MAKBRI:	MUL	T,NILEV			;SCALE BY PGP CAPABILITY
	DIVI	T,7
	CAIL	TT,4			;ROUND
	AOS	T
	MOVEM	T,PGPBRI
	POPJ	P,

	EBEGPG-.-1
BEGPRG:	ASCIZ	!BEGIN
	ON HCA
	 '113'=0;
	 '114'=0;
	 '301'=$0;
	 '302'=0;
	 [2]='110';
	 [3]='111';
	 [4]='112';
	 [5]='113'\1\;
	 [6]='113'\2\;
	 [7]='114'\1\;
	 [8]='114'\2\;
	 [9]='115';
	 [10]='116';
	END,
	ON TSA
	 XY[2,6,8]=TSXY;
	 X[4]=TSX;
	 Y[3]=TSY;
	END,
	END!
	1
	EBEGPG__.
>;PGP
                                                                                                                                                                                                ;APR AND CTRL C TRAPS
DECAPR:	MOVEM	P,DECSVP#
	MOVE	P,.JBCNI	;TYPE LOSSAGE
	TRNE	P,200000
	OUTSTR	[ASCIZ /PDL OVERFLOW /]
	TRNE	P,20000
	OUTSTR	[ASCIZ /ILL MEM REF /]
	OUTSTR	[ASCIZ /APR TRAP
/]
	MOVE	P,[IOWD SPPDSZ,SPPDL]	;BECAUSE PDL OVFL MAYBE
	PUSHJ	P,TODDT
	MOVE	P,DECSVP
	JRST	2,@.JBTPC

CTRLCX:	MOVE P,CCSAVP
	PUSH P,T
VB10,<	SETZ
	SETUWP
	JFCL
>;VB10
	PUSHJ P,DECGO
	POP P,INTBLK+2
	JRST CTRLCY

CTRLCS:	POP P,INTBLK+2		;THIS IS WHERE TO RETURN TO
CTRLCI:	MOVEM	P,DESVP2#
	MOVE	P,[IOWD SPD2SZ,SPPDL2]
	PUSHJ P,PUSHIT
	RELEAS	ODSK,
	SETZM	DSKOPN
	PUSHJ P,DPYREL		;LET GO OF DISPLAY
	PUSH P,0
	PUSH P,M
	MOVEM P,CCSAVP#		;SAVE STACK POINTER IN CASE THIS IS SAVE
	SETZM .JBINT		;DISABLE ^C INTS HERE
VIROS,<	OUTSTR[ASCIZ/^C/]	>
	EXIT	1,
CTRLCY:	MOVE P,CCSAVP
	POP P,M
	POP P,0
	PUSHJ P,DCLAIM		;GET DISPLAY AGAIN
	PUSH	P,FILNAM
	PUSH	P,FILNAM+1
	PUSH	P,FILNAM+2
	PUSH	P,FILNAM+3
	PUSHJ P,LOGINI
	POP	P,FILNAM+3
	POP	P,FILNAM+2
	POP	P,FILNAM+1
	POP	P,FILNAM
	PUSHJ P,POPIT
	MOVEI P,INTBLK
	MOVEM P,.JBINT		;TURN ^C INTERCEPT BACK ON
	HRRZS	P,INTBLK+2
	CAILE	P,DCHR2	;NOW OUTPUTTING TO LOG FILE?
	CAILE	P,DCHR4
	SKIPA			;NO
	MOVEI	P,DCHR2	;YES, RESTART
	CAILE	P,LOGINI	;NOW INITING LOG FILE?
	CAILE	P,LOGIN5
	SKIPA			;NO
	MOVEI	P,CPOPJ		;YES, IGNORE IT
	EXCH P,DESVP2
	SETZM INTBLK+2
	JRST @DESVP2
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ;INTIALIZE LOG FILE
LOGINI:	SKIPN	DSKOPN
	SKIPN	ISDPY
	POPJ	P,		;NO LOG IF NO DPY OR ALREADY OUTPUTING
	INIT	ODSK,0
	'DSK   '
	DSKOHD,,IOHD
	JRST	[OUTSTR [ASCIZ /
CAN'T INIT DSK. NO LOG FILE BEING WRITTEN!
/]
		POPJ	P,]
	MOVE	T,['DRAW  ']
	MOVEM	T,FILNAM	;SET UP LOG FILE NAME
	MOVSI	T,'LOG'
	MOVEM	T,FILNAM+1
	SETZM	FILNAM+2
	GETPPN	T,		;GET OUR OWN PPN
	MOVEM	T,FILNAM+3
	MOVEM T,1(P)
	LOOKUP	ODSK,FILNAM	;ALREADY EXISTS?
	JRST	LOGINN		;NO, NO HACK TO PERFORM
	MOVE TTT,[3,,T]
	MOVEI T,ODSK
	PATH TTT,		;GET REAL PPN
	MOVE TTT,1(P)		;NO PATH UUO, MAKE IT LOOK OK
	CAME TTT,1(P)
	JRST LOGINN
	HLRE	TT,FILNAM+3	;CALC LAST BLOCK NUMBER
	JUMPE TT,LOGINN		;DON'T HACK 0 LENGTH FILES
	JUMPG	TT,LOGIN3	;MOBY FILES HAVE +BLOCK COUNT
	MOVN	TT,TT
	ADDI	TT,177		;ROUND UP
	LSH	TT,-7		;ASSUME 200 WORDS/BLOCK
	JRST LOGIN3

LOGINN:	SETOM DSKOPN
	CLOSE ODSK,
LOGIN3:	HLLZS	FILNAM+1	;RE-INIT FILE NAME
	SETZM	FILNAM+2
	MOVE T,1(P)		;GET BACK PPN
	MOVEM	T,FILNAM+3
	ENTER	ODSK,FILNAM	;UPDATE MODE FOR EXISTING LOG FILE
	JRST	LOGIN4
	MOVEI	T,DSKOBF
	EXCH	T,.JBFF		;SET UP OUTPUT BUFFER
	OUTBUF	ODSK,1
	MOVEM	T,.JBFF
	SKIPE	DSKOPN		;APPENDING?
	POPJ	P,		;NO, DONE
	USETI	ODSK,(TT)	;GET COPY OF LAST BLOCK
	MOVEI	T,IOBUF		;INPUT LAST BLOCK
	EXCH	T,.JBFF
	INBUF	ODSK,1
	MOVEM	T,.JBFF
	IN	ODSK,
	SOSA	DSKOPN
	JRST	LOGIN6
	USETO	ODSK,(TT)
LOGIN1:	ILDB	C,IOHD+1
	JUMPE	C,LOGIN2
	PUSHJ	P,DCHR2
	SOSLE	IOHD+2
	JRST	LOGIN1
LOGIN2:	CLOSE	ODSK,1		;CLOSE INPUT ONLY
	MOVEI	C,LAMBDA
	JRST	DCHR2

LOGIN6:	OUTSTR [ASCIZ /
LOG FILE INPUT ERROR. NO LOG FILE BEING WRITTEN!
/]
	RELEAS	ODSK,
	POPJ	P,

LOGIN4:	RELEAS	ODSK,0
	SETZM	DSKOPN
	MOVEI	A,FILNAM
	MOVE	C,FPRINT
	JSR	FPRINT
	MOVEM	C,FPRINT
	OUTSTR [ASCIZ /, ENTER FAILED!
/]
LOGIN5:	POPJ	P,
                                                                                                                           TODDT:	RELEAS	ODSK,0
	SETZM	DSKOPN
	SKIPN	.JBDDT	;IS DDT LOADED
	JRST	[OUTSTR	[ASCIZ/
NO DDT!
/]
		PUSH P,[10000,,CPOPJ]
		POP P,INTBLK+2
		JRST CTRLCI]
	OUTSTR	[ASCIZ/
DDT
/]
	PUSH P,[10000,,CPOPJ]
	POP P,.JBOPC
	SETZM .JBINT
	PUSH P,[10000,,TODDT1]
	PUSH P,.JBDDT
	POPJ P,

TODDT1:	PUSH P,[INTBLK]
	POP P,.JBINT
	POPJ	P,

VB10,<
MAKWRD:	ROT	TTT,=11
	DPB	TTT,[POINT 11,TTT,28]
	LSH	TTT,-7
	TRZ	TTT,776000
	TLZ	TTT,776000
	ADD	TTT,[XWD 220000,160000]
	TDC	TTT,[XWD 1000,1000]
	POPJ	P,
SAVWR2:	0
                                                                                                               ;VB10C INSTRUCTION COMPILER

CMPVB5:	PUSHJ	P,@(A) [CPOPJ
				INIPNT
				COMERR
				INICHR
				INIVEC
				COMERR
				INIINC
				COMERR]
	POP	P,B
	MOVEM	A,VBMODE
CMPVB:	CAMN	A,VBMODE
	JRST	@(A) [COMPAR
			COMPNT
			COMERR
			COMCHR
			COMVEC
			COMERR
			COMINC
			COMERR]
	JUMPL	A,COMERR
	CAILE	A,7
	JRST	COMERR
	PUSH	P,B
	MOVE	B,VBMODE
	PUSHJ	P,@(B)[	CMPVB1
			CMPVB1
			COMERR
			CMPVB2
			CMPVB3
			COMERR
IFNDEF	ILOSE<		CMPVB4>
IFDEF	ILOSE<		CMPVB1>
			COMERR]
	JRST	CMPVB5
                                                                                                                              COMPAR:	PUSHJ	P,STASH
	MOVE	A,B
	TRNN	A,10
	JRST	COMPA1
	ANDI	A,7
	MOVEM	A,VBBRIT
COMPA1:	TRNN	B,100
	POPJ	P,
	ANDI	B,60
	LSH	B,-4
	MOVEM	B,VBSIZE
	POPJ	P,

INIPNT:	SETZM	PNTFLG
	POPJ	P,

INICHR:	PUSHJ	P,CHKPR0
	JRST	INICH1
CHKPR0:	MOVE	C,IISIZE
	SOSA C
INIVEC:	MOVEI C,0
	CAMN	C,VBSIZE
	JRST	CHKPR2
CHKPR4:	LDB	B,COMPTR
	SKIPE	VBMODE
	JRST	CHKPR3
CHKPR5:	DPB	C,[POINT 2,B,31]
	MOVEM	C,VBSIZE
	MOVE	C,IIBRIT
	TRZ	B,17
	IORI	B,110(C)
	MOVEM	C,VBBRIT
	DPB	B,COMPTR
	POPJ	P,

CHKPR2:	MOVE	B,IIBRIT
	CAMN	B,VBBRIT
	POPJ	P,
	JRST	CHKPR4
                                                                    CHKPR3:	PUSH	P,B
	TRZ	B,160000
	DPB	B,COMPTR
	POP	P,B
	ANDI	B,160000
	PUSHJ	P,STASH
	SETZM	VBMODE
	JRST	CHKPR5

INIINC:	PUSHJ	P,CHKPR0
IFNDEF	ILOSE<
	JRST	INIIN1>
IFDEF	ILOSE<
	JRST	INIPNT>

CMPVB1:	LDB	B,COMPTR
	DPB	A,[POINT 3,B,22]
	DPB	B,COMPTR
	POPJ	P,

CMPVB3:	LDB	B,COMPTR
	TRO	B,400000
	DPB	B,COMPTR
CMPVB6:	JUMPE	A,CPOPJ
	MOVE	B,A
	LSH	B,15
	MOVE	C,IIBRIT
	MOVEM	C,VBBRIT
	ADDI	B,10(C)
	SETZM	VBMODE
	JRST	STASH

IFNDEF ILOSE<
CMPVB4:	MOVE	B,TMPDAT
	TRNN	B,177777
	JRST	CMPVB3
	TROA	B,400000
>;-ILOSE
CMPVB2:	MOVE	B,TMPDAT
	PUSHJ	P,STASH
	JRST	CMPVB6
COMCHR:	SKIPE	SHFTIN
	JRST	COMCH1
	TRNN	B,200
	JRST	COMCH2
COMCH3:	ANDI	B,77
	SKIPE	SHFTIN
	CAIGE	B,72
	CAIG	B,37
	CAIGE	B,34
	SKIPA
	PUSHJ	P,COMERR
	MOVE	G,VBSIZE
	MOVEI	A,1
	LSH	A,(G)
	IMULI	A,6
	CAIN	B,33
	JRST	COMCH6
	ADD	A,VBX
	CAILE	A,1777
	POPJ	P,
	MOVEM	A,VBX
COMCH4:	IDPB	B,TMPPTR
	MOVE	B,TMPPTR
	TLNE	B,760000
	POPJ	P,
	MOVE	B,TMPDAT
	PUSHJ	P,STASH
INICH1:	MOVE	B,[POINT 6,TMPDAT,17]
	MOVEM	B,TMPPTR
	MOVEI	B,373737
	MOVEM	B,TMPDAT
	POPJ	P,

COMCH1:	SKIPL	SHFTIN
	JRST	COMCH7
	TRNE	B,100
	JRST	COMCH3
COMCH8:	PUSH	P,B
	MOVEI	B,35
COMCH5:	SETCMM	SHFTIN
	PUSHJ	P,COMCH4
	POP	P,B
	JRST	COMCH3

COMCH7:	SETOM	SHFTIN
	TRNE	B,200
	JRST	COMCH8
	SETZM	SHFTIN
COMCH2:	PUSH	P,B
	MOVEI	B,36
	JRST	COMCH5

COMCH6:	SUB	A,VBY
	JUMPG	A,CPOPJ
	MOVNM	A,VBY
	JRST	COMCH4

COMINC:	MOVE	G,VBSIZE
	MOVEI	A,0
	TRNN	B,10
	JRST	COMIN1
	TRNN	B,4
	AOSA	A
	SOS	A
	ASH	A,(G)
COMIN1:	ADDB	A,VBX
	SKIPL	A		;X OFF SCREEN?
	CAILE	A,1777
	TRZ	B,34		;YES, BEAM TRACKS Y INVISIBLY
	MOVEI	A,0
	TRNN	B,2
	JRST	COMIN2
	TRNN	B,1
	AOSA	A
	SOS	A
	ASH	A,(G)
COMIN2:	ADDB	A,VBY
	SKIPL	A		;Y OFF SCREEN?
	CAILE	A,1777
	TRZ	B,23		;YES, BEAM TRACKS X INVISIBLY
	TRNN	B,17		;NO MOVEMENT?
	POPJ	P,		;NONE, SO RETURN
IFNDEF	ILOSE<
	SKIPN	VISIB
	JRST	COMIN3>
	TRNN	B,20
IFNDEF	ILOSE<
	JRST	COMIN4
COMIN5:	IDPB	B,TMPPTR
	MOVE	B,TMPPTR
	TLNE	B,760000
	POPJ	P,
COMIN6:	MOVE	B,TMPDAT
	TRNE	B,177777
	PUSHJ	P,STASH
INIIN1:	MOVE	B,[POINT 4,TMPDAT,19]
	MOVEM	B,TMPPTR
	SKIPE	B,VISIB
	MOVEI	B,200000
	MOVEM	B,TMPDAT
	POPJ	P,

COMIN3:	TRNN	B,20
	JRST	COMIN5
COMIN4:	PUSH	P,B
	SETCMM	VISIB
	PUSHJ	P,COMIN6
	POP	P,B
	JRST	COMIN5
>	;-ILOSE
IFDEF	ILOSE<
	TDZA	B,B
	MOVEI	B,2000
	ADD	B,VBX
	HRL	B,VBY
	LDB	A,COMPTR
	TRZ	A,140000
	TRO	A,20000
	DPB	A,COMPTR
	SETOM	VBX
	SETOM	VBY>
COMPNT:	MOVS	A,B
	XOR	A,VBY
	TRNE	A,1777
	JRST	COMPN1
	TRNE	B,2000
	JRST	COMPN4
	MOVE	A,B
	XOR	A,VBX
	TRNN	A,1777
	JRST	[MOVN	A,PNTFLG
		MOVEM	A,VBMODE
		JUMPN	A,CPOPJ
		LDB	A,COMPTR
		TRZ	A,160000
		DPB	A,COMPTR
		POPJ	P,]
COMPN4:	TRZ	B,774000
	TRO	B,20000
	MOVE	A,B
	ANDI	A,1777
	MOVEM	A,VBX
	SETOM	PNTFLG
	JRST	STASH
COMPN1:	TRNN	B,2000
	JRST	COMPN3
	MOVE	A,B
	XOR	A,VBX
	TRNE	A,1777
	JRST	COMPN3
COMPN2:	MOVSS	B
	TRZ	B,776000
	HRRZM	B,VBY
	TLNE	B,2000
	TROA	B,222000
	TRO	B,220000
	SETOM	PNTFLG
	JRST	STASH

COMPN3:	PUSH	P,B
	TRZ	B,2000
	PUSHJ	P,COMPN2
	POP	P,B
	JRST	COMPN4

COMVEC:	LDB	A,[POINT 8,B,27]
	TRZE	A,200
	MOVNS	A
	ADDM	A,VBY
	MOVE	A,B
	ANDI	A,377
	TRZE	A,200
	MOVNS	A
	ADDM	A,VBX
	TRZ	B,400000
	TRO	B,200000
	JRST	STASH

STORAGE(IMPURE)
PNTFLG:	0			;0=LAST VB 1/2 WORD=PARAM MODE, -1=PNT
SHFTIN:	0			;0=SHIFT IN, -1= SHIFT OUT, +1= NOT SURE
VBMODE:	0			;VB MODE
VBX:	0			;X COORD
VBY:	0			;Y COORD
TMPDAT:	0			;TMP FOR INCREMENTS AND CHRS
TMPPTR:	0			;BYTE PTR FOR TMPDAT
COMCNT:	0			;COUNT OF III COMMAND WORDS
COMIDX:	0			;PTR TO III COMMAND LIST
COMCTR:	0			;COUNT OF VB10 COMMAND BYTES
COMPTR:	0			;PTR TO VB COMMAND LIST
IFNDEF	ILOSE<
VISIB:	0			;VISIBILITY FLAG FOR INCREMENTS
>
VBSIZE:	0			;CURRENT SCALE
VBBRIT:	0			;CURRENT BRITNESS
STOPCD:	0			;PTR TO LAST STOP INTERRUPT

CHFLG:	0
SIMPTR:	0
IIBRIT:	0
IISIZE:	0
IIX:	0
IIY:	0
STORAGE(PURE)

COMERR:	OUTSTR	[ASCIZ/
?BUG IN VB DATA
/]
	JRST	TODDT		;I.E. TO DDT

STASH:	SOSG	COMCTR
	JRST	TOOBIG
STASH1:	IDPB	B,COMPTR
	POPJ	P,

TOOBIG:
NOVIROS,<
	PUSH	P,B
	PUSHJ	P,DSTOP
	MOVEI	B,4000
	ADDM	B,COMCTR
CNTEXP:	HRRZ	B,.JBREL
	ADDI	B,2000
	CORE	B,
	JRST	[OUTSTR[ASCIZ/
CAN'T EXPAND LOW SEGMENT
/]
		PUSHJ	P,TODDT
		JRST CNTEXP]
	PUSHJ	P,DSTART
	POP	P,B
	JRST	STASH1
>;NOVIROS
VIROS,<
	SKIPN COMCTR			;FIRST TIME OUT?
	OUTSTR[ASCIZ/
SORRY, RAN OUT OF SYSTEM BUFFER SPACE.
WILL TRY TO LIMP ALONG.
/]
	POPJ P,
>;VIROS
>;VB10

NOGT,<
DPOUT:	SKIPN ISDPY
	POPJ P,
	LDB	T,[POINT 4,A,12]
	JUMPE	T,DSTART
	HRRZ	B,1(A)
	MOVEM	B,COMCNT
VB10,<	CAILE	T,4
	JRST	DPOUT3
>;VB10
	PUSHJ	P,PGFLSH
	SKIPN	COMCNT
VB10,<	JRST	DPOUT5	>
PGP,<	POPJ	P,	>
	PUSH	P,T
	SKIPL	GOING
	PUSHJ	P,DISERR
>;NOGT
VB10,<	MOVSI	C,-4
	MOVE	D,FBUF
	AOS	D
	HRRZ	B,PGTBL(C)
	CAIL	B,(D)
	MOVE	D,PGTBL(C)
	AOBJN	C,.-3
	HLRZ	TT,D
	ADDI	TT,(D)
	MOVEM	TT,STOPCD
	AOS	TT
	HRRZM	TT,PGTBL-1(T)
	JRST	DPOUT4

DPOUT3:	JUMPE	B,CPOPJ
	MOVEI	T,4
	PUSH	P,T
	SKIPN	B,PGTBL+3
	PUSHJ	P,DISERR
	MOVSI	C,-3
	HRRZ	D,PGTBL(C)
	CAIL	D,(B)
	PUSHJ	P,DISERR
	AOBJN	C,.-3
	HLRZ	TT,B
	ADDI	TT,(B)
	MOVEM	TT,STOPCD
	AOS	TT
DPOUT4:	TLO	TT,442200
	MOVEM	TT,COMPTR
	HRRZ	B,.JBREL
	SUBI	B,(TT)
	ADDI	B,2(B)
	MOVEM	B,COMCTR
	MOVEI	B,0
	PUSHJ	P,STASH
	SETOM	VBX
	SETOM	VBY
	SETOM	VBSIZE
	SETOM	VBBRIT
	SETZM	CHFLG
	SETZM	VBMODE
	MOVEI	B,1
	MOVEM	B,SHFTIN
>;VB10
PGP,<	SETOM	PGPBRI		;FORCE PARAM OUT
	MOVN	T,BLNKIT	;SET BLINK STATE
	MOVEM	T,PGPBRI+2
	SETZM	PGPBRI+1	;SOLID LINES
	SETZM	BLNKIT		;RESET BLINK FLAG
	SETZM	PSEGN		;PRIMITIVES TO SEGMENT 0
	MOVEI	T,1B18		;PHONEY X COORD TO FORCE A MOVE
	MOVEM	T,PGPX
	RTNCAL	(MRU,<[0],[1],[-2]>)			;10-MIL UNITS
	RTNCAL	(WINDO,<[-1000],[-1000],[1000],[1000]>)	;FULL SCREEN
	RTNCAL	(OSEG)			;USES ARG ALREADY ON THE STACK
>;PGP
NOGT,<	HRRZ	B,(A)
	MOVEM	B,COMIDX
	HRRZ	B,1(A)
	MOVEM	B,COMCNT
GETII1:	AOS	COMIDX
	SOSG	COMCNT			;END TEST
	JRST	DPOUT1
GETIII:	MOVE	A,@COMIDX
	TRZE	A,1
	JRST	DISCHR
VB10,<	SETZM	CHFLG	>
	TRNE	A,10
	PUSHJ	P,DISERR
	MOVE	B,A
	LSH	B,-1
	ANDI	B,3
	PUSHJ	P,@(B)[DISHLT
			DISVCT
			DISERR
			DISPNT]
	JRST	GETII1
>;NOGT

VB10,<
DPOUT1:	SETZB	A,B
	SKIPE	VBMODE		;ALREADY HAVE PARAM WORD?
	PUSHJ	P,CMPVB		;NO, SO MAKE ONE
	MOVE	C,COMPTR	;INSERT JMP FBUF+2
	MOVEI	B,160000
	TLNE	C,20000		;JMP WORD MUST BE LEFT 1/2
	PUSHJ	P,STASH
	DPB	B,COMPTR
	PUSHJ	P,STASH		;MAKE SURE WE HAVE ONE FREE WORD
	MOVEI	B,FBUF+2
	MOVEM	B,@COMPTR
	MOVE	B,[XWD 400000,NULLO]
	MOVEM	B,@STOPCD	;REMOVE OLD JMP FBUF+2
	HRRZ	B,COMPTR
	POP	P,T
	SUB	B,PGTBL-1(T)
	HRLM	B,PGTBL-1(T)
	HRRZ	B,COMPTR
DPOUT5:	JUMPE	B,CPOPJ
	PUSHJ	P,REDUCE
	JRST DSTART
>;VB10
PGP,<
DPOUT1:	POP	P,T
	MOVEI	TT,1
	LSH	TT,(T)
	IORM	TT,PGBITS
	RTNCAL	(CSEG,T)
	RTNCAL	(ENDPIC)
	POPJ	P,
>;PGP

DISERR:	OUTSTR	[ASCIZ /BUG IN DISPLAY DATA
/]
	JRST	TODDT

VB10,<
PGFLSH:	SKIPN	B,PGTBL-1(T)
	POPJ	P,
	MOVSI	C,-4
	HLRZ	F,B
	SETCM	F,F
	SETZM	PGTBL-1(T)
	MOVE	D,FBUF
	AOS	D

PGFLS2:	MOVE	E,PGTBL(C)
	HRRZ	H,E
	CAILE	H,(B)
	ADDM	F,PGTBL(C)
	CAILE	H,(D)
	MOVE	D,E
	AOBJN	C,PGFLS2
	HRRZ	C,D
	CAIG	C,(B)
	JRST	PGFLS1
	HLRZ	E,D
	ADD	C,E
	ADD	C,F
	HRRZ	E,B
	MOVEI	D,-1(E)
	SUB	E,F
	HRL	B,E
	MOVEI	E,FBUF+2
	MOVEM	E,(D)
	BLT	B,(C)
	MOVE	E,[XWD 400000,NULLO]
	MOVEM	E,(D)
	HRRZ	B,C
	JRST DSTART

PGFLS1:	HLRZ	B,D
	ADDI	B,(D)
	MOVEI	C,FBUF+2
	MOVEM	C,(B)
	JRST DSTART

DISCH2:	MOVEI	A,3
	PUSHJ	P,CMPVB
DISCH1:	POP	P,A
DISCHR:	JUMPE	A,GETII1
	MOVEI	B,0
	ROTC	A,7
	JUMPE	B,DISCHR
	PUSH	P,A
	ROTC	A,-2
	SKIPGE	A
	SKIPA	B,CHRTBL(B)
	MOVS	B,CHRTBL(B)
	TLNN	A,200000
	LSH	B,-=9
	ANDI	B,777
	MOVE	C,IISIZE
	MOVE	C,WDTBL-1(C)
	MOVE	D,IIX
	ADDM	C,IIX
	CAMGE	D,[-1000]
	JRST	DISCH1
	ADD	D,C
	CAILE	D,777
	JRST	DISCH3
	SKIPN	CHFLG
	JRST	DISCH4
DISCH5:	TRZN	B,400
	JRST	DISCH2
	ADD	B,[POINT 5,TALPHA]
	MOVEM	B,SIMPTR
DISSIM:	ILDB	B,SIMPTR
	JUMPE	B,DISCH1
	MOVEI	A,6
	PUSHJ	P,CMPVB
	JRST	DISSIM
DISCH3:	MOVEM	D,IIX
	JRST	DISCH1

WDTBL:	CWIDTH
	2*CWIDTH
	4*CWIDTH
	8*CWIDTH

DISCH6:	POP	P,A
	JRST	GETII1

DISCH4:	MOVE	D,IIY
	CAMGE	D,[-1000]
	JRST	DISCH6
	ADD	D,C
	ADD	D,C
	CAILE	D,777
	JRST	DISCH6
	SETOM	CHFLG
	PUSH	P,B
	MOVEI	A,0
	MOVE	B,IISIZE
	MOVE	B,WDTBL-1(B)
	LSH	B,-1
	EXCH	C,B
	MOVNS	B
	ADDI	B,2(C)		;UNDO LOSING III OFFSET
	ADD	B,IIX
	ADD	C,IIY
	PUSHJ	P,MAKPNT
	POP	P,B
	JRST	DISCH5

TALPHA:
PHASE	400
ALF::	BYTE (5) 12,12,12,30,37,36,34
	BYTE (5) 37,23,33,30,32,33,10
	BYTE (5) 10,0
BET::	BYTE (5) 14,30,32,22,30,36,22
	BYTE (5) 30,36,22,30,33,23,33
	BYTE (5) 37,13,13,10,0
NAY::	BYTE (5) 02,02,30,30,30,30,30
	BYTE (5) 23,23,10,13,0
EPS::	BYTE (5) 30,30,30,16,22,34,37
	BYTE (5) 22,22,32,30,30,13,13
	BYTE (5) 03,03,0
PIE::	BYTE (5) 30,22,22,22,36,30,30
	BYTE (5) 30,30,37,23,23,23,10
	BYTE (5) 10,10,0
LAM::	BYTE (5) 32,32,36,36,03,03,03
	BYTE (5) 23,12,10,30,33,10,10
	BYTE (5) 0
INF::	BYTE (5) 22,22,22,30,33,23,37
	BYTE (5) 34,12,12,32,30,23,23
	BYTE (5) 37,30,10,10,0
DEL::	BYTE (5) 30,36,22,32,30,30,33
	BYTE (5) 22,22,36,36,34,13,13
	BYTE (5) 13,03,23,37,34,10,10
	BYTE (5) 10,10,0
CAP::	BYTE (5) 22,22,22,22,32,30,30
	BYTE (5) 33,23,23,23,13,10,0
ALL::	BYTE (5) 32,36,22,22,02,22,23
	BYTE (5) 33,30,30,30,22,22,03
	BYTE (5) 03,23,23,37,37,10,10
	BYTE (5) 10,10,0
EXI::	BYTE (5) 14,30,30,30,30,30,22
	BYTE (5) 22,22,22,22,22,34,34
	BYTE (5) 34,34,03,03,33,30,30
	BYTE (5) 13,13,13,0
IFF::	BYTE (5) 22,30,30,30,23,32,36
	BYTE (5) 14,36,36,32,23,30,30
	BYTE (5) 30,13,13,03,03,0
NEQ::	BYTE (5) 02,02,02,22,30,33,22
	BYTE (5) 30,30,36,32,17,17,17
	BYTE (5) 37,30,23,37,12,32,30
	BYTE (5) 30,13,13,0
LEQ::	BYTE (5) 12,10,32,34,34,34,32
	BYTE (5) 32,32,17,17,03,03,37
	BYTE (5) 30,30,30,10,10,10,0
GEQ::	BYTE (5) 02,22,30,30,30,36,36
	BYTE (5) 36,03,03,03,03,23,30
	BYTE (5) 30,30,10,10,10,0
IDN::	BYTE (5) 22,30,30,30,30,02,22
	BYTE (5) 34,34,34,34,02,22,30
	BYTE (5) 30,30,30,13,13,03,03
	BYTE (5) 0
CUP::	BYTE (5) 32,36,22,22,22,10,10
	BYTE (5) 10,30,23,23,23,37,34
	BYTE (5) 13,10,10,10,0
ATS::	BYTE (5) 30,36,22,22,22,22,32
	BYTE (5) 30,30,33,23,34,34,23
	BYTE (5) 23,30,32,23,17,37,30
	BYTE (5) 10,10,10,0
GAM::	BYTE (5) 02,02,02,22,32,33,33
	BYTE (5) 33,23,37,36,22,12,32
	BYTE (5) 13,13,03,03,0
SIG::	BYTE (5) 22,22,22,32,32,22,30
	BYTE (5) 30,17,37,30,33,23,17
	BYTE (5) 17,34,30,30,32,13,10
	BYTE (5) 0
OHM::	BYTE (5) 30,34,32,36,22,32,30
	BYTE (5) 30,33,23,37,23,30,10
	BYTE (5) 10,0
INT::	BYTE (5) 22,33,32,22,22,22,22
	BYTE (5) 32,33,13,13,03,03,03
	BYTE (5) 0
PLM::	BYTE (5) 22,30,30,22,22,22,34
	BYTE (5) 34,12,32,23,33,30,17
	BYTE (5) 03,23,30,13,10,0
MU::	BYTE (5) 22,23,23,23,12,12,22
	BYTE (5) 34,36,22,22,10,10,30
	BYTE (5) 23,23,33,13,10,0
DEPHASE
                                                                                                                                     CHRTBL:
BYTE (9) 100,150,ALF,BET	;NUL	DWNARO	ALF	BET
BYTE (9) 141,NAY,EPS,PIE	;AND	BAR	RNDE	PI
BYTE (9) LAM,GAM,SIG,INT	;LAMBDA	GAMMA	SIGMA	INTEGRATE
BYTE (9) PLM,200,INF,DEL	;PLSMNS	CRCPLS	INFINTY	DELTA
BYTE (9) 145,144,CAP,CUP	;LEFTU	RGHTU	DOWNU	UPU
BYTE (9) ALL,EXI, MU,IFF	;UPA	BAKE	MICRO	DUBLARO
BYTE (9) OHM,147,143,NEQ	;OMEGA	RITEARO	SQG	SLSHEQ
BYTE (9) LEQ,GEQ,IDN,142	;LESBAR	MOREBAR	EQUBAR	OR
BYTE (9) 340,241,242,243	;SP	!	"	#
BYTE (9) 244,245,246,247	;$	%	&	'
BYTE (9) 250,251,252,253	;(	)	*	+
BYTE (9) 254,255,256,257	;,	-	.	/
BYTE (9) 260,261,262,263	;0	1	2	3
BYTE (9) 264,265,266,267	;4	5	6	7
BYTE (9) 270,271,272,273	;8	9	:	;
BYTE (9) 274,275,276,277	;<	=	>	?
BYTE (9) ATS,201,202,203	;@	A	B	C
BYTE (9) 204,205,206,207	;D	E	F	G
BYTE (9) 210,211,212,213	;H	I	J	K
BYTE (9) 214,215,216,217	;L	M	N	O	
BYTE (9) 220,221,222,223	;P	Q	R	S
BYTE (9) 224,225,226,227	;T	U	V	W
BYTE (9) 230,231,232,153	;X	Y	Z	[
BYTE (9) 152,154,146,151	;\	]	^	_
BYTE (9) 166,101,102,103	;'	a	b	c
BYTE (9) 104,105,106,107	;d	e	f	g
BYTE (9) 110,111,112,113	;h	i	j	k
BYTE (9) 114,115,116,117	;l	m	n	o
BYTE (9) 120,121,122,123	;p	q	r	s
BYTE (9) 124,125,126,127	;t	u	v	w
BYTE (9) 130,131,132,153	;x	y	z	{
BYTE (9) 162,167,154,152	;LINE	ROOF	~	DEL
                 DISPNT:	TRNE	A,34000			;
	JRST	DISBRT			;
DISPN1:	TRNE	A,3400			;
	JRST	DISSIZ			;
DISPN2:	LDB	B,[POINT 11,A,10]	;X
	LDB	C,[POINT 11,A,21]	;Y
	TRNE	B,2000			;
	ORCMI	B,1777			;
	TRNE	C,2000			;
	ORCMI	C,1777			;
	TRNE	A,100			;
	JRST	DISPN3			;
DISPN0:	ADD	B,IIX			;
	ADD	C,IIY			;
DISPN3:	TRNE	A,40			;
	JRST	DISPN4			;
	TRNN	A,20			;
	JRST	DISPN5			;
	MOVEM	B,IIX			;POINT
	MOVEM	C,IIY			;
	MOVEI	A,2000			;FALL INTO MAKPNT
MAKPNT:	ANDI	B,3777			;
	ANDI	C,3777			;
	TRC	B,2000			;
	TRC	C,2000			;
	SUBI	B,1000			;
	SUBI	C,1000			;
	TRNN	B,2000			;
	TRNE	C,2000			;
	POPJ	P,			;
	HRL	B,C			;
	IOR	B,A			;
	MOVEI	A,1			;
	JRST	CMPVB			;
DISPN4:	MOVEM	B,IIX			;INVIS POINT
	MOVEM	C,IIY			;
	POPJ	P,			;

DISPN5:	MOVE	D,B			;LONG VECTOR
	MOVE	E,C			;
	EXCH	B,IIX			;BC=XY1 ,DE=XY2
	EXCH	C,IIY			;
	MOVE	A,D			;
	SUB	A,B			;DX
	MOVE	F,E			;
	SUB	F,C			;DY
	CAIG	B,777			;
	CAMGE	B,[-1000]		;
	JRST	P1OFF			;
	CAIG	C,777			;
	CAMGE	C,[-1000]		;
	JRST	P1OFF			;
DISPN6:	CAIG	D,777			;
	CAMGE	D,[-1000]		;
	JRST	P2OFF			;
	CAIG	E,777			;
	CAMGE	E,[-1000]		;
	JRST	P2OFF			;
DISPN7:	SUB	D,B			;
	SUB	E,C			;
	PUSH	P,D			;
	PUSH	P,E			;
	MOVEI	A,0			;
	PUSHJ	P,MAKPNT		;
DISPN9:	POP	P,C			;
	POP	P,A			;
	CAIG	A,177			;
	CAMGE	A,[-177]		;
	JRST	SPLIT			;
	CAIG	C,177			;
	CAMGE	C,[-177]		;
	JRST	SPLIT			;
DISPN8:	MOVEI	B,200000		;
	SKIPGE	A			;
	TRO	B,200			;
	SKIPGE	C			;
	TRO	B,100000		;
	MOVMS	A			;
	MOVMS	C			;
	IOR	B,A			;
	DPB	C,[POINT 7,B,27]	;
	MOVEI	A,4			;
	JRST	CMPVB			;
SPLIT:	MOVM	B,A			;
	MOVM	D,C			;
	CAMGE	D,B			;
	MOVE	D,B			;
	ADDI	D,176			;
	IDIVI	D,177			;
	PUSH	P,A			;
	PUSH	P,C			;
	IDIV	A,D			;
	IDIV	C,D			;
	MOVN	D,A			;
	ADDM	D,-1(P)			;
	MOVN	D,C			;
	ADDM	D,(P)			;
	PUSHJ	P,DISPN8		;
	JRST	DISPN9			;
P1OFF:	PUSHJ	P,PXOFFF		;
	 POPJ	P,			;ALL OFF
	MOVE	A,D			;
	SUB	A,B			;
	MOVE	F,E			;
	SUB	F,C			;
	JRST	DISPN6			;

P2OFF:	EXCH	B,D			;
	EXCH	C,E			;
	PUSHJ	P,PXOFFF		;
	 PUSHJ	P,DISERR		;
	EXCH	B,D			;
	EXCH	C,E			;
	JRST	DISPN7			;

PXOFFF:	JUMPE	F,PXOFFE		;
	CAMGE	C,E			;
	SKIPA	T,[-1000]		;
	MOVEI	T,777			;
	CAMN	E,T			;
	JRST	PXOFF2			;
	CAMG	E,T			;
	JRST	PXOFF1			;
	CAMLE	C,T			;
	JRST	PXOFFE			;
PXOFF2:	SUB	T,E			;X=(Y-Y2)*DX/DY+X2
	MUL	T,A			;
	DIV	T,F			;
	ADD	T,D			;
	CAILE	T,777			;
	JRST	PXOFFR			;
	CAMGE	T,[-1000]		;
	JRST	PXOFFL			;
	CAMGE	C,E			;
	SKIPA	C,[-1000]		;
	MOVEI	C,777			;
	MOVE	B,T			;
	JRST	CPOPJ1			;

PXOFF1:	CAML	C,T			;
	JRST	PXOFF2			;
PXOFFE:	CAMGE	B,D			;
PXOFFL:	SKIPA	T,[-1000]		;
PXOFFR:	MOVEI	T,777			;
	JUMPE	A,CPOPJ			;
	CAMN	D,T
	JRST	PXOFF3
	CAMG	D,T
	JRST	PXOFF4
	CAMLE	B,T
	POPJ	P,
PXOFF3:	MOVE	B,T			;Y=(X-X2)*DY/DX+Y2
	SUB	T,D			;
	MUL	T,F			;
	DIV	T,A			;
	ADD	T,E			;
	CAIG	T,777			;
	CAMGE	T,[-1000]		;
	POPJ	P,			;
	MOVE	C,T			;
	JRST	CPOPJ1			;

PXOFF4:	CAML	B,T
	JRST	PXOFF3
	POPJ	P,

DISBRT:	LDB	B,[POINT 3,A,24]	;
	MOVEM	B,IIBRIT		;
	JRST	DISPN1			;

DISSIZ:	LDB	B,[POINT 3,A,27]	;
	MOVEM	B,IISIZE		;
	JRST	DISPN2			;

DISHLT:	TRNE	A,20			;
	PUSHJ	P,DISERR		;
	MOVEI	A,0			;
	MOVEI	B,3000			;HALT
	SETZM	COMCNT			;
	JRST	CMPVB			;
>;VB10

NOGT,<
DISVCT:	PUSH	P,A			;
	PUSHJ	P,DISVC1		;
	POP	P,A			;
	DPB	A,[POINT 20,A,19]	;
DISVC1:	LDB	B,[POINT 7,A,6]		;
	LDB	C,[POINT 7,A,13]	;
	TRNE	B,100			;
	ORCMI	B,77			;
	TRNE	C,100			;
	ORCMI	C,77			;
	LSH	A,=16			;
	JRST	DISPN0			;
>;NOGT

VB10,<
%DPCLR:	SKIPN ISDPY
	POPJ P,
	PUSHJ	P,DSTOP
	SETZM	PGTBL
	SETZM	PGTBL+1
	SETZM	PGTBL+2
	SETZM	PGTBL+3
	MOVEI	C,FBUF+2
	MOVE	B,FBUF
	AOS	B
	MOVEM	C,(B)
REDUCE:
NOVIROS,<
	TRO	B,1777
	CAML	B,.JBREL
	POPJ	P,
	PUSHJ	P,DSTOP
	CORE	B,
	JFCL
>;NOVIROS		CAN'T GIVE IT BACK HERE ON VIROS
	POPJ	P,
>;VB10					;;JB END OF VB10C STUFF.
             GT,<					;;JB IF GT40, ASSEMBLE IN THE FOLLOWING.
DPOUT:	SKIPN ISDPY
	POPJ P,
	PUSHJ	P,SAVER			;;JB SAVE ALL MAJOR REGISTERS NOW.
	LDB	14,[POINT 4,A,12]	;;JB GET THE BUFFER NUMBER=PICT. #
	JUMPE	14,RESTRE		;;JB 0=NOTHING. RESTORE AND RETURN.
	HRRZ	15,1(A)			;;JB PICK UP THE COUNT OF "III" VECTORS.
	HRRZ	16,0(A)			;;JB AND THE STARTING ADDRESS.
	PUSHJ	P,TRANS8		;;JB TRANSLATE THEM AND SEND THEM OUT.
	JRST	RESTRE			;;JB RESTORE THE REGISTERS AND RETURN.

%DPCLR:	SKIPN ISDPY
	POPJ P,
	JRST	CLEARS			;;JB ON A CLEAR, SIMPLY CALL THE CLEAR ROUTINE.
>;GT					;;JB END OF OUR STUFF.
                                           PGP,<				;PGP CODE
PGFLSH:	MOVEI	TT,1		;FIND RIGHT BIT
	LSH	TT,(T)
	TDNN	TT,PGBITS	;THIS PG IN USE?
	POPJ	P,		;NO
	ANDCAM	TT,PGBITS	;YES, CLR THE BIT
	MOVEM	T,OUTBLK	;FLUSH THE PG IN THE PGP
	RTNCAL	(INTERA,<[PLIT PUTPRG],[PLIT [PLIT OUTBLK]]>)
	JRST	CHCINT		;MAKE IT HAPPEN AND RETURN

DISPNT:	TRNE	A,34000		;BRIGHTNESS CHANGING?
	JRST	DISBRT		;YES, DO IT
DISPN1:	TRNE	A,3400		;CHR SIZ CHANGING?
	JRST	DISSIZ		;YES, DO IT
DISPN2:	LDB	B,[POINT 11,A,10] ;GET X
	LDB	C,[POINT 11,A,21] ;GET Y
	TRNE	B,2000		;SIGN EXTEND X
	ORCMI	B,1777
	TRNE	C,2000		;SIGN EXTEND Y
	ORCMI	C,1777
	TRNE	A,100		;ABSOLUTE?
	JRST	DISPN3		;YES
DISPN0:	ADD	B,IIX		;NO, MAKE ABSOLUTE
	ADD	C,IIY
DISPN3:	TRNE	A,40		;VISIBLE?
	JRST	DISPN4		;NO
	TRNN	A,20		;VECTOR?
	JRST	DISPN5		;YES
	MOVEM	B,IIX		;NO, POINT, SET XY
	MOVEM	C,IIY
	CAMN	B,PGPX		;AT RIGHT X?
	CAME	C,PGPY		;YES, AND AT RIGHT Y?
	PUSHJ	P,DISPN8	;NO, MOVE THERE
DISPN7:	RTNCAL	(ILIN2,<PSEGN,[0],[0]>) ;ZERO LENGTH VECTOR = POINT
	POPJ	P,

DISPN8:	MOVEM	B,PGPX		;SET PGP XY
	MOVEM	C,PGPY
DISPN9:	RTNCAL	(AMOV2,<PSEGN,B,C>) ;GET PGP TO RIGHT SPOT
	POPJ	P,

DISPN5:	PUSH	P,B		;SAVE XY
	PUSH	P,C
	MOVE	B,IIX		;PGP AT RIGHT XY?
	MOVE	C,IIY
	CAMN	B,PGPX
	CAME	C,PGPY
	PUSHJ	P,DISPN9	;NO, GET IT THERE
	POP	P,C		;RESTORE XY
	POP	P,B
	MOVEM	B,IIX		;SET X-Y
	MOVEM	C,IIY
	MOVEM	B,PGPX		;SET PGP XY
	MOVEM	C,PGPY
	RTNCAL	(ALIN2,<PSEGN,B,C>) ;MAKE ABSOLUTE VECTOR
	POPJ	P,

DISPN4:	MOVEM	B,IIX		;SET X-Y
	MOVEM	C,IIY
	POPJ	P,

DISBRT:	LDB	B,[POINT 3,A,24]	;GET III BRIGHTNESS
	MOVEM	B,IIBRIT
	MUL	B,NILEV			;SCALE TO PGP BRIGHTNESS
	DIVI	B,7
	CAIL	C,4			;ROUND
	AOS	B
	CAMN	B,PGPBRI		;NEED TO CHANGE?
	JRST	DISPN1			;NO
	MOVEM	B,PGPBRI		;YES, REMEMBER NEW BRIGHTNESS
	PUSH	P,A			;SAVE AC
	RTNCAL	(PARAMS,[PLIT PGPBRI])	;SET PARAMS
	POP	P,A			;RESTORE AC
	JRST	DISPN1			;DO REST OF VECTOR WORD

DISSIZ:	LDB	B,[POINT 3,A,27]	;GET III CHR SIZ
	SUBI	B,1
	MOVEM	B,IISIZE		;JUST SAVE
	JRST	DISPN2			;DO REST OF VECTOR WORD

DISCHR:	JUMPE	A,GETII1		;ALL CHRS DONE?
	SETZ	B,			;NO, GET NEXT CHR
	ROTC	A,7
	JUMPE	B,DISCHR		;NULL CHR?
	PUSH	P,A			;NO, SAVE REMAINING CHRS
	PUSHJ	P,CHRDRW		;DRAW THIS CHR
	POP	P,A			;RESTORE CHRS
	JRST	DISCHR			;DO THE REMAINING ONES

CHRDRW:	PUSH	P,IIX			;SAVE CHR START POINT
	PUSH	P,IIY
	PUSH	P,CHRTAB(B)		;GET PTR TO STROKE TABLE
	MOVEI	C,CWIDTH		;***UNDO LOSING III OFFSET
	ASH	C,@IISIZE
	MOVEI	B,(C)
	LSH	C,-1
	SUBI	B,(C)
	ADDI	B,2
	ADDM	B,IIX
	ADDM	C,IIY			;***
CHRDR1:	ILDB	A,(P)			;GET NEXT STROKE
	JUMPE	A,CHRDR4		;LAST STROKE?
	LDB	B,[POINT 4,A,31]	;NO, EXTRACT X
	LDB	C,[POINT 4,A,35]	;EXTRACT Y
	SUBI	B,10			;REMOVE OFFSET
	SUBI	C,10
	ASH	B,@IISIZE		;SCALE BY CHR SIZ
	ASH	C,@IISIZE
	TRNE	A,1B27			;VISIBLE STROKE?
	JRST	CHRDR2			;YES
	ADDM	B,IIX			;NO, JUST UPDATE COORDS
	ADDM	C,IIY
	JRST	CHRDR1			;TO NEXT STROKE

CHRDR2:	MOVE	D,IIX			;PGP AT RIGHT SPOT?
	CAME	D,PGPX
	JRST	CHRDR5			;NO
	MOVE	D,IIY
	CAME	D,PGPY
	JRST	CHRDR5			;NO
CHRDR3:	ADDB	B,IIX			;YES, UPDATE NEW III COORDS
	ADDB	C,IIY
	MOVEM	B,PGPX			;AND UPDATE PGP COORDS
	MOVEM	C,PGPY
	RTNCAL	(ALIN2,<PSEGN,B,C>)	;DRAW THE STROKE
	JRST	CHRDR1			;NEXT STROKE

CHRDR4:	POP	P,(P)			;FLUSH BYTE PTR
	POP	P,IIY			;RESTORE ORIGINAL Y
	POP	P,IIX			;UPDATE X BY 1 CHR WIDTH
	MOVEI	A,CWIDTH
	ASH	A,@IISIZE		;SCALED BY CHR SIZE
	ADDM	A,IIX
	POPJ	P,			;DONE WITH CHR

CHRDR5:	PUSH	P,B			;SAVE DESIRED COORDS
	PUSH	P,C
	RTNCAL	(AMOV2,<PSEGN,IIX,IIY>)	;INVISIBLE MOVE TO DESIRED SPOT
	POP	P,C			;RESTORE COORDS
	POP	P,B
	JRST	CHRDR3			;DRAW THE STROKE

DISHLT:	TRNE	A,20			;UNKNOWN FUNCTION?
	PUSHJ	P,DISERR		;YES, COMPLAIN
	SETZM	COMCNT			;NO, SIMULATE HALT
	RTNCAL	(CSEG,SEGN)
	RTNCAL	(ENDPIC)
	POPJ	P,

DRWDEM:	SETZ	B,			;DRW CHRS AT REFPT
DRWDE0:	MOVEM	B,IIX			;DRW CHRS AT SELECTED OFFSET
	SETZM	IIY
	HLRZM	A,PSEGN			;SEGN TO USE
	HRLI	A,440700		;MAKE CHR BYTE PTR
	PUSH	P,A			;SAVE FOR GETTING CHRS
	MOVSI	A,1B18			;FORCE PGP MOVE COMMAND
	MOVEM	B,PGPX
	MOVEI	A,TITBIG-1		;SET UP CHR SIZE
	MOVEM	A,IISIZE
DRWDE1:	ILDB	B,(P)			;GET NEXT CHR
	JUMPE	B,DRWDE2		;END OF STRING?
	PUSHJ	P,CHRDRW		;NO, DRAW IT
	JRST	DRWDE1			;DO NEXT CHR

DRWDE2:	POP	P,(P)			;FIX UP STACK
	POPJ	P,

PGPERR:	OUTSTR	[ASCIZ /PICTURE TOO BIG FOR PGP
/]
	RTNCAL	(ERRACK)		;RESET PGP
	SETZM	$VAL			;REINIT ERROR CELL
	POPJ	P,

%DPCLR:	RTNCAL	(STPIC)			;START NEW PICTURE
	RTNCAL	(OSEG,[0])		;GET AROUND PGP BUG
	RTNCAL	(CSEG,[0])		;***
	RTNCAL	(ENDPIC)		;IMMEDIATE STOP
	RTNCAL	(INTERA,<[PLIT %CLPRG],[PLIT NULARG]>)
	SETZM	GOING
	JRST	CHCINT

	E%CLPG-.-1
%CLPRG:	ASCIZ	!BEGIN
	ON HCA
	 TSA=0;
	END,
	END!
	0
	E%CLPG__.

STORAGE(IMPURE)
COMCNT:	0
COMIDX:	0
IIBRIT:	0
IISIZE:	0
IIX:	0
IIY:	0
PGPX:	0
PGPY:	0
PGPJBF:	0
	6
PGPBRI:	BLOCK	6
STORAGE(PURE)
>;PGP
                                                                                                                                                                                                                                                                                 ;COME HERE TO PUT DEFAULT PPN IN AC OF THE UUO
%DSKPN:	MOVEI	B,C
	MOVEI	C,-1
	SETZ E,
	PATH	B,		;PATH UUO
	GETPPN	E,		;IF NOT IMPLEMENTED USE GETPPN
	ROT	A,=13		;GET AC FIELD OF UUO
	ANDI	A,17
	ADD	A,P
	MOVEM	E,-20(A)	;PUT PPN IN SAVED AC
	POPJ	P,

STORAGE(PURE)
>;DEC
                                                                                                                                                                                                                                                                                                                                                                    COMMENT    VALID 00002 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	VERSION(LAST,2)
C00004 ENDMK
C;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       VERSION(LAST,2)


XLIST
STORAGE(IMPURE)
VAR
STORAGE(PURE)
LIT
LIST
STORAGE(IMPURE)
TWO,<STORAGE(PURE)>

FSTBEG:		;FREE STORAGE MAY START HERE

LAY,<

MD,<BEND D>
MPC,<BEND PC>

PASS1,<
DEPHASE
^LAY1E:
>;PASS1

PASS2,<
DEPHASE
^LAY2E:
TOTSUM__VERSUM	;PASS TOTAL BACK FOR FIXUP
TWO,<
STORAGE(LOW)
^LOWEND:
>;TWO
END SAVE
>;PASS2

^^PASSNM__PASSNM+1
>;LAY


NOLAY,<
TOTSUM__VERSUM	;PASS TOTAL BACK FOR FIXUP
END STRT
>;NOLAY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              