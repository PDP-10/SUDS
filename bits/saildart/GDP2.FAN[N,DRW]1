COMMENT    VALID 00027 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	CMU,<
C00008 00003	IMPURE STORAGE FOR GDP2 STUFF
C00012 00004	INITIALIZE COMMUNICATIONS WITH THE GDP2 VIA THE ATY LINE
C00015 00005	OPATYO:	INIT ATYO,4		CMU IMAGE MODE
C00016 00006	OPATYI:	INIT ATYI,4		CMU IMAGE MODE
C00017 00007	INITIALIZE A BUFFER TO HOLD A MESSAGE FOR THE DP2
C00019 00008	ROUTINES TO READ A BYTE FROM THE GDP2
C00020 00009	ROUTINES TO WRITE A BYTE OR WORD TO THE GDP2
C00021 00010	OUTPUT A BUFFER TO THE GDP2
C00023 00011	ROUTINES TO OUTPUT A PIECE OF GLASS TO THE GDP2
C00026 00012	IIILV:	TRNE A,77B27		BRIGHTNESS OR SIZE?
C00028 00013	LNGVEC:	SKIPG GDPMOD		ARE WE ALREADY IN LONG VECTOR MODE?
C00029 00014	IIISV:	SKIPE GDPMOD		MAKE SURE WE ARE IN MEDIUM VECTOR MODE
C00030 00015	LIOFF1:	SKIPA T,[6]		LONG NEEDS 6
C00031 00016	IIICH:	CAIN A,1		IS IT REALLY NULL STRING?
C00033 00017	MACROS TO SIMULATE III DPYCLR, DPYPOS, DPYSIZ
C00034 00018	NOLAST:	TLNN DSPACT
C00035 00019	PMODE:	TLNN DSPACT
C00036 00020	UPLVL:	TLNN DSPACT
C00037 00021	UPSCAL:	TLNN DSPACT
C00038 00022	READY:	PUSH P,T
C00039 00023	CURBRT:	TLNN DSPACT
C00040 00024	CLRCLC:	SKIPA TT,[TRZN T,BIGFLG]
C00041 00025	VHLINE:	TLNN DSPACT
C00042 00026	FOLOW1:	PUSHJ P,VECT
C00044 00027	>CMU
C00045 ENDMK
C;
CMU,<

VERSION(GDP2,3)


;ROUTINES FOR THE CMU GDP2 (GRAPHIC WONDER)

;PDP-11 INSTRUCTION DEFINITIONS
EMT11__104000
TRAP11__104400
NOP11__240
JMP.R0_110		;JMP @R0

;GRAPHIC MONITOR CONTROL WORDS
PASGRAPH__4	;FOR PASSING A BUFFER TO GRAPHIC MEMORY
PASBUF__0	;FOR PASSING A BUFFER TO ARBITRARY MEMORY
PASREGS__2	;FOR PASSING REGISTERS
GET2REGS__52	;CAUSES 2 REGISTERS TO BE RETURNED

;EXTENDED GRAPHIC CALLS FOR THE DRAWING PROGRAM
;(WE LOAD THE CODE FOR THESE FROM DRAW11.LNK)
LOADPG_EMT11+001	;LOADS A PIECE OF GLASS
BLNKPG_EMT11+002	;LOADS A BLINKING PIECE OF GLASS
ADDPG_EMT11+003		;ADDS DATA TO THE END OF THE LAST GLASS LOADED
REPPG_EMT11+024		;LIKE LOADPG, BUT DOESN'T CLEAR SCREEN
REPAPG_EMT11+025	;LIKE ADDPG, BUT DOESN'T CLEAR SCREEN
REPLPG_EMT11+026	;LIKE REPAPG, BUT FOR LAST PIECE - CLEARS REMAINING PIECES
SAVPOG_EMT11+027	;SAVES CURRENT POG INFO
RSTPOG_EMT11+030	;RESTORES CURRENT POG INFO
DELPG_EMT11+004		;DELETES A PIECE OF GLASS
CLRGDP_EMT11+005	;CLEARS ALL PIECES OF GLASS
PPTOP_TRAP11+113	;SETS POSITION OF TOP OF PIECE OF PAPER
PPSIZ_EMT11+006		;SETS SIZE OF PIECE OF PAPER
PG0SET_EMT11+007	;SETS SPECIAL STUFF IN PIECE OF GLASS # 0
SETFIL_EMT11+011	;SETS  FILE NAME IN POG 0
SETMOD_EMT11+013	;SETS MODE IN POG 0
SETLVL_EMT11+015	;SETS MACRO LEVEL IN POG 0
SETSCL_EMT11+014	;SETS SCALE IN POG 0
SETRDY_EMT11+012	;SETS THE READY INDICATOR (*) IN POG 0
SETFBR_EMT11+020	;SETS THE CURSOR BRIGHTNESSES IN POG 0
STFLG_EMT11+022	;SETS THE FLAGS WORD IN POG 0
SETCUR_EMT11+010	;SETS THE CURSOR POSITION IN POG 0
GETCUR_EMT11+023	;GETS THE CURSOR POSITION FROM POG 0
STLOC_EMT11+021		;SETS LOCATION OF CURRENTLY SELECTED THING IN POG 0
SETFV1_EMT11+016	;SETS THE LOCATION OF FOLLOW VECTOR 1 IN POG 0
SETFV2_EMT11+017	;SETS THE LOCATION OF FOLLOW VECTOR 2 IN POG 0

;GDP2 INSTRUCTIONS:
LFMT_100060		;SETS VECTOR FORMAT
LFMTM_LFMT+1		;SETS VECTOR FORMAT TO MEDIUM
LFMTL_LFMT+2		;SETS VECTOR FORMAT TO LONG
LCMD_100040		;SETS CMODE
TERM_100000		;TERMINATES A VECTOR LIST
ION_100201		;TURNS BEAM ON
IOFF1_100204		;TURNS OFF BEAM FOR THE NEXT VECTOR
LSCA_100140		;LOADS THE SCALE, ABSOLUTE
LILA_100100		;LOADS THE INTENSITY, ABSOLUTE
NOPGDP_100360		;NO OP FOR THE GDP2
SXYGDP_100222		;SET X AND Y

;LOCATION WELL OFF SCREEN, FOR HIDING THINGS
OFSCRN__4000
;IMPURE STORAGE FOR GDP2 STUFF
	STORAGE(IMPURE)

IIIX:	0			;ABSOLUTE POSITION OF THE BEAM
IIIY:	0

GDPMOD:	0			;CURRENT GDP2 VECTOR MODE (0=MED,+=LONG,-=UNKNOWN)

CHRWID__10			;WIDTH OF THE NORMAL SCALE CHARACTER
CHRSCL:	0			;LH = CURRENT CHAR WIDTH, RH = CURRENT CHAR SCALE
IFN 0,<
	XWD CHRWID/2,LSCA+4
	XWD CHRWID*5/8,LSCA+5
	XWD CHRWID*3/4,LSCA+6
VECSCL:	XWD CHRWID,LSCA+10	;THIS IS ALSO THE VECTOR SCALE
	XWD CHRWID*3/2,LSCA+12
	XWD CHRWID*2,LSCA+14
	XWD CHRWID*3,LSCA+16
>;IFN 0
IFE 0,<
VECSCL:	XWD CHRWID,LSCA+10
	XWD CHRWID*5/4,LSCA+11
	XWD CHRWID*3/2,LSCA+12
	XWD CHRWID*2,LSCA+14
	XWD CHRWID*3,LSCA+16
	XWD CHRWID*7/2,LSCA+17
	XWD CHRWID*7/2,LSCA+17
>;IFE 0

IIIBRT:	0			;CURRENT III BRIGHTNESS
	LILA+11
	LILA+12
	LILA+13
	LILA+14
	LILA+15
	LILA+16
	LILA+17

CMUFBF:				;PIECE OF GLASS 0 DATA
FILWRD:	NOPGDP			; FILE NAME
RDYWRD:	"*"*400+200		;READY FLAG
MODWRD:	"?"*401			;CURRENT MODE
SCLWRD: "?"*401		;CURRENT SCALE
LVLWRD: "?"*401		;CURRENT MACRO LEVEL
FVEC1X:	NOPGDP			;FOLLOW VECTOR 1
FVEC1Y:	NOPGDP
FVEC2X:	NOPGDP			;FOLLOW VECTOR 2
FVEC2Y:	NOPGDP
FBRT:	LILA+16			;CURSOR INTENSITY
LOCATX:	OFSCRN			;CURRENTLY SELECTED THING LOCATION
LOCATY:	OFSCRN
CURSX:	0			;CURSOR POSITION
CURSY:	0
FBFLGS:	0			;FLAGS (10000=BIG CURSOR, 200=FOLLOW SPARK PEN)
	BIGFLG__100000		;BIG CURSOR FLAG
	FOLFLG__200		;FOLLOW SPARK PEN
CMUFBL__.-CMUFBF

;IMPURE STORAGE FOR ATY STUFF
CHKSUM:	0			;RUNNING CHECKSUM OF THIS MESSAGE

ATYOHD:	BLOCK 3			;BUFFER HEADER FOR ATY OUTPUT
ATYOBL__2*(4+=256)+1		;SIZE OF ATY OUTPUT BUFFERS (=256 DATA WORDS)
ATYOB1:	0			;FIRST ATY OUTPUT BUFFER
	XWD ATYOBL+1,ATYOB2+1
	BLOCK ATYOBL+1
ATYOB2:	0			;SECOND ATY OUTPUT BUFFER
	XWD ATYOBL+1,ATYOB1+1
	BLOCK ATYOBL+1

ATYIHD:	BLOCK 3			;BUFFER HEADER FOR ATY INPUT
ATYIBL__7			;SIZE OF ATY INPUT BUFFERS
ATYIB1:	0			;FIRST ATY INPUT BUFFER
	XWD ATYIBL+1,ATYIB2+1
	BLOCK ATYIBL+1
ATYIB2:	0			;SECOND ATY INPUT BUFFER
	XWD ATYIBL+1,ATYIB1+1
	BLOCK ATYIBL+1

GDPFIL:	BLOCK 4			;FOR USE BY LOOKUP OF FILES TO INIT THE GDP
	STORAGE(PURE)
;FILES TO BE COPIED TO THE XGP ON INITIALIZATION

DEFINE FILMAC
<
	FILMC2(DRAW11,LNK,DATPPN)
	FILMC2(GRAPH,GST,<XWD 1,4>)
>

DEFINE FILMC2 (A,B,C)
<	SIXBIT /A/
>
FILTAB:	FILMAC
NFILS__.-FILTAB

DEFINE FILMC2 (A,B,C)
<	SIXBIT /B/
>
GEXTAB:	FILMAC

DEFINE FILMC2 (A,B,C)
<	C
>
PPNTAB:	FILMAC
IFN 0,<
;TABLE OF GDP'S (USE UNTIL SYS GIVES BETTER WAY TO FIND OUT)

GDP2TB:	DPYTAB:	;SPARE NAMES IN CASE I FORGET WHEN PATCHING
GDPTAB:	-1	;SPARE WORD FOR PATCHING IN NEW GDP2'S
	3	;THE ORIGINAL GDP2
	10	;THE FIRST PRODUCTION GDP2
	13	;THE FIRST GDP2 REMOTE FROM ITS PDP-11
	1	;THERE'S ONE IN THE C.mmp ROOM
GDPCNT__.-GDPTAB
>;IFN 0
;INITIALIZE COMMUNICATIONS WITH THE GDP2 VIA THE ATY LINE

INIGDP:	TLNN DSPACT
	POPJ P,
	PUSHJ P,OPATYI
	PUSHJ P,OPATYO
	JSP TT,INATYO		;RESTART THE PDP-11
	JMP.R0
	PASREGS
	MOVEI T,1000		;STARTING ADDRESS IS 1000
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
	MOVEI T,=1000		;GIVE IT A SECOND TO HAPPEN
	HIBER T,
	HALT .

;NOW PRINT A PRETTY MESSAGE ON THE SCREEN WHILE LOADING THE PDP-11
	OUTSTR [ASCIZ /


GDP-2 programs loading.  Wait Please...


Note:	There is an "XEXIT" command to exit this program. 



There is now a menu facility. (XCURSOR to invoke, X-CURSOR to remove)

The P command in Body Mode has been changed such that after inserting a body,
		You are no longer attached and moving the new body.
/]

;NOW INITIALIZE THE GDP2 SPECIAL ROUTINES
	INIT DAT,14		;INIT THE DSK
	SIXBIT/DSK/
	XWD 0,IOHD
	JRST [	OUTSTR [ASCIZ/
Unable to init the DSK, loading ATY
Type CONTINUE to try again
/]
		HALT .-3 ]
	MOVEI T,IOBUF		;SET UP THE BUFFERS
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVSI TT,-NFILS		;GET COUNT OF FILES TO COPY
INGDP2:	MOVE T,FILTAB(TT)
	MOVEM T,GDPFIL
	MOVE T,GEXTAB(TT)
	MOVEM T,GDPFIL+1
	SETZM GDPFIL+2
	SETZM GDPFIL+3	;FIRST SEE IF HE HAS ONE!
	LOOKUP DAT,GDPFIL
	JRST [	MOVE T,PPNTAB(TT)
		MOVEM T,GDPFIL+3
		LOOKUP DAT,GDPFIL
		CAIA
		JRST .+1		;OUT OF THE LITERAL
		OUTSTR [ASCIZ/
Unable to find the file "/]
		PUSH P,A
		PUSH P,TT
		MOVEI A,GDPFIL
		JSR FPRINT
		POP P,TT
		POP P,A
		OUTSTR [ASCIZ/"
Type CONTINUE to try again
/]
		EXIT 1,
		JRST INGDP2 ]
	OUT ATYO,		;INIT THE ATYO BUFFERS
	CAIA
	HALT .
INGDPL:	SOSGE IOHD+2		;ANY WORDS THERE?
	JRST INGDPN		;NO, GET SOME MORE IF WE CAN
	ILDB T,IOHD+1		;GET THE WORD
	ANDI T,377		;MAKE SURE ONLY 8 BITS
	IDPB T,ATYOHD+1		;ZAP IT OUT
	SOSG ATYOHD+2		;IS THE BUFFER FULL
	OUT ATYO,		;YES, GET ANOTHER
	JRST INGDPL		;AND DO THE NEXT WORD
	JRST [	OUTSTR [ASCIZ/
Output error on ATY, while loading GDP2 program
/]
		HALT . ]

INGDPN:	IN DAT,			;GET SOME MORE DATA
	JRST INGDPL		;AND TRY AGAIN
	GETSTS DAT,T		;HMMMMM....
	TRNN T,74B23		;ERROR?
	TRNN T,1B22		;NO, BETTER HAVE EOF!
	JRST [	OUTSTR [ASCIZ/
Input error on GDP2 program
/]
		HALT . ]
	CLOSE DAT,		;CLOSE THE DISK
	CLOSE ATYO,		;AND THE ATY
	AOBJN TT,INGDP2		;AND LOOP IF THERE ARE MORE FILES
	RELEAS DAT,		;DONE WITH THE DSK
	CLOSE ATYO,		;FLUSH THE LAST BUFFER

;Now print another pretty message
	OUTSTR [ASCIZ /
Loading complete.  You may proceed.
/]

	POPJ P,			;THAT'S ALL FOLKS
OPATYO:	INIT ATYO,4		;CMU IMAGE MODE
	SIXBIT/ATY/
	XWD ATYOHD,0
	JRST [	OUTSTR [ASCIZ/Unable to init ATY for display output
Type CONTINUE to try again
/]
		HALT OPATYO ]
	PUSH P,T
	MOVE T,[XWD 400000,ATYOB1+1]
	MOVEM T,ATYOHD
	MOVSI T,(<POINT 36,0,35>)
	MOVEM T,ATYOHD+1
	POP P,T
	POPJ P,
OPATYI:	INIT ATYI,4		;CMU IMAGE MODE
	SIXBIT/ATY/
	XWD 0,ATYIHD
	JRST [	OUTSTR [ASCIZ/Unable to init ATY for display input
Type CONTINUE to try again
/]
		HALT OPATYI ]
	PUSH P,T
	MOVE T,[XWD 400000,ATYIB1+1]
	MOVEM T,ATYIHD
	MOVSI T,(<POINT 36,0,35>)
	MOVEM T,ATYIHD+1
	POP P,T
	POPJ P,
;INITIALIZE A BUFFER TO HOLD A MESSAGE FOR THE DP2

;CALL IS:
;	JSP TT,INATYO
;	PDP-11 INSTRUCTION WORD
;	CONTROL WORD
;	(RETURN)

INATYO:	OUT ATYO,		;INIT THE BUFFERS
	CAIA
	HALT .
	HRRZ T,ATYOHD		;GET POINTER TO THE BUFFER
	ADD T,[POINT 36,2]	;MAKE IT A BYTE POINTER
	MOVEM T,ATYOHD+1	;SET UP THE HEADER
;	MOVEI T,<ATYOBL-5>/2*2	;GET THE BYTE COUNT, LEAVING ROOM FOR TERMINATE, WORD COUNT, AND CHECKSUM
	MOVEI T,<ATYOBL+1>/2*2	;GET THE BYTE COUNT
	MOVEM T,ATYOHD+2	;AND SET THE HEADER
	SETZM CHKSUM
	MOVEI T,1		;REQUIRED FOR MESSAGES
	PUSHJ P,ATYOW		;..
;;	MOVEI T,0		;REQUIRED FOR MESSAGES
;;	PUSHJ P,ATYOW
	MOVE T,(TT)		;GET FIRST ARGUMENT
	PUSHJ P,ATYOW
	MOVE T,1(TT)		;GET SECOND ARG
	PUSHJ P,ATYOW
	IBP ATYOHD+1		;SKIP THE WORD COUNT
	IBP ATYOHD+1
	JRST 2(TT)		;AND RETURN
;ROUTINES TO READ A BYTE FROM THE GDP2

ATYIB:	ILDB TT,ATYIHD+1
	SOSL ATYIHD+2
	POPJ P,
	IN ATYI,
	JRST ATYIB
	OUTSTR [ASCIZ/Input error from GDP ATY line!
/]
	HALT .
;ROUTINES TO WRITE A BYTE OR WORD TO THE GDP2

;CALL IS:
;	LOAD WORD OR BYTE INTO LOW ORDER BITS OF T
;	PUSHJ P,ATYOW (OR ATYOB)

ATYOW:	PUSHJ P,ATYOB		;OUTPUT THE LOW BYTE FIRST
	ASH T,-10		;NOW THE HIGH BYTE
ATYOB:	IDPB T,ATYOHD+1		;STORE THE BYTE
	ADDM T,CHKSUM		;KEEP CHECKSUM AS WE GO
	SOSE ATYOHD+2		;COUNT IT
	POPJ P,			;AND RETURN IF BUFFER NOT FULL
	HALT .			;IN CASE WE GO TOO FAR
ATYONX:
;	PUSH P,T		;SAVE SOME REGS
;	PUSH P,TT
	PUSHJ P,ATYOTM		;TERMINATE THIS BUFFER
	XSOFAR			;CHECK IF HE TYPED ANYTHING
	JSP TT,INATYO		;START A NEW MESSAGE
;	ADDPG
	REPAPG
	PASGRAPH
	MOVEI T,SXYGDP
	PUSHJ P,ATYOW
	MOVE T,IIIX
	PUSHJ P,ATYOW
	MOVE T,IIIY
	PUSHJ P,ATYOW
	SETOM GDPMOD		;FORGET THE VECTOR FORMAT!
;	POP P,TT
;	POP P,T
	POPJ P,
;OUTPUT A BUFFER TO THE GDP2

ATYOTM:
;	SETOM ATYOHD+2		;MAKE SURE WE DON'T RECURSE!
	MOVEI T,TERM		;OUTPUT A TERMINATE
	PUSHJ P,ATYOW
DOATYO:	HRRZ TT,ATYOHD		;GET THE BUFFER POINTER
	HRRZ T,ATYOHD+1		;FIND OUT WHERE WE ARE
	SUBI T,4*2+1(TT)	;GET THE BYTE COUNT
	ASH T,-1		;MAKE IT WORDS
	MOVEM T,2+<3*2>(TT)	;AND STORE THE LOW PART OF THE WORD COUNT
	ADDM T,CHKSUM
	ASH T,-10		;NOW THE HIGH PART
	MOVEM T,2+<3*2>+1(TT)
	ADD T,CHKSUM		;COMPUTE THE FINAL CHECKSUM
	MOVN T,T		;GDP-2 WANTS IT NEGATIVE
	IDPB T,ATYOHD+1		;PUT IT IN THE BUFFER
	HRRZ T,ATYOHD		;LOAD T FOR DEBUGGING
	MOVE T,2+<1*2>(T)
	CLOSE ATYO,		;ZAP IT OUT
	POPJ P,
	OUTSTR [ASCIZ/Output error on ATY !!!!!!
/]
	HALT .
;ROUTINES TO OUTPUT A PIECE OF GLASS TO THE GDP2

;FIRST, TO CLEAR A PIECE OF GLASS
HYDPOG:	TLNN DSPACT		;SHOULD WE EVEN BOTHER?
	POPJ P,			;NO
	PUSH P,TT
	MOVEI TT,1
	LSH TT,(T)
	TDNN TT,PAGACT		;IS THIS PIECE OF GLASS ACTIVE
	JRST HYDPG2		;NO, ITS ALREADY CLEAR
	ANDCAM TT,PAGACT	;MARK IT INACTIVE
	PUSH P,T
	JSP TT,INATYO		;OK SEND THE MESSAGE TO THE GDP2
	DELPG
	PASREGS
	MOVE T,(P)		;RESTORE THE PIECE OF GLASS NUMBER
	PUSHJ P,ATYOW		;SEND IT TOO
	PUSHJ P,DOATYO		;ZAP IT OUT
	POP P,T
HYDPG2:	POP P,TT
	POPJ P,

;NOW ONE TO OUTPUT A BLINKING PIECE OF GLASS
BLINKO:	TLNN DSPACT		;SHOULD WE EVEN BOTHER
	POPJ P,			;NO
	PUSH P,T
	PUSH P,TT
	JSP TT,INATYO		;START IT WITH BLINKING
	BLNKPG
	PASGRAPH
	JRST DPYOU2		;AND ACT AS IF IT WERE NOT BLINKING

;AND FINALLY ONE TO PUT OUT A NORMAL PIECE OF GLASS
DPYOUT:	TLNN DSPACT		;SHOULD WE EVEN BOTHER
	POPJ P,			;NO
	PUSH P,T
	PUSH P,TT
	JSP TT,INATYO		;AND START THE MESSAGE
;	LOADPG
	REPPG
	PASGRAPH
DPYOU2:	SKIPN T,PGLASS		;GET THE PIECE NUMBER
	JRST [	OUTSTR [ASCIZ/Asked to output Piece Of Glass 0!
/]
		HALT . ]
	PUSHJ P,ATYOW		;OUTPUT IT
	PUSHJ P,MRKPAG		;MARK THE PIECE ACTIVE
	PUSH P,TTT
	PUSH P,A
	PUSH P,B
	SETZM IIIX		;MOVE TO CENTER SCREEN
	SETZM IIIY
	SETZM GDPMOD		;ASSUME WE ARE IN MEDIUM VECTOR MODE AT FIRST
	MOVE T,CHRSCL+1		;SCALE 1 (III)
	MOVEM T,CHRSCL
	MOVE T,IIIBRT+1		;BRIGHTNESS 1 (III)
	MOVEM T,IIIBRT
	MOVEI B,DPYBUF		;GET LENGTH OF III BUFFER
	SUBI B,@BUFPTR
	HRLZI B,(B)		;PUT IT IN LEFT HALF
	JUMPGE B,IIIDN		;GET OUT IF ITS A NULL LIST!
	HRRI B,DPYBUF+1		;GET THE FIRST WORD ADDRESS
IIILOP:
	MOVE T,ATYOHD+2
	CAIGE T,4*2+6		;MAKE SURE THERE IS ROOM FOR A LONG INVISIBLE VECTOR OF DIFFERENT BRIGHTNESS
	PUSHJ P,ATYONX
	MOVE A,(B)		;GET AN III WORD
	TRNE A,1		;ASCII?
	JRST IIICH		;YES, GO DO IT
	JUMPE A,IIIDN
	TRC A,6
	TRNN A,37		;LONG VECTOR
	JRST IIILV
	TDNN A,[4,,33]		;SHORT VECTOR
	JRST IIISV
	OUTSTR [ASCIZ/Illegal III instruction encountered in DPYOUT!
/]
	HALT .
IIILV:	TRNE A,77B27		;BRIGHTNESS OR SIZE?
	JRST [	LDB T,[POINT 3,A,27]
		MOVE T,CHRSCL(T)
		MOVEM T,CHRSCL
		LDB T,[POINT 3,A,24]
		MOVE T,IIIBRT(T)
		CAMN T,IIIBRT
		JRST DOVEC
		MOVEM T,IIIBRT
		PUSHJ P,ATYOW
		JRST DOVEC ]
DOVEC:	MOVE TT,A
	ASHC TT,=11-=36		;TT NOW CONTAINS X FIELD, SIGN EXTENDED
	LSH TTT,1
	ASH TTT,=11-=36		;AND TTT CONTAINS Y
	TRNN A,100		;ABSOLUTE?
	JRST IIIREL		;NO
	SUB TT,IIIX		;YES, MAKE IT RELATIVE
	SUB TTT,IIIY
IIIREL:	ADDM TT,IIIX		;UPDATE CURRENT POSITION
	ADDM TTT,IIIY
	CAIG TT,177		;CAN WE DO THIS WITH A MEDIUM VECTOR?
	CAMGE TT,[-177]
	JRST LNGVEC		;NO, X IS TOO BIG
	CAIG TTT,177
	CAMGE TTT,[-200]
	JRST LNGVEC		;NO, Y IS TOO BIG
MEDVEC:	SKIPE GDPMOD		;ARE WE ALREADY IN MEDIUM VECTOR MODE?
	JRST [	MOVEI T,LFMTM	;SWITCH TO MEDIUM VECTOR FMT
		PUSHJ P,ATYOW
		SETZM GDPMOD
		JRST .+1 ]
	MOVEI T,IOFF1
	TRNE A,40		;INVISIBLE?
;	PUSHJ P,MIOFF1		;YES, GO TURN OFF BEAM
	PUSHJ P,ATYOW		;YES, GO TURN OFF BEAM
	MOVE T,TTT		;OUTPUT Y
	PUSHJ P,ATYOB
	MOVE T,TT		;OUTPUT X
	PUSHJ P,ATYOB

IIIVDN:	AOBJN B,IIILOP		;GO BACK IF THERE ARE ANY MORE VECTORS
IIIDN:	HRRZ TT,ATYOHD		;GET TOP OF BUFFER AGAIN
	MOVE T,2+<1*2>(TT)	;GET OLD INSTRUCTION
	CAIN T,REPPG		;IF IT IS A REPPG
	MOVEI T,LOADPG		;MAKE IT A LOADPG
	CAIN T,REPAPG		;AND IF IT IS A REPAPG
	MOVEI T,REPLPG		;MAKE IT A REPLPG
	SUB T,2+<1*2>(TT)
	ADDM T,2+<1*2>(TT)	;CHANGE THE LOW BYTE (THE HIGH BYTE STAYS AN EMT11)
	ADDM T,CHKSUM
	PUSHJ P,ATYOTM		;ALL DONE! TERMINATE IT.
	POP P,B
	POP P,A
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,
LNGVEC:	SKIPG GDPMOD		;ARE WE ALREADY IN LONG VECTOR MODE?
	JRST [	MOVEI T,LFMTL	;NO, PUT US IN LONG VEC FMT
		PUSHJ P,ATYOW
		MOVEM T,GDPMOD
		JRST .+1 ]
	MOVEI T,IOFF1
	TRNE A,40		;INVISIBLE?
;	PUSHJ P,LIOFF1		;YES, GO TURN IT OFF
	PUSHJ P,ATYOW		;YES, GO TURN IT OFF
;	MOVEI T,4		;WE NEED AT LEAST 4 CONTIGUOUS BYTES
;	CAMLE T,ATYOHD+2	;CAN WE FIT INTO THIS BUFFER?
;	PUSHJ P,ATYONX		;NO, GO TO THE NEXT BUFFER
	MOVE T,TTT		;OUTPUT Y
	PUSHJ P,ATYOW
	MOVE T,TT		;OUTPUT X
	PUSHJ P,ATYOW
	JRST IIIVDN		;AND SEE IF THERE ARE ANY MORE
IIISV:	SKIPE GDPMOD		;MAKE SURE WE ARE IN MEDIUM VECTOR MODE
	JRST [	MOVEI T,LFMTM
		PUSHJ P,ATYOW
		SETZM GDPMOD
		JRST .+1 ]
IIISV2:	MOVE TT,A
	ASHC TT,=7-=36		;TT GETS X FIELD
	LSH TTT,1
	ASH TTT,=7-=36		;TTT GETS Y FIELD
	ADDM TT,IIIX		;UPDATE POSITION
	ADDM TTT,IIIY
	MOVEI T,IOFF1
	TLNE A,10		;INVISIBLE?
;	PUSHJ P,MIOFF1		;YES, TURN IT OFF
	PUSHJ P,ATYOW		;YES, TURN IT OFF
	MOVE T,TTT		;OUTPUT Y
	PUSHJ P,ATYOB
	MOVE T,TT		;OUTPUT X
	PUSHJ P,ATYOB
IIISV3:	LSH A,=16		;GET THE OTHER VECTOR
	TLNE A,1		;DID WE ALREADY DO IT?
	JRST IIISV2		;NO, GO DO IT
	JRST IIIVDN
;LIOFF1:	SKIPA T,[6]		;LONG NEEDS 6
;MIOFF1:	MOVEI T,4		;AND MEDIUM 4 CONSECUTIVE BYTES
;	CAMLE T,ATYOHD+2	;DO WE HAVE ENOUGH ROOM IN THIS BUFFER?
;	PUSHJ P,ATYONX		;NO, START THE NEXT BUFFER
;	MOVEI T,IOFF1		;TURN OFF ONE VECTOR
;	JRST ATYOW
IIICH:	CAIN A,1		;IS IT REALLY NULL STRING?
	JRST IIIVDN		;YES, IGNORE IT
	MOVE T,ATYOHD+2
	CAIGE T,2*5+<2*6>+6
	PUSHJ P,ATYONX
	MOVEI T,LCMD+1		;SWITCH TO CHARACTER MODE
	PUSHJ P,ATYOW
	MOVE T,CHRSCL		;CHECK THE SCALE
	CAME T,VECSCL		;IS IT LIKE VECTORS?
	PUSHJ P,ATYOW		;NO, GO CHANGE IT
	HLRE TT,CHRSCL		;GET THE CHARACTER WIDTH
	MOVEI T,200		;SPECIAL CODE TO INITIALIZE STRINGS
	PUSHJ P,ATYOB
IIICH2:
FOR I_1,5 <
	LDB T,[POINT 7,A,<7*I-1>]
	JUMPE T,.+5		;UNLESS ITS A NULL CHARACTER
	ADDM TT,IIIX		;COUNT ITS WIDTH
	PUSHJ P,ATYOB		;AND OUTPUT THE CHARACTER
	MOVEI T,301		;BACK UP 2 INCS FOR THE LOSING CHAR SET
	PUSHJ P,ATYOB
>;FOR LOOP
	MOVE TTT,ATYOHD+2
	CAIGE TTT,2*5+<2*3>+1+6	;IS THERE ENOUGH ROOM FOR ANOTHER WORD?
	JRST IIICNB		;NO, GO TO THE NEXT BUFFER
	MOVE A,1(B)		;GET THE NEXT WORD
	TRNE A,1		;IS IT ASCII TOO?
	AOBJN B,IIICH2		;YES, GO DO IT UNLESS OFF END
IIICNB:	MOVEI T,0
	TRNE TTT,1		;DID WE OUTPUT AN ODD NUMBER OF CHARS?
	PUSHJ P,ATYOB		;YES, GO OUTPUT ONE MORE
	AOBJP B,IIIDN		;IF WE HAVE NO MORE III STUFF, FINISH UP
;	JUMPE A,IIIDN		;0 IS END OF DISPLAY
	MOVE T,VECSCL		;CHECK THAT WE ARE BACK TO VECTOR SCALE
	CAME T,CHRSCL
	PUSHJ P,ATYOW
	MOVEI T,ION		;MAKE SURE WE ARE VISIBLE
	PUSHJ P,ATYOW
	MOVEI T,LCMD+0		;GO BACK TO VECTOR MODE
	PUSHJ P,ATYOW
	SETOM GDPMOD		;CHARACTERS CLOBBER THE VECTOR FORMAT!
	JRST IIILOP		;AND GO DO THE NEXT WORD
;MACROS TO SIMULATE III DPYCLR, DPYPOS, DPYSIZ

DEFINE DPYCLR <
PUSHJ P,[
	PUSH P,T
	PUSH P,TT
	JSP TT,INATYO
	CLRGDP
	PASREGS
	PUSHJ P,DOATYO
	POP P,TT
	POP P,T
	POPJ P,
]
>

DEFINE DPYPOS (I) <
PUSHJ P,[
	JSP TT,INATYO
	PPTOP
	PASREGS
	MOVEI T,<I>
	PUSHJ P,ATYOW
	JRST DOATYO
]
>

DEFINE DPYSIZ (I) <
PUSHJ P,[
	JSP TT,INATYO
	PPSIZ
	PASREGS
	MOVEI T,<I>&777
	PUSHJ P,ATYOW
	MOVEI T,<<I>&777>*<<I>/1000>
	PUSHJ P,ATYOW
	JRST DOATYO
]
>
NOLAST:	TLNN DSPACT
	POPJ P,
	MOVE T,NAMBUF
	TLNN T,774000		;IS THE FILE NAME NULL?
	JRST [	JSP TT,INATYO	;YES, SPECIAL CASE IT.

		SETFIL
		PASREGS
		MOVEI T,NOPGDP
		PUSHJ P,ATYOW
		JRST DOATYO ]
	JSP TT,INATYO
	SETFIL
	PASGRAPH
	MOVE TT,[POINT 7,NAMBUF]
	MOVEI T,200		;SPECIAL CHAR TO SET UP CHARACTER SET
	PUSHJ P,ATYOB
	ILDB T,TT
	JUMPN T,.-2
	MOVE TT,ATYOHD+2	;CHECK IF WE OUTPUT AN ODD NUMBER OF BYTES
	TRNE TT,1
	PUSHJ P,ATYOB		;YES, PUT OUT A PAD
	JRST ATYOTM		;AND GO FINISH IT OUT
PMODE:	TLNN DSPACT
	POPJ P,
	PUSH P,TT
	MOVE T,MODE
	MOVE TT,DMODE(T)	;GET THE NEW MODE
	LSHC T,7		;T GETS FIRST CHAR
	LSH TT,=8-=36
	SKIPN TT
	MOVEI TT,40*2
	DPB TT,[POINT 9,T,28]	;AND THE SECOND CHAR
	CAMN T,MODWRD		;IS IT THE SAME AS BEFORE
	JRST PMODE2		;YES, DONT CHANGE IT
	MOVEM T,MODWRD
	JSP TT,INATYO
	SETMOD
	PASREGS
	MOVE T,MODWRD
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
PMODE2:	POP P,TT
	POPJ P,
UPLVL:	TLNN DSPACT
	POPJ P,
	HRRZ T,MACPNT
	SUBI T,MACPDL-1
	IDIVI T,5
	PUSHJ P,GETD2
	CAMN T,LVLWRD
	POPJ P,
	MOVEM T,LVLWRD
	JSP TT,INATYO
	SETLVL
	PASREGS
	MOVE T,LVLWRD
	PUSHJ P,ATYOW
	JRST DOATYO

GETD2:	PUSH P,TT
	IDIVI T,=10
	JUMPE T,[
		HRREI T,-20*400
		JRST GETD2B ]
	LSH TT,=8
	PUSH P,TT
	IDIVI T,=10
	POP P,T
GETD2B:	ADDI T,60*401(TT)
	POP P,TT
	POPJ P,
UPSCAL:	TLNN DSPACT
	POPJ P,
	MOVE T,NSCALE
	PUSHJ P,GETD2
	CAMN T,SCLWRD
	POPJ P,
	MOVEM T,SCLWRD
	JSP TT,INATYO
	SETSCL
	PASREGS
	MOVE T,SCLWRD
	PUSHJ P,ATYOW
	JRST DOATYO
READY:	PUSH P,T
	MOVEI T,"*"*400+200
	JRST SREADY

NREADY:	PUSH P,T
	MOVEI T,200
SREADY:	TLNE DSPACT
	CAMN T,RDYWRD
	JRST XREADY
	MOVEM T,RDYWRD
	PUSH P,TT
	JSP TT,INATYO
	SETRDY
	PASREGS
	MOVE T,RDYWRD
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
	POP P,TT
XREADY:	POP P,T
	POPJ P,
CURBRT:	TLNN DSPACT
	POPJ P,
	ANDI T,7
	SKIPN T,IIIBRT(T)
	MOVE T,IIIBRT+6
	CAMN T,FBRT
	POPJ P,
	MOVEM T,FBRT
	JSP TT,INATYO
	SETFBR
	PASREGS
	MOVE T,FBRT
	PUSHJ P,ATYOW
	JRST DOATYO
CLRCLC:	SKIPA TT,[TRZN T,BIGFLG]
SETCLC:	MOVE TT,[TROE T,BIGFLG]
CHFLGS:	MOVE T,FBFLGS
	XCT TT
	POPJ P,
	MOVEM T,FBFLGS
	JSP TT,INATYO
	STFLG
	PASREGS
	MOVE T,FBFLGS
	PUSHJ P,ATYOW
	JRST DOATYO

CURSOFF:TRZ M,CURSOR
	MOVE TT,[TRZN T,FOLFLG]
	JRST CHFLGS

CURSON:	TRO M,CURSOR
	MOVE TT,[TROE T,FOLFLG]
	JRST CHFLGS
VHLINE:	TLNN DSPACT
	POPJ P,
	PUSH P,T
	TLNE LOCATE
	PUSHJ P,VECT
	JRST [	MOVEI TT,OFSCRN
		MOVEI T,OFSCRN
		JRST VHLIN2 ]
	MOVE T,TT
	LSH T,=11
	ASH T,=11-=36
	ASH TT,=11-=36
VHLIN2:	CAMN TT,LOCATX
	CAME T,LOCATY
	CAIA
	JRST VHLIN1
	MOVEM TT,LOCATX
	MOVEM T,LOCATY
	JSP TT,INATYO
	STLOC
	PASREGS
	MOVE T,LOCATX
	PUSHJ P,ATYOW
	MOVE T,LOCATY
	PUSHJ P,ATYOW
	PUSHJ P,DOATYO
VHLIN1:	POP P,T
	POPJ P,
FOLOW1:	PUSHJ P,VECT
	JRST CLEAR1
	MOVE T,TT
	LSH T,=11
	ASH T,=11-=36
	ASH TT,=11-=36
FOLW1B:	CAMN TT,FVEC1X
	CAME T,FVEC1Y
	TLNN DSPACT
	POPJ P,
	MOVEM TT,FVEC1X
	MOVEM T,FVEC1Y
	JSP TT,INATYO
	SETFV1
	PASREGS
	MOVE T,FVEC1X
	PUSHJ P,ATYOW
	MOVE T,FVEC1Y
	PUSHJ P,ATYOW
	JRST DOATYO

CLEAR1:	MOVEI TT,NOPGDP
	MOVEI T,NOPGDP
	JRST FOLW1B

FOLOW2:	PUSHJ P,VECT
	JRST CLEAR2
	MOVE T,TT
	LSH T,=11
	ASH T,=11-=36
	ASH TT,=11-=36
FOLW2B:	CAMN TT,FVEC2X
	CAME T,FVEC2Y
	TLNN DSPACT
	POPJ P,
	MOVEM TT,FVEC2X
	MOVEM T,FVEC2Y
	JSP TT,INATYO
	SETFV2
	PASREGS
	MOVE T,FVEC2X
	PUSHJ P,ATYOW
	MOVE T,FVEC2Y
	PUSHJ P,ATYOW
	JRST DOATYO

CLEAR2:	MOVEI TT,NOPGDP
	MOVEI T,NOPGDP
	JRST FOLW2B
>;CMU
    