TITLE WL

XALLNOLIT

DEFINE SETSW $ (NAME,DEFVAL)
<	IFNDEF NAME$SW,<NAME$SW__IFIDN <DEFVAL> <> <0;>DEFVAL
>
	NAME$SW__NAME$SW
>

DEFINE ONOFSW $ (NAME)
<	IFN NAME$SW,<NAME$SW__-1>	;MAKE IT NICE FOR  AND 
>
DEFINE DEFSW $ (NAME)
<	DEFINE NAME,<IFN NAME$SW>
	DEFINE NO$NAME,<IFE NAME$SW>
>
DEFINE MAKESW(NAME,VAL)
<	SETSW(NAME,VAL)
	ONOFSW(NAME)
	DEFSW(NAME)
>

MAKESW(STAN)
MAKESW(DEC)
MAKESW(CMU)
MAKESW(ITS)

DEFINE STANFO,<STAN>		;LONG FORM FOR HYSTERICAL RAISINS

DEFINE CHECK $ (SITE,VAR) <IFDEF VAR,<SITE$SW__-1;>>
IFE STANSW!DECSW!CMUSW!ITSSW,<
;IF NO SITE SET MANUALLY ABOVE, WE MUST DECIDE FOR OURSELVES WHERE WE ARE
CHECK(ITS,.IOT) CHECK(CMU,CMUDEC) CHECK(STAN,SPWBUT) DECSW__-1
>

DEFINE MOR (A)
<TMPSW__0
FOR B IN (A)
<	B,<TMPSW__-1>
>
IFN TMPSW>

DEFINE MWL,<IFE 0>	;THIS IS WL
DEFINE MPC,<IFN 0>	;NOT PC
DEFINE MD,<IFN 0>	;OR D
DEFINE MDPC,<IFN 0>

MAKESW(ROUTE,-1)	;WIRE WRAP ROUTER -- OPTIMIZES RUNS

NODEC,<VIROSSW__0>
MAKESW(VIROS,-1)

MAKESW(BOTH,CMUSW)		;OUTPUT BOTH IC AND WIREWRAP SIDE INFORMATION

MAKESW(TAPR8,DECSW!CMUSW)	;SPECIAL TAPR8 WIREWRAP OUTPUT


MAKESW(USAGE,-1)	;FREE STORAGE USAGE COUNTERS

MAKESW(DECOS,DECSW!CMUSW)	;SITE HAS DEC LIKE OPERATING SYSTEM

MAKESW(TTYBT,DECOSSW)	;SITE CAN SET TTY BREAK TABLE

MAKESW(ESCMP,DECSW!CMUSW)	;MUST MAP ESCAPES FROM TTY INTO ALTMODES
			;YOU ONLY NEED THIS IF 176, 175, AND 33 ARE ALL ALTMODE
NOCMU,<
NOITS,<
DEFINE ECLROUTE<ECLSW__-1PRINTS/ECL ROUTING SELECTED
/>

PRINTS/TYPE NAME TO SET ANY OF THE FOLLOWING SPECIAL SWITCHES,
 THEN TYPE <CTRL><META><LINEFEED>:

ECLROUTE

/
.INSERT TTY:

IFNDEF ECLSW <ECLSW__0>
>;NOITS
>;NOCMU
;IO CHANNELS, IOVERSIONS, FLAG BITS, ACS
;IO CHANNEL ASSIGNMENTS
DAT__0
LST__1
IDSK__2
DECOS,<TTYCHN__3>
ITS,<FONTCH__4>

;SOME FILE EXTENSIONS
NODEC,<
CMU,<	EXTSAV__'SAV'	>
NOCMU,<	EXTSAV__'DMP'	>
ITS,<	EXTSAV__'BIN'	>
>;NODEC

;IO VERSION #'S
WDVER__13
WPCVER__400002
WDRVER__1
BACVER__12
LESVER__1
DIPVER__3

EXTERNAL .JBFF,.JBSA,.JBSYM,.JBREL,.JBDDT,.JBOPC,.JBREN

;AC0 FLAG BITS
FLAG__1			;TEMPORARY FLAG BIT
ASCFLG__2		;=1 ASCII INPUT =0 FULL WORD INPUT
PCNOTD__4		;READING PC FILE, NOT D
CONLY__10		;CONNECTOR INTERCONNECTIONS NEEDED ONLY
ISBACK__20		;IS BACK PANEL LIST WE ARE DOING
MODINC__40		;AUTO-INCREMENTING PINS
DOBEQ__100		;DOING BACK PANEL EQUIVALENCES
DOALLC__200		;DO ALL CARDS AT TTY PRINT
DOERRS__400		;DOING ERROR SUMMARY
DOWIE__1000		;DOING OUTPUT OF WIRE LIST INPUT ERRORS
DOGIN__2000		;INVENTING PIN NAMES FOR "U" PINS IN SIMPLE FILE
DOPRTL__4000		;DOING PARTS LIST, NOT STUFF LISTING
DOPWR__10000		;DO ALL PWR IN BSIMPLE

ROUTE,<DOROUT__100000	;DOING OUTPUT OF WIRE LIST USING ROUTER>
REFLAG__200000		;DO REFERENCE HACK IN 'WL' FILE
PETIT__400000		;PETIT SWITCH

;LEFT HALF BITS
NOT__1			;NOT IN T
NOTT__2			;NOT IN TT
TFLG__4			;TEMPORARY FLAG
SEMFLG__10		;SEMI COLON SEEN IN TILDANOT
NOFF__20		;NO FORM FEED NEEDED WHEN HEADER GOES OUT
ASKHIM__40		;ASK FLAG

DEC,<COMLIN__40000>	;ANY LINE OUTPUT SHOULD BE A COMMENT LINE
			;I.E. PRECEEDED BY "/"
SIMTAB__100000		;SIMULATE TABS WITH SPACES
DOLC__200000		;DO LOADING AND COUNTS IN GATHER
BAKGAT__400000		;TELLS GATHER THIS IS A BACK PANEL WIRE LIST


A_1
B_2
C_3
D_4
E_5
F_6
G_7
H_10
L_11		;CURRENT ID LIST
W_12		;CURRENT CARD LIST
T_13
TT_14
TTT_15
TTTT_16
P_17
;DEFINITIONS

;SPECIAL CHARACTER DEFS
GENCHR__"%"	;FIRST CHAR OF GENERATED NAMES
	GENLEN__=20	;MAX LENGTH OF PIN NAME
			;BBRRSS LNNNN(PPPPPP)
	GNPCLN__GENLEN-7	;NEVER NEED BBRRSS FOR PC
FORALL__""	;"BOTH" CHAR FOR P COMMANDS
NODEC,<NOTCHR__"">	;NOT AT STANFORD
DEC,<NOTCHR__"-">	;MINUS AT DEC
ITS,<NOTCHR__"-">	;ALSO MIT
STANFO,<ALTMOD__175	>
NOSTANFO,<ALTMOD__33		>
ALTCHR__33		;ALTMODE FROM DSKIN IF ALTMOD IS NOT EQUAL TO 33
NODEC,<CBCHR__"'">	;CHAR WHICH INCREMENTS CONTROL BITS FOR TTY
DEC,<TEXIST__"">	;THERE EXISTS CHARACTER FOR FILENAME
NODEC,<TEXIST__25>
WLDCHR__"*"
NODEC,<BWAROW__"">
DEC,<BWAROW__"@">
NOSTANFO,<UBAR__"_">
STANFO,<UBAR__"">
NODEC,<
CTRL__""		;CONTROL
META__3			;META
CTLMTA__""		;BOTH
INTERNAL CTRL,META,CTLMTA
>;NODEC


;SPECIAL TYPE CHARACTERS
PWRCHR__"V"
GNDCHR__"G"

;CONTROL CODES FOR 'LES' FILE
LESWIR__1		;THE FOLLOWING IS A WIRE

;DAT FILE OUTPUT NAME (TO FORTRAN)
DATNAM__<'FOR20 '>

;MAX NUMBER OF PADDLES FOR UML OUTPUT
MAXPAD__=64

;MAX PINS IN RUN FOR ROUTER
MAXP__=64	;NUMBER PINS/RUN MAX.

;MAX # OF PINS FOR VERIFY STUFF (TABLE LIMITATION)
;MAXPIN__=40	;I HAVE NOTHING AGAINST 40 PIN DIPS (PJ)
MAXPIN__=64	; we like 64 pin dips (boo to you, PJ!) [jag & jmn]

;# OF BITS OF HASH FOR SIGNAL NAMES
HASHB__=9	;TRY 9 FOR NOW
HASHL__1HASHB	;SIZE OF TABLE

;MAX LENGTH OF SIGNAL OR BODY NAME IN WORDS
MXSTLN__=500/5	;WHAT ABOUT [<><><><><>]

PDLLEN__1000	;OH WELL, THIS IS THE PRICE YOU PAY FOR RECURSIVE ROUTINES

RADIX =10
;BOTTOM PAGE MARGINS FOR VARIOUS OUTPUT STUFF
FILMAR__4		;FILLST OUTPUT AT FRONT OF MOST FILES
WLBMAR__7		;'WL' BODIES
WLWMAR__10		;'WL' WIRES
WLZMAR__10		;'WLZ' WIRES
WDCMAR__4		;'BL' DIP COUNTS
WSBMAR__15		;'WLS' BODIES
PREMAR__3		;'WLS' PART NUMBER ERRORS
BVMAR__20		;'WLS' VERIFY CONNECTOR PIN USAGE
POLMAR__2		;'WLS' POLARITY ERRORS
WSWMAR__8		;'WLS' SIGNAL NAMES
STFMAR__3		;'STF' DIP STUFFING LIST
PRTMAR__2		;'PRT' PARTS LIST
OTSMAR__6		;'OTS' OUTPUT TERMINATION SUMMARY
OTLMAR__2		;'OTL' TERMINATION TEST POINT LIST
MPLMAR__20		;'MPL' MASTER PARTS LIST
MPMMAR__2		;'MPL' MODULE COUNT LIST
WUPMAR__20		;'WLU' BODY/PIN/SIGNAL
WUCMAR__3		;'WLU' CON PIN/SIGNAL
WVMAR__15		;'WLV' VERIFY BODIES AND PINS
WSSMAR__4		;'WSS' SIGNAL SUMMARY
WCIMAR__15		;'WLC' INCORRECT WIRES
WLDMAR__5		;'WLD' INCORRECT PINS/SOCKET
WCWMAR__20		;'WLC' WHOLE WRONG WIRES
WCLMAR__5		;'WLC' SINGLE PINS
WWPMAR__15		;'WWC' WIRE WRAP OUTPUT
DIPMAR__5		;'LSD' DIP LIST
UMLMAR__6		;'UML' 6 LINES PER ROW OF DIPS
DEC,<
SREMAR__2		;'SR' EDGE PIN LIST
SRDMAR__2		;'SR' DIPTYPE LIST
SRNMAR__5		;'SR' NODE LIST
>;DEC

RADIX 8

;PAGE SIZE FOR OUTPUT STUFF
NODECOS,<
STDPAG__=52
STDWID__=120
>;NODECOS
DECOS,<
STDPAG__=60
STDWID__=132
>;DECOS
ITS,<
STDPAG__=60
STDWID__=132
XGPVBI__=192		;XGP VERTICAL BITS PER INCH
>;ITS
;OPDEFS

OPDEF PUTSTR[1B8]
OPDEF PUTSIX[2B8]
OPDEF PUTBYT[3B8]
OPDEF ASK[4B8]
OPDEF ERRSTR[5B8]

CMU,<
OPDEF CMUDEC [CALLI -2]
OPDEF DECCMU [CALLI -3]
>;CMU

ITS,<
OPDEF CALL	[ 40B8]
OPDEF INIT	[ 41B8]
OPDEF CALLI	[ 47B8]
OPDEF OPEN	[ 50B8]
OPDEF TTYUUO	[ 51B8]
OPDEF RENAME	[ 55B8]
OPDEF IN	[ 56B8]
OPDEF OUT	[ 57B8]
OPDEF SETSTS	[ 60B8]
OPDEF STATO	[ 61B8]
OPDEF GETSTS	[ 62B8]
OPDEF STATZ	[ 63B8]
OPDEF INBUF	[ 64B8]
OPDEF OUTBUF	[ 65B8]
OPDEF INPUT	[ 66B8]
OPDEF OUTPUT	[ 67B8]
OPDEF CLOSE	[ 70B8]
OPDEF RELEASE	[ 71B8]
OPDEF MTAPE	[ 72B8]
OPDEF UGETF	[ 73B8]
OPDEF USETI	[ 74B8]
OPDEF USETO	[ 75B8]
OPDEF LOOKUP	[ 76B8]
OPDEF ENTER	[ 77B8]
OPDEF UJEN	[100B8]
OPDEF PTYUUO	[711B8]

OPDEF PTWR1S	[PTYUUO 7,]
OPDEF PTWRS9	[PTYUUO 12,]
OPDEF PTJOBX	[PTYUUO 16,]

OPDEF DSKPPN	[CALLI 400071]
OPDEF SWAP	[CALLI 400004]
>;ITS

NOSTAN,<
OPDEF RESET[CALLI]
OPDEF DEVCHR[CALLI 4]
OPDEF CORE[CALLI 11]
OPDEF EXIT[CALLI 12]
OPDEF DATE[CALLI 14]
OPDEF MSTIME[CALLI 23]
OPDEF GETPPN [CALLI 24]

OPDEF INCHRW [TTYUUO 0,]
OPDEF OUTCHR [TTYUUO 1,]
OPDEF INCHRS [TTYUUO 2,]
OPDEF OUTSTR [TTYUUO 3,]
OPDEF INCHWL [TTYUUO 4,]
OPDEF INCHSL [TTYUUO 5,]
OPDEF GETLIN [TTYUUO 6,]
OPDEF SETLIN [TTYUUO 7,]
OPDEF RESCAN [TTYUUO 10,]
OPDEF CLRBFI [TTYUUO 11,]
OPDEF CLRBFO [TTYUUO 12,]
OPDEF INSKIP [TTYUUO 13,]
OPDEF SETACT [TTYUUO 15,]
>;NOSTAN

DECOS,<OPDEF DSKPPN[GETPPN]>

;ALL THE SPECIAL FORMS OF PUTSTR
OPDEF PUTSIG[PUTSTR 1,]
OPDEF PUTCOM[PUTSTR 2,]
OPDEF BINSTR[PUTSTR 3,]
OPDEF BINSIG[PUTSTR 4,]
OPDEF BINSGU[PUTSTR 5,]
DEC,<OPDEF OUTSIG[PUTSTR 6,]>	;DEC MUST FIX SIGNAL NAME
NODEC,<OPDEF OUTSIG[OUTSTR]>	;STANFORD AND ITS CAN JUST PRINT
;MACROS
	DEFINE GETFS $ (A,BLK)
<%%BLK__IFDIF<BLK><><V.$BLK;>1
	SKIPN A,@FSTPNT+%%BLK
	JSR NOFST
	EXCH A,FSTPNT+%%BLK
>

	DEFINE FSTRET $ (A,BLK)
<%%BLK__IFDIF<BLK><><V.$BLK;>1
	HLLI A,
	EXCH A,FSTPNT+%%BLK
	HRRZM A,@FSTPNT+%%BLK
>

	DEFINE PGETFS $ (A,BLK)
<%%BLK__IFDIF<BLK><><V.$BLK;>1
	MOVEI A,%%BLK+1
	ADD A,FSTOP
	CAMLE A,.JBREL
	JSR MORCOR
	EXCH A,FSTOP
USAGE,<AOS FSTCNT+%%BLK>
>

	DEFINE CRLF
<	PUTSTR[BYTE(7)15,12]	>
;HAS TO BE EXACTLY 1 INSTRUCTION

DEFINE DIPCHECK<>
;JUST A MARKER

VMAJOR__7	;MAJOR VERSION #
VMINOR__0	;MINOR VERSION LETTER
VGROUP__2	;MODIFYING GROUP

ORG	137
	<BYTE (3) VGROUP (9) VMAJOR (6) VMINOR>+27
ORG
SUBTTL	STRUCTURE MACROS
;THE FOLLOWING NAMES ARE USED IN STRUCTURE POINTER DEFINITIONS
;F.XXX		INSTRUCTION TO FETCH VALUE
;S.XXX			"	STORE   "
;V.XXX		VALUE OF INDEX INTO BLOCK
;		OR LENGTH OF A BLOCK-1
;C.XXX		INSTRUCTION TO CLEAR CELL

DEFINE CAT $ (A,B)<A$B>

DEFINE FETCH $ (AC1,AC2,INDEX)
<	F.$INDEX	AC1,V.$INDEX(AC2)
>

DEFINE STORE $ (AC1,AC2,INDEX)
<	S.$INDEX	AC1,V.$INDEX(AC2)
>

DEFINE CLEAR $ (AC1,INDEX)
<	C.$INDEX	V.$INDEX(AC1)
>

DEFINE BCLEAR $ (AC1,AC2,INDEX)
<	SETZM (AC2)
IFG V.$INDEX,<
	MOVSI AC1,(AC2)
	HRRI AC1,1(AC2)
	BLT AC1,ADDR(AC2,INDEX)
    >
>

DEFINE SBLOCK
<	INDEX__0
>

DEFINE EBLOCK $ (NAME)
<	V.$NAME__INDEX-1
IFG INDEX-FSTLEN<FSTLEN__INDEX>
>

DEFINE ADDR $ (AC1,INDEX)<V.$INDEX(AC1)>

DEFINE RADDR $ (AC1,INDEX1,INDEX2)<V.$INDEX1-V.$INDEX2(AC1)>

DEFINE HWDS $ (LEFT,RIGHT,LE,RE)
<
IFDIF<LEFT><><
IFDIF<LE><E><OPDEF F.$LEFT(A)[HLRZ]>
IFIDN<LE><E><OPDEF F.$LEFT(A)[HLRE]>
OPDEF S.$LEFT(A)[HRLM]
OPDEF C.$LEFT(A)[HRRZS]
V.$LEFT__INDEX
>
IFDIF<RIGHT><><
IFDIF<RE><E><OPDEF F.$RIGHT(A)[HRRZ]>
IFIDN<RE><E><OPDEF F.$RIGHT(A)[HRRE]>
OPDEF S.$RIGHT(A)[HRRM]
OPDEF C.$RIGHT(A)[HLLZS]
V.$RIGHT__INDEX
>
INDEX__INDEX+1
>

DEFINE FWD $ (WORD)
<
IFDIF<WORD><><
OPDEF F.$WORD(A)[MOVE]
OPDEF S.$WORD(A)[MOVEM]
OPDEF C.$WORD(A)[SETZM]
V.$WORD__INDEX
>
INDEX__INDEX+1
>
SUBTTL	DATA STRUCTURES
;		STRUCTURE DEFINTIONS

FSTLEN__2			;THIS WILL ACCUMULATE LONGEST BLOCK


;PC OR D LIST HEADERS

SBLOCK
HWDS	(BKNM,BLST)		;BACK PANEL FILENAME LIST AND WIRE LIST
				;BKNM MUST BE LEFT HALF POINTER
HWDS	(WLNM,WIRL)		;TITLE STRING AND D WIRELIST POINTER
				;WIRL MUST BE RIGHT HALF
HWDS	(WLID,PCWL)		;ID STRING AND PC WIRELIST POINTER
				;PCWL MUST BE RIGHT HALF
HWDS	(,INXT)			;NEXT WIRE LIST (ID)
EBLOCK	LSTHEAD


;FILENAME BLOCK FOR LIST OF FILENAMES FOR BACK PANEL LIST
;AND SINGLE CARD WIRE LISTS

SBLOCK
FWD	(FILN)			;FILENAME
FWD	(FPPN)			;PPN
FWD	(FDAT)			;DATE AND TIME FROM LOOKUP OF DRW FILE
FWD	(FPOL)			;NUMBER OF POLARITY CHECK ERRORS FOUND BY DWG PROG
HWDS	(FNXT,FMOD)		;NEXT FILENAME LINK AND MODULE NAME POINTER
				;FNXT MUST BE LEFT HALF POINTER
HWDS	(FVAR,FPRF)		;VARIABLE AND PREFIX
HWDS	(TIT1,TIT2)		;TITLE LINES 1 AND 2
HWDS	(FREV,AUTHOR)		;REVISION STRING AND AUTHOR
HWDS	(FPROJ,FPAGE)		;PROJECT AND PAGE STRINGS
HWDS	(FOF,FBRD)		;OF STRING AND BOARD TYPE (INDEX)
HWDS	(MUBN,MLBN,E,E)		;VARIABLE UPPER, LOWER BOUNDS FROM INPUT TERM
HWDS	(MCRD,MVLS)		;CARD LOC, VARIABLE LIST FROM INPUT TERM
EBLOCK	FBLK


;NORMAL WIRE LIST HEADER UNIT (ONE CARD)

SBLOCK
HWDS	(NGEN,NXTWL)		;GEN NUMBER AND NEXT WLBLOCK
				;NXTWL MUST BE RIGHT HALFWORD
HWDS	(FILS,WIRES)		;FILENAME LIST AND SIGNAL LIST
				;WIRES MUST BE RIGHT HALFWORD
HWDS	(FCRD,WBDY)		;LAST CARD AND LOC BLOCKS
				;WBDY MUST BE RIGHT HALFWORD
FWD(HASHTB)			;FIRST WORD OF HASH TABLE
INDEX__INDEX+HASHL-1		;REST OF TABLE
EBLOCK	WLBLOCK


;BODY BLOCK

SBLOCK
HWDS	(DIPT,NXTB)		;DIPTYPE POINTER AND NEXT BODY
HWDS	(BID,BPIN)		;BODY ID AND BODY PIN LIST
				;BPIN MUST BE RIGHT HALF POINTER
HWDS	(BBIT,)			;BODY BITS
HWDS	(PRPX,PRTN)		;EXTRA PROPERTIES LIST AND PART NUMBER BLOCK POINTER
HWDS	(BLOC,FILB)		;BODY LOC AND FILENAME POINTER
FWD	(BNAM)			;FIRST WORD OF BODY NAME (THE REST FOLLOW SEQUENTIALLY)
EBLOCK	BHEAD


;WIRE HEADER

SBLOCK
HWDS	(WBIT,ALPH)		;WIRE BITS AND TEXT LINK
				;ALPH MUST BE RIGHT HALF POINTER
HWDS	(TBIT,WPIN)		;TYPE BITS AND PIN LIST
				;WPIN MUST BE RIGHT HALF POINTER
HWDS	(NNAM,WTMP)		;NEXT NAME FOR WIRE AND TMP STORE
HWDS	(,WRN)			;UNUSED AND WIRE RULE NUMBER
FWD	(SCMP)			;COMPARE WORD
FWD	(SPNT)			;PRINT NAME (MUST FOLLOW SCMP)
EBLOCK	WHEAD



;PIN BLOCK

SBLOCK
HWDS	(PBDY,NXTP)		;BODY POINTER AND NEXT PIN
				;NXTP MUST BE RIGHT HALF POINTER
HWDS	(HPNT,NXBP)		;POINTER TO WHEAD AND BODY PIN LINK
HWDS	(PID,PINN)		;POINT ID AND PIN #
INDEX__INDEX-1
HWDS	(CBIT,)			;FOR BACK PANEL, PID IS REALLY CBIT
HWDS	(PBIT,FILP)		;PIN BITS AND FILENAME POINTER
HWDS	(PTYP,RDCN)		;TYPE POINTER AND REDAC LIBRARY NUMBER
INDEX__INDEX-1
HWDS	(HILD,LILD,E,E)		;HI LOADING FOR BP PIN, NOT PTYP, RDCN
EBLOCK	PHEAD
HWDS	(HOLD,LOLD,E,E)		;LOW LOADING FOR BP PIN.
EBLOCK	BPHEAD


;DIP TYPE HEADER BLOCK

SBLOCK
HWDS	(DNAM,NXTD)		;DIPNAME AND NEXT POINTER
HWDS	(DPNN,DPIN)		;NUMBER OF PINS ON DIP, DIP PIN LIST
FWD	(DTMP)			;TMP CELL FOR DIP COUNTS
HWDS	(PRPN,PRPV)		;PROPERTY NAME LIST, PROPERTY VALUE LIST
EBLOCK	DHEAD


;DIP PIN BLOCK

SBLOCK
HWDS	(DPBIT,DPNXT)		;BITS AND NEXT
FWD	(DUSE)			;SIXBIT USE FIELD
HWDS	(LHI,LLOW,E,E)		;HI AND LOW LOADING
HWDS	(SCTB,SCTP)		;SECT BITS AND SECT PIN #
HWDS	(PSWP,)			;PIN SWAPPING/SHARING #
EBLOCK	DPHEAD


;PROPERTY NAME BLOCK

SBLOCK
HWDS	(PRNN,PRNS)		;NEXT PROPERTY NAME BLOCK AND PROPERTY NAME STRING
EBLOCK	PNBK


;PROPERTY VALUE BLOCK

SBLOCK
HWDS	(PRBT,PRNV)		;PROPERTY VALUE BITS AND NEXT PROPERTY VALUE BLOCK
HWDS	(PRPP,PRNP)		;PREVIOUS PROPERTY VALUE (UP TREE) AND NEXT PROPERTY VALUE (DOWN TREE)
HWDS	(PRNB,PRVS)		;PROPERTY NAME BLOCK AND PROPERTY VALUE STRING
EBLOCK	PVBK


;BACK PANEL MODULE INFO BLOCK

SBLOCK
HWDS	(MNUM,MNXT)		;MODULES PER MACHINE, NEXT MODULE BLOCK
HWDS	(MNAM,)			;MODULE NAME STRING
EBLOCK	BMOD


;PARTS LIST THREAD BLOCK

SBLOCK
HWDS	(PLBT,NXPL)		;PLBK BITS, NEXT PLBK
HWDS	(PLPT,MDCN)		;POINTER TO PVBK OF PART NUMBER, MASTER PART COUNT LIST(MDBLOCK)
EBLOCK	PLBK


;MASTER COUNT DIPTYPE BLOCK

SBLOCK
HWDS	(MDIP,MDNX)		;DIPTYPE, NEXT (MDBLOCK)
HWDS	(,MXPT)			;POINTER TO EXTRA PART BLOCK (MXBLOCK)
EBLOCK	MDBLOCK


;MASTER COUNT EXTRA PROPERTY BLOCK

SBLOCK
HWDS	(MPRX,MXNX)		;EXTRA PROPERTY LIST, NEXT (MXBLOCK)
HWDS	(,MCPT)			;PART COUNT BLOCK POINTER
EBLOCK	MXBLOCK


;MASTER COUNT PART COUNT BLOCK

SBLOCK
HWDS	(MODC,MCNX)		;MODULE COUNT BLOCK POINTER (BMOD), NEXT (MCBLOCK)
FWD	(MAPP)			;APPROXIMATE COUNT
FWD	(MREA)			;REAL COUNT
EBLOCK	MCBLOCK


;DIRECTORY LIST BLOCK

SBLOCK
HWDS	(DEXT,DIRNXT)
FWD	(DFIL)
FWD	(DPPN)
HWDS	(,CVAR)			;CARD AND VARIABLE LIST POINTER (MUST BE RIGHT HALF)
EBLOCK	DIRHEAD


;CARD LOC AND BOUND BLOCK

SBLOCK
HWDS	(,NSLC)			;NEXT SLICE
HWDS	(CDLC,VLST)		;CARD LOC AND VARIABLE LIST POINTER
HWDS	(LBND,UBND,E,E)		;UPPER AND LOWER BOUNDS (EXTEND SIGN ON FETCH)
EBLOCK	CBND


;VARIABLE BLOCK IN VARLIST

SBLOCK
HWDS	(VAL,NVAR,E)		;VALUE(EXTEND SIGN ON FETCH) AND NEXT
HWDS	(WID,LET)			;WIDTH,,LETTER
EBLOCK	VBLK


;GND AND VCC PIN BLOCKS FOR ROUTER

ROUTE,<
SBLOCK
HWDS	(PNTR,NWRD)			;PIN POINTER,,NEXT BLOCK
FWD	(PNAM)				;PIN NAME
EBLOCK	WBLK
>;ROUTE


;CURRENT@VOLTAGE LIST FOR WLS FILE

SBLOCK
HWDS	(VLTS,NXTM,E)		;VOLTS (W/SIGN) AND NEXT BLOCK POINTER
FWD	(MAMP)			;# OF MILLIAMPS AT VOLTS
EBLOCK	MABLK


;2 WORD TMP LIST BLOCK

SBLOCK
HWDS	(TVAL,NXTT)		;LINK
HWDS	(TLFT,TRHT)		;LEFT AND RIGHT TEMP CELLS
EBLOCK	TBLK


;COUNT BLOCK FOR WSS, WCS, AND WLS PRINT SUBR
SBLOCK
HWDS	(CFIL,NXTC)		;FILE POINTER AND NEXT
HWDS	(ICNT,OCNT)		;# INPUTS, #OUTPUTS
HWDS	(CCNT,ZCNT)		;# CONNECTORS+BITS, # TERMINATORS
EBLOCK	CBLK
SUBTTL	BITS
;GOOD BITS
;BITS IN BODY ENTRY (BBIT)
BTMP1__400000		;TEMP MARK BIT
PRX2ND__200000		;SECOND OCCURENCE OF THIS PRPX POINTER

BWILD__1000		;THIS IS A WILD CONNECTOR
BEDGE__400		;EDGE PIN BODY
BANYPOS__200		;INDICATES XPOS AND YPOS ARE VALID
BXPOSL__3		;3 BITS WORTH
BXPOSB__4		;4 FROM RIGHT
BYPOSL__2		;2 BITS WORTH
BYPOSB__2		;2 FROM RIGHT
R1416__2		;RIGHT JUSTIFIED 14 PIN DIP IN 16 PIN SOCKET
L1416__1		;LEFT		"

CBODY__BEDGE!BWILD	;CON BODY BITS


;BITS FROM D WHICH MUST BE STORED IN BODY BITS ABOVE
R1416D__2		;R1416 FROM D
L1416D__1		;L1416 FROM D


;BITS IN PIN ENTRY IN WIRE LIST (PBIT)
PTMP1__400000		;MARK BIT
PTMP2__200000		;ANOTHER

TRMBTS__140000		;TERMINATOR RULE BITS (FOR CON ONLY)
	TRMBSZ__2	;NUMBER OF BITS
	TRMBPS__3	;LOW ORDER BIT
CANYPOS__20000
CXPOSL__3
CXPOSB__12		;DISTANCE FROM RIGHT EDGE OF HALFWORD
CYPOSL__2
CYPOSB__10		;DISTANCE FROM RIGHT EDGE OF HALFWORD

DUP__200		;THIS PIN IS A DUPLICATE OF ANOTHER PIN IN RUN
PIDPIN__100		;NO PIN #, USED PID!
PSHARE__40		;THIS INPUT LOAD IS ALREADY SHARED WITH ANOTHER PIN
QBITS__37		;BIT MASK TO GET QUALIFIER LETTER FROM THIS HALFWORD
			;LSB OF BIT MASK MUST EQUAL 17


;POINT BITS FROM DRAWING PROG ('WD' FILE)
DEFPIN__4000		;THIS PIN IS DEFAULTED, NOT EXPLICIT (BODY PINS ONLY)
CPNBTS__6000		;BITS FOR TERMINATOR RULES (CPINS ONLY)
	CPNBPS__7	;LOW ORDER BIT POS
	CPNBSZ__2	;# OF BITS



;BITS IN DPBIT, TBIT, AND CBIT (TYPE BITS)
INLD__400000		;INPUT LOAD
OUTLD__200000		;OUTPUT LOAD
NULLD__100000		;NO LOADING AT PRESENT
GND__40000		;GROUND CONNECTION
PWR__20000		;POWER CONNECTION
	VPWR__=500	;TTL POWER
TRI__10000		;TRI-STATE OUTPUT
SHARE__4000		;SHARE INPUT LOAD BIT (OR EXTRA OUTPUT)
OPENC__2000		;OPEN COLLECTOR OUTPUT
PULL__1000		;THIS OUTPUT IS A PULLUP
ECL__400		;ECL PIN
TTL__200		;TTL PIN
CLK__100		;CLK SEEN AS FIRST 3 CHARS OF USE
TERM__40		;TERMINATOR PIN
FFOUT__20		;FLIP-FLOP OUTPUT
DRVREQ__10		;DRIVE REQUIRED FOR THIS INPUT

ANYCON__1		;THERE IS A CONNECTOR IN THIS RUN (NOT USED IN DPBIT)

;BITS FROM OLD VERSION DIP FILE
VEE__200		;-5.5V ECL POWER
	VEEVLT__-=520
OTTL__100		;OLD TTL BIT
VBB__40			;-1.5V ECL THRESHOLD
	VBBVLT__-=150
VTT__20			;-2V ECL TERMINATORS
	VTTVLT__-=200
OCLK__10		;OLD CLK BIT


ALLTYP__INLD!OUTLD!NULLD!GND!PWR!TRI!SHARE!OPENC!PULL!TERM	;ALL TYPE BITS
INBITS__INLD!SHARE!NULLD				;ALL INPUT BITS


;BITS IN WBIT (WIRE BITS)
SNC__400000		;THIS WIRE HAS THE NAME "NC"
SHI__200000		;THIS WIRE HAS THE NAME "HI"
SPWR__100000		;THIS WIRE HAS THE NAME "VCC"
SGND__40000		;THIS WIRE HAS THE NAME "GND"

CABRUN__400		;PUT C QUALIFIER ON EDGE PINS
WNULL__200		;COMPLETELY NULL WIRE
WSINGL__100		;WIRE WITH ONLY 1 PIN
GLB2__40		;THIS IS THE SIGNAL TO COME OUT IN THE SIMPLE FILE
GLB1__20		;THIS IS ONLY SIGNAL TO GO TO BACK PANEL
GENSIG__10		;THIS IS A GENERATED SIGNAL
WTMP1__4		;TEMP MARK BIT FOR WIRE HEADER
SIG1__2			;THIS SIGNAL BLOCK IS THE FIRST OF A SET OF EQUIVALENT NAMES
NAM2ND__1		;INTERNAL WIRE HEADER BIT FOR SECOND NAME OF SIGNAL

SIGBIT__SNC!SHI!SPWR!SGND	;WIRE TYPE BITS


;RUN BITS FROM DRAWING PROG ('WD' FILE)
CABBDY__1		;"CABLE" BODY PIN ON RUN


;BITS USED BY PINMAP FOR PIN IDENTIFICATION
MAPCON__400000		;THIS IS A CON (MUST BE SIGN BIT)
MAPGND__200000		;THIS IS A GND PIN
MAPPWR__100000		;THIS IS A PWR PIN
CRDPIN__MAPGND!MAPPWR	;THIS IS A CARD PIN
PLUS1__40000		;THIS WAS MADE BY +1
PLUS2__20000		;THIS WAS MADE BY +2
;77			;PIN # FOR BODIES IN LEFT HALF

ROUTE,<
;BITS IN PNTBL WORD USED BY ROUTER
RPGPIN__400000		;THIS IS A POWER OR GROUND PIN, IT IS NOT IN WIRE LIST
RERPIN__200000		;THIS PIN IS IN ERROR IN SOME WAY, DON'T WIRE IT!
ROUMRK__100000		;MARK BIT FOR ROUTER
>;ROUTE


;BITS IN PROPERTY VALUE BLOCKS
DEFPRP__400000		;THIS IS THE DEFAULT PROPERTY AT THIS LEVEL
PARTNM__200000		;THIS IS A PART NUMBER BLOCK
PNUSED__100000		;THIS PART NUMBER BLOCK IN USE
NULVAL__40000		;THIS IS A NULL VALUE STRING AND SHOULDN'T NORMALLY BE PRINTED

PRTMP1__1		;TEMP MARK BIT


;BITS IN PLBK FOR PARTS LIST THREAD
PL2ND__400000		;THIS IS SECOND OCCURENCE OF SAME PART NUMBER
SUBTTL	DATA
DEFINE DATA(LABEL,SIZE)
<
LABEL:
IFIDN <SIZE><><BLOCK 1>
IFDIF <SIZE><><BLOCK SIZE>
>;END DATA

ITS,<VALBFL__=80/5	>	;SIZE OF ITS VALRET BUFFER, 80 CHARACTERS

	LIBPPN_'DATDRW'
ITS,<		LIBPPN__'DATRPH'	>
CMU,<		LIBPPN_<10173,,101310>	>	;E210DP00
DEC,<
NOVIROS,<	LIBPPN__0		>
VIROS,<		LIBPPN__<4,,253>	>
>;DEC

DIPPPN:	LIBPPN

ZEROBEGIN:
ITS,<
	DATA	XGP
	DATA	XGPVSP
	DATA	XGPFNT
	DATA	XGPEXT
	DATA	XGPPPN
	DATA	VALBUF,VALBFL
>;ITS
	DATA	LOADMG
	DATA	GNDFLG
	DATA	OFFSET
	DATA	MSINGL
	DATA	USEDWL
	DATA	CURDIP
	DATA	DEPTH
	DATA	VARERR
	DATA	SIGCHR
	DATA	EXPER2
	DATA	DVER
	DATA	LOW2UP
	DATA	LOSBIT
	DATA	LOSNAM
	DATA	CONFLG
	DATA	WWPBDY
	DATA	WWPBIT
	DATA	WWPTYP
	DATA	WWFILN
	DATA	WWPINN
	DATA	UPINS,MAXPIN
	DATA	STRTAB,MXSTLN
	DATA	TPTRP
	DATA	TTPTRP
	DATA	ANYOVR
	DATA	TTYFLG
	DATA	SECTMP
	DATA	LSTDIP
	DATA	PRPPTR
	DATA	PRXPTR
	DATA	PININC
	DATA	BSLOT
	DATA	BAKBIT
	DATA	BAKILD
	DATA	BAKOLD
	DATA	CDSKPC
	DATA	GINPIN
	DATA	LSLOT
	DATA	FSLOT
	DATA	TOTDIP
	DATA	REALDV
	DATA	WLLIST
	DATA	REFLST
	DATA	PRPLST
	DATA	PID
	DATA	WIRTMP
	DATA	SHRNUM
	DATA	PADDLE,MAXPAD
	DATA	MROW
	DATA	UMLEHT
	DATA	UMLPGF
	DATA	MCOL
	DATA	COLLOP
	DATA	DEFLST
	DATA	ERRP
	DATA	FACTR1
	DATA	FACTR2
	DATA	DISPWD
	DATA	PROMPT
	DATA	DOOXWD
	DATA	FSTPNT,FSTLEN
USAGE,<	DATA	FSTCNT,FSTLEN
	DATA	FSTTMP,FSTLEN
>;USAGE
	DATA	FSTOP
	DATA	SHIFT
	DATA	GOODW
	DATA	BADW
	DATA	LAST
	DATA	SIGN
	DATA	SAVEA
	DATA	SAVEB
	DATA	SAVET
	DATA	UUOSAV
	DATA	MIN
	DATA	DIPLST
	DATA	PARTLIST
	DATA	NULPART
	DATA	LSTPART
	DATA	LPRPX
	DATA	DIRLST
	DATA	IDRLST
	DATA	STRING
	DATA	DSTRNG
	DATA	NEWPNT
	DATA	GETCHR
	DATA	PUTCHR
	DATA	SVPTCH
	DATA	SLICE
	DATA	SLICEL
	DATA	LOWER
	DATA	UPPER
	DATA	WIDTH
	DATA	VARLST
	DATA	PINLOC
	DATA	PINNUM
	DATA	PINTMP
	DATA	BID
	DATA	DEFEXT
	DATA	THSFIL
	DATA	OLDBOD
	DATA	DIPPNT
	DATA	LETTER
	DATA	NUMBER
	DATA	HEADER
	DATA	LINCNT
	DATA	PAGLEN
	DATA	(PAGCNT)	;NUMBER OF PAGES THUS FAR
	DATA	(LWIDTH)	; MAXLISTING WIDTH (initially set to STDWID_
	DATA	MARGIN
	DATA	OVRFLW
	DATA	SMPCNT
	DATA	TCOUNT
	DATA	(LCOUNT)	;LETTER COUNT THUS FAR THIS LINE
TAPR8,<
	DATA	(PCOUNT)	;PIN COUNT THUS FAR THIS RUN
>;TAPR8
	DATA	NBODS
	DATA	RBODS
	DATA	NDIPS
	DATA	TMPCN1
	DATA	TMPCN2
	DATA	AMPLST
	DATA	LSTHD,3
	DATA	LSTBUF,210*2
	DATA	DATHD,3
	DATA	DATBUF,210
	DATA	LSTNAM
NODEC,<	DATA	(SAVBLK)>	;THIS MUST PRECEDE FILNAM FOR SWAP UUO
	DATA	FILNAM
	DATA	FILEXT
	DATA	FILDAT
	DATA	FILPPN
	DATA	ATPPN
CMU,<	DATA	PPNBUF,3 >	;FOR CONVERTING PPN'S
	DATA	PNTNAM
	DATA	PNTEXT
	DATA	PNTDAT
	DATA	PNTPPN
	DATA	ALLNAM
	DATA	ALLPPN
	DATA	ALLCRD
	DATA	SAVFLG
	DATA	DEFECL
	DATA	ECLBIT
	DATA	SAVEP
	DATA	NDIG
	DATA	MODULE
	DATA	MODLST
	DATA	MPLTIT
DEC,<	DATA	RDCSAV
	DATA	RDCSVB
	DATA	RDCLIB
	DATA	IGNTRM
>;DEC
NOTTYBT,<
	DATA	SAVLIN
	DATA	BUFPTR
	DATA	TTBUF,=75/5
	TTBEND_.-1
>;NOTTYBT
ZEROEND__.-1
	DATA	PDL,PDLLEN
	DATA	PATCH,100
	DATA	ZPPN
DIPNAM:	'DIPS  '
	'DIP   '
	0
	0

CNTTAB:	DATA	ANYOUT
	DATA	NIN
	DATA	NOUT
	DATA	NINOUT
	DATA	NTRI
	DATA	NOC
	DATA	NPULL
	DATA	NTERM
	DATA	NTRMOUT
	DATA	NTRMIN
	DATA	NULLS
	DATA	NCONS
	DATA	NGND
	DATA	NPWR
	DATA	PVOLTS
	DATA	ILVOLT
	DATA	PMAMPS
LODTAB:	DATA	LINL
	DATA	LINH
	DATA	LOUTL
	DATA	LOUTH
	DATA	LOCL
	DATA	LPULLH
	DATA	LTRIL
	DATA	LTRIH
LODLEN__.-LODTAB

LODSAV:	BLOCK LODLEN

RESIDENT:	0		;IF SET THIS IS PERMANENT RESIDENT DIPLST
OLDFF:		0		;SAVED .JBFF

DATA	DSKCNT
DATA	DSKNAM
DATA	DSKEXT
DATA	DSKDAT
DATA	DSKPP
DATA	DSKFLG
DATA	DSKACT
DATA	CBITS
DATA	IDSKHD,3
DATA	IDSKBF,203

;R$G	TO GET BACK AFTER ^C DD.
R:	JRST @130
CPOPJ3:AOS (P)
CPOPJ2:AOS (P)
CPOPJ1:AOS(P)
CPOPJ:	POPJ P,
SUBTTL	DUMP FILE
;HERE WE SAVE A DUMP FILE OF THIS WIRE LISTER
SAVE:
NODEC,<
	MOVSI T,EXTSAV
	MOVEM T,DEFEXT
	PUSHJ P,SETFIL
	POPJ P,
	MOVE T,.JBREL
NOITS,<
NOCMU,<	LSH T,-12
	ADDI T,1
	HRLI T,CONT		;STARTUP LOC
	MOVSM T,FILDAT
>;NOCMU
>;NOITS
CMU,<	PUSH P,.JBSA
	HRLM T,.JBSA
	PUSH P,FILPPN
	SETZM FILPPN	;AT CMU IT'S A NOT A PPN IN THIS ARG!
>;CMU
	MOVSI T,'DSK'
	MOVEM T,SAVBLK
>;NODEC
	MOVEI T,1(P)
	BLT T,17(P)		;BLT 17 AC'S ONTO STACK
	MOVEM P,SAVEP
NODEC,<	ADD P,[17,,17]
	MOVSI T,SAVBLK
	PUSH P,DSKACT		;SAVE OLD STATE
	SETZM DSKACT		;HOLD DISK INPUT
ITS,<	JRST ITSAVE	>	;LET ME OUT OF THIS TANGLED MESS OF CONDITIONAL ASSEMBLY
NOITS,<
NOCMU,<	SWAP T, >
CMU,<	MOVSM T,DMPARG
	RESET
EXTERNAL SAVJOB
	JSR SAVJOB
DMPARG:	0
	JRST [	HRRE T,FILEXT
		JUMPE T,CONT
		HALT . ]
>;CMU
	POP P,T			;GET OLD STATE
	JUMPE T,CONT		;IF ALREADY OFF, JUST CONT
	PUSHJ P,DSKCON		;ELSE THIS WILL RESET DSKIN FILE (WE REALLY HAVE A STACK)
>;NODEC
DEC,<	SETZM DSKACT
	OUTSTR[ASCIZ/SAVE CORE IMAGE WITH "SAVE" COMMAND.
THEN TYPE "START" OR "RUN".
/]
	MOVEI T,CONT
	HRRM T,.JBSA
	EXIT 1,
>;DEC
CONT:	OUTSTR[ASCIZ/
/]
DEC,<	SKIPE DSKFLG
	OUTSTR[ASCIZ/DISK INPUT HOLDING, TYPE "XDSKCON" TO CONTINUE IT.
/]
>;DEC
NOCMU,<	MOVEI T,STRT
	HRRM T,.JBSA		;RESTORE START-UP
>;NOCMU
	MOVE P,SAVEP
	MOVSI T,1(P)
	BLT T,16		;GET BACK AC'S
CMU,<	POP P,FILPPN
	POP P,.JBSA
>;CMU
	POPJ P,
>;NOITS
ITS,<
ITSAVE:	MOVEI T,CONT
	HRL T,FSTOP
	MOVEM T,.JBSA
	PUSHJ P,VALINI		;FLUSH CORE SET POINTERS, ETC.
	MOVEI TT,[ASCIZ /}Y /]
	PUSHJ P,DDTSTR
	MOVE TT,FILPPN
	PUSHJ P,DDTSIX
	MOVEI T,";"
	PUSHJ P,DDTPUT
	MOVE TT,FILNAM
	PUSHJ P,DDTSIX
	MOVEI T,40
	PUSHJ P,DDTPUT
	MOVE TT,FILEXT
	PUSHJ P,DDTSIX
	JRST VALRET

VALINI:	HLRZ T,.JBSA		;CORE SIZE
	LSH T,-12		;PAGE # OF HIGHEST LOW PAGE
	MOVSI TT,-377(T)	;-# PAGES TO FLUSH
	HRRI TT,1(T)		;STARTING 1 PAST LAST PAGE
	.CALL [	SETZ		;FLUSH THE DEC COMPATIBLITIY ROUTINES
		SIXBIT /CORBLK/
		1000,,0		;FLUSH PAGES
		1000,,-1	;FROM SELF
		SETZ TT]
	.VALUE
	SETZM VALBUF
	MOVE TT,[VALBUF,,VALBUF+1]
	BLT TT,VALBUF+VALBFL-1
	MOVEI TT,[ASCIZ /:} TYPE <cr> TO DUMP ME OUT, OR <control>D TO ABORT }
/]
	MOVE TTT,[440700,,VALBUF]
DDTSTR:	HRLI TT,440700
DDTST1:	ILDB T,TT
	JUMPE T,CPOPJ
	PUSHJ P,DDTPUT
	JRST DDTST1

DDTPUT:	IDPB T,TTT
	POPJ P,

DDTSIX:	JUMPE TT,CPOPJ
	MOVEI T,0
	LSHC T,6
	ADDI T,40
	PUSHJ P,DDTPUT
	JRST DDTSIX
>;ITS
SUBTTL	IOPAC-UUOCON

LOC 41
PUSHJ P,$UUOCON
RELOC

^$UUOCON:MOVEM T,UUOSAV
	LDB T,[POINT 9,40,8]
	CAILE T,5
	MOVEI T,0
	MOVE T,(T)[[HALT CPOPJ]
		STRPUT
		SIXPUT
		OUTBYT
		.ASK
		STRERR]
	EXCH T,UUOSAV
	JRST 2,@UUOSAV
SUBTTL	IOPAC-OUTPUT SUBRS
.ASK:	OUTSTR @40
	PUSH P,TTT
	PUSHJ P,TTYIN
	JFCL
	HRRZS -1(P)
	CAIE TTT,"Y"
	CAIN TTT,"y"
	HRROS -1(P)
.ASK1:	CAIN TTT,ALTMOD
	JRST [	OUTSTR[ASCIZ/
/]
		POP P,TTT
		POPJ P,]
	CAIN TTT,12
	JRST .ASK2
	PUSHJ P,TTYIN
	JFCL
	JRST .ASK1

.ASK2:	POP P,TTT
	SKIPGE (P)
	AOS (P)
	JRST CPOPJ1

STRERR:	PUSH P,T
	PUSH P,TT
	PUSH P,TTT
	PUSH P,40			;SAVE ARGS HERE
	SKIPE TTYFLG			;TTY?
NODEC,<	SKIPA TT,[9*8-2]	>	;YES, 8 TABS WORTH
DEC,<	SKIPA TT,[8*8-2]	>
	MOVEI TT,=13*8-2		;NO, 13
	HRRZ T,(P)			;START OF STRING
	TLOA T,(<POINT 7,0>)		;MAKE IT BYTE POINTER
	SUBI TT,1
	ILDB TTT,T
	JUMPN TTT,.-2
	PUSH P,TT
	CAMG TT,LCOUNT			;AT LEAST ONE BETWEEN US AND LAST THING?
	CRLF				;NO, RETURN
	MOVE TT,(P)
	LSH TT,-3			;LAST TAB STOP BEFORE OUR STRING
	MOVE T,LCOUNT			;GET CURRENT LINE POSITION
	LSH T,-3			;CONVERT BOTH TO TABS
	SUB TT,T			;THIS IS HOW MANY TABS WE CAN DO
	SKIPA TTT,[11]
	XCT PUTCHR
	SOJGE TT,.-1
	POP P,T
	SUB T,LCOUNT
	SKIPA TTT,[40]			;NOW SPACES TO START OF STRING
	XCT PUTCHR
	SOJGE T,.-1
	HRRZ T,(P)			;START OF STRING
	PUSHJ P,STRPT1			;PRINT ROUTINE
	PUTSTR[ASCIZ/	____ /]
	POP P,T			;NOW THE #
	LSH T,-=18-5
	ANDI T,17
	PUSHJ P,DECOUT
	CRLF
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,

SIXPUT:	PUSH P,T
	PUSH P,TT
	PUSH P,TTT
	MOVE TT,@40
	PUSHJ P,SIXLOP
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,

SIXLOP:	JUMPE TT,CPOPJ
	SETZ T,
	LSHC T,6
	MOVEI TTT,40(T)
	XCT PUTCHR
	JRST SIXLOP

OUTBYT:	PUSH P,TTT
	MOVEI TTT,@40
	XCT PUTCHR
	POP P,TTT
	POPJ P,

^F4CRLF:MOVE TTT,LSTHD+2
	CAIG TTT,2		;IF NO ROOM FOR LF, THEN
	SETZM LSTHD+2		;FORCE OUTPUT
	MOVEI TTT,15
	PUSHJ P,BYTOUT
	MOVEI TTT,12
;FALL INTO BYTOUT
^BYTOUT:JUMPE TTT,CPOPJ
DEC,<	TLNE COMLIN		;COMMENT LINE?
	SKIPE LCOUNT		;YES, BEGIN LINE?
	JRST NOCOML		;NO
	CAIE TTT,15
	CAIN TTT,12
	JRST NOCOML		;NOT BEFORE VERTICAL POSITIONING
	CAIN TTT,14
	JRST NOCOML
	PUSH P,TTT
	MOVEI TTT,"/"
	PUSHJ P,NOCOML		;PUT OUT COMMENT CHAR
	POP P,TTT
NOCOML:
>;DEC
	CAIN TTT,11
	JRST BYTTAB
NOSIMB:	SOSG LSTHD+2
	OUT LST,
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR!
/]
		EXIT 1,
		POPJ P,]
	IDPB TTT,LSTHD+1
.COUNT:	CAIN TTT,12
	JRST [	AOS LINCNT	;COUNT ANOTHER LINE
		POPJ P,]
	CAIN TTT,14
	JRST [	SETZM LINCNT		;JUST IN CASE
		POPJ P,]		;FORM FEED DOES NOTHING FOR NOW
	CAIN TTT,15
	JRST [	SETZM LCOUNT
		POPJ P,]
	CAIN TTT,11
	JRST TABCNT
	AOS LCOUNT
	AOS TCOUNT
	POPJ P,

BYTTAB:	TLNN SIMTAB		;MUST WE SIMULATE?
	JRST NOSIMB		;NO
	PUSH P,TTT
BYTTB1:	MOVEI TTT,40
	PUSHJ P,BYTOUT
	MOVE TTT,LCOUNT
	TRNE TTT,7		;AT TAB STOP YET?
	JRST BYTTB1
	POP P,TTT
	POPJ P,

TABCNT:	EXCH TTT,LCOUNT
	ADDI TTT,10
	ANDCMI TTT,7
	EXCH TTT,LCOUNT
	EXCH TTT,TCOUNT
	ADDI TTT,10
	ANDCMI TTT,7
	EXCH TTT,TCOUNT
	POPJ P,

FILL:	PUTBYT 11
	CAMLE A,LCOUNT		;THERE YET?
	JRST FILL
	POPJ P,

SPFILL:	PUSH P,A
	TRZ A,7
	CAMLE A,LCOUNT
	PUSHJ P,FILL
	POP P,A
	SUB A,LCOUNT
	JUMPLE A,CPOPJ
	PUTBYT 40
	SOJG A,.-1
	POPJ P,

^TTYOUT:JUMPE TTT,CPOPJ
DEC,<	TLNE COMLIN		;COMMENT LINE?
	SKIPE LCOUNT		;YES, BEGIN LINE?
	JRST NOCOMT		;NO
	CAIE TTT,15
	CAIN TTT,12
	JRST NOCOMT		;NOT BEFORE VERTICAL POSITIONING
	CAIN TTT,14
	JRST NOCOMT
	PUSH P,TTT
	MOVEI TTT,"/"
	PUSHJ P,NOCOMT		;PUT OUT COMMENT CHAR
	POP P,TTT
NOCOMT:
>;DEC
	CAIN TTT,11
	JRST TTYTAB
NOSIMT:	OUTCHR TTT
	JRST .COUNT

TTYTAB:	TLNN SIMTAB		;DO WE HAVE TO SIMULATE TAB?
	JRST NOSIMT		;NO
	PUSH P,TTT
TTYTB1:	MOVEI TTT,40
	PUSHJ P,TTYOUT
	MOVE TTT,LCOUNT
	TRNE TTT,7		;ARE WE AT A TAB STOP YET?
	JRST TTYTB1		;NO
	POP P,TTT
	POPJ P,

^FILPNT:
NOITS,<
	PUTSIX (A)
	PUTBYT "."
	HLLZ TT,1(A)
	PUTSIX TT
DEC,<	SKIPN 3(A)
	POPJ P,
>;DEC
	PUTBYT "["
NOCMU,<	HLLZ TT,3(A)
	PUSHJ P,LSIXOUT
	PUTBYT ","
	HRLZ TT,3(A)
	PUSHJ P,LSIXOUT
>;NOCMU
CMU,<	SKIPN TTT,3(A)
	DSKPPN TTT,
	MOVE TT,[TTT,,PPNBUF]
	DECCMU TT,		;CONVERT DEC PPN TO CMU PPN (ASCIZ)
	JRST [	PUTSIX 3(A)	;IF NOT A CMU PPN, PUT IT OUT IN SIXBIT
		JRST .+2]
	PUTSTR PPNBUF
>;CMU
	PUTBYT "]"
	POPJ P,
>;NOITS
ITS,<
	PUTSIX 3(A)
	PUTBYT ";"
	PUTSIX (A)
	PUTBYT 40
	PUTSIX 1(A)
	POPJ P,
>;ITS

NOCMU,<
^LSIXOUT:
NODEC,<	TLNN TT,777700
	LSH TT,14
	TLNN TT,770000
	LSH TT,6
	JRST SIXLOP		;JUMP INTO PRINT ROUTINE
>;NODEC
DEC,<	HLRZ T,TT
LOCT:	IDIVI T,10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,LOCT
	HLRZ TTT,(P)
	ADDI TTT,60
	XCT PUTCHR
	POPJ P,
>;DEC
>;NOCMU

STRPUT:	PUSH P,T
	PUSH P,TT
	PUSH P,TTT
	MOVEI T,@40		;SETUP FOR ROUTINES
	LDB TT,[POINT 4,40,12]
	CAILE TT,MAXSAC
	SETZ TT,
	PUSHJ P,@SUUOTB(TT)
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,

SUUOTB:	STRPT1
	SIGPUT
	COMPUT
	STRBIN
	SIGBIN
	SGUBIN
DEC,<	SIGOUT	>
MAXSAC__.-SUUOTB-1

NODEC,<
SIGPUT:
>;NODEC
STRPT1:	HRLI T,(<POINT 7,0>)
STRPT3:	ILDB TTT,T
	JUMPE TTT,CPOPJ
STRPT2:	XCT PUTCHR
	JRST STRPT3

^GNDPUT:SETOM GNDFLG
	CAIA
^SMPPUT:SETZM GNDFLG
	MOVEM TT,SMPCNT		;SAVE LENGTH,,SPACING
	SETZM OVRFLW		;NO OVERFLOW YET
	HRLI T,(<POINT 7,0>)
	SETZM TCOUNT		;CLEAR TMP COUNT
	HLRZ TT,SMPCNT		;GET LENGTH
	ILDB TTT,T
	CAIN TTT,NOTCHR
	TLOA NOT
	TLZA NOT
	ILDB TTT,T
	JRST DSTRO4

DSTRO0:	XCT PUTCHR
	ILDB TTT,T
DSTRO4:	JUMPE TTT,DSTRO1
DEC,<	CAIE TTT,11	>	;ARE WE AT AP STUFF?
	CAIN TTT,";"		;DON'T CONFUSE DAVE WITH COMMENTS
	JRST DSTRO1
	SOJGE TT,DSTRO0
	SETOM OVRFLW		;SIGNAL OVERFLOW
DSTRO1:	PUSH P,A
	HRRZ A,SMPCNT
	SUB A,TCOUNT
	ADD A,LCOUNT
	PUSHJ P,SPFILL
	POP P,A
	SKIPE GNDFLG
	JRST [	PUTSTR [ASCIZ/G /]
		POPJ P,]
NODEC,<	TLNN NOT
	SKIPA TTT,[40]
	MOVEI TTT,"-"
	XCT PUTCHR
	MOVEI TTT,40
	XCT PUTCHR
	POPJ P,
>;NODEC
DEC,<	LDB TTT,T
	CAIA
DSTRO2:	ILDB TTT,T
	JUMPE TTT,DSTRO3
	CAIN TTT,";"
	JRST DSTRO3
	CAIE TTT,11
	JRST DSTRO2
	ILDB TTT,T
	TLNE NOT
	MOVEI TTT,"-"
	XCT PUTCHR		;ASSERTION
	ILDB TTT,T
	XCT PUTCHR		;POLARITY
	POPJ P,

DSTRO3:	MOVEI TTT," "
	TLNE NOT
	MOVEI TTT,"-"
	XCT PUTCHR
	MOVEI TTT," "
	XCT PUTCHR
	POPJ P,

SIGPUT:	HRLI T,(<POINT 7,0>)
SIGPT0:	ILDB TTT,T
	JUMPE TTT,CPOPJ
	CAIN TTT,";"
	JRST STRPT2		;NO A/P, JUST PRINT REST OF STRING
	CAIN TTT,11
	JRST SIGPT1
	XCT PUTCHR
	JRST SIGPT0

SIGPT1:	MOVEI TTT,40
	XCT PUTCHR
	ILDB TTT,T
	CAIN TTT,40
	JRST STRPT3
	MOVEI TTT,"("
	XCT PUTCHR
	LDB TTT,T
	XCT PUTCHR
	MOVEI TTT,")"
	JRST STRPT2
>;DEC

;SIGNAL OUT TO TTY

^SIGOUT:
	PUSH P,PUTCHR		;SAVE CURRENT OUTPUT CALL
	MOVE TTT,[OUTCHR TTT]
	MOVEM TTT,PUTCHR
	PUSHJ P,SIGPUT		;PRINT SIGNAL
	POP P,PUTCHR
	POPJ P,

STRBIN:	PUSHJ P,SETBIN
	PUSHJ P,STRPT1
CLRBIN:	PUSHJ P,WRTZERO
	SOS TT,LSTHD+2
	IDIVI TT,5
	ADDI TT,1
	MOVEM TT,LSTHD+2
	MOVEI TT,(<POINT 36,0,35>)
	HRLM TT,LSTHD+1
	POPJ P,

SETBIN:	SOS TT,LSTHD+2
	IMULI TT,5
	ADDI TT,1
	MOVEM TT,LSTHD+2
	MOVEI TT,(<POINT 7,0,34>)
	HRLM TT,LSTHD+1
	POPJ P,

SIGBIN:	PUSHJ P,SETBIN
SIGBN1:	PUSHJ P,SIGPUT
	JRST CLRBIN

SGUBIN:	PUSHJ P,SETBIN
	MOVEI TTT,GLBCHR
	XCT PUTCHR
	JRST SIGBN1

COMPUT:	MOVEI T,@40
	HRLI T,(<POINT 7,0>)
COMOU1:	ILDB TTT,T
	JUMPE TTT,CPOPJ
	CAIE TTT,";"
	JRST COMOU1
	JRST STRPT3

^STRTTY:PUSH P,PUTCHR
	MOVE TTT,[OUTCHR TTT]
	MOVEM TTT,PUTCHR
	PUSHJ P,STROUT
	POP P,PUTCHR
	POPJ P,

^STROUT:JUMPE A,CPOPJ
STROU2:	HRLI A,(<POINT 7,0,35>)
STROU1:	ILDB TTT,A
	XCT PUTCHR
	TLNE A,760000
	JRST STROU1
	HRR A,-1(A)
	TRNE A,-1
	JRST STROU1
	POPJ P,

^MILOUT:IDIVI T,=1000
	PUSH P,TT
	PUSHJ P,DECOUT
	PUTBYT "."
	MOVEI T,3
	MOVEM T,NDIG
	POP P,T
	JRST NDECOUT

^LDOUT:	SKIPGE T
	PUTBYT "-"
	MOVM T,T
	IDIVI T,=100
	PUSH P,TT
	PUSHJ P,DECOUT
	PUTBYT "."
	MOVEI T,2
	MOVEM T,NDIG
	POP P,T
	JRST NDECOUT

^TTYDEC:IDIVI T,=10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,TTYDEC
	HLRZ TT,(P)
	ADDI TT,60
	OUTCHR TT
	POPJ P,

^DECOU4:SKIPA TT,[4]
^DECOU5:MOVEI TT,5
	MOVEM TT,NDIG
DECOU6:	IDIVI T,=10
	ADDI TT,60
	JUMPN T,DECOU7
	CAIE TT,60
	JRST DECOU7
	MOVE T,NDIG
	CAIE T,5
	SUBI TT,20
	SETZ T,
DECOU7:	HRLM TT,(P)
	SOSG NDIG
	JUMPE T,.+2
	PUSHJ P,DECOU6
	HLRZ TT,(P)
	PUTBYT (TT)
	POPJ P,
SUBTTL	IOPAC-INPUT SUBRS
^BYTIN:	SOSG DAT,DATHD+2
	IN DAT,
	CAIA
	JRST [	STATO DAT,1B22
		OUTSTR[ASCIZ/INPUT ERROR!
/]
		SETZ TTT,
		JRST CPOPJ]
	ILDB TTT,DATHD+1
	TRNN ASCFLG
	JRST CPOPJ1
	MOVE TTT,@DATHD+1
	TRNN TTT,1
	JRST GOTIT
	MOVNI TTT,5
	ADDM TTT,DATHD+2
	AOS DATHD+1
	JRST BYTIN
GOTIT:	LDB TTT,DATHD+1
	TRNN ASCFLG
	JRST CPOPJ1
	CAIE TTT,15
	CAIN TTT,14
	JRST BYTIN
	JUMPE TTT,BYTIN
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40
	JRST CPOPJ1

^INDCHR:PUSHJ P,BYTIN
	POPJ P,
IFN ALTMOD-ALTCHR,<
	CAIN TTT,ALTCHR
	MOVEI TTT,ALTMOD
>;ALTMOD-ALTCHR
	JRST CPOPJ1

^TTYINC:SETZM CBITS
	SKIPE DSKACT
	PUSHJ P,DSKINC
	JRST TTYINQ
	POPJ P,

^LETCHK:CAIL TTT,"A"
	CAILE TTT,"Z"
	CAIA
	JRST CPOPJ1
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	POPJ P,
	SUBI TTT,40
	JRST CPOPJ1

^TTYINB:SETZM CBITS
	SKIPE DSKACT
	PUSHJ P,DSKINC
	JRST TTYINY
	POPJ P,

TTYINY:
NOTTYBT,<
	SKIPE SAVLIN		;DO WE NEED SPECIAL CODE?
	JRST TTYIN1		;YES
>;NOTTYBT
	INCHWL TTT
TTYINX:	CAIN TTT,15
	JRST .-2
NODEC,<	CAIN TTT,CBCHR		;CONTROL BIT CHAR?
	JRST TTYINZ
	CAIN TTT,CTRL
	JRST [	MOVEI TTT,200
		IORM TTT,CBITS
		JRST TTYINQ]
	CAIN TTT,META
	JRST [	MOVEI TTT,400
		IORM TTT,CBITS
		JRST TTYINQ]
	CAIN TTT,CTLMTA
	JRST [	MOVEI TTT,600
		IORM TTT,CBITS
		JRST TTYINQ]
>;NODEC
ESCMP,<	CAIL TTT,175
	CAILE TTT,176
	CAIN TTT,33
	JRST TTYINZ		;ALTMODE HACK
	CAIN TTT,177		;RUBOUT?
	JRST [	SKIPN CBITS		;IF ALTMODES TYPED?
		JRST .+1
		OUTSTR[ASCIZ/ XXX /]
		JRST TTYINB]		;THEN FLUSH THEM AND START AGAIN
>;ESCMP
	IOR TTT,CBITS
	POPJ P,

TTYINZ:	MOVEI TTT,200
	ADD TTT,CBITS
	ANDI TTT,600
	MOVEM TTT,CBITS
DEC,<	JUMPE TTT,[MOVEI TTT,ALTMOD
		POPJ P,]
>;DEC
TTYINQ:	INCHRW TTT
	JRST TTYINX

NOTTYBT,<
^LINCLR:PUSH P,BUFPTR
	SETZ TTT,
	IDPB TTT,BUFPTR
	POP P,BUFPTR
	POPJ P,

TTYIN2:	MOVEI TTT,0
	IDPB TTT,BUFPTR
	MOVE TTT,[POINT 7,TTBUF]
	MOVEM TTT,BUFPTR
TTYIN1:	ILDB TTT,BUFPTR
	JUMPN TTT,CPOPJ
TTYIN4:	MOVE TTT,[POINT 7,TTBUF]
	MOVEM TTT,BUFPTR
	SETZM TTBEND
TTYIN5:	INCHRW TTT
	JUMPE TTT,TTYIN5
	CAIN TTT,15
	JRST TTYIN5
	CAIN TTT,177
	JRST TTYIN3
	CAIN TTT,""
	JRST TTYIN4
	CAIGE TTT,175
	CAIN TTT,33
	MOVEI TTT,ALTMOD
	IDPB TTT,BUFPTR
	CAIE TTT,11
	CAIN TTT,12
	JRST TTYIN2
	CAIE TTT,ALTMOD
	SKIPE TTBEND
	JRST TTYIN2
	JRST TTYIN5

TTYIN3:	REPEAT 4,<	IBP BUFPTR	>
	SOS TTT,BUFPTR
	CAMN TTT,[POINT 7,TTBUF-1,27]
	JRST TTYIN4
	JRST TTYIN5
>;NOTTYBT
^TTYIN:	PUSHJ P,TTYINB
STANFO,<CAIN TTT,612		;THIS IS SPECIAL
	POPJ P,			;GIVE EOF RETURN
>;STANFO
	ANDI TTT,177
	CAIN TTT,15		;IGNORE CR'S HERE
	JRST TTYIN
	JRST CPOPJ1

^DSKINC:SOSG IDSKHD+2
	IN IDSK,
	CAIA
	JRST [	STATO IDSK,1B22
		OUTSTR[ASCIZ/
INPUT ERROR ON INDIRECT FILE!/]
		OUTSTR[ASCIZ/
END OF INDIRECT FILE!
/]
		SETZM DSKFLG
		SETZM DSKACT
		RELEASE IDSK,
		POPJ P,]
	AOS DSKCNT			;COUNT CHAR (REGARDLESS OF WHAT IT IS)
	IBP IDSKHD+1
	MOVE TTT,@IDSKHD+1
	TRNN TTT,1
	JRST DSKIND
	MOVNI TTT,5
	ADDM TTT,IDSKHD+2
	AOS IDSKHD+1
	JRST DSKINC

DSKIND:	LDB TTT,IDSKHD+1
	JUMPE TTT,DSKINC
NODEC,<	CAIN TTT,CBCHR
	JRST [	MOVEI TTT,200
		ADD TTT,CBITS
		ANDI TTT,600
		MOVEM TTT,CBITS
		SKIPE DSKACT
		OUTCHR [CBCHR]
		JRST DSKINC ]
	CAIN TTT,CTRL
	JRST [	MOVEI TTT,200
		IORM TTT,CBITS
		SKIPE DSKACT
		OUTCHR[CTRL]
		JRST DSKINC]
	CAIN TTT,META
	JRST [	MOVEI TTT,400
		IORM TTT,CBITS
		SKIPE DSKACT
		OUTCHR[META]
		JRST DSKINC]
	CAIN TTT,CTLMTA
	JRST [	MOVEI TTT,600
		IORM TTT,CBITS
		SKIPE DSKACT
		OUTCHR[CTLMTA]
		JRST DSKINC]
>;NODEC
DEC,<	CAIN TTT,33
	JRST [	SKIPE DSKACT
		OUTCHR["$"]
		MOVEI TTT,200
		ADD TTT,CBITS
		ANDI TTT,600
		MOVEM TTT,CBITS
		JUMPN TTT,DSKINC
		MOVEI TTT,ALTMOD
		JRST NXDACT]
>;DEC
	CAIE TTT,14
	CAIN TTT,15
	JRST DSKINC
IFN ALTMOD-ALTCHR,<
	CAIN TTT,ALTCHR
	MOVEI TTT,ALTMOD
>;ALTMOD-ALTCHR
	SKIPN DSKACT
	JRST NXDACT
	CAIN TTT,12
	OUTCHR[15]
DECOS,<	CAIGE TTT,40
	JRST [	CAIE TTT,11
		CAIN TTT,12
		JRST .+1
		OUTCHR["^"]
		ADDI TTT,100
		OUTCHR TTT
		SUBI TTT,100
		JRST NXDACT]
>;DECOS
	OUTCHR TTT
NXDACT:	IOR TTT,CBITS
	SETZM CBITS
	JRST CPOPJ1

^IN0:	INIT DAT,0
	'DSK   '
	DATHD
	JRST [LOSIN:	OUTSTR[ASCIZ/INIT FAILED OF DSK!
/]
		EXIT 1,
		POPJ P,]
	TRO ASCFLG
SETIN:	MOVEI T,DATBUF
	EXCH T,.JBFF
	INBUF DAT,1
	MOVEM T,.JBFF
	JRST CPOPJ1

^IN10:	INIT DAT,10
	'DSK   '
	DATHD
	JRST LOSIN
	TRZ ASCFLG
	JRST SETIN

^GETWRT:SETZ A,
	MOVE T,[POINT 6,A]
GETWR1:	CAIE TTT,ALTMOD
	CAIGE TTT,40
	JRST CPOPJ1
	CAIL TTT,140
	SUBI TTT,40
	SUBI TTT,40
	TLNE T,770000
	IDPB TTT,T
GETWR2:	XCT GETCHR
	POPJ P,
	CAIE TTT,14
	CAIN TTT,15
	JRST GETWR2
	JRST GETWR1

^GETWRN:SETZ A,
	MOVE T,[POINT 6,A]
	PUSHJ P,CHRCK1
	POPJ P,
	JRST CKSPC
	JRST CHROK

ITS,<
^FILWRD:
	SETZ A,
	MOVE T,[POINT 6,A]
FILW1:	XCT GETCHR
	POPJ P,
FILW2:	CAIE TTT,11
	CAIN TTT,40
	JRST FILW1
	JRST FILW4
FILW3:	XCT GETCHR
	POPJ P,
FILW4:	CAIE TTT,14
	CAIN TTT,15
	JRST FILW3
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40	;LOWER CASE
	CAIL TTT,40
	CAILE TTT,"_"
	JRST CPOPJ1	;NOT SIXBIT
	CAIE TTT,11
	CAIN TTT,40
	JRST CPOPJ1
	CAIN TTT,";"
	JRST CPOPJ1
	SUBI TTT,40
	TLNE T,770000
	IDPB TTT,T
	JRST FILW3
>;ITS

NOCMU,<
^RDPPN:
DEC,<	SETZ A,
OCTSPC:	XCT GETCHR
	POPJ P,
	CAIE TTT,11
	CAIN TTT,40
	JRST OCTSPC
GETOCT:	CAIL TTT,"0"
	CAILE TTT,"7"
	JRST CPOPJ1
	ASH A,3
	ADDI A,-60(TTT)
	XCT GETCHR
	POPJ P,
	JRST GETOCT
>;DEC
NODEC,<	PUSHJ P,GETWRD
	POPJ P,
	HLRZ A,A
	TRNN A,7777
	LSH A,-14
	TRNN A,77
	LSH A,-6
	JRST CPOPJ1
>;NODEC
>;NOCMU

^GETWRD:
	SETZ A,
	MOVE T,[POINT 6,A]
SKPSPC:	PUSHJ P,CHRCHK
	POPJ P,			;EOF
	JRST CKSPC		;BREAK CHAR.
	JRST CHROK

CKSPC:	CAIE TTT,11
	CAIN TTT,40
	JRST SKPSPC
	JRST CPOPJ1		;BREAK ALREADY

CHRGET:	PUSHJ P,CHRCHK
	POPJ P,			;EOF
	JRST CPOPJ1		;BREAK CHARACTER
CHROK:	SUBI TTT,40
	TLNE T,770000		;END OF WORD?
	IDPB TTT,T		;NO
	JRST CHRGET

CHRCHK:	XCT GETCHR
	POPJ P,
CHRCK1:	CAIE TTT,14
	CAIN TTT,15
	JRST CHRCHK
	CAIL TTT,"0"
	CAILE TTT,"9"
	CAIA
	JRST CPOPJ2
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40		;CHANGE UPPER TO LOWER
	CAIL TTT,"A"
	CAILE TTT,"Z"
	JRST CPOPJ1
	JRST CPOPJ2

^SLDECIN:CAIE TTT,"-"
	JRST LDECIN
	XCT GETCHR
	POPJ P,
	PUSHJ P,LDECIN
	POPJ P,
	MOVN A,A
	JRST CPOPJ1

^LDECIN:PUSHJ P,TDECIN
	POPJ P,
	IMULI A,=100
	CAIE TTT,"."
	JRST CPOPJ1
	PUSH P,B
	MOVEI B,=10		;MULTIPLIER
LDEC1:	XCT GETCHR
	JRST [	POP P,B
		POPJ P,]
	CAIG TTT,"9"
	CAIGE TTT,"0"
	JRST [	POP P,B
		JRST CPOPJ1]
	SUBI TTT,60
	IMUL TTT,B
	ADD A,TTT
	IDIVI B,=10
	JRST LDEC1

^SDECIN:XCT GETCHR
	JRST [	SETZ A,
		POPJ P,]
	CAIE TTT,"-"
	JRST TDECIN
	PUSHJ P,DECIN
	SOS (P)			;FLAG EOF, BUT NEGATE ANYWAY
	MOVN A,A
	JRST CPOPJ1

^DECIN:	XCT GETCHR
	JRST [	SETZ A,
		POPJ P,]
^TDECIN:CAIE TTT,11
	CAIN TTT,40
	JRST DECIN
	SETZ A,
	JRST DECLP1
DECLOP:	XCT GETCHR
	POPJ P,
DECLP1:	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST CPOPJ1
	IMULI A,=10
	ADDI A,-60(TTT)
	AOS NDIG
	JRST DECLOP

^O6IN:	MOVEI T,6
	SETZ A,
OIN:	XCT GETCHR
	POPJ P,
	ANDI TTT,7
	LSH A,3
	IOR A,TTT
	SOJG T,OIN
	JRST CPOPJ1

^I3IN:	SKIPA T,[3]
^I5IN:	MOVEI T,5
	SETZ A,
	XCT GETCHR
	POPJ P,
	CAIN TTT,12
	JRST CPOPJ1
	JRST IIN1

IIN:	XCT GETCHR
	POPJ P,
IIN1:	IMULI A,=10
	ANDI TTT,17
	ADD A,TTT
	SOJG T,IIN
	JRST CPOPJ2

SUBTTL	SUBRS CALLED BY PERMUT
^^SIGGET:ILDB TTT,A
	POPJ P,

^^GETVAR:MOVE TT,VARLST
	PUSH P,TTT
GETVR1:	FETCH(TTT,TT,LET)
	CAMN TTT,(P)
	JRST ISVAR		;YES
	FETCH(TT,TT,NVAR)
	JUMPN TT,GETVR1
	POP P,TTT
	SETOM EXPER2		;VARIABLE ERROR
	MOVEI TT,1
	LSH TT,-"A"(TTT)
	TDNE TT,VARERR		;HAVE WE HAD THIS ERROR ALREADY?
	JRST GETVR2
	IORM TT,VARERR		;NO, SAVE IT
	PUTSTR[ASCIZ/NO VALUE FOR VARIABLE "/]
	PUTBYT (TTT)
	PUTSTR[ASCIZ/".
/]
	POPJ P,			;ERROR RETURN SO SIGNAL WILL PRINT

GETVR2:	SETZ TT,		;IF NO VAR ERROR PRINT, THE GIVE OK RETURN
	JRST CPOPJ1

ISVAR:	FETCH(TTT,TT,WID)
	CAMLE TTT,NDIG
	MOVEM TTT,NDIG
	FETCH(TT,TT,VAL)	;RETURN VALUE
	POP P,TTT
	JRST CPOPJ1

WHERRP:	PUTSTR[ASCIZ/CAUSED BY SIGNAL - /]
	PUTSIG ADDR(G,SPNT)
	PUTSTR[ASCIZ/
/]
	POPJ P,
SUBTTL	RSTR, TRSTR
^RSTR:	XCT GETCHR
	SETZ TTT,
	JUMPE TTT,CPOPJ
	GETFS (T)
	SETZM (T)
	HRLM T,(P)
	JRST RSTR2

RSTR1:	GETFS (TT)
	SETZM (TT)
	HRRM TT,(T)
	MOVE T,TT
RSTR2:	MOVEM TTT,1(T)
	TRNE TTT,377
	XCT GETCHR
	JRST RSTR3
	JUMPN TTT,RSTR1
RSTR3:	HLRZ T,(P)
	JRST CPOPJ1

^TISTRU:	SETOM LOW2UP
	JRST ISTR0

^ISTR:	SETZM LOW2UP
	XCT GETCHR
	POPJ P,
ISTR0:	CAIN TTT,ALTMOD
	JRST CPOPJ1
	CAIE TTT,11
	CAIN TTT,12
	JRST CPOPJ2
	GETFS(B)
	SETZM (B)
	SETZM 1(B)
	MOVSI TT,(<POINT 7,0>)
	HRRI TT,1(B)
ISTR1:	TLNE TT,760000
	JRST ISTR2
	PUSH P,TTT
	GETFS(TTT)
	SETZM (TTT)
	SETZM 1(TTT)
	HRRM TTT,-1(TT)
	HRR TT,TTT
	POP P,TTT
ISTR2:	SKIPN LOW2UP
	JRST ISTR3
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	CAIA
	SUBI TTT,40
ISTR3:	IDPB TTT,TT
	XCT GETCHR
	POPJ P,
	CAIN TTT,ALTMOD
	JRST [	PUSHJ P,PUTFS
		JRST CPOPJ1]
	CAIE TTT,11
	CAIN TTT,12
	JRST CPOPJ3
	JRST ISTR1

^TRSTR:	MOVE T,[-MXSTLN,,STRTAB]
TRSTR1:	XCT GETCHR
	POPJ P,
	MOVEM TTT,(T)
	TRNE TTT,376		;END OF ASCIZ?
	AOBJN T,TRSTR1
	JUMPL T,TRSTR3		;END OK?
	TRZ TTT,377
	MOVEM TTT,(T)		;STORE WORD WITH ONE CHAR ZEROED
	OUTSTR[ASCIZ/STRING TOO LONG, TRUNCATED TO:
/]
	OUTSTR STRTAB
	OUTSTR[ASCIZ/
/]
TRSTR2:	XCT GETCHR
	POPJ P,
	TRNE TTT,376
	JRST TRSTR2
TRSTR3:	SKIPE STRTAB
	AOS (P)
	JRST CPOPJ1

^TTYSIG:PUSHJ P,SIGIN
	JFCL				;EOF RETURN
	SKIPE STRTAB
	CAIN TTT,ALTMOD
	POPJ P,				;NULL RETURN ON ALTMODE
	CAIE TTT,11
	JRST CPOPJ1
TTYSKP:	XCT GETCHR
	JRST TTYSK1
	CAIE TTT,12
	CAIN TTT,ALTMOD
	JRST TTYSK1
	JRST TTYSKP

TTYSK1:	OUTSTR[ASCIZ/ILLEGAL TAB IN SIGNAL NAME!
/]
	POPJ P,

^SIGIN:	MOVE T,[POINT 7,STRTAB]
	SETZM STRTAB			;FOR TEST LATER
TTYSG1:	XCT GETCHR
	JRST [	SKIPN STRTAB
		POPJ P,			;GIVE EOF RETURN IF NO STRING
		MOVEI TTT,12
		JRST TTYSG3]
	CAIN TTT,ALTMOD
	POPJ P,
	CAIE TTT,11
	CAIN TTT,12
	JRST TTYSG3
	CAMN T,[POINT 7,STRTAB+MXSTLN-1,27]
	JRST [	OUTSTR[ASCIZ/STRING TOO LONG, TRUNCATING!
/]
	TTYSG2:	XCT GETCHR
		MOVEI TTT,12
		CAIE TTT,12
		CAIN TTT,ALTMOD
		POPJ P,
		JRST TTYSG2]
	IDPB TTT,T
	JRST TTYSG1

TTYSG3:	SETZ TT,			;END FINISH OUT
	IDPB TT,T
	TLNE T,760000
	JRST .-2
	JRST CPOPJ1
SUBTTL	FREE STORAGE ROUTINES

^FSTINI:MOVEI T,[0]		;GET A POINTER TO A 0
	MOVEM T,FSTPNT
	MOVE T,[FSTPNT,,FSTPNT+1]
	BLT T,FSTPNT+FSTLEN-1	;FILL TABLE
	MOVE T,.JBFF
	MOVEM T,FSTOP		;SET AS TOP OF DIVIDED CORE
	CORE T,			;MAYBE CORE DOWN
	JFCL			;IGNORE ERROR
	POPJ P,


^NOFST:	0
	MOVEM A,SAVEA
	MOVEM B,SAVEB
	MOVE B,@NOFST		;GET POINTER INTO FS TABLE
CHKFST:	MOVE A,.JBREL
	SUB A,FSTOP
	CAIL A,-FSTPNT(B)	;ENOUGH?
	JRST ISFST1		;YES
NOFST3:	MOVE A,.JBREL
	ADDI A,2000		;ANOTHER K
	CORE A,
	JRST [	OUTSTR[ASCIZ/CORE UUO FAILED AT NOFST!
/]
		EXIT 1,
		JRST NOFST3]
	JRST CHKFST

ISFST1:	MOVE A,FSTOP
	EXCH A,(B)
	HRRZM A,@(B)
USAGE,<	AOS FSTCNT-FSTPNT(B)	;INC COUNT>
	MOVEI A,-FSTPNT+1(B)	;THIS IS LENGTH OF NEW BLOCK
	ADDM A,FSTOP		;ADVANCE FSTOP
	MOVE B,SAVEB
	MOVE A,SAVEA
	SOS NOFST
	SOS NOFST		;RETURN TO SKIPN
	JRST @NOFST

^MORCOR: 0
	MOVEM A,SAVEA
	AOS A,.JBREL
	CORE A,
	JRST [	OUTSTR[ASCIZ/CORE UUO FAILED AT MORCOR!
/]
		EXIT 1,
		JRST .-2]
	MOVNI A,2
	ADDM A,MORCOR			;RETURN TO TEST INSTRUCTION
	MOVE A,SAVEA
	JRST @MORCOR

^TPUTFS:MOVE B,T
^PUTFS:	HLLI B,
	JUMPE B,CPOPJ
	MOVS T,FSTPNT+1
	HRRZM B,FSTPNT+1
PUTFS1:	HRR T,B
	HRRZS B,(B)	;PICKUP LINK, CLEAR LH
	JUMPN B,PUTFS1
	HLRZM T,(T)	;LINK END TO OLD FS LIST
	POPJ P,

;CALL WITH POINTER TO ASCIZ STRING IN TT
;RETURNS WITH FS STRING IN T
;CLOBBERS TT AND TTT
ASCCOP:	GETFS(T)
	PUSH P,T
ASCCP1:	MOVE TTT,(TT)
	MOVEM TTT,1(T)
	TRNN TTT,376
	JRST ASCCP2
	SKIPN 1(TT)
	JRST ASCCP2
	GETFS(TTT)
	HRRZM TTT,(T)
	MOVE T,TTT
	AOJA TT,ASCCP1

ASCCP2:	SETZM (T)
	POP P,T
	POPJ P,

;CALL WITH POINTER TO FS STRING IN TT
;RETURNS WITH COPY OF STRING IN T
;CLOBBERS TT AND TTT
LSTCOP:	GETFS(T)
	HRLM T,(P)
	JRST LSTCP1

LSTCP2:	GETFS(TTT)
	MOVEM TTT,(T)
	MOVE T,TTT
LSTCP1:	MOVE TTT,1(TT)
	MOVEM TTT,1(T)
	HRRZ TT,(TT)
	JUMPN TT,LSTCP2
	SETZM (T)
	HLRZ T,(P)
	POPJ P,
SUBTTL	ASCMAT, TXTMAT, ASCPAR, TXTPAR

^TXTPAR:PUSHJ P,TXTMAT
	JRST TXTPR1
	JRST CPOPJ1			;TT LESS THAN T, JUST INDICATE THIS
	JRST CPOPJ3			;EXACT

TXTPR1:	JUMPE T,CPOPJ2			;IF T ENDS, THEN PARTIAL MATCH
	ADD TT,[POINT 7,1]
	PUSHJ P,ASCPR0
	POPJ P,
	JRST CPOPJ2			;PARTIAL MATCH

TXTMA2:	MOVE TTT,1(T)
	CAME TTT,1(TT)
	JRST TXTMA1
	HRRZ T,(T)
	HRRZ TT,(TT)
^TXTMAT:JUMPE T,[JUMPE TT,CPOPJ2	;EQUAL
		POPJ P,]		;UNEQUAL T LESS THAN TT
	JUMPN TT,TXTMA2
	JRST CPOPJ1			;UNEQUAL TT LESS THAN T

TXTMA1:	LSH TTT,-1
	PUSH P,TT
	MOVE TT,1(TT)
	LSH TT,-1
	CAML TTT,TT
	AOS -1(P)			;UNEQUAL TT LESS THAN T
	POP P,TT
	POPJ P,				;UNEQUAL T LESS THAN TT

^ASCPAR:PUSHJ P,ASCMAT
	CAIA
	JRST CPOPJ2			;DOUBLE SKIP FOR EXACT MATCH
	JUMPE T,CPOPJ1			;IF FS STRING ENDS, THEN PARTIAL MATCH
	HRLI TT,(<POINT 7,0>)
ASCPR0:	ADD T,[POINT 7,1]
	PUSH P,A
ASCPR1:	ILDB TTT,T
	JUMPE TTT,[POP P,A
		JRST CPOPJ1]		;IF FS STRING ENDS, THEN PARTIAL MATCH
	ILDB A,TT
	CAMN A,TTT
	JRST ASCPR1
	POP P,A
	POPJ P,				;NO MATCH AT ALL

^ASCMAT:MOVE TTT,(TT)
	CAME TTT,1(T)
	POPJ P,
	ADDI TT,1
	HRRZ T,(T)
	JUMPN T,ASCMAT
	TRNE TTT,376
	SKIPN (TT)
	AOS (P)
	POPJ P,

^SEQMAT:MOVE TTT,(TT)
	CAME TTT,(T)
	JRST SEQMT1
	TRNN TTT,376
	JRST [	AOS (P)
		MOVE TTT,(T)
		TRNN TTT,376
		AOS (P)		;T=TT
		POPJ P,]	;TT LESS THAN T
	MOVE TTT,(T)
	TRNN TTT,376
	POPJ P,			;T LESS THAN TT
	ADDI TT,1
	AOJA T,SEQMAT

SEQMT1:	LSH TTT,-1
	MOVE TT,(T)
	LSH TT,-1
	CAML TT,TTT
	AOS (P)			;TT LESS THAN T
	POPJ P,			;T LESS THAN TT
SUBTTL	TOP LEVEL

CLEARS:	SETZ
	SETZM ZEROBEGIN
	MOVE T,[XWD ZEROBEGIN,ZEROBEGIN+1]
	BLT T,ZEROEND
	MOVSI T,DIRLST
	MOVEM T,DIRLST
	PUSHJ P,CLPAGE		;INIT PAGE LENGTH
	PUSHJ P,CLRWID		;INIT LINE LENGTH
	PUSHJ P,SETBRD		;INITIALIZE BOARD TYPE POINTERS
	PUSHJ P,CLOADM		;RESET LOAD MARGIN TO 100%
	JRST FSTINI		;INITIALIZE FREE STORAGE!

UNRESI:	SKIPN RESIDENT
	POPJ P,
	SETZM RESIDENT
	MOVE T,OLDFF
	HRLM T,.JBSA
	MOVEM T,.JBFF
	POPJ P,

REE:	MOVE P,[IOWD PDLLEN,PDL]
	PUSHJ P,UNRESI
	RESET
	PUSHJ P,CLEARS
	PUSHJ P,DIPCHK
	OUTSTR[ASCIZ/MOBY LOSSAGE FROM DIPCHK AT RESIDENT DIPLST CODE!
/]
	MOVE T,DIPLST
	JUMPE T,STRT
	MOVEM T,RESIDENT
	HLRZ T,.JBSA
	MOVEM T,OLDFF		;REMEMBER OLD .JBFF
	MOVE T,FSTOP		;THIS IS FIRST WORD WE AREN'T USING
	HRLM T,.JBSA
ITS,<
	PUSHJ P,VALINI		;FLUSH ALL EXTRA CORE, AND THE SIMULATOR
	MOVEI TT,[ASCIZ /}Y DRAW1;WL BIN/]
	PUSHJ P,DDTSTR		;PUT OUT FINAL STRING
VALRET:	MOVEI T,0
	PUSHJ P,DDTPUT		;AND A NULL FOR GOOD MEASURE
	MOVEI T,VALBUF+VALBFL
	SUBI T,(TTT)
	SKIPG T
	.VALUE [ASCIZ /:} VALRET BUFFER OVERFLOW, PROCEED AT YOUR OWN RISK }
/]	
	.VALUE VALBUF
	.BREAK 16,60000		;AUTO EXPUNGE
>;ITS
STRT:	MOVE P,[IOWD PDLLEN,PDL]
	RESET
	SETZM DSKFLG		;CLEAR DSKIN
	SETZM DSKACT		;AND ACTIVE
	SETZM ZPPN		;INITIALIZE DEFAULT INPUT PPN
STRTC:	PUSHJ P,CLEARS		;CLEAR TABLES
	MOVE T,RESIDENT		;RESIDENT DIPS?
	MOVEM T,DIPLST		;STORE POINTER
	PUSHJ P,THREAD		;THREAD ANY PART NUMBERS WE HAVE NOW
	PUSHJ P,TOPMOD		;TOP MODE
	PUSHJ P,WIRINI		;SET DEFAULT WIRE LIST
MAIN:	HRRZ T,DIRLST
	SKIPE T			;EMPTY LIST?
	PUSHJ P,DIRRET		;NO, RETURN LIST FROM LAST LOSER
	SKIPE B,IDRLST
	PUSHJ P,IDRRET		;NO, RETURN LIST FROM LAST LOSER
	SETZM VARLST		;NO VARS NOW
	RELEASE DAT,		;FLUSH ANY IO THAT WAS GOING ON
	RELEASE LST,		;POSSIBLE IERROR FILE ALSO
	OUTSTR @PROMPT		;PRINT APPROPRIATE PROMPT
CMU,<	PUSHJ P,TTYINC	>	;READ TTY IN CHAR MODE TO GOBBLE CBCHR
NOCMU,<	PUSHJ P,TTYINB	>	;ITS A LOSER WHEN I CHANGE MY MIND ABOUT WHAT I TYPED
	MOVE A,TTT
	LDB B,[POINT 2,A,28]
	ANDI A,177
	CAIL A,"a"
	CAILE A,"z"
	CAIA
	SUBI A,40
	XCT @DISPWD
	JRST MAIN
	JRST ERRET

CERRET:SKIPE DSKACT
	JRST IERRET
	OUTSTR[ASCIZ/???
/]
	JRST GOMAIN

NERRET:SKIPE DSKACT
	JRST IERRET
	JRST ERRET1

ERRET:	SKIPE DSKACT
	JRST IERRET
	OUTSTR[ASCIZ/???
/]
	JRST ERRET1

IERRET:	RELEASE IDSK,
	SETZM DSKACT
	OUTSTR[ASCIZ/ERROR IN DSKIN FILE, DSKHLD DONE!
/]
ERRET1:	INCHSL A			;NOW FLUSH ANY INPUT
	JRST GOMAIN
	CAIE T,12
	CAIN T,ALTMOD
	JRST GOMAIN
	JRST ERRET1

GOMAIN:	MOVE P,[IOWD PDLLEN,PDL]
	JRST MAIN

DDTCAL:	SKIPN TT,.JBDDT
	JRST [	OUTSTR[ASCIZ/SORRY, NO DDT!
/]
		POPJ P,]
	MOVE T,[10000,,CPOPJ]
	MOVEM T,.JBOPC
	JRST (TT)

DOEXIT:	EXIT 1,
	JRST STRT

TOPTAB:	CAIA
FOR I_1,11
<	CAIA
>
	OUTCHR[15]
FOR I_13,77
<	CAIA
>
	PUSHJ P,DSKIN
	CAIA
	XCT (B)[JRST ERRET
		PUSHJ P,BREADD
		PUSHJ P,RDPART
		PUSHJ P,READEQ]
	XCT (B)[JRST ERRET
		PUSHJ P,WIRCOM
		PUSHJ P,DIPCOM
		PUSHJ P,WDECO]
	XCT (B)[JRST ERRET
		JRST ERRET
		JRST ERRET
		PUSHJ P,DIPMOD]
	JRST DOEXIT
	CAIA
	CAIA
	CAIA
	XCT (B)[JRST ERRET
		PUSHJ P,WREADD
		PUSHJ P,WREADP
		PUSHJ P,RDWEQ]
	CAIA
	CAIA
	XCT (B)[JRST ERRET
		PUSHJ P,LIST
		PUSHJ P,SUMLST
		PUSHJ P,USEPIN]
	CAIA
	XCT (B)[JRST ERRET
		PUSHJ P,NTITLE
		JRST ERRET
		JRST ERRET]
	CAIA			;O
	XCT (B)[PUSHJ P,TLIST
		PUSHJ P,TLISTB
		PUSHJ P,TTYUSE
		PUSHJ P,TLISTA]
FOR I_"Q","T"
<	CAIA
>
	XCT (B)[JRST ERRET
		JRST ERRET
		JRST ERRET
		PUSHJ P,DTOPC]
	CAIA
	XCT (B)[JRST ERRET
		PUSHJ P,PUTOUT	;WRITE WDR FILE
		PUSHJ P,BAKOUT	;WRITE BAC FILE
		JRST ERRET]
	XCT (B)[PUSHJ P,DOOX
		PUSHJ P,DOOXA
		PUSHJ P,DOOXA
		PUSHJ P,DOOXA]
FOR I_"Y",136
<	CAIA
>
	XCT (B)[PUSHJ P,WIRGET
		PUSHJ P,WIRFOR
		PUSHJ P,WIRBAK
		PUSHJ P,WIRPNT]
FOR I_140,200
<	CAIA
>
;END OF TOPTAB



DIPTAB:	CAIA
FOR I_1,11
<	CAIA
>
	OUTCHR[15]
FOR I_13,77
<	CAIA
>
	PUSHJ P,DSKIN
	PUSHJ P,DIPPRP		;ALTER PROPERTY TREE
	CAIA
	PUSHJ P,DIPCOP		;COPY DIP DEF
	PUSHJ P,DIPDEL		;DELETE DIP DEF
	PUSHJ P,TOPMOD		;GO BACK TO MAIN LOOP
FOR I_"F","H"
<	CAIA
>
	PUSHJ P,DIPIN		;READ DIP FILE
FOR I_"J","K"
<	CAIA
>
	PUSHJ P,DIPPRA		;LIST ALL DEF'S
	PUSHJ P,MODIFY		;MODIFY DIP DEFINITION
	PUSHJ P,NDNAME		;NEW DIP FILE NAME OR JUST PRINT
	CAIA			;O
	PUSHJ P,DIPPRN		;PRINT DIP DEFINITION
	CAIA
	PUSHJ P,DIPREN		;RENAME A DIP NAME
	CAIA
FOR I_"T","V"
<	CAIA
>
	PUSHJ P,DIPWRT		;WRITE DIP FILE
	XCT (B)[PUSHJ P,DDOOX
		PUSHJ P,DDOOXA
		PUSHJ P,DDOOXA
		PUSHJ P,DDOOXA]
FOR I_"Y",177
<	CAIA
>
	CAIA

TOPMOD:	MOVE T,[TOPTAB(A)]
	MOVEM T,DISPWD
	MOVEI T,[ASCIZ/*/]
	MOVEM T,PROMPT
	OUTSTR[ASCIZ/TOP MODE!
/]
	POPJ P,

DIPMOD:	MOVE T,[DIPTAB(A)]
	MOVEM T,DISPWD
	MOVEI T,[ASCIZ/*/]
	MOVEM T,PROMPT
	OUTSTR[ASCIZ/DIP SUB-MODE!
/]
	POPJ P,

SUBTTL	X SCANNER
DOOXA:	OUTSTR[ASCIZ/
Si?/]
	JRST DOOX
DDOOXA:	OUTSTR[ASCIZ/
Si?/]
DDOOX:	SKIPA T,[-DTBLEN,,DXTAB]
DOOX:	MOVE T,[-TABLEN,,XTAB]
	MOVEM T,DOOXWD
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
IGNSP1:	XCT GETCHR
	JFCL
	CAIE TTT,40		;IGNORE LEADING BLANKS
	CAIN TTT,11
	JRST IGNSP1
NOCMU,<	CAIN TTT,"?"
	JRST PUSE		;PRINT USE TABLE
>;NOCMU
	CAIN TTT,"-"
	TLOA TFLG
	TLZA TFLG
	MOVEI TTT,40		;SKIP ANY SPACES
	PUSHJ P,GETWRN		;FIRST CHAR IN T
	JFCL
	PUSHJ P,CHRCK1		;SKIP BLANKS
	JFCL			;IGNORE EOF
	JFCL			;IGNORE KIND OF CHAR
	CAIE TTT,12		;EOL?
	JRST ERRET
	JUMPE A,CPOPJ		;NULL COMMAND?
	MOVSI TTT,770000
	SETZ TT,		;CLEAR MASK
	TDNE A,TTT
	TDO TT,TTT
	LSH TTT,-6
	JUMPN TTT,.-3
	SETZ T,		;NO PARTIAL MATCH FOUND YET!
	MOVE D,DOOXWD
XLOP:	CAMN A,(D)
	JRST EXACT
	MOVE TTT,TT
	AND TTT,(D)
	CAMN TTT,A
	JRST [	JUMPN T,XAMBIG	;TOO MANY MATCHES?
		MOVE T,D
		JRST .+1]
	AOBJN D,XLOP
	JUMPE T,CERRET	;ANY MATCH?
	MOVE D,T	;YES, CALL IT
	TLNE TFLG
	OUTCHR["-"]
	PUTSIX (D)
	OUTSTR[ASCIZ/
/]
EXACT:	ADDI D,XDIS-XTAB
	TLNN TFLG	;IS THIS A NOT
	SKIPA A,(D)	;NO
	MOVS A,(D)	;YES
	TRNN A,-1	;ANY DISPATCH FOR THIS FLAVOR?
	JRST CERRET
	JRST (A)	;YES

XAMBIG:	OUTSTR[ASCIZ/SORRY, AMBIGUOUS
/]
	POPJ P,
SUBTTL	X TABLES
;COMMANDS FOR TOP MODE
DEFINE XARGS
<
	XMAC	HELP,PUSE,,<Print out this message>
	XMAC	SPACES,SETSPC,CLRSPC,<See spaces in signal names>
	XMAC	REFERENCES,SETREF,CLRREF,<Enable multiple signal name references>
	XMAC	STATUS,PSTATE,,<Print current status>
	XMAC	DEFPPN,STZPPN,CLZPPN,<Set default PPN for input only>
	XMAC	USED,USED,USEPC,<Use D wirelist>
	XMAC	USEPC,USEPC,USED,<Use PC wirelist>
	XMAC	WLID,WIRID,,<Change wirelist ID>
	XMAC	FILES,PFILES,,<Print file list for card>
	XMAC	BFILES,BFILES,,<Print file list for backpanel>
	XMAC	WLSSEL,WLSSEL,,<Write 'WLS' file and select category(s)>
	XMAC	BSSEL,BSSEL,,<Write 'BS' file and select category(s)>
	XMAC	MAKALL,MAKALL,,<Write 'WL', 'WLS', and 'WLU' files>
	XMAC	BMAKALL,BMAKAL,,<Write 'BL', and 'BLS' files>
	XMAC	PART,DOPART,,<Write Wagner partition file>
	XMAC	UML,PNTUML,,<Make UML listing>
	XMAC	SIGSUM,DOREF,,<Make signal summary>
	XMAC	CONSUM,SIGCOM,,<Make connectors needed summary>
DEC,<
	XMAC	UMAKE,UMLOUT,,<MAKE 'UML' FILE FOR SETTING "U" NUMBERS FROM REAL PINS>
	XMAC	FIXCON,CPNOUT,,<OUTPUT LIST OF CONNECTOR PINS FOR UPDATING DRAWINGS>
	XMAC	SPREFIX,SPIOUT,,<OUTPUT SIGNAL LIST FOR "GREAT SIGNAL NAME CHANGE">
>;DEC
	XMAC	STUFF,STFLST,,<Make dip stuffing list for card>
	XMAC	LPART,PRTLST,,<Make parts list>
	XMAC	MPART,MPART,,<Make master parts list (from BAC files)>
	XMAC	OUTSUM,OUTSUM,,<Write output pin termination summary>
	XMAC	TERMLIST,TRMLST,,<Write terminator test point list>
	XMAC	TEST,TSTWRT,,<Write card tester file>
	XMAC	SIMPLE,WIRWRT,,<Output back panel to DEC wirelister>
	XMAC	ASIMPLE,ASIMPLE,,<Write 'SMP' file, but assign real pin names in place of "U" pin names>
	XMAC	BSIMPLE,BSIMPLE,,<Write 'SMP' file including all pwr pins>
	XMAC	OSIMPLE,OSIMPLE,,<Write 'SMP' file offsetting slot numbers>
	XMAC	PSIMPLE,PSIMPLE,,<Write 'SMP' file with only power pins in it>
DEC,<	XMAC	REDAC,REDAC,,<OUTPUT REDAC CONNECTION LIST>
	XMAC	CALDEC,REDAC,,<OUTPUT CALDEC CONNECTION LIST>
	XMAC	CS,CSWRT,,<OUTPUT 'CS' CIRCUIT SCHEMATIC NETWORK FILE FOR WRLCOM (BOARD)>
	XMAC	BCS,BCSWRT,,<OUTPUT 'CS' CIRCUIT SCHEMATIC NETWORK FILE FOR WRLCOM (BACKPANEL)>
	XMAC	SR,SRWRT,,<OUTPUT 'SR' SCHEMATIC REPRESENTATION FOR MODULE TEST GENERATOR>
	XMAC	WRESISTOR,RESFIL,,<OUTPUT FILE FOR RESISTOR DRAWING>
	XMAC	WLCOMP,WRTWCI,,<OUTPUT 'WCI' FILE FOR WLCOMP INPUT>
>;DEC
TAPR8,<
	XMAC	TAPR8,TP8WRT,,<Output TAPR-8 connection file>
>;TAPR8
	XMAC	ERRSUM,ERRSUM,,<Logic error summary back to D>
	XMAC	BLIST,BAKLST,,<Back panel wire list>
	XMAC	BSUM,BACSUM,,<Back panel summary>
	XMAC	BPRINT,TLSTBP,,<Print back panel signal>
	XMAC	IERROR,SETWIE,CLRWIE,<Enable wire list input errors to go to file>
USAGE,<	XMAC	USAGE,UCOUNT,,<Count free storage usage>	>
	XMAC	WIREGND,STWGND,CLWGND,<Enable wiring of ground pins on dips>
	XMAC	LNGRID,SETLNG,CLRLNG,<Switch DEC card to a letter number grid>
	XMAC	MARGIN,SLOADM,CLOADM,<Set margin for run overload error>
ROUTE,<	XMAC	ROUTE,ROUTIT,,<Routed wire list>
	XMAC	ZLEVEL,ZLEVP,,<Make Z-level wrap list>
	XMAC	RAYTHEON,RAYP,,<Raytheon wire wrap list "From-To" format>
	XMAC	RAY,RAYP,,<Raytheon wire wrap list "From-To" format>
	XMAC	RAYTT,RAYTT,,<Raytheon wire wrap list "To-To" format>
>;ROUTE
>;XARGS

;COMMANDS FOR BOTH MODES
DEFINE BXARGS
<	XMAC	BOARD,BRDSET,BRDCLR
	XMAC	DDT,DDTCAL,,<Call DDT>
	XMAC	SAVE,SAVE,,<Save a dump file>
	XMAC	ECL,SETECL,CLRECL
	XMAC	TTL,SETTTL,CLRECL
	XMAC	RESIDENT,REE,UNRESI,<Make dip defs resident>
	XMAC	CLEAR,STRTC,,<Clear core except for resident dip defs>
	XMAC	CITYBLK,DOCITY,NOCITY,<Wire lengths for city block routing (only affects Augat boards)>
	XMAC	DSKIN,DSKIN,,<Accept TTY input from disk>
	XMAC	DSKHLD,DSKHLD,,<Hold disk input(closes file)>
	XMAC	DSKCON,DSKCON,,<Continue disk input(Reopens file, reads to last position)>
	XMAC	DSKSKP,DSKSKP,,<Skip over lines in DSKIN file>
	XMAC	PAGE,STPAGE,CLPAGE,<Set lines per page (for listings)>
	XMAC	WIDTH,SETWID,CLRWID,<Set characters per line (for listings)>
	XMAC	FRACTI,STFRAC,,<Sets resultion of wire lengths in fractions of inch>
ITS,<	XMAC	XGP,SETXGP,CLRXGP,<Produce XGP output>	>
>

;COMMANDS FOR DIP MODE
DEFINE DXARGS
<	XMAC	FOO,CPOPJ,,<No-op to hold table space>		;HOLD THIS PLACE FOR OTHER COMMANDS
>

DEFINE XMAC(A,B,C,D)
<	<SIXBIT/A/>
>

XTAB:	XARGS
DXTAB:	BXARGS
TABLEN__.-XTAB
	DXARGS
DTBLEN__.-DXTAB

DEFINE XMAC(A,B,C,D)
<	IFIDN<C><><0>C,,B
>

XDIS:	XARGS
DXDIS:	BXARGS
	DXARGS

DEFINE XMAC(A,B,C,D)
<	[ASCIZ/D/]
>

UTAB:	XARGS
BUTAB:	BXARGS
DUTAB:	DXARGS
DUEND__.
SUBTTL	USAGE COUNTERS
USAGE,<
UCOUNT:
	SETZM FSTTMP
	MOVE T,[FSTTMP,,FSTTMP+1]
	BLT T,FSTTMP+FSTLEN-1		;CLEAR OUT TMP TABLE
	SETZB D,E
	MOVE L,DEFLST
	PUSHJ P,DODCNT
	FETCH(W,L,PCWL)
	JRST DOPCCN

DODCNT:	FETCH(W,L,BLST)
	JUMPE W,NOUBAK
	OUTSTR[ASCIZ/
BACK PANEL LIST:
/]
	SETZB A,D
	FETCH(H,L,BKNM)
	JUMPE H,NXBKNM
BKNMCT:	ADDI A,1
	FETCH(H,H,FNXT)
	JUMPN H,BKNMCT
	MOVEI T,1+ADDR(0,FBLK)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,A
	ADDM T,FSTTMP+ADDR(0,FBLK)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,A
	IMULI T,1+ADDR(0,FBLK)
	MOVE D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	FILENAME BLOCKS
/]
NXBKNM:	TRO ISBACK
	PUSHJ P,WCNT
NOUBAK:	FETCH(W,L,WIRL)
DOPCCN:	JUMPE W,NOUCNT
	TRZ ISBACK
	OUTSTR[ASCIZ/
CARD(S):
/]
UCNT3:	OUTSTR[ASCIZ/
/]
	FETCH(T,W,FCRD)
	HRLZM T,SLICEL
	JUMPE T,.+2
	PUSHJ P,PSLICL
	OUTSTR[ASCIZ/
/]
	SETZ D,
	PUSHJ P,WCNT
	FETCH(W,W,NXTWL)
	JUMPN W,UCNT3
NOUCNT:	CAMN E,D
	JRST NOTOT
	OUTSTR[ASCIZ/GRAND TOTAL =	/]
	MOVE T,E
	PUSHJ P,TTYDEC
NOTOT:	OUTSTR[ASCIZ/

/]
	MOVE A,[-FSTLEN,,1]
	OUTSTR[ASCIZ/SIZE	COUNT	TOTAL
/]
	SETZB D,E
UCNT1:	SKIPN FSTCNT-1(A)
	JRST NALLOC
	MOVEI T,(A)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,FSTCNT-1(A)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,(A)
	IMUL T,FSTCNT-1(A)
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	ALLOCATED
/]
	MOVE C,FSTPNT-1(A)
	SETZ B,
	SKIPE C,(C)
	AOJA B,.-1
	JUMPE B,NFREE
	OUTCHR[11]
	MOVE T,B
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,B
	IMULI T,(A)
	SUB D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	FREE
/]
NFREE:	SKIPN T,FSTTMP-1(A)
	JRST NALLOC
	OUTCHR[11]
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,FSTTMP-1(A)
	IMULI T,(A)
	ADD E,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	IN USE
/]
NALLOC:	AOBJN A,UCNT1
	JUMPE D,CPOPJ
	OUTSTR[ASCIZ/TOTAL ALLOCATED - FREE =	/]
	MOVE T,D
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	OUTSTR[ASCIZ/          TOTAL IN USE =	/]
	MOVE T,E
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	MOVE T,D
	SUB T,E
	JUMPE T,CPOPJ
	OUTSTR[ASCIZ/            TOTAL LOST =	/]
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	POPJ P,

WCNT:	AOS FSTTMP+ADDR(0,WLBLOCK)
	SETZB A,B
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST WCNT1

WCNT2:	ADDI A,1
	MOVEI G,ADDR(H,BNAM)
	MOVE B,G
BCNT1:	MOVE T,(G)
	TRNE T,376
	AOJA G,BCNT1
	SUBM G,B
WCNT1:	FETCH(H,H,NXTB)
	JUMPN H,WCNT2
	MOVEI T,1+ADDR(0,BHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,A
	ADDM T,FSTTMP+ADDR(0,BHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,1+ADDR(0,BHEAD)
	IMUL T,A
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	BODIES
1	/]
	MOVE T,B
	ADDM T,FSTTMP
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,B
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	BODY NAMES-1
/]
	MOVEI H,RADDR(W,WIRES,ALPH)
	SETZB A,B
	SETZB C,F
	SETZ TT,
	JRST WCNT3

WCNT4:	ADDI B,1
	MOVEI G,ADDR(H,SPNT)
	MOVE T,G
WCNTS:	MOVE TTT,(G)
	TRNE TTT,376
	AOJA G,WCNTS
	SUB G,T
	ADD F,G
	FETCH(T,H,WBIT)
	TRNE T,NAM2ND
	JRST WCNT3
	ADDI A,1
	SETZM LSLOT
	MOVEI G,RADDR(H,WPIN,NXTP)
	JRST WCNT5

WCNT6:	ADDI C,1
WCNT5:	FETCH(G,G,NXTP)
	JUMPN G,WCNT6
WCNT3:	FETCH(H,H,ALPH)
	JUMPN H,WCNT4
	OUTCHR[11]
	MOVE T,A
	PUSHJ P,TTYDEC
	OUTCHR[11]
	OUTSTR[ASCIZ/	WIRES
/]
	MOVEI T,1+ADDR(0,WHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,B
	ADDM T,FSTTMP+ADDR(0,WHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,1+ADDR(0,WHEAD)
	IMUL T,B
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	SIGNAL BLOCKS
1	/]
	MOVE T,F
	ADDM T,FSTTMP
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,F
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	SIGNAL NAMES-1
/]
	MOVEI T,1+ADDR(0,PHEAD)
	TRNE ISBACK
	MOVEI T,1+ADDR(0,BPHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,C
	TRNN ISBACK
	ADDM T,FSTTMP+ADDR(0,PHEAD)
	TRNE ISBACK
	ADDM T,FSTTMP+ADDR(0,BPHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,1+ADDR(0,PHEAD)
	TRNE ISBACK
	MOVEI T,1+ADDR(0,BPHEAD)
	IMUL T,C
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	PINS
/]
	OUTSTR[ASCIZ/	TOTAL =	/]
	MOVE T,D
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	ADD E,D
	POPJ P,
>;USAGE
SUBTTL	MORE EXTENDED SUBRS
MAKALL:	SETZM ALLNAM
	SETZM ALLCRD
NODEC,<	PUSHJ P,LIST	>
DEC,<	PUSHJ P,WRTWCI	>
	PUSHJ P,ALLWLS
	PUSHJ P,ALLUSE
	TRZ DOPRTL
	PUSHJ P,ALLSTF
	TRO DOPRTL		;DO PARTS LIST
	JRST ALLSTF

BMAKAL:	MOVE L,DEFLST
	FETCH(W,L,BLST)
	JUMPE W,[OUTSTR[ASCIZ/NO BACK PANEL WIRELIST.
/]
		POPJ P,]
	PUSHJ P,BAKLST
	JRST ALLBS

PUSE:
NOCMU,<	XCT GETCHR
	JFCL
	CAIE TTT,12
	JRST ERRET
>;NOCMU
	OUTSTR[ASCIZ/COMMAND	 ********* MEANING *******************
?	PRINT THIS LIST
/]
	MOVE A,[UTAB-BUTAB,,0]
	OUTSTR[ASCIZ/
TOP MODE:
/]
	PUSHJ P,PUSE1
	MOVE A,[BUTAB-DUTAB,,BUTAB-UTAB]
	OUTSTR[ASCIZ/
TOP MODE OR DIP SUB-MODE:
/]
	PUSHJ P,PUSE1
	MOVE A,[DUTAB-DUEND,,DUTAB-UTAB]
	OUTSTR[ASCIZ/
DIP SUB-MODE:
/]
PUSE1:	PUTSIX XTAB(A)		;SIXBIT COMMAND NAME
	HLRZ T,XDIS(A)
	SKIPE T			;-?
	OUTCHR["-"]		;YES
	OUTCHR[11]
	PUTSTR @UTAB(A)
	OUTSTR[ASCIZ/
/]
	AOBJN A,PUSE1
	POPJ P,

BRDSET:	SKIPGE A,BRDTYP
	JRST GETBRD
	OUTSTR[ASCIZ/BOARD TYPE IS: /]
	OUTSTR @BNAMES(A)
	OUTSTR[ASCIZ/
/]
	JRST GETBRD

BRDCLR:	SETOM BRDTYP
	JRST SETBRD

PFILES:	TRZA ISBACK
BFILES:	TRO ISBACK
	MOVE TTT,[PUSHJ P,TTYOUT]
	MOVEM TTT,PUTCHR
	SETOM TTYFLG
	SETZM LCOUNT
	SETZM LINCNT
	TLO NOFF
	MOVE L,DEFLST
	TRNE ISBACK
	JRST AFILES
	PUSHJ P,LSTGET
	POPJ P,
AFILES:	PUSHJ P,TFILES
	PUTHDR
	POPJ P,

SETECL:	SKIPA T,[ECL]
SETTTL:	MOVEI T,TTL
	MOVEM T,DEFECL
	POPJ P,

CLRECL:	SETZM DEFECL
	POPJ P,

SETLNG:	SKIPN ISWW
	JRST NXWW
	SETOM LNGRID
	POPJ P,

NXWW:	OUTSTR[ASCIZ/SORRY, COMMAND VALID FOR WIRE WRAP BOARDS ONLY.
/]
	POPJ P,

CLRLNG:	SKIPN ISWW
	JRST NXWW
	SETZM LNGRID
	POPJ P,

STWGND:	SKIPN ISWW
	JRST NXWW
	SETOM WIRGND
	POPJ P,

CLWGND:	SKIPN ISWW
	JRST NXWW
	SETZM WIRGND
	POPJ P,

OUTLPP:	OUTSTR[ASCIZ/LINES PER PAGE = /]
	POPJ P,

STPAGE:	PUSHJ P,OUTLPP
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,DECIN
	JFCL
	CAIE TTT,12
	JRST ERRET
	JUMPE A,ERRET
	MOVEM A,PAGLEN
	POPJ P,

CLPAGE:	MOVEI TTT,STDPAG
	MOVEM TTT,PAGLEN
	POPJ P,

SETWID:	OUTSTR[ASCIZ/Characters per line = /]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,DECIN
	JFCL
	CAIE TTT,12
	JRST ERRET
	JUMPE A,ERRET
	MOVEM A,LWIDTH
	POPJ P,

CLRWID:	MOVEI TTT,STDWID
	MOVEM TTT,LWIDTH
	POPJ P,

SLOADM:	OUTSTR[ASCIZ/% of maximum = /]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,DECIN
	JFCL
	CAIE TTT,12
	JUMPLE A,ERRET
	MOVEM A,LOADMG
	POPJ P,

CLOADM:	MOVEI TTT,=100
	MOVEM TTT,LOADMG
	POPJ P,

ITS,<
CLRXGP:	SETZM XGP
	MOVEI T,STDPAG
	MOVEM T,PAGLEN
	POPJ P,

FONTI:	.CALL [	SETZ
		SIXBIT /IOT/
		1000,,FONTCH
		SETZ T]
	JRST ERRET
	POPJ P,

SETXGP:	SETZM XGP
	MOVE T,[SIXBIT /KST/]
	MOVEM T,DEFEXT
	MOVEI T,0		;ALL KINDS OF KLUDGERY TO DEFAULT PPN CORRECTLY
	DSKPPN T,
	PUSH P,T
	MOVE T,[SIXBIT /FONTS/]
	DSKPPN T,
	PUSHJ P,SETFIL
	CAIA
	JRST SETXG1		;RESTORE DSKPPN AND OPEN FONT
	MOVE T,[SIXBIT /20FG/]	;GIVE HIM FIX20
	MOVEM T,FILNAM
	MOVE T,[SIXBIT /KST/]
	MOVEM T,FILEXT
	MOVE T,[SIXBIT /FONTS/]
	MOVEM T,FILPPN
	PUSH P,A
	MOVEI A,FILNAM
	PUSHJ P,FILPNT
	POP P,A
SETXG1:	POP P,T
	DSKPPN T,
	.CALL [	SETZ
		SIXBIT /OPEN/
		1000,,FONTCH
		[SIXBIT /DSK/]
		FILNAM
		FILEXT
		FILPPN
		405000,,4]	;IMAGE, UNIT, INPUT
	JRST ERRET
	PUSHJ P,FONTI		;IGNORE KSTID
	PUSHJ P,FONTI		;BYTE (9) CPA, BASE_LINE (18) HEIGHT
	.CALL [	SETZ
		SIXBIT /CLOSE/
		SETZI FONTCH]
	JRST ERRET
	HRRZS T
	MOVEM T,XGPFNT		;HEIGHT
	IDIVI T,5		;VSP
	MOVEM T,XGPVSP
	ADDM T,XGPFNT
	MOVEI T,=11*XGPVBI-=256	;11"-TOP AND BOTTOM MARGINS
	IDIV T,XGPFNT
	MOVEI T,1(T)		;FIRST LINE GOES IN TOP MARGIN
	MOVEM T,PAGLEN		;THATS THE PAGE LENGTH
	OUTSTR [BYTE (7) 15, 12]
	PUSHJ P,OUTLPP
	PUSHJ P,DECOUT
	OUTSTR [BYTE (7) 15, 12]
	MOVE T,FILNAM
	MOVEM T,XGPFNT
	MOVE T,FILEXT
	MOVEM T,XGPEXT
	MOVE T,FILPPN
	MOVEM T,XGPPPN
	SETOM XGP
	POPJ P,
>;ITS
SETSPC:	TRO PETIT		;SPACES ARE SIGNIFICANT
	POPJ P,

CLRSPC:	TRZ PETIT		;SPACES AREN'T SIGNIFICANT
	POPJ P,

SETREF:	TRO REFLAG		;ENABLE REFERENCE HACK
	POPJ P,

CLRREF:	TRZ REFLAG		;DISABLE REFERENCE HACK
	POPJ P,

SETWIE:	TRO DOWIE
	POPJ P,

CLRWIE:	TRZ DOWIE
	POPJ P,

USED:	SETOM USEDWL
	POPJ P,

USEPC:	SETZM USEDWL
	POPJ P,

STZPPN:
NOCMU,<
NOITS,<	OUTSTR [ASCIZ/Default input P,PN? /]
	PUSHJ P,RDPPN
	JRST ERRET
	JUMPE A,[CAIE TTT,12
		JRST ERRET
		JRST CLZPPN]
	HRLM A,(P)
	CAIN TTT,12
	JRST [	SETZ A,
		DSKPPN A,
NOSTAN,<	HLR A,(P)	>
STAN,<		HLL A,(P)	>
		JRST GOTPN]
	CAIN TTT,","
	PUSHJ P,RDPPN
	JRST ERRET
	JUMPE A,ERRET
	CAIE TTT,12
	JRST ERRET
	HLL A,(P)
GOTPN:
>;NOITS
>;NOCMU
ITS,<	OUTSTR[ASCIZ/Default input ppn? /]
	PUSHJ P,FILWRD
	JRST ERRET
	CAIE TTT,12
	JRST ERRET
>;ITS
CMU,<	OUTSTR [ASCIZ/Default input ppn? /]
	SETZM PPNBUF		;CLEAR OUT A BUFFER FOR THE PPN
	SETZM PPNBUF+1
	SETZM PPNBUF+2
	MOVE A,[POINT 7,PPNBUF]
	MOVEI T,=13		;13 CHARACTERS AT MOST!
CMUPP1:	XCT GETCHR		;GET A CHAR
	JRST CMUPP3
	CAIE TTT,15		;IGNORE CR
	CAIN TTT,40		;AND SPACE
	JRST CMUPP1
	CAIN TTT,12		;LF
	JRST CMUPP3		;YES, THAT'S ALL FOLKS.
	CAIE TTT,"["		;IGNORE [
	CAIN TTT,"]"		;AND ]
	JRST CMUPP1
	CAIL TTT,"a"		;CONVERT LOWER CASE TO UPPER CASE
	CAILE TTT,"z"
	JRST .+2
	SUBI TTT,40		;CONVERT IT
CMUPP2:	IDPB TTT,A
	SOJGE T,CMUPP1		;AND GO GET ANOTHER CHAR UNLES WE HAVE 13+1
	JRST ERRET	;FUNNY, WE DIDN'T GET THERE IN 13 CHARACTERS!
CMUPP3:	MOVE T,[XWD A,PPNBUF]
	CMUDEC T,		;CONVERT THE PPN TO DEC FORMAT
	JRST ERRET		;WHOOPS, BAD PPN
>;CMU
	MOVEM A,ZPPN
	POPJ P,

CLZPPN:	SETZM ZPPN
	POPJ P,


PSTATE:	OUTSTR[ASCIZ/Spaces are/]
	TRNN PETIT
	OUTSTR[ASCIZ/n't/]
	OUTSTR[ASCIZ/ significant.
Reference hack is/]
	TRNN REFLAG
	OUTSTR[ASCIZ/n't/]
	OUTSTR[ASCIZ/ enabled.
/]
	OUTSTR[ASCIZ/Default wire list = /]
	MOVE T,DEFLST
	FETCH(A,T,WLID)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/ (/]
	SKIPE USEDWL
	OUTCHR["D"]
	SKIPN USEDWL
	OUTSTR[ASCIZ/PC/]
	OUTCHR[")"]
	FETCH(A,L,WLNM)
	JUMPE A,NOWLNM
	OUTCHR[" "]
	PUSHJ P,STRTTY
NOWLNM:	OUTSTR[ASCIZ/
/]
	OUTSTR[ASCIZ/Lines per page = /]
	MOVE T,PAGLEN
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	OUTSTR[ASCIZ/Characters per line = /]
	MOVE T,LWIDTH
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	SKIPN ISWW
	JRST NXWW1
	SKIPN WIRGND
	OUTSTR[ASCIZ/Not /]
	OUTSTR[ASCIZ/Wiring grounds.
/]
NXWW1:	SKIPN ZPPN
	JRST NOZPPN
	OUTSTR[ASCIZ/Default input P,PN = /]
NOCMU,<	HLLZ TT,ZPPN
	PUSHJ P,LSIXOUT
	OUTCHR[","]
	HRLZ TT,ZPPN
	PUSHJ P,LSIXOUT
>;NOCMU
CMU,<	MOVE TT,[ZPPN,,PPNBUF]
	DECCMU TT,
	JRST [	PUTSIX ZPPN
		JRST .+2]
	OUTSTR PPNBUF
>;CMU
	OUTSTR[ASCIZ/
/]
NOZPPN:	MOVE T,DEFECL
	TRNE T,ECL
	OUTSTR[ASCIZ/Dip-mode, default ECL pins.
/]
	TRNE T,TTL
	OUTSTR[ASCIZ/Dip-mode, default TTL pins.
/]
	SKIPN DIPLST
	JRST DSKICK
	OUTSTR[ASCIZ/Dips are in/]
	SKIPE RESIDENT
	OUTSTR[ASCIZ/ and permanently core resident/]
	OUTSTR[ASCIZ/.
/]
DSKICK:	SKIPN DSKFLG
	JRST CKBRDT
	OUTSTR[ASCIZ/DSKIN:	/]
	MOVEI A,DSKNAM
	PUSHJ P,FILPNT
	SKIPN DSKACT
	JRST [	OUTSTR[ASCIZ/holding
/]
		JRST CKBRDT]
	OUTSTR[ASCIZ/Active
/]
CKBRDT:	SKIPGE T,BRDTYP
	JRST	CKFRAC
	OUTSTR[ASCIZ/Board type: /]
	OUTSTR @BNAMES(T)
	OUTSTR[ASCIZ/
/]
CKFRAC:
	OUTSTR [asciz \Fraction resolution of wire lengths is 1/\]
	MOVE	T,FRACTN
	PUSHJ	P,DECOUT
	OUTSTR [asciz \
\]
	POPJ	P,

DSKIN:	PUSHJ P,DSKINB
	JFCL
	POPJ P,

DSKINB:	MOVSI T,'TXT'
	MOVEM T,DEFEXT
	PUSHJ P,SETFIL		;GET A FILE NAME
	POPJ P,			;QUIT
DSKINA:	INIT IDSK,0
	'DSK   '
	IDSKHD
	JRST [	OUTSTR[ASCIZ/Can't get disk!
/]
		SETZM DSKFLG
		SETZM DSKACT
		POPJ P,]
	MOVEI T,IDSKBF
	EXCH T,.JBFF
	INBUF IDSK,1
	MOVEM T,.JBFF
	MOVE T,FILPPN
	LOOKUP IDSK,FILNAM
	JRST [	MOVE T,[OUTCHR TTT]
		MOVEM T,PUTCHR
		OUTSTR[ASCIZ/ LOOKUP failed, code = /]
		HRRZ T,FILEXT
		PUSHJ P,DECOUT
		OUTSTR[ASCIZ/
/]
		SETZM DSKFLG
		SETZM DSKACT
		RELEASE IDSK,
		POPJ P,]
	MOVEM T,DSKPP
	MOVE T,FILNAM
	MOVEM T,DSKNAM
	HLLZ T,FILEXT
	MOVEM T,DSKEXT
	SETZM DSKCNT		;NO CHARS READ YET!
	SETOM DSKFLG		;NOW READING INDIRECT FILE
	SETOM DSKACT		;ACTIVATE IT
	SETZM CBITS
	OUTSTR[ASCIZ/
/]
	JRST CPOPJ1

DSKHLD:	SKIPE DSKFLG
	JRST DSKHL1
	OUTSTR[ASCIZ/No file open yet.
/]
	PUSHJ P,DSKINB
	POPJ P,			;LOSE
DSKHL1:	SKIPN DSKACT
	JRST [	OUTSTR[ASCIZ/Already holding!
/]
		POPJ P,]
	SETZM DSKACT
	RELEASE IDSK,		;JUST FOR FUN, RELEASE IT
	POPJ P,

DSKCON:	SKIPN DSKFLG
	JRST ERRET
	SKIPE DSKACT
	POPJ P,
	PUSHJ P,DSKCN0
	POPJ P,
	POPJ P,

DSKCN0:	MOVE T,DSKNAM
	MOVEM T,FILNAM
	MOVE T,DSKEXT
	MOVEM T,FILEXT
	MOVE T,DSKPP
	MOVEM T,FILPPN
	SETZM FILDAT
	PUSH P,DSKCNT
	PUSHJ P,DSKINA
	JRST [	POP P,(P)
		POPJ P,]
	POP P,A
	SETZM DSKACT		;DEACTIVATE SO WON'T ECHO
DSKCN1:	CAMG A,DSKCNT		;THERE YET?
	JRST DSKCN2		;YES
	PUSHJ P,DSKINC		;NO, READ SOME MORE
	POPJ P,			;RAN OUT??????
	JRST DSKCN1

DSKCN2:	SKIPN DSKFLG		;STILL IN FILE?
	POPJ P,
	SETOM DSKACT		;YES, ACTIVATE INPUT AGAIN
	JRST CPOPJ1

DSKSKP:	SKIPE DSKFLG
	JRST DSKSK0
	OUTSTR[ASCIZ/No file open yet.
/]
	PUSHJ P,DSKINB
	POPJ P,
	PUSH P,[0]
	JRST DSKSK1

DSKSK0:	PUSH P,DSKACT
	SKIPE DSKACT
	JRST DSKSK1
	PUSHJ P,DSKCN0
	POPJ P,
DSKSK1:	SETOM DSKACT
	PUSHJ P,DSKINC
	JRST DSKSK2
	CAIE TTT,12
	JRST DSKSK1
	SETZM DSKACT		;NOW GET FROM TTY
	ASK[ASCIZ/STOP?/]
	JRST DSKSK2
	JRST DSKSK1
	POP P,DSKACT
	POPJ P,

DSKSK2:	POP P,(P)
	SETZM DSKACT
	POPJ P,

IERR:	SKIPN DSKACT		;DOING DISK INPUT?
	JRST [	CLRBFI		;NO
		POPJ P,]
	OUTSTR[ASCIZ/
Manual intervention required, DSKHLD done.
/]
	SETZM DSKACT
	RELEASE IDSK,
	POPJ P,
SUBTTL	MAKLST
;READ A FILENAME AND GO INDIRECT IF NECESSARY!

MAKLST:	SETZM VARLST		;CLEAR THESE
	SETZM SLICEL
	SKIPN T,ZPPN
	DSKPPN T,
	MOVEM T,ATPPN		;SET DEFAULT PPN
	TLZ TFLG		;FLAG NO VAR LIST YET
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,GETWRD
	JRST TTYEOF
	CAIN TTT,"@"
	JUMPE A,INDIR
	PUSHJ P,TERMA
	JRST TTYEOF		;EOF?????
	POPJ P,
	MOVE T,FILNAM
	MOVEM T,LSTNAM		;REMEMBER NAME FOR ^E
	POPJ P,

TTYEOF:	OUTSTR[ASCIZ/Unexpected EOF from TTY.
/]
	JRST NERRET

NONAME:	OUTSTR[ASCIZ/No filespec after @.
/]
	JRST NERRET

INDIR:	MOVE T,DEFEXT
	HLLM T,(P)		;SAVE OLD EXT
	MOVSI T,'DIR'
	MOVEM T,DEFEXT		;SET DEFAULT FOR @FILE
	PUSHJ P,GTERM		;READ INDIRECT FILESPEC
	JRST TTYEOF		;EOF??????
	JRST NONAME		;@ WITH NO NAME??
	HLLZ T,(P)
	MOVEM T,DEFEXT		;RESET DEFAULT EXT
	HRRZ T,DIRLST
	MOVEM T,IDRLST
	MOVEI T,DIRLST
	HRLZM T,DIRLST
	PUSHJ P,IN0		;SETUP FOR TEXT INPUT
	POPJ P,			;GIVE UP
	MOVE T,[PUSHJ P,INDCHR]
	MOVEM T,GETCHR
	MOVE E,IDRLST
	FETCH(E,E,CVAR)		;GET VAR POINTER
INDIRA:	MOVE A,IDRLST
	FETCH(T,A,DFIL)
	MOVEM T,FILNAM
	FETCH(T,A,DEXT)
	HRLZM T,FILEXT
	FETCH(T,A,DPPN)
	MOVEM T,FILPPN
	SKIPN T,ZPPN
	MOVE T,FILPPN
	MOVEM T,ATPPN		;USE AS DEFAULT PPN ALSO
	SETZM VARLST		;ASSUME NO VARS
	JUMPE E,NOCLVR		;ANY CARD OR VAR LIST?
	TLO TFLG		;FLAG VARS AND OR BOUNDS AND OR CARD LOC
	FETCH(T,E,CDLC)		;CARD LOC
	HRLZM T,SLICEL		;SETUP INFO TO COPY
	FETCH(T,E,LBND)		;LOWER BOUND
	MOVEM T,LOWER
	FETCH(T,E,UBND)		;UPPER BOUND
	MOVEM T,UPPER
	FETCH(T,E,VLST)		;VARIABLE LIST
	MOVEM T,VARLST
NOCLVR:	OUTCHR ["@"]
	PUSH P,A
	MOVEI A,FILNAM
	PUSHJ P,FILPNT
	POP P,A
	LOOKUP DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/ LOOKUP failed, code = /]
		HRRZ T,FILEXT+1
		PUSHJ P,DECOUT
		OUTSTR[ASCIZ/
/]
		JUMPE E,CPOPJ
		ASK[ASCIZ/Type Y to go on?/]
		POPJ P,
		POPJ P,
		JRST INDIRB]
	MOVE T,FILNAM
	MOVEM T,LSTNAM		;REMEMBER @NAME FOR OUTPUT
	SKIPN SLICEL
	JRST NDISLC
	OUTCHR[11]
	PUSHJ P,PSLICL
NDISLC:	SKIPN VARLST
	JRST INDIRC
	SKIPN SLICEL
	OUTCHR[11]
	OUTCHR["("]
	MOVE T,LOWER
	CAMN T,[-400000]
	JRST NPLWR
	PUSHJ P,DECOUT
	OUTCHR[74]
NPLWR:	MOVE T,UPPER
	CAIN T,377777
	JRST NPUPR
	PUSHJ P,DECOUT
	OUTCHR[76]
NPUPR:	SKIPN A,VARLST
	JRST VARDNI
	CAIA
VARLPI:	OUTCHR[","]
	FETCH(T,A,LET)
	OUTCHR T
	OUTCHR["="]
	FETCH(T,A,VAL)
	FETCH(TT,A,WID)
	MOVEM TT,NDIG
	PUSHJ P,NDECOUT
	FETCH(A,A,NVAR)
	JUMPN A,VARLPI
VARDNI:	OUTCHR[")"]
INDIRC:	PUSH P,VARLST
	PUSH P,SLICEL
	PUSHJ P,GTERM
	JRST [	POP P,SLICEL
		POP P,VARLST
		JRST INDIRB]
	JFCL			;IGNORE NULL
	POP P,SLICEL
	POP P,VARLST		;RESTORE INDIRECT VARLST
	JRST INDIRC

INDIRB:	OUTSTR[ASCIZ/
/]
	JUMPE E,CPOPJ
	FETCH(E,E,NSLC)
	JUMPN E,INDIRA
	POPJ P,

DIRRET:	HRRZ B,DIRLST
	MOVSI T,DIRLST
	MOVEM T,DIRLST		;POINT DIRLST TO ITSELF
RETIT:	MOVE A,B
	FETCH(B,B,DIRNXT)	;GET NEXT POINTER NOW
	FETCH(C,A,CVAR)		;GET CARD AND VAR HEADER
	FSTRET(A,DIRHEAD)	;RETURN HEAD
	JUMPE C,RETIT1		;LEAVE IF NO VARLIST
RETIT2:	FETCH(D,C,VLST)		;VAR LIST POINTER
	JUMPE D,RETIT3
RETIT4:	MOVE A,D
	FETCH(D,D,NVAR)
	FSTRET(A,VBLK)
	JUMPN D,RETIT4
RETIT3:	MOVE A,C
	FETCH(C,C,NSLC)
	FSTRET(A,CBND)
	JUMPN C,RETIT2
RETIT1:	JUMPN B,RETIT
	POPJ P,

IDRRET:	SETZM IDRLST
	JRST RETIT
SUBTTL	GTERM
;READ ONE TERM FOR MAKLST

GTERM:	PUSHJ P,GETWRD		;READ WORD
	JRST [	JUMPN A,MIDEOF	;ERROR IF NOT NULL WORD
		POPJ P,]	;EOF
TERMA:	PUSHJ P,FTERM0
	JRST MIDEOF		;TOO LATE FOR EOF, ERROR
	JRST [	SKIPN FILNAM	;NO LF, NULL NAME ILLEGAL
		JRST NOFNAM
		JRST TERM1]
	SKIPN FILNAM	;NO LF SEEN
	JRST CPOPJ1	;NULL NAME RETURN
TERM1:	GETFS(T,DIRHEAD)
	HLRZ TT,DIRLST
	STORE(T,TT,DIRNXT)
	HRLM T,DIRLST
	CLEAR(T,DIRNXT)
	MOVE TT,FILNAM
	STORE(TT,T,DFIL)	;STORE FILENAME
	HLRZ TT,FILEXT
	STORE(TT,T,DEXT)	;STORE EXT
	MOVE TT,FILPPN
	STORE(TT,T,DPPN)	;STORE PPN
	CLEAR(T,CVAR)		;CLEAR CVAR POINTER
	MOVEI B,RADDR(T,CVAR,NSLC)	;THIS WILL LOOK LIKE AN NSLC POINTER
	JRST TERM4

TERM3:	XCT GETCHR
	JRST MIDEOF		;ILLEGAL EOF
TERM4:	CAIE TTT,40
	CAIN TTT,11
	JRST TERM3
	CAIN TTT,12
	JRST TERME
	GETFS(T,CBND)		;EITHER NEED BLOCK OR ERROR
	STORE(T,B,NSLC)		;STORE AS HIS NEXT SLICE BLOCK
	MOVE B,T
	BCLEAR(T,B,CBND)	;CLEAR OUT BLOCK
	PUSHJ P,GTSLTT		;TRY TO READ SLOT
	JRST ILLSLT		;APPEARED TO BE THERE, BUT WRONG FORMAT
	HLRZ A,SLICEL
	STORE(A,B,CDLC)		;STORE CARD LOC
	CAIE TTT,"("
	JRST [	JUMPE A,ILLSLT
		JRST TERM4]
;HERE WE ARE READING A VARIABLE LIST
	MOVNI T,400000
	STORE(T,B,LBND)
	MOVEI T,377777
	STORE(T,B,UBND)
	PUSHJ P,VCOPY		;COPY ANY VARS FROM HIGHER UP
	MOVEI C,RADDR(B,VLST,NVAR);MAKE IT LOOK LIKE AN NVAR POINTER
GOTULB:	PUSHJ P,SDECIN
	JRST MIDEOF
	CAIE TTT,74
	JRST CKUPR
	HRLM A,1(C)
	PUSHJ P,SDECIN
	JRST MIDEOF
CKUPR:	CAIE TTT,76
	JRST [	JUMPN A,ILLBND
		JRST GOTLET]
	HRRM A,1(C)
	HLRE T,1(C)
	CAMLE T,A
	JRST ILLBND
RVARS1:	XCT GETCHR
	JRST MIDEOF
GOTLET:	PUSHJ P,LETCHK
	JRST ILLVAR
	MOVEM TTT,LETTER
	SETZM NDIG
	PUSHJ P,SDECIN
	JRST MIDEOF
	CAIN TTT,"="
	JUMPE A,[SETZM NDIG
		PUSHJ P,SDECIN
		JRST MIDEOF
		JRST .+1]
	MOVEM A,WIDTH
	MOVEI C,RADDR(B,VLST,NVAR)
	MOVE T,LETTER
	JRST CKVAR1

CKVAR2:	FETCH(TT,C,LET)
	CAMN T,TT
	JRST [	FETCH(D,D,NVAR)
		JRST CKVAR3]
CKVAR1:	MOVE D,C
	FETCH(C,C,NVAR)
	JUMPN C,CKVAR2
	GETFS(C,VBLK)
	CLEAR(C,NVAR)
	STORE(C,D,NVAR)
CKVAR3:	MOVE T,LETTER
	STORE(T,C,LET)
	MOVE T,WIDTH
	STORE(T,C,VAL)
	MOVE T,NDIG
	STORE(T,C,WID)
	CAIN TTT,","
	JRST RVARS1		;MORE VARS
	CAIE TTT,")"
	JRST ILLVAR
	JRST TERM3

MIDEOF:	OUTSTR[ASCIZ/EOF in middle of term.
/]
	JRST NERRET

NOFNAM:	OUTSTR[ASCIZ/No filename seen in filespec.
/]
	JRST NERRET

ILLSLT:	OUTSTR[ASCIZ/Illegal board location.
/]
	JRST NERRET

ILLBND:	OUTSTR[ASCIZ/Error in bounds args.
/]
	JRST NERRET

ILLVAR:	OUTSTR[ASCIZ/Error in variable specification.
/]
	JRST NERRET

TERME:	HLRZ B,DIRLST
	FETCH(T,B,CVAR)		;CARD VAR LIST
	JUMPN T,TERMF1
	SKIPN SLICEL		;ANY CRDLOC
	SKIPE VARLST		;OR VARS?
	CAIA			;YES, COPY THEM
	JRST CPOPJ2		;NO, THAT'S ALL
	GETFS(T,CBND)
	STORE(T,B,CVAR)
	MOVE B,T
	CLEAR(B,NSLC)
	CLEAR(B,VLST)
	HLRZ T,SLICEL
	STORE(T,B,CDLC)
	PUSHJ P,VCOPY
	JRST CPOPJ2

;SET SLICE FROM I FILE
TERMF1:	FETCH(B,B,CVAR)		;DO EACH
TERMG:	FETCH(T,B,CDLC)
	JUMPN T,TERMF		;ALREADY GOT ONE?
	MOVE T,SLICEL
	STORE(T,B,CDLC)		;STORE ONE FROM I FILE
TERMF:	FETCH(B,B,NSLC)
	JUMPN B,TERMG
	JRST CPOPJ2

VCOPY:	TLNN TFLG		;ANYTHING FROM INDIRECT TERM?
	POPJ P,			;NO, RETURN IMMEDIATELY
	MOVE T,UPPER
	STORE(T,B,UBND)
	MOVE T,LOWER
	STORE(T,B,LBND)
	SKIPN D,VARLST		;ANY VARS?
	POPJ P,			;NO, THATS ALL
	MOVEI C,RADDR(B,VLST,NVAR)
VCOPY1:	GETFS(T,VBLK)
	STORE(T,C,NVAR)
	MOVE C,T
	FETCH(T,D,VAL)
	STORE(T,C,VAL)
	FETCH(T,D,LET)
	STORE(T,C,LET)
	FETCH(T,D,WID)
	STORE(T,C,WID)
	FETCH(D,D,NVAR)
	JUMPN D,VCOPY1
	CLEAR(C,NVAR)		;CLEAR LAST LINK
	POPJ P,

FVCOPY:	HRRZ T,PINLOC
	STORE(T,B,MCRD)
	MOVE T,UPPER
	STORE(T,B,MUBN)
	MOVE T,LOWER
	STORE(T,B,MLBN)
	SKIPN D,VARLST
	POPJ P,
	MOVEI C,RADDR(B,MVLS,NVAR)
	JRST VCOPY1
SUBTTL	FILENAME SCANNER
FTERM0:	MOVE T,ATPPN
	JRST FTERM1

FTERM:	PUSHJ P,GETWRD
	POPJ P,
	SETZ T,
NODECOS,<	DSKPPN T,>
FTERM1:	MOVEM T,FILPPN
	MOVE T,DEFEXT
	MOVEM T,FILEXT
	SETZM FILDAT
NOITS,<
	JUMPN A,NEXIST
	CAIE TTT,TEXIST
	JRST NEXIST
	PUSHJ P,CHRCHK
	POPJ P,
	CAIA			;DELIMITER AS EXPECTED
	JRST CPOPJ1
	SKIPN A,LSTNAM
	JRST CPOPJ1
NEXIST:	MOVEM A,FILNAM
	CAIE TTT,"."
	JRST FTERM2
	PUSHJ P,GETWRD
	POPJ P,
	HLLZM A,FILEXT
FTERM2:	CAIE TTT,"["
	JRST FTERM3
NOCMU,<
	PUSHJ P,RDPPN
	POPJ P,
	HRLM A,FILPPN
	CAIE TTT,","
	JRST NOPRG
	PUSHJ P,RDPPN
	POPJ P,
	HRRM A,FILPPN
NOPRG:	CAIN TTT,12
	JRST CPOPJ2
>;NOCMU
CMU,<	SETZM PPNBUF		;CLEAR OUT A BUFFER FOR THE PPN
	SETZM PPNBUF+1
	SETZM PPNBUF+2
	MOVE A,[POINT 7,PPNBUF]
	MOVEI T,=13		;13 CHARACTERS AT MOST!
CMUPP4:	XCT GETCHR		;GET A CHAR
	POPJ P,
	CAIL TTT,"0"		;0-9 ARE LEGAL IN PPN'S
	CAILE TTT,"9"
	CAIN TTT,","		;SO IS COMMA
	JRST CMUPP5		;SO GO STORE IT
	PUSHJ P,LETCHK
	JRST CMUPP6		;NO, MUST BE THE END
CMUPP5:	IDPB TTT,A
	SOJG T,CMUPP4		;AND GO GET ANOTHER CHAR UNLES WE HAVE 13
	XCT GETCHR		;IN WHICH CASE WE GET THE "]" (WE HOPE!)
	POPJ P,
CMUPP6:	MOVE T,[XWD FILPPN,PPNBUF]
	CMUDEC T,		;CONVERT THE PPN TO DEC FORMAT
	POPJ P,			;WHOOPS, BAD PPN
>;CMU
	CAIE TTT,"]"
	POPJ P,
	XCT GETCHR
	POPJ P,
FTERM3:	CAIN TTT,12
	AOS (P)
	JRST CPOPJ1
>;NOITS
ITS,<
	CAIE TTT,";"
	JRST FTERM2
	MOVEM A,FILPPN
	PUSHJ P,FILWRD
	POPJ P,
FTERM2:	JUMPN A,NEXIST
	CAIE TTT,TEXIST
	JRST NEXIST
	PUSHJ P,CHRCHK
	POPJ P,			;EOF
	CAIA			;DELIMITER
	JRST CPOPJ1		;ERROR
	SKIPN A,LSTNAM
	JRST CPOPJ1
NEXIST:	MOVEM A,FILNAM
	CAIE TTT,40
	CAIN TTT,11
	JRST [	PUSHJ P,FILWRD
		POPJ P,
		JUMPE A,.+1
		MOVEM A,FILEXT
		JRST .+1]
FTERM3:	CAIN TTT,12
	JRST CPOPJ2
	CAIN TTT,ALTMOD
	JRST [	MOVEI TTT,40
		JRST CPOPJ1]
	PUSHJ P,FILWRD
	JRST FTERM3
>;ITS


;STANDARD FILENAME SETUP (SINGLE FILENAME)
SETFIL:	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUTSIX DEFEXT
	OUTSTR[ASCIZ/ Filename?/]
	PUSHJ P,CFILE
	POPJ P,
	AOS (P)
	PUSH P,A
	MOVEI A,FILNAM
	PUSHJ P,FILPNT
	POP P,A
	POPJ P,

CFILE:	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,FTERM
	JRST ERRET
	JRST ERRET
	SKIPE FILNAM
	AOS (P)
	POPJ P,
SUBTTL	WIRINI, WIRGET, LSTGET, NTITLE, BRS1W, TREAD, TREADU
WIRINI:	GETFS(L,LSTHEAD)
	BCLEAR(T,L,LSTHEAD)
	MOVEM L,WLLIST
	MOVEM L,DEFLST
	MOVEI TT,[ASCIZ/NIL/]
	PUSHJ P,ASCCOP
	STORE(T,L,WLID)		;NULL ID
	PUSHJ P,USED		;USE D WIRELIST
DEC,<	TRO PETIT!REFLAG	>
CMU,<	TRO PETIT!REFLAG	>;MAKE SPACES SIGNIFICANT AND DO REFERANCING FOR EACH OF NUMEROUS SIGNAL NAMES
	POPJ P,

WIRFOR:	MOVE L,DEFLST
	FETCH(L,L,INXT)
	SKIPN L
	MOVE L,WLLIST
WIRBK2:	MOVEM L,DEFLST
	FETCH(A,L,WLID)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/
/]
	POPJ P,

WIRBAK:	MOVE W,DEFLST
	CAMN W,WLLIST		;IF THIS IS FRONT,
	SETZ W,			;THEN SEARCH FOR END
	MOVE L,WLLIST
WIRBK1:	FETCH(T,L,INXT)
	CAMN T,W
	JRST WIRBK2
	FETCH(L,L,INXT)
	JUMPN L,WIRBK1
	JRST CPOPJ1		;LOSE!

WIRGET:	PUSHJ P,FNDID
	POPJ P,
	JRST WIRGT1
	MOVEM L,DEFLST
	JRST PUTFS

WIRGT1:	GETFS(L,LSTHEAD)
	BCLEAR(T,L,LSTHEAD)
	MOVE T,STRING
	STORE(T,L,WLID)
	MOVE W,DEFLST
	FETCH(T,W,INXT)
	STORE(T,L,INXT)
	STORE(L,W,INXT)
	MOVEM L,DEFLST
	OUTSTR[ASCIZ/New wirelist.
/]
	POPJ P,

NOID:	OUTSTR[ASCIZ/No such wirelist ID.
/]
	MOVE B,STRING
	JRST PUTFS

FNDID:	PUSHJ P,TREADU
	POPJ P,
	POPJ P,
	MOVEM B,STRING
	MOVE L,WLLIST
FNDID1:	FETCH(T,L,WLID)
	MOVE TT,STRING
	PUSHJ P,TXTMAT
	JRST FNDID2
	JRST FNDID2
	JRST CPOPJ2

FNDID2:	FETCH(L,L,INXT)
	JUMPN L,FNDID1
	JRST CPOPJ1

WIRID:	MOVE L,DEFLST
	OUTSTR[ASCIZ/Current wirelist ID is /]
	FETCH(A,L,WLID)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/
Wirelist ID? /]
	PUSHJ P,TREADU
	POPJ P,
	POPJ P,
	FETCH(T,L,WLID)
	STORE(B,L,WLID)
	MOVE B,T
	JRST PUTFS

WIRPNT:	OUTSTR[ASCIZ/
/]
	MOVE L,DEFLST
WIRPT1:	FETCH(A,L,WLID)
	PUSHJ P,STRTTY
	FETCH(A,L,WLNM)
	JUMPE A,WIRPT2
	OUTCHR[11]
	PUSHJ P,STRTTY
WIRPT2:	OUTSTR[ASCIZ/
/]
	FETCH(W,L,BLST)
	JUMPE W,WIRPT3
	FETCH(W,W,WBDY)
	JUMPE W,WIRPT3
	OUTSTR[ASCIZ/	BP	/]
	SETZ T,
WIRBP1:	ADDI T,1
	FETCH(W,W,NXTB)
	JUMPN W,WIRBP1
	PUSHJ P,WIRPT9
WIRPT3:	ADDI T,1
	FETCH(W,L,WIRL)
	JUMPE W,WIRPT4
	OUTSTR[ASCIZ/	D	/]
	SETZ T,
WIRD1:	ADDI T,1
	FETCH(W,W,NXTWL)
	JUMPN W,WIRD1
	PUSHJ P,WIRPT9
WIRPT4:	FETCH(W,L,PCWL)
	JUMPE W,WIRPT5
	OUTSTR[ASCIZ/	PC	/]
	SETZ T,
WIRPC1:	ADDI T,1
	FETCH(W,W,NXTWL)
	JUMPN W,WIRPC1
	PUSHJ P,WIRPT9
WIRPT5:	FETCH(L,L,INXT)
	SKIPN L
	MOVE L,WLLIST
	CAME L,DEFLST
	JRST WIRPT1
	POPJ P,

WIRPT9:	PUSH P,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ Board/]
	POP P,T
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/
/]
	POPJ P,

NTITLE:	MOVE L,DEFLST
	FETCH(A,L,WLNM)
	JUMPE A,NTITL1
	OUTSTR[ASCIZ/Current title is /]
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/
/]
NTITL1:	OUTSTR[ASCIZ/Wire list title?/]
	PUSHJ P,TREAD
	POPJ P,
	SETZ B,				;STORE 0 FOR BLANK LINE
	FETCH(T,L,WLNM)			;GET WIRE LIST NAME POINTER
	STORE(B,L,WLNM)
	JUMPE T,CPOPJ
	MOVE B,T
	JRST PUTFS

LSTGET:	FETCH(W,L,WIRL)
	SKIPN USEDWL
	FETCH(W,L,PCWL)
LSTGT0:	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	JUMPE W,NXCARD
	FETCH(T,W,NXTWL)
	JUMPE T,[FETCH(T,W,FCRD)
		HRLZM T,SLICEL		;SAVE FOR FURTHER REFERENCES
		HRLZM T,ALLCRD
		JUMPE T,BLANKL		;DON'T PRINT BLANK
		OUTCHR[11]
		PUSHJ P,BRS1W
	BLANKL:	OUTSTR[ASCIZ/
/]
		JRST CPOPJ1]		;IF ONLY ONE, JUST RETURN IT!
	OUTSTR[ASCIZ/Card list (/]
	OUTSTR @SLTCUE			;PRINT CUE MESSAGE HERE
	OUTSTR[ASCIZ/)?/]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,GETSLT
	JRST LSTERR
	CAIE TTT,12
	JRST LSTERR
GETLOP:	FETCH(T,W,FCRD)			;GET CARD SPEC
	HRLZ T,T
	CAMN T,SLICEL
	JRST [	MOVEM T,ALLCRD
		JRST CPOPJ1]
	FETCH(W,W,NXTWL)
	JUMPN W,GETLOP
NXCARD:	OUTSTR[ASCIZ/No such card!
/]
	POPJ P,

BRS1W:	PUSH P,A
	FETCH(A,W,FCRD)
	PUSH P,TTT
	PUSH P,PUTCHR
	MOVE TTT,[OUTCHR TTT]
	MOVEM TTT,PUTCHR
	PUSHJ P,SLTOUT
	POP P,PUTCHR
	POP P,TTT
	POP P,A
	POPJ P,

LSTERR:	SETZ W,				;RETURN NULL POINTER
	CAIN TTT,ALTMOD
	POPJ P,
	OUTSTR[ASCIZ/Input error!
/]
	CAIE TTT,12
	PUSHJ P,TREAD			;GOBBLE REST OF LINE
	POPJ P,
	POPJ P,
	JRST PUTFS

TREADU:	SETOM LOW2UP
	CAIA
TREAD:	SETZM LOW2UP
	GETFS (B)
	HRRZ T,B
	ADD T,[POINT 7,1]
	SETZM -1(T)
	SETZM (T)
TREAD2:	PUSHJ P,TTYIN
	JFCL
	CAIN TTT,ALTMOD		;LET HIM OUT ON ALTMODE AND
	JRST [	OUTSTR[ASCIZ/
/]
		JRST PUTFS]		;RETURN STRING
	CAIN TTT,12		;ON LF
	JRST [	AOS (P)
		SKIPE 1(B)
		JRST CPOPJ1
		JRST PUTFS]
	TLNE T,760000		;END OF WORD?
	JRST TREAD1		;NO
	GETFS (TT)
	HRRM TT,-1(T)
	HRR T,TT
	SETZM (T)
	SETZM 1(T)
TREAD1:	SKIPN LOW2UP
	JRST TREAD3
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	CAIA
	SUBI TTT,40			;CONVERT LC TO UC
TREAD3:	IDPB TTT,T
	JRST TREAD2
 