COMMENT    VALID 00031 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	<DRAW>IN.FAI112, 29-JUL-75 11:19:42, EDIT BY HELLIWELL
C00009 00003	READ CARD, FIX SET, FIX ID'S, FINISH UP
C00015 00004	READ VERSION NUMBER, LIBRARY SUBRS
C00024 00005	LIBRARY SUBRS
C00028 00006	HERE IS WHERE WE READ A NEW LIBRARY IN!
C00036 00007	READ TYPES
C00047 00008	CHECK IF TYPE EXISTS, REPLACE MAYBE
C00051 00009	CALL TYPE READING SUBR, READ INSTANCES OF TYPES
C00056 00010	PLACE INSTANCES OF TYPES
C00061 00011	READ POINT, FIND POINT, D PROG
C00064 00012	MORE READ POINT, LINES, D PROG
C00067 00013	READ POINT, FIND, MAKE LINES, PC PROG
C00071 00014	READ REST OF POINT INFO
C00075 00015	READ SETS
C00077 00016	SET IN, PUT IN STRUCTURE, OR FLUSH -- READ SPECIAL STRINGS -- CARD SUBR
C00084 00017	'ROU'		READ WAGNER'S ROUTER FILES
C00091 00018	'WDR'	'LES'	READ LOGIC WIRE LIST AND MAKE INTERNAL POINTERS
C00098 00019	'DAT'		PARTITION FILE
C00108 00020	WORDIN, CHKLOC
C00110 00021	GSTR, RSTR, FIND.P
C00112 00022	'UML'		READ REDAC PIN ASSIGMENTS
C00115 00023			FIND PIN OR BODY AND SET NEW LOC
C00117 00024			SUBRS FOR READING UML FILE
C00120 00025			READ LOCATION FROM STRING
C00121 00026	INPUT SIGNAL NAME CHANGE FILE
C00124 00027	CHANGE FILE INPUT SUBRS
C00126 00028	INPUT SIGNAL NAME CHANGE FILE
C00129 00029	IMPLEMENT ONE CHANGE LINE
C00131 00030	RDVER TABLES!
C00139 00031	
C00140 ENDMK
C;
;<DRAW>IN.FAI;112, 29-JUL-75 11:19:42, EDIT BY HELLIWELL
VERSION(IN,15)
;INIT DISK, SET FLAGS, CHECK FOR VIRGIN, ETC.
MD,<
DREADR:	TLO M,TYPNLY!TYPREP	;TYPES ONLY AND ALWAYS REPLACE (SILENTLY)!
	JRST DREAD1
>;MD
DREADT:	TLOA M,TYPNLY		;TYPES ONLY
DREAD:	TLZ M,TYPNLY
	TLZ M,TYPREP		;DON'T REPLACE AUTOMATICALLY!
DREAD1:	MOVEM P,PERRSAV		;FOR ERROR RETURNS
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM
	POPJ P,			;LET HIM OUT THIS WAY
	SETZM WIRDAT		;MAKE SURE WE READ FILE
WIRENT:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	RELEASE DAT,
		OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF		;USE COMPILED IN BUFFER
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
	MOVE T,FILPPN
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
	LDB T,[POINT 11,FILDAT,23]
	HRL T,FILDAT
	LDB TT,[POINT 3,FILEXT,20]
	DPB TT,[POINT 6,T,5]
	CAMGE T,WIRDAT
	JRST [	OUTSTR[ASCIZ/, OLDER THAN WIRE LIST FILE.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
;PATCH TO FIX OLD TEXT OFFSETS WHICH ARE WRONG
	SKIPN LSTNAM		;SKIP ALL THIS IF ALREADY HAVE DEFAULT NAME
	TLNE M,TYPNLY		;IF TYPES ONLY, DON'T UPDATE NAMES
	JRST XNAME
	MOVE T,FILNAM
	MOVEM T,LSTNAM		;REMEMBER LAST NAME
MD,<	MOVEM T,DRWNAM	>	;REMEMBER FOR PLOTS ALSO
	MOVE D,FILPPN
	MOVEM D,LSTPPN
MD,<	MOVEM D,DRWPPN
	LDB T,[POINT 11,FILDAT,23]
	HRL T,FILDAT
	LDB TT,[POINT 3,FILEXT,20]
	DPB TT,[POINT 6,T,5]
	MOVEM T,DRWDAT		;REMEMBER DATE LAST WRITTEN OF DRW FILE
>;MD
	PUSHJ P,FILEUP		;AND UPDATE DISPLAY
XNAME:	SETZM NEWBOD		;LIST OF NEW BODY POINTERS.
	SETZM HASHP
MPC,<	SETZM MXPADN		;CLEAR MAXIMUM PAD # SEEN	>
	MOVE A,[HASHP,,HASHP+1]	;CLEAR OUT HASH TABLES
	BLT A,HASHB+LHASHB
	MOVE A,[HASHP(TT)]
	MOVEM A,PHASHP
MPC,<	MOVE A,[HASHP2(TT)]
	MOVEM A,PHASH2
>;MPC
	MOVE T,BID
	MOVEM T,OLDBID
	MOVEM T,MAXBID
	MOVE T,PID
	MOVEM T,OLDPID
	MOVEM T,MAXPID
	TRO VIRGIN		;ASSUME VIRGIN
MPC,<	SKIPN PONPN2	>;MPC
	SKIPE PONPNT
	TRZ VIRGIN		;NOT VIRGIN
	SKIPE DBODPN
	TRZ VIRGIN
	TRO MAKSET
MD,<
	TLNN M,TYPNLY		;NOW, IF TYPNLY OR
>;MD
	TRNE VIRGIN		;A VIRGIN
	JRST [	TRZ MAKSET	;NO SET GETS MADE
		JRST NOVSET]
	SETZM LSTNAM		;FORGET NAME IF NOT VIRGIN!
MD,<	DATE T,			;SET DATE AND TIME TO CURRENT
	HRLZM T,DRWDAT
	MSTIME T,
	IDIVI T,=1000*=60	;TO MINUTES
	HRRM T,DRWDAT
	SETZB T,DRWNAM
NODEC,<	DSKPPN T,	>
DEC,<	GETPPN T,	>
	MOVEM T,DRWPPN		;INIT PPN
>;MD
LAY,<	SETZM SAVNAM	>
	PUSHJ P,FILEUP		;AND UPDATE THAT
	TRNN MAKSET		;SHALL WE MAKE A SET?
	JRST NOVSET		;NO, NO SET
	SETZM DX1
	SETZM DY1
	SETZM DX3
	SETZM DY3
NOVSET:	PUSH P,CURSE
	PUSH P,MODE
MPC,<
	PUSH P,SID
	TLNE SID,FRONT		;LET'S START ON FRONT
	JRST ISFRNT
	FSWITCH
ISFRNT:
>;MPC
	PUSHJ P,RDFILE		;READ FILE!
	SKIPE B,NEWBOD		;RETURN FREE STORAGE FROM NEWBOD LIST(IF ANY)
	PUSHJ P,PUTFS
	SETZM NEWBOD
MPC,<
	POP P,T
	EQV T,SID
	JUMPL T,ISRITE		;ARE WE ON RIGHT SIDE?
	FSWITCH
ISRITE:
>;MPC
;READ CARD, FIX SET, FIX ID'S, FINISH UP
	TRO MCHG!NEEDCL
	TRZ INLIN!INMOV!STBOX	;MAKE SURE THESE ARE OFF
	POP P,MODE
	POP P,CURSE		;PUT CURSOR BACK WHERE IT WAS
	TRNE MAKSET		;DID WE TRY TO MAKE A SET?
	SKIPN DY3		;YES, IS THERE ONE?
	JRST NOVST1
	GETFS(T)
	HRL TT,DY3
	HRR TT,SETPNT
	MOVEM TT,(T)
	HRRZM T,SETPNT
	MOVE TT,DX1
	IDIV TT,DX3
MPC,<	ASH TT,-1
	IDIV TT,STPSIZ
	IMUL TT,STPSIZ
	ASH TT,1
>;MPC
MD,<	TRZ TT,1	>
	HRLM TT,1(T)
	MOVE TT,DY1
	IDIV TT,DX3
MPC,<	ASH TT,-1
	IDIV TT,STPSIZ
	IMUL TT,STPSIZ
	ASH TT,1
>;MPC
MD,<	TRZ TT,1	>
	HRRM TT,1(T)
	PUSH P,T
	MOVEI T,SETM
	PUSHJ P,CHNGMD		;GO TO SET MOVING MODE
	POP P,T
	PUSHJ P,SCLOSP	;FIND LAST POINTER, SET CLOSES, MOVE TO CENTER
	PUSHJ P,DOSMOV
	OUTSTR[ASCIZ/YOUR NEW FILE IS NOW A SET
AND YOU ARE MOVING IT!
/]
NOVST1:
MD,<	SKIPE B,UTLIST
	PUSHJ P,RELUTL		;RELEASE TYPE USE LIST
>;MD
	SKIPN RDVER		;**RDVER
	JRST ERCHK		;DO END CHECK
	MOVSI T,-LHASHP
NOVST3:	SKIPN A,HASHP(T)
	JRST NOVST2
	HLRZ B,A
	HLLI A,
	EXCH A,PONPNT
	HRRM A,(B)
NOVST2:	AOBJN T,NOVST3
MPC,<	MOVSI T,-LHASHP
NOVST5:	SKIPN A,HASHP2(T)
	JRST NOVST4
	HLRZ B,A
	HLLI A,
	EXCH A,PONPN2
	HRRM A,(B)
NOVST4:	AOBJN T,NOVST5
>;MPC
	TRNN VIRGIN		;IS THIS A VIRGIN
	JRST NDOVIR		;NO, FIX NEWEST PIN ID'S
	MOVE T,MAXBID		;YES, SET MAX AS LAST ASSIGNED
	MOVEM T,BID
	MOVE T,MAXPID
	MOVEM T,PID
	JRST ERCHK

NDOVIR:	MOVE T,OLDBID
	MOVEM T,BID
	MOVE T,OLDPID
	MOVEM T,PID
	PUSHJ P,REEID		;REASSIGN ID'S
ERCHK:
MPC,<	PUSHJ P,CARDIO		;CHECK AND MAYBE READ CARD
	SKIPE CRDNAM		;DID WE GET A CARD?
	TLO M,CRDISP		;YES, DISPLAY IT!
	PUSHJ P,MXPADP		;PRINT MAX PAD # IF BIG ENOUGH
>;MPC
	RELEASE DAT,		;DONE WITH INPUT FILE
STANFO,<
MD,<	SETZ T,
	GETPPN T,
	HLLI T,
	CAIE T,'DWP'		;IS IT POOLE?
	CAIN T,'H'		;IS IT HOLLOWAY?
	PUSHJ P,C16		;DO A SHOW BOX FOR HIM
>;MD
>;STANFO
DEC,<	MOVE T,RDVER	;**RDVER
	TLNN M,TYPNLY		;SKIP IF ONLY READ TYPES
	CAIL T,14
	JRST OFFOK
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/YOU SHOULD PROBABLY DO AN OFFALL!
/]
OFFOK:
>;DEC
	TRNN VIRGIN
	 POPJ P,
	TLNE NOINIT		;SUPPRESS CALL OF INIT MACRO?
	 popj p,		;YES, then done!
	TRO TFLG		;FLAG TO CALL ONLY IF JUST READ IN
	PUSHJ P,MACCAL		;NOTE WE ONLY INIT A VIRGIN
	ASCIZ/INIT/		;SETUP INIT MACRO FOR EXECUTION
	POPJ P,

MD,<
RELUTL:	HLRZ A,(B)
	PUSHJ P,PUTFS
	SKIPE B,A
	JRST RELUTL
	SETZM UTLIST
	POPJ P,
>;MD

REEID:	SKIPE A,PONPNT
	PUSHJ P,REEPNT
MPC,<	SKIPE A,PONPN2
	PUSHJ P,REEPNT
>;
	SKIPN A,DBODPN
	POPJ P,
REEBOD:	HLRZ T,(A)
	HLRZ T,1(T)
	HLRZ TT,(T)
	CAMG TT,OLDBID		;WAS THIS A NEW ONE?
	JRST NOREEB
	AOS TT,BID		;YES, ASSIGN NEW ID
	HRLM TT,(T)
NOREEB:	HRRZ A,(A)
	JUMPN A,REEBOD
	POPJ P,

REEPNT:	HLRZ T,(A)
	HRRZ TT,1(T)
	MOVE TT,1(TT)
	TLNE TT,ISPIN		;PINS USE BODY, DON'T DO THEM HERE
	JRST NOREEP
	HRRZ TT,(T)		;GET POINT ID
	CAMG TT,OLDPID		;NEW POINT?
	JRST NOREEP
	AOS TT,PID		;YES, GET NEW ID
	HRRM TT,(T)
NOREEP:	HRRZ A,(A)
	JUMPN A,REEPNT
	POPJ P,

MPC,<
MXPADQ:	MOVE T,MXPADN
	JRST MXPADR

MXPADP:	MOVE T,MXPADN
	CAIG T,STDMAX		;BIGGER THAN STANDARD MAX?
	POPJ P,			;NO
MXPADR:	OUTSTR[ASCIZ/MAXIMUM PAD TYPE IS /]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,
>;MPC
;READ VERSION NUMBER, LIBRARY SUBRS
GETVER:	PUSHJ P,REDVER		;READ IO VERSION #
	CAIN TTT,IOVER		;SAME AS CURRENT
	POPJ P,
	OUTSTR[ASCIZ/READING OLD IO VERSION # /]
	MOVE T,TTT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,

REDVER:	PUSHJ P,WORDIN		;GET FIRST WORD OF FILE
	TLNN TTT,-1
	JUMPN TTT,[CAIG TTT,IOVER	;DO WE KNOW ABOUT IT?
		JRST NEWVER
		OUTSTR[ASCIZ/I DON'T KNOW ABOUT THIS IO VERSION #!
/]
		CAIL TTT,IOVER+10	;REASONABLE TO TRY OUR HIGHEST?
		JRST .+1		;NO
		MOVEI TTT,IOVER
		JRST NEWVER]
	AOS IOHD+2
	SOS IOHD+1		;OLD BACKUP TO THIS WORD
	SETZ TTT,		;AND USE IOVER=0
NEWVER:	MOVEM TTT,RDVER
MDPC,<	CAIGE TTT,BRDIOV >	;WHAT SHOULD BRDIOV BE FOR THE PC PROGRAM
	POPJ P,
	PUSHJ P,RDBRD
	MOVE TTT,RDVER
	POPJ P,

TYPIN:	PUSHJ P,GETVER
MD,<	PUSHJ P,DOLBTY		;READ LIBRARY AND LOCAL TYPES
	TRNN FSTLIB		;FIRST LIBRARY?
	TDZA C,C		;NO, DON'T TURN ON MACRO BITS
>;MD				;ALWAYS SAVE IN PC
	MOVSI C,MSAVE		;YES, PUT SAVE BIT ON SO IT WILL GO BACK OUT
	TLO C,MACTMP		;MARK AS JUST READ IN
	MOVE T,RDVER		;**RDVER
	CAILE T,13		;THESE DON'T HAVE MACROES IN THEM
	JRST MACIN		;GET THEM
	POPJ P,

MD,<
DOLBTY:	MOVE T,RDVER		;**RDVER
	CAIGE T,3
	JRST RDTYP		;VERSIONS 3 AND HIGHER HAVE LIBRARIES
	CAIGE T,13		;DO WE HAVE LIST OF LIB TYPE USED?
	JRST FRCLIB		;NO, FORCE MERGING IF ALREADY USED
	TRNE FSTLIB		;ARE WE AT TOP LEVEL?
	JRST RDLTYP		;YES, READ NAMES OF USED TYPES FROM LIB'S
	PUSHJ P,SKPSTR		;NO, JUST SKIP THEM
	JRST GETLIB
	JRST .-2

RDLTYP:	SKIPE B,UTLIST
	PUSHJ P,RELUTL
	SETOM USEFLG		;FLAG USE LIST ACTIVE
RDLTY1:	PUSHJ P,RSTRZ
	JRST GETLIB
	EXCH T,UTLIST
	HRLM T,@UTLIST
	SKIPN C,BODPNT
	JRST RDLTY1
RDLTY2:	HRRZ A,(C)		;BODY NAME
	MOVE B,UTLIST		;NAME WE JUST READ
	PUSHJ P,TXTMAT
	JRST RDLTY3
	HLRZ A,(C)		;LIBRARY POINTER
	JUMPE A,RDLTY1		;ANY?
	HLRZ A,(A)		;SECOND WORD OF LIBRARY NAME BLOCK
	MOVEI T,NEEDMR
	IORM T,(A)		;TURN ON BIT SAYING WE NEED TO READ THIS LIBRARY AGAIN
	JRST RDLTY1

RDLTY3:	HRRZ C,1(C)
	JUMPN C,RDLTY2
	JRST RDLTY1

FRCLIB:	SKIPN C,LIBLST
	JRST GETLIB
FRCLB1:	HLRZ A,(C)
	MOVEI T,NEEDMR
	IORM T,(A)		;FORCE MERGING OF ANY LIBRARIES USED IN THIS DWG
	HRRZ C,(C)
	JUMPN C,FRCLB1
GETLIB:	PUSHJ P,WORDIN
	JUMPE TTT,RDTYP
	GETFS (T)
	MOVEM TTT,1(T)
	MOVE B,TTT
	GETFS (TT)
	HRLZM TT,(T)
	PUSHJ P,WORDIN
	TRZ TTT,DTMP1!TOPLVL
	TRNE FSTLIB
	TRO TTT,TOPLVL
	MOVEM TTT,(TT)
	HLLZ C,TTT
	PUSHJ P,WORDIN
	MOVEM TTT,1(TT)
	MOVE D,TTT
	EXCH T,LIBTMP		;LINK ON FRONT OF LIST
	HRRM T,@LIBTMP
	PUSHJ P,MAPLIB		;LOOK FOR MAP ENTRY
	JRST GETLIB		;READ ANOTHER NAME
	MOVE TT,LIBTMP		;THIS IS THE ENTRY WE JUST MADE
	HLRZ A,(A)
	HRRZ A,(A)
	MOVE TTT,1(A)		;GET NEW NAME
	MOVEM TTT,1(TT)
	HLRZ TT,(TT)
	HLRZ A,(A)
	HLLZ TTT,(A)		;EXT
	HLLM TTT,(TT)
	MOVE TTT,1(A)		;PPN
	MOVEM TTT,1(TT)
	JRST GETLIB

RDTYP:	PUSHJ P,RDTYPX
	JRST GOTYPS
	PUSHJ P,RDTYPY
	JRST RDTYP

GOTYPS:	SKIPN E,LIBTMP
	POPJ P,			;NO LIBRARIES TO DO OR WILL BE DONE HIGHER UP
	SETZM LIBTMP		;MAKE SURE NO ONE DOWN UNDER SEES THESE
	PUSH P,FILNAM
	PUSH P,FILEXT
	PUSH P,FILPPN
LIBIT:	PUSH P,(E)
	MOVE B,1(E)
	MOVEM B,FILNAM
	HLRZ TT,(E)
	HLLZ C,(TT)
	MOVEM C,FILEXT
	MOVE D,1(TT)
	MOVEM D,FILPPN
LIBIT1:	PUSHJ P,LNAMCK		;DO WE ALREADY HAVE THIS LIBRARY?
	JRST LGOTIT		;YES
	MOVEM E,LIBNAM		;POINTER TO LIBRARY DESCRIPTOR
	PUSH P,ALLFLG		;SAVE STATE OF FLAG SAYING WE ARE JUST GETTING THE REST OF SOME DEF'S
LIBIT3:	PUSH P,0		;SAVE CURRENT STATE OF FSTLIB
	TRZ FSTLIB		;NO LONGER FIRST
	AOS DEPTH
	PUSHJ P,LIBRED
	JRST LIBFAI
	SOS DEPTH
	POP P,T			;GET OLD STATE OF FSTLIB
	TRNE T,FSTLIB
	TRO FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES
	POP P,ALLFLG
LIBIT2:	POP P,E
	HRRZ E,E
	JUMPN E,LIBIT
	TRNE FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES?
	SETZM LIBNAM		;YES, BODIES HERE DON'T GET LIBRARY POINTER
	POP P,FILPPN
	POP P,FILEXT
	POP P,FILNAM
	LOOKUP DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/FILE I WAS READING WENT AWAY!
/]
		PUSHJ P,FUCKUP
		MOVE P,PERRSAV
		POPJ P,]	;LOSE BIG
	MOVE T,3(P)		;GET BACK PPN
	MOVEM T,FILPPN
	PUSHJ P,REDVER		;AVOID TYPEOUT
	MOVE T,RDVER		;**RDVER
	CAIGE T,13
	JRST SKPTY1
	PUSHJ P,SKPSTR		;SKIP LIB TYPE NAMES AT FRONT
	JRST SKPTY1
	JRST .-2

LIBIT4:	MOVE E,LIBNAM
	HLRZ TT,(E)
	FSTRET(E)
	FSTRET(TT)
	JRST LIBIT2

SKPTY1:	PUSHJ P,WORDIN		;SKIP LIBRARY FILENAMES
	JUMPE TTT,SKPTY2
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST SKPTY1

SKPTY2:	PUSHJ P,SKPSTR		;SKIP BODY NAME
	POPJ P,			;END OF BODY DEFS
	MOVE T,RDVER
	CAIGE T,10		;**RDVER
	JRST SKPTY3		;NO DIP TYPE NAMES!
	CAIGE T,23		;NOT HERE FOR .GE.23
	PUSHJ P,SKPSTR		;SKIP DIP TYPE NAME
	JFCL
	CAIL T,13		;**RDVER DO WE HAVE BITS,,UNUSED?
	PUSHJ P,WORDIN		;YES, SKIP IT
	CAIGE T,12		;**RDVER DO WE HAVE DEF OFFSET
	JRST SKPTY3		;NO
	PUSHJ P,WORDIN		;YES, GET IT
	CAILE T,23		;**RDVER
	PUSHJ P,WORDIN		;SKIP CHAR OFFSET IF THERE
SKPTY3:	PUSHJ P,WORDIN
	CAIN TTT,400000
	JRST SKPTY4
	PUSHJ P,WORDIN
	CAIL T,17
	PUSHJ P,WORDIN		;SKIP NEW WORD
	JRST SKPTY3

SKPTY4:	PUSHJ P,WORDIN
	CAIE TTT,400000
	JRST SKPTY4
	MOVE C,RDVER
	CAIL C,23
	JRST SKPTY6		;**RDVER
SKPTY5:	PUSHJ P,WORDIN
	CAIN TTT,400000
	JRST SKPTY2
	CAIGE C,2		;**RDVER
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	CAILE C,3		;**RDVER
	PUSHJ P,WORDIN
	PUSHJ P,SKPSTR
	JFCL
	JRST SKPTY5

SKPTY6:	PUSHJ P,SKPPRP
	JRST SKPTY2

SKPPRP:	PUSHJ P,SKPSTR
	POPJ P,
	PUSHJ P,SKPSTR
	JFCL
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST SKPPRP
;LIBRARY SUBRS
SETMAP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/OLD LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	POPJ P,
	ENTPPN
	MOVE B,FILNAM
	HLLZ C,FILEXT
	MOVE D,FILPPN
	PUSHJ P,MAPLIB		;TRY TO FIND IT
	CAIA
	JRST GOTMAP
	GETFS(A)
	GETFS(T)
	HRL T,MAPLST
	MOVSM T,(A)
	MOVEM A,MAPLST
	MOVEM B,1(A)
	HLLZM C,(T)
	MOVEM D,1(T)
GOTMAP:	HRLM A,(P)
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	JRST MAPKIL
	ENTPPN
	HLRZ A,(P)
	HLRZ T,(A)
	HRRZ TT,(T)
	JUMPE TT,NOMAPD
	HLRZ TTT,(TT)
	FSTRET(TTT)
	FSTRET(TT)
NOMAPD:	GETFS(TT)
	HRRM TT,(T)
	GETFS(TTT)
	HRLZM TTT,(TT)
	MOVE T,FILNAM
	MOVEM T,1(TT)
	HLLZ T,FILEXT
	MOVEM T,(TTT)
	MOVE T,FILPPN
	MOVEM T,1(TTT)
	POPJ P,

MAPKIL:	HLRZ A,(P)
	MOVEI T,MAPLST
	JRST MAPKL1

MAPKL2:	CAIN T,(A)
	JRST MAPKL3
MAPKL1:	MOVE TT,T
	HRRZ T,(T)
	JUMPN T,MAPKL2
	PUSHJ P,FUCKUP
	POPJ P,

MAPKL3:	HRRZ T,(A)
	HRRM T,(TT)
MAPKL0:	HLRZ T,(A)
	HRRZ TT,(T)
	FSTRET(T)
	FSTRET(A)
	JUMPE TT,CPOPJ
	HLRZ TTT,(TT)
	FSTRET(TT)
	FSTRET(TTT)
	POPJ P,

CLRMAP:	SKIPN B,MAPLST
	POPJ P,
CLRMP1:	MOVE A,B
	HRRZ B,(B)
	PUSHJ P,MAPKL0
	JUMPN B,CLRMP1
	SETZM MAPLST
	POPJ P,

MAPLIB:	SKIPN A,MAPLST
	POPJ P,
MAPLB1:	CAME B,1(A)
	JRST MAPLB2
	HLRZ T,(A)
	CAME D,1(T)
	JRST MAPLB2
	HLLZ TT,(T)
	CAMN TT,C
	JRST CPOPJ1
MAPLB2:	HRRZ A,(A)
	JUMPN A,MAPLB1
	POPJ P,

LNAMCK:	SKIPN A,LIBLST
	JRST CPOPJ1
NXTLB1:	CAME B,1(A)
	JRST NXTLIB
	HLRZ T,(A)
	HLLZ TT,(T)
	CAMN C,TT
	CAME D,1(T)
	JRST NXTLIB
	POPJ P,

NXTLIB:	HRRZ A,(A)
	JUMPN A,NXTLB1
	JRST CPOPJ1

LIBUSE:	OUTSTR[ASCIZ/LIBRARY NAME CONFLICT, CHOOSE ANOTHER!
/]
	POPJ P,

LIBFAI:	SOS DEPTH
	POP P,T			;GET OLD STATE OF FSTLIB
	TRNE T,FSTLIB
	TRO FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES
	POP P,ALLFLG
	OUTSTR[ASCIZ/LIKE TO TRY ANOTHER LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	JRST LIBIT4		;HE GAVE UP
	MOVE E,LIBNAM		;UPDATE SAVED NAME
	HLRZ TT,(E)
	MOVE B,FILNAM
	MOVEM B,1(E)
	HLLZ C,FILEXT
	HLLM C,(TT)
	MOVE D,FILPPN
	MOVEM D,1(TT)
	JRST LIBIT1

LGOTIT:	HLRZ TT,(E)
	FSTRET(E)
	FSTRET(TT)
	HRRZ TT,(T)		;GET FLAG BITS FROM FOUND LIBRARY
;	TRZN TT,NEEDMR		;NEED MERGE?
	TRZA TT,NEEDMR		;****** TEMPORARY BUG FIX, ALWAYS RE-READ LIBRARY
	JRST LIBIT2		;NO, SKIP IT
	HRRM TT,(T)		;MAKE SURE WE ONLY MERGE ONCE
	MOVEM A,LIBNAM		;YES, STORE LIBRARY POINTER THAT'S ALREADY IN
	PUSH P,ALLFLG		;YES, SAVE ALLFLG
	SETOM ALLFLG		;AND SET IT
	JRST LIBIT3
;HERE IS WHERE WE READ A NEW LIBRARY IN!
DOLIB:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	POPJ P,			;LET HIM OUT THIS WAY
	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
DEC,<
	SKIPN D,FILPPN		;0 WILL CONFUSE US
	PUSHJ P,[LOOKUP DAT,FILNAM
		JRST NOLUCK
		MOVE A,[3,,B]
		MOVEI B,DAT
		PATH A,		;PATH UUO TO GET REAL PPN
	NOLUCK:	DSKPPN D,	;PATH UUO FAILED, GET OUR PPN
		SETZM FILNAM+2
		CLOSE DAT,
		MOVEM D,FILPPN
		POPJ P,]
>;DEC
NODEC,<	MOVE D,FILPPN	>
	MOVE B,FILNAM
	HLLZ C,FILEXT
	CAMN B,LSTNAM
	CAME C,[EXTFIL,,0]
	JRST NAMOK
	CAME D,LSTPPN
NAMOK:	PUSHJ P,LNAMCK
	JRST LIBUSE
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	GETFS(A)
	MOVEM A,LIBNAM		;CURRENT LIBRARY NAME
	MOVE T,FILNAM
	MOVEM T,1(A)
	GETFS(T)
	HRLZM T,(A)
	HLLZ TT,FILEXT
	HRRI TT,TOPLVL		;SET AS TOP LEVEL LIBRARY
	MOVEM TT,(T)
	MOVE TT,FILPPN
	MOVEM TT,1(T)
	TLO M,TYPREP!TYPNLY	;REPLACE AUTOMATICALLY AND TYPES ONLY
	TRZ FSTLIB		;NOT FIRST LIBRARIES ANY MORE
	SETOM USEFLG		;ENABLE NON-READIN STUFF
	SETZM ALLFLG		;READING LIBRARY AFRESH
	SETZM LIBTMP		;CLEAR THIS FOR LIBRARY READING
	SKIPE B,UTLIST
	PUSHJ P,RELUTL		;RELEASE ALL USE NAMES (WILL BE CAUGHT AT RDTYPY)
	PUSHJ P,CLBMRK		;CLEAR NEEDMR IN LIBLST
	SETZM DEPTH
	AOS DEPTH
	PUSHJ P,LIBRED
	CAIA
	JRST DOLIB1
	MOVE A,LIBNAM
	HLRZ T,(A)
	FSTRET(A)
	FSTRET(T)
DOLIB1:	RELEASE DAT,
	POPJ P,

LIBRED:	MOVE T,DEPTH
	OUTSTR[ASCIZ/  /]
	SOJG T,.-1
	OUTSTR[ASCIZ/LIBRARY /]
	MOVEI A,FILNAM
	JSR FPRINT		;PRINT LIBRARY NAME
	MOVE T,FILPPN
	LOOKUP DAT,FILNAM	;GET LIBRARY FILE
	JRST LOOKER
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
	OUTSTR[ASCIZ/
/]
	AOS (P)			;SUCCESSFUL LOOKUP
	SKIPE ALLFLG		;IF JUST RE-READING
	JRST TYPIN		;ALREADY GIVEN BACK
	MOVE T,LIBNAM
DEC,<	HLRZ TT,(T)
	MOVE TTT,FILPPN
	MOVEM TTT,1(TT)		;STORE REAL PPN
>;DEC
	EXCH T,LIBLST
	HRRM T,@LIBLST
	JRST TYPIN

;GET A BODY FROM LIBRARY
;POINTER TO HEADER BLOCK OF BODY IN A, PREVIOUS IN LEFT HALF
BDYGET:	HLRZ T,(A)		;LIBRARY BLOCK POINTER
	JUMPE T,[OUTSTR[ASCIZ/NON-LIBRARY BODY NOT FULLY READ IN!
/]
		JRST FUCKUP]
	MOVE TTT,1(T)
	MOVEM TTT,FILNAM
	HLRZ T,(T)
	MOVE TTT,(T)
	HLLZM TTT,FILEXT
	MOVE TTT,1(T)
	MOVEM TTT,FILPPN
	HRRZ T,1(A)
	HLRZ TT,A
	HRRM T,1(TT)		;TEMPORARILY LINK THIS ONE OUT
	HRRZ T,(A)
	MOVEM T,LIBTMP		;STORE BODY NAME HERE
	PUSHJ P,PUSHIT		;MAKE THE WORLD SAFE FOR HIGHER UPS
	PUSHJ P,DORBDY
	JRST GTBDYE
	PUSHJ P,POPIT
	MOVE C,A
	MOVE A,BODPNT		;NEW BODY IS HERE (I HOPE).
	HLRZ T,(C)		;LIBRARY POINTER
	HRLM T,(A)		;STORE INTO BODY JUST READ
	HRRZ B,(C)		;NOW GIVE BACK HEADER BLOCK, AND BOTH NAMES
	HLRZ B,(B)
	SKIPE B
	PUSHJ P,PUTFS		;RETURN DIP TYPE NAME
	MOVE B,C
	PUSHJ P,PUTFS		;RETURN BODY NAME
	JRST CPOPJ1		;GIVE SUCCESS RETURN

GTBDYE:	PUSHJ P,POPIT
	HLRZ TT,A
	HRRM A,1(TT)		;LINK BACK IN
	OUTSTR[ASCIZ/SORRY,/]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ NO LONGER IN LIBRARY!
/]
	POPJ P,

RDBODY:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ALLEDM!1EDTAM]		;CANNOT BE IN EDIT MODE!!!
	JRST PERRET
	TRZ INMOV
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE BODY NAME
/]
	PUSHJ P,TREADU
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	MOVEM B,LIBTMP		;SAVE HERE TEMPORARILY
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM		;READ FROM DRAW FILE
	JRST RDLEAV		;LET HIM OUT
	PUSHJ P,DORBDY
	JRST RDLEV1
	JRST RDLEV2

RDLEV1:	OUTSTR[ASCIZ/SORRY,/]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ NOT FOUND!
/]
RDLEV2:	RELEASE DAT,
RDLEAV:	MOVE B,LIBTMP
	JRST PUTFS

DORBDY:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	OUTSTR[ASCIZ/SEARCHING FOR /]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ IN /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	SETZM USEFLG		;MAKE SURE IT IS READ IN
	SETZM ALLFLG
	SETZM LIBNAM		;CLEAR LIBRARY NAME
	TLZ M,TYPREP		;DON'T REPLACE AUTOMATICALLY
	TRZ FSTLIB
	TRO BRDINH		;DON'T CHANGE THE BOARD TYPE
	MOVEM P,PERRSAV		;RETURN UP FROM HERE
	PUSHJ P,GETVER
	TRZ BRDINH
	MOVE T,RDVER
	CAIGE T,3		;**RDVER
	JRST RDTYPZ		;VERSIONS 3 AND ABOVE HAVE LIBRARIES
	CAIGE T,13		;**RDVER
	JRST RDTYPC		;NO LIST OF LIB TYPES TO SKIP
	PUSHJ P,SKPSTR
	JRST RDTYPC
	JRST .-2

RDTYPC:	PUSHJ P,WORDIN
	JUMPE TTT,RDTYPZ	;SKIP OVER LIBRARY NAMES
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST RDTYPC

RDTYPZ:	PUSHJ P,RDTYPX
	POPJ P,
	MOVE A,LIBTMP
	MOVE B,STRING
	PUSHJ P,TXTMAT		;COMPARE NAME HE TYPED WITH BODY NAME
	JRST [	PUSHJ P,RELTYP	;NO, RELEASE TYPE
		JRST RDTYPZ]	;TRY ANOTHER
	PUSHJ P,RDTYPY		;TRY TO GET TYPE INTO STRUCTURE
	TRO MCHG!NEEDCL	;FOUND, COULD BE REPLACING OLD VERSION, SO UPDATE SCREEN
	JRST CPOPJ1

CLBMRK:	SKIPN T,LIBLST
	POPJ P,
	MOVEI TT,NEEDMR
CLBMR1:	HLRZ TTT,(T)
	ANDCAM TT,(TTT)
	HRRZ T,(T)
	JUMPN T,CLBMR1
	POPJ P,
;READ TYPES
RDTYPX:	PUSHJ P,RSTRZ		;READ TYPE NAME
	POPJ P,			;DONE WITH TYPES!
	MOVEM T,STRING		;SAVE NAME HERE
	SETZM DEFOFF		;CLEAR DIP TYPE POINTER, DEF OFFSET
	SETZM ODIPTYP
	SETZM DEFBTS		;AND BITS,,UNUSED
	MOVE TT,RDVER		;**RDVER
	CAIGE TT,10		;DOES THIS FILE HAVE DIP TYPE?
	JRST NODTYP
	CAIL TT,23
	JRST ISTYPN		;**RDVER
	PUSHJ P,RSTRZ		;READ DIP TYPE
	SETZ T,			;NULL
	MOVEM T,ODIPTYP
ISTYPN:	SETZ TTT,		;CLEAR DEF OFFSET
	MOVE TT,RDVER
	CAIGE TT,12		;**RDVER
	JRST NODTYP
	CAIGE TT,13		;**RDVER
	JRST NODBTS
	PUSHJ P,WORDIN		;READ BITS,,UNUSED
	TLZ TTT,FOUNDL!DTMP1	;CLEAR MARK BITS ON INPUT
	MOVEM TTT,DEFBTS
NODBTS:	PUSHJ P,WORDIN		;READ DEFAULT OFFSET
	MOVEM TTT,DEFOFF
	MOVEI TTT,400000
	MOVE T,RDVER
	CAILE T,23		;**RDVER
	PUSHJ P,WORDIN
	MOVEM TTT,DEFOF1
NODTYP:	SETZM PINS		;INITIALIZE PIN LIST.
	MOVEI T,PINS		;DUMP IN HERE FIRST
RDPIN2:	PUSHJ P,WORDIN		;GET A PIN LOC
RDPINS:	CAIN TTT,400000		;END OF PINS?
	JRST RPINDN		;YES
	MOVE A,RDVER
	CAIG A,10		;**RDVER
	JRST [	ADD TTT,[PXOFF,,PYOFF]
		AND TTT,[PXMASK,,PYMASK]
		JRST .+1]
	GETFS(TT)		;GET PIN X,Y BLOCK
	HRRM TT,(T)		;LINK IT IN
	MOVE T,TT
	GETFS(TT)		;GET PIN ID, PIN NAME, ETC. BLOCK
	HRLZM TT,(T)		;LINK IN
	CAIL A,17
	JRST NWPND1		;**RDVER THIS IS SIMPLE
	PUSH P,TTT
	PXY(TTT)
	MOVEM TTT,1(T)
DEC,<	LDB TTT,[POINT 2,(P),5]
	CAIN TTT,1
	TLO TTT,ASSH
	CAIN TTT,2
	TLO TTT,ASSL
	HLLM TTT,(TT)
>;DEC
	POP P,TTT
	NXY(TTT)
	LSH TTT,=17
	TRZE TTT,400000
	PUSHJ P,NIPCOP
	HLLZM TTT,1(TT)
	PUSHJ P,WORDIN
	HRRM TTT,(TT)
	TRZE TTT,700000
	TRZ TTT,77000		;MAKE (.GE.64) NOT BUSSED THROUGH
	PUSH P,TTT
	ANDI TTT,777
	HRRM TTT,1(TT)
	HRRZ TTT,(P)
	TRNN TTT,777000
	TDZA TTT,TTT
	MOVSI TTT,BUSSED
	IORM TTT,(TT)
	POP P,TTT
	MOVE TT,RDVER
DEC,<	TLNE TTT,1		;MARKER BIT ON?
	CAIG TT,10		;**RDVER
	CAIA
	HLLM TTT,PINS		;FLAG DIP OFFSET IS FIRST PIN
>;DEC
	CAILE TT,2		;**RDVER
	JRST RDPIN2
RDPIN1:	PUSHJ P,WORDIN
	HLRZ TT,TTT
	CAIE TT,400000
	JRST RDPINS
	JRST RDPIN1

NIPCOP:	MOVS TTT,TTT		;GET IN RH FOR INDEX
	TRZ TTT,777770		;AVOID CONFUSING GARBAGE
	MOVE A,NXYTAB(TTT)	;GET OFFSET FOR NIPPLE BIT
	MOVS TTT,TTT
	DPB A,[POINT YOFFW,TTT,YOFFB]
	HLRZ A,A
	DPB A,[POINT XOFFW,TTT,XOFFB]
	POPJ P,

DEC,<NIPOFF__1>
NODEC,<NIPOFF__2>

NXYTAB:	0,,NIPOFF
	0,,NIPOFF
	-NIPOFF,,0
	-NIPOFF,,0
	0,,-NIPOFF
	0,,-NIPOFF
	NIPOFF,,0
	NIPOFF,,0

NWPND1:	MOVEM TTT,1(T)
	PUSHJ P,WORDIN
	TLZ TTT,FOUNDD		;CLEAR MARK BIT
	MOVEM TTT,(TT)
	PUSHJ P,WORDIN
	CAIGE A,20		;NEW PIN POS?
	TLZN TTT,400000		;NO, CLEAR NIPPLE BIT
	CAIA
	PUSHJ P,NIPCOP
	MOVEM TTT,1(TT)
	JRST RDPIN2

RPINDN:	SETZM LINES		;INITIALIZE LINES
	MOVEI T,LINES		;DUMP HERE FIRST
RDLINS:	PUSHJ P,WORDIN		;GET A POINT
	CAIN TTT,400000		;DONE?
	JRST RLINDN		;YES
	GETFS(TT)		;GET A BLOCK FOR HIM
	MOVEM TTT,1(TT)		;STORE LOC
	SETZM (TT)		;CLEAR LINK WORD
	MOVEM TT,(T)		;LINK ON END OF LIST
	MOVE T,TT		;NEW END
	JRST RDLINS		;GET SOME MORE
RLINDN:	SETZM BTEXT		;INITIALIZE BODY TEXT LIST
	MOVE C,RDVER		;GET IOVERSION #
	CAIL C,23		;**RDVER
	JRST RBTXTN
	MOVEI T,BTEXT		;DUMP FIRST POINTER HERE
RBTEXT:	PUSHJ P,WORDIN		;GET LOC OF TEXT
	CAIN TTT,400000		;DONE?
	JRST BTXTDN		;YES
	GETFS(TT)		;GET A BLOCK FOR IT
	SETZM (TT)		;CLEAR LINK
	TLZ TTT,1		;CLEAR MARK BIT
	TRO TTT,1		;SET AUTO OFFSET BIT FOR OLD FORMAT
	MOVEM TTT,1(TT)		;SAVE LOC
	HRRM TT,(T)		;LINK ONTO LIST
	MOVEM T,LOSEPT		;SAVE OLD END IN CASE THIS STRING LOSES
	GETFS(T)		;ANOTHER BLOCK
	HRLM T,(TT)		;LINK TO LEFT POINTER
	CAIGE C,2		;**RDVER
	PUSHJ P,WORDIN		;SKIP REL VECT FROM OLD VERSIONS
	PUSHJ P,WORDIN		;GET LINES, CHARS, AND SIZE
	CAIGE C,4		;**RDVER
	TRZN TTT,10		;OLD VERSIONS INDICATE VERT HERE
	CAIA
	TRO TTT,400000		;MARK VERT FOR OLD VERSIONS
	HRRZ A,TTT
	HRRZ B,A
	ANDI B,377777
	CAILE B,CSIZES		;LEGAL CHAR SIZE?
	JRST [	OUTSTR[ASCIZ/ILLEGAL CHARACTER SIZE READ FOR BODY TEXT.
WILL USE STANDARD TEXT SIZE INSTEAD.
/]
		TRZ A,377777
		TRO A,STDBIG
		JRST .+1]
	CAILE C,3		;**RDVER
	JRST GETCON
	LDB B,[POINT 9,TTT,8]	;GET # OF CHARS
	LDB D,[POINT 9,TTT,17]	;GET # OF LINES-1
	SUBI D,1
	ANDI TTT,377777
	LSH TTT,2		;MAKE IT SCREEN OFFSET
	IMUL B,TTT
	LSH TTT,1		;TIMES 2
	IMUL TTT,D
	MOVNS B
	HRL TTT,B
	TRNN A,400000		;WAS IT VERT?
	JRST GOTCON
	PUSH P,F
	EXCH T,TTT
	MOVEI F,1
	PUSHJ P,ORIENT
	POP P,F
	EXCH T,TTT
	JRST GOTCON
GETCON:	PUSHJ P,WORDIN		;READ CONSTANT OFFSET
GOTCON:	MOVEM TTT,1(T)		;STORE REL VECT
	HRLM A,(P)
	PUSHJ P,RSTRZ		;READ TEXT
	JRST [	HLRZ TTT,(TT)
		FSTRET(TT)
		FSTRET(TTT)
		MOVE T,LOSEPT
		HLLZS (T)
		JRST RBTEXT]
	HLRZ A,(P)
	HRLM A,(T)		;SAVE SIZE IN FIRST WORD OF STRING
	HLRZ TTT,(TT)		;GET BACK POINTER TO REL VEC WORD
	HRRZM T,(TTT)		;LINK IN STRING
	MOVE T,TT		;GET END OF LIST INTO T
	JRST RBTEXT		;ANOTHER ONE

RBTXTN:	PUSHJ P,PROPIN
	JRST BTXTDN

PROPIN:	PUSHJ P,RSTRZ
	POPJ P,
	GETFS(TT)
	HRRZM T,(TT)
	GETFS(TTT)
	HRLZM TT,(TTT)
	EXCH TTT,BTEXT
	HRRM TTT,@BTEXT
	PUSHJ P,RSTRZ
	SETZ T,
	HRLM T,(TT)
	PUSHJ P,WORDIN
	HRRZ T,(TT)
	HRLM TTT,(T)
	PUSHJ P,WORDIN
	MOVE T,BTEXT
	TLZ TTT,1		;CLEAR MARK BIT ON INPUT
	MOVEM TTT,1(T)
	PUSHJ P,WORDIN
	MOVEM TTT,1(TT)
	JRST PROPIN

BTXTDN:	SKIPN T,ODIPTYP		;ANY OLD FORMAT DIPTYPE?
	JRST NODPTY		;NO
	GETFS(TT)
	MOVEI TTT,1
	MOVEM TTT,1(TT)		;INITIALIZE TO AUTO OFFSET
	GETFS(TTT)
	HRLM TTT,(TT)
	HRRM T,(TTT)
	SETZM 1(TTT)
	EXCH TT,BTEXT
	HRRM TT,@BTEXT
	MOVEI TT,[ASCIZ/DIPTYPE/]
	PUSHJ P,ASCCOP
	MOVE A,BTEXT
	HLRZ TT,(A)
	HRLM T,(TT)
	PUSHJ P,EDTTZA
NODPTY:	GETFS(T)		;GET BLOCK FOR POINTERS TO PINS,LINES,BTEXT
DEC,<	SKIPE TT,PINS
	TLNN TT,1		;DIP OFFSET SEEN?
	JRST GOTCO1		;NO
	MOVE TTT,1(TT)		;GET OFFSET
	MOVEM TTT,DEFOFF	;AND STO IT HERE
	HRRZ TTT,(TT)
	MOVEM TTT,PINS
	FSTRET(TT)
GOTCO1:
>;DEC
	GETFS(TT)
	HRLZM TT,(T)
	MOVE TTT,DEFOFF		;DEF LOC OFFSET
	MOVEM TTT,1(TT)
	MOVE TTT,DEFBTS		;BITS,,UNUSED
	HLLZM TTT,(TT)		;CLEAR DIP DEF LIST POINTER
	MOVE TTT,DEFOF1
	CAIN TTT,400000
	JRST NDLCOF
	GETFS(TTT)
	HRRM TTT,(TT)
	SETZM (TTT)
	MOVE TT,DEFOF1
	MOVEM TT,1(TTT)
NDLCOF:	MOVE TT,PINS
	HRRM TT,(T)		;LINK IN PINS
	MOVE TT,LINES
	HRRM TT,1(T)		;LINK IN LINES
	MOVE TT,BTEXT
	HRLM TT,1(T)		;LINK IN BTEXT
	GETFS(TT)		;ANOTHER BLOCK
	HRLZM T,1(TT)		;LINK IN POINTERS
	HRRZ T,STRING		;TYPE NAME
	HRL T,LIBNAM		;YES, GET POINTER TO NAME BLOCK
	MOVEM T,(TT)		;TO FIRST BLOCK
	MOVEM TT,TYPE
	JRST CPOPJ1		;SUCCESS RETURN
;CHECK IF TYPE EXISTS, REPLACE MAYBE
RDTYPY:	MOVE T,STRING		;ARG IN T
	PUSHJ P,TNAME		;DOES NAME ALREADY EXIST?
	JRST TYPEXI		;YES
	MOVE T,TYPE		;NO, NEW TYPE TO ENTER
	MOVE TT,BODPNT
	HRRM TT,1(T)		;LINK TYPE LIST TO THIS TYPE
	MOVEM T,BODPNT		;MAKE THIS TYPE THE FIRST
CKUBDY:	SKIPN USEFLG		;DO WE HAVE THE USE FEATURE
	POPJ P,
	MOVE T,TYPE
	HLRZ T,(T)
	JUMPE T,CPOPJ		;IF NOT LIBRARY BODY, KEEP IT ALL IN
	MOVE C,STRING
	PUSHJ P,USETYP		;WILL WE USE TYPE?
	POPJ P,			;YES
	MOVE B,TYPE
	HLRZ C,1(B)		;GET POINTER TO THE STUFF WE WANT TO GIVE BACK
	HRRZS 1(B)		;AND CLEAR IT
	PUSHJ P,PARREL		;RELEASE THIS PART OF BODY DEF
	MOVE C,BODPNT
	HRRZ C,(C)
	HLRZ B,(C)
	JUMPE B,CPOPJ
	HRRZS (C)		;CLEAR DIP TYPE POINTER ALSO
	JRST PUTFS		;AND RETURN IT

USETYP:	SKIPN D,UTLIST		;ANY USE LIST?
	JRST CPOPJ1		;NOT USED
USETY1:	MOVE A,D
	MOVE B,C
	PUSHJ P,TXTMAT
	CAIA
	POPJ P,			;MATCH, WILL BE USED
	HLRZ D,(D)
	JUMPN D,USETY1
	JRST CPOPJ1		;NOT USED AT ALL

TYPEXI:	MOVEM C,OLDTYP		;SAVE THIS IN CASE WE WILL REPLACE
	MOVE A,TYPE
	MOVEM A,NEWTYP
	SKIPN ALLFLG		;TRYING TO GET ALL OF DEF?
	JRST TYPEXJ		;NO, DO REG. THING
	HLRZ T,1(C)		;DATA POINTER FOR TYPE
	JUMPN T,RELTYP		;ALL IN, SKIP IT COMPLETELY
	JRST NOREPB		;IF NOT ALL IN, REPLACE WITH FULL DEF

TYPEXJ:	TLNE M,TYPREP
	JRST AUTORP
	TLNE M,DSKACT!MACACT
	JRST NOASKM
	OUTSTR[ASCIZ/SHALL I REPLACE /]
	MOVE B,OLDTYP
	PUSHJ P,OUTIT
	OUTSTR[ASCIZ/ WITH /]
	MOVE B,NEWTYP
	PUSHJ P,OUTIT
NOASKM:	PUSHJ P,YORN
	JRST RELTYP
	JRST RELTYP
	JRST GETMOD

RELTYP:	MOVE A,TYPE
	JRST TYPREL		;RELEASE FREE STORAGE FOR THIS TYPE

GETMOD:	MOVE T,OLDTYP
	HLRZ T,1(T)
	JUMPE T,NOREPB		;DON'T HAVE TO REPLACE IF NOT USED (NOT IN)
	PUSHJ P,REPST1		;SETUP CORRESPONDENCE
	JRST RELTYP		;GIVE UP!
DOREP:	PUSHJ P,REPLOP
NOREPB:	MOVEI A,BODPNT-1
	JRST FNDTP1
FNDTYP:	CAMN A,OLDTYP
	JRST FOUND
FNDTP1:	MOVE B,A
	HRRZ A,1(A)
	JUMPN A,FNDTYP
	PUSHJ P,FUCKUP
	POPJ P,
FOUND:	MOVE C,TYPE
	HRRM C,1(B)
	HRRZ B,1(A)
	HRRM B,1(C)
	HLRZ T,1(A)
	JUMPN T,TYPREL
	PUSHJ P,TYPREL
	JRST CKUBDY		;IF NOT CURRENTLY USED, WE CAN CHECK

AUTORP:	MOVE B,OLDTYP
	PUSHJ P,OUTIT
	OUTSTR[ASCIZ/ BEING REPLACED BY /]
	MOVE B,NEWTYP
	PUSHJ P,OUTIT
	MOVE T,OLDTYP
	HLRZ T,1(T)
	JUMPE T,[OUTSTR[ASCIZ/
/]
		JRST NOREPB]	;NO REPLACE IF BODY NOT USED(NOT IN)
	PUSHJ P,REPCL1		;TRY GEOMETRIC OVERLAY
	JRST RELTYP		;ASK FOR ANOTHER MODE
	OUTSTR[ASCIZ/
/]
	JRST DOREP
>;MD
;CALL TYPE READING SUBR, READ INSTANCES OF TYPES
RDFILE:	MOVEM P,PERRSAV		;RETURN ONE UP FROM HERE ON INPUT ERRORS
MD,<	SETZM LIBNAM		;NO LIBRARY NAME YET
	SETZM LIBTMP
	SETZM DEPTH
	SETZM USEFLG		;ASSUME USE LIST NOT ACTIVE
	SETZM ALLFLG		;START OUT NORMAL
	TRO FSTLIB		;FIRST LIBRARY LEVEL
	PUSHJ P,CLBMRK		;CLEAR LIBRARY NEEDMR BITS
>;MD
	PUSHJ P,MACCLR		;CLEAR TMP BIT IN MACROS
	PUSHJ P,TYPIN		;GET TYPES IN (MAY RECUR!!!)
	MOVEI F,NEWBOD		;PUT FIRST POINTER HERE
MD,<	TLNE M,TYPNLY		;ONLY TYPES?
	POPJ P,			;GO DIRECTLY TO END DO NOT PASS SETS DO NOT SCREW UP
>;MD
	MOVEI T,[ASCIZ/BODY/]
	MOVEM T,TYPLOC
RDBOD:	PUSHJ P,WORDIN		;LOC OF BODY
	CAIN TTT,400000		;DONE?
MD,<	JRST RDPNT		>
MPC,<	JRST DOPNTX		;YES>
	PUSHJ P,CHKLOC
	MOVEM TTT,CURSE		;SAVE LOC
MPC,<	MOVE TTT,RDVER		;**RDVER
	CAIGE TTT,10		;HAVE DIP TYPE?
	JRST NODTYP
	PUSHJ P,RSTRZ		;DIP TYPE NAME
	SETZ T,			;NULL
	MOVEM T,STRING
NODTYP:
>;MPC
	PUSHJ P,WORDIN		;GET ORIENTATION
	MOVE TT,TTT
MPC,<	ANDI TTT,3	>
MD,<
	MOVE A,RDVER
	XCT %IV6(A)		;**RDVER
>;MD
	MOVEM TTT,CURORT
	SETZM LETTER
	SETZM NUMBER		;NONE SO FAR
	SETZM NUMBR1
MD,<	TRNN TT,400000		;ANY LOCATION?
	JRST NNFORM		;NO
	MOVE A,RDVER
	XCT %IV7(A)		;**RDVER
	SETZ TTT,
	MOVE A,RDVER
	CAILE A,23		;**RDVER
	PUSHJ P,WORDIN
	MOVEM TTT,NUMBR1
>;MD
MPC,<	MOVE A,RDVER
	XCT %IV8(A)		;**RDVER
>;MPC
	MOVE A,RDVER
MD,<	CAILE A,14	>	;**RDVER
MPC,<	CAILE A,15	>	;**RDVER
	JRST NNFORM
	HRRZ A,LETTER		;MAKE SWAPPED 6 BIT BYTES
	DPB A,[POINT 6,A,23]
	LSH A,-6
	DPB A,[POINT 12,LETTER,35];INTO ONE 12 BIT BYTE
NNFORM:	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER
	JRST OLDVR1
	TLZ TTT,FOUNDB!BTMP1
	PUSH P,TTT		;SAVE BODY ID AND BITS
	JRST OLDVR2
OLDVR1:	GETFS (TT)
	MOVEM TT,(F)
	MOVE F,TT
	SETZM (F)
	HRLZM TTT,1(F)		;UNIQUE EXTERNAL NAME FOR BODY INTO NEWBOD LIST
	PUSH P,F		;SAVE NEWBOD LIST POINTER
OLDVR2:
MD,<
	PUSHJ P,RSTR		;NAME OF TYPE
	MOVEM T,STRING		;SAVE FOR GARBAGE COLLECT
	PUSHJ P,TNAME		;FIND LOCATION OF THAT TYPE (POINTER TO STRING IN )
	CAIA			;FOUND (POINTER TO TYPE IN C)
	JRST [	PUSHJ P,OUTTXT
		OUTSTR[ASCIZ/ TYPE NOT FOUND!
BODY WILL BE RELEASED!
/]
		MOVE B,STRING
		PUSHJ P,PUTFS
		POP P,F		;RESTORE NEWBOD LIST POINTER
		MOVE T,RDVER
		CAIL T,23	;**RDVER
		PUSHJ P,SKPPRP	;SKIP OVER PROPERTIESIF NOT PLACING BODY
		JRST RDBOD]	;TRY TO GO ON.
	MOVEM C,CURBOD		;SAVE TYPE POINTER
	MOVE B,STRING
	PUSHJ P,PUTFS
	SETZM BTEXT
	MOVE TT,RDVER
	CAIL TT,23		;**RDVER
	PUSHJ P,PROPIN
>;MD
MPC,<
	PUSHJ P,WORDIN		;NUMBER OF PINS
	HRRZ A,TTT
	CAIG A,2
	JRST [	MOVE T,RDVER
		CAIGE T,10	;**RDVER
		JRST [	CAIN A,1
			MOVEI T,=400/5
			CAIN A,2
			MOVEI T,=200/5
			JRST IS2PNO]
		HLRZ T,TTT
	IS2PNO:	PUSHJ P,G2PIN	;FIND OR MAKE THIS 2 PIN DIP!
		JRST FNDTYP]
FNDT12:	MOVE A,BODPNT
FNDT1:	HLRZ B,(A)
	CAIN B,(TTT)
	JRST FNDTYP
	HRRZ A,(A)
	JUMPN A,FNDT1
	OUTSTR[ASCIZ/TYPE NOT FOUND!
BODY WILL BE RELEASED!
/]
	POP P,F		;RESTORE NEWBOD LIST POINTER
	JRST RDBOD	;TRY TO GO ON.
;PLACE INSTANCES OF TYPES
FNDTYP:	MOVEM A,CURBOD		;SAVE TYPE POINTER
>;MPC
	PUSHJ P,BPYESF		;PLACE BODY(X,Y IN CURSE;TYPE IN CURBOD;ORIENTATION IN CURORT)
	HRRZ T,LSTBOD		;NEWEST BODY
	POP P,F
	SKIPN RDVER		;**RDVER
	HRRM T,1(F)		;STORE INTERNAL POINTER IN NEWBOD LIST
	TRNN MAKSET		;MAKING SET?
	JRST NOBVIR		;NO
	GETFS(TT)
	HRLZM T,1(TT)
	EXCH TT,DY3
	HRRZM TT,@DY3
	HLRE TTT,1(T)
	ADDM TTT,DX1
	HRRE TTT,1(T)
	ADDM TTT,DY1
	AOS DX3
NOBVIR:	HLRZ T,(T)
	HLRZ T,1(T)		;POINTER TO DIPNUM BLOCK
	SKIPN RDVER		;**RDVER
	JRST OLDVR0
	ADD F,OLDBID
	HRLM F,(T)		;SAVE BODY ID FROM FILE
	HLLM F,1(T)		;STO BODY BITS!
	HRRZ F,F
	CAMLE F,MAXBID
	MOVEM F,MAXBID
	ANDI F,LHASHB-1
	HRRZ TT,LSTBOD
	SKIPE TTT,HASHB(F)	;IS THIS BUCKET EMPTY?
	JRST BODLNK
	MOVEM TT,HASHB(F)	;YES MAKE THIS ENTRY
	MOVEI TTT,DBODPN
BODLNK:	HRRZ D,(TTT)		;ADD AFTER FIRST ENTRY IN BUCKET
	HRRM D,(TT)
	HRRM TT,(TTT)
OLDVR0:
MPC,<
	MOVE TT,LETTER
	HRRM TT,(T)
	MOVE TT,STRING
	HRRM TT,1(T)
	JRST RDBOD
>;MPC
MD,<	SKIPN BTEXT
	JRST NXBTXT
	HRRZ A,LSTBOD
	HLRZ A,(A)
	HLRZ B,1(A)
	ADDI B,1
	HRRZ A,1(A)
	HLRZ A,1(A)
	HLRZ A,1(A)
	JUMPE A,NXTTXT
BTLOP1:	HLRZ T,(A)
	HLRZ T,(T)
	JUMPE T,BTLOP2
	MOVE TTT,BTEXT
	PUSHJ P,FPROPX
	JRST BTLOP2
	JRST BTLOP3

BTLOP2:	GETFS(T)
	HRRM T,(B)
	MOVE B,T
	SETZM (B)
	HRRZM A,1(B)
BTLOP3:	HRRZ A,(A)
	JUMPN A,BTLOP1
NXTTXT:	MOVE T,BTEXT
	HRRM T,(B)
NXBTXT:	HRRZ T,LSTBOD
	HLRZ T,(T)
	HLRZ T,1(T)
	HRRZ TT,(T)
	JUMPN TT,GTLCBK
	SKIPN LETTER		;ANY LOC THERE?
	JRST RDBOD		;NO, LOOP NOW
	GETFS(TT)
	HRRM TT,(T)
	GETFS(T)
	HRLZM T,(TT)
GTLCBK:
DEC,<	MOVE T,RDVER		;**RDVER
	CAILE T,14		;OLD LOSING DEC VERSION?
	JRST NLCFUD		;NO, NO FUDGE
	PUSH P,TT
	PUSH P,A
	SETZM CHRCNT
	MOVS A,LETTER
	PUSH P,PUTCHR
	MOVE T,[AOS CHRCNT]	;change putchr to count chars
	MOVEM T,PUTCHR
	PUSHJ P,SLTLPN
	POP P,PUTCHR
	MOVE T,CHRCNT
	POP P,A
	IMULI T,CWIDTH/2
	HRLZ T,T
	HRRI T,CHGHT/2
	ADJUST(ADD,T,NUMBER)
	MOVEM T,NUMBER
	POP P,TT
NLCFUD:
>;DEC
	MOVE T,NUMBER		;LOC OFFSET
	MOVEM T,1(TT)
	HLRZ B,(TT)
	MOVE T,LETTER
	MOVEM T,(B)
	MOVE T,NUMBR1
	MOVEM T,1(B)
DEC,<	MOVE T,RDVER
	CAILE T,23		;**RDVER
	JRST NLCOFF
	MOVE A,LSTBOD
	HLRZ A,(A)
	HLRZ A,1(A)
	MOVSI T,FIXBLO
	IORM T,1(A)
	PUSH P,TT
	MOVE T,LSTBOD
	PUSHJ P,OFFBLO
	POP P,TT
NLCOFF:
>;DEC
	MOVE T,RDVER		;**RDVER
	CAIGE T,12		;COMING FROM VERSION WITH NO DEF OFFSET?
	JRST RDBOD		;YES, SKIP IT
	HRRZ A,LSTBOD		;LAST BODY MADE (US)
	HLRZ A,(A)		;DATA BLOCK
	HLRZ T,1(A)		;SECOND DATA BLOCK
	MOVE TTT,1(T)		;BITS
	TLNN TTT,FIXLOC!FIXBLO	;DOES HE WANT THE LOC UPDATED?
	JRST RDBOD		;NO, LEAVE IT ALONE
	MOVE T,CURBOD
	HLRZ T,1(T)
	HLR TTT,(T)
	TLNN TTT,FIXLOC
	JRST FXDBLC
	MOVE T,1(TTT)
	HLRZ F,(A)		;ORIENTATION
	PUSHJ P,ORIENT		;ROTATE IT
	MOVEM T,1(TT)		;SET OFFSET TO DEF FROM TYPE FOR OLD VERSIONS
FXDBLC:	TLNE TTT,FIXBLO
	TLNN TTT,FIXLOC		;ONLY COPY OFFSET FROM DEF IF LOC IS FROM DEF
	JRST RDBOD
	HRRZ TTT,(TTT)
	JUMPE TTT,RDBOD
	MOVE T,1(TTT)
	HLRZ TT,(TT)
	MOVEM T,1(TT)
	JRST RDBOD		;GET ANOTHER ONE
>;MD
;READ POINT, FIND POINT, D PROG
MD,<
RDPNT:	PUSHJ P,WORDIN		;GET LOC OF POINT
	CAIN TTT,400000		;DONE?
	JRST RPNTDN		;YES
	MOVEI T,[ASCIZ/POINT/]
	MOVEM T,TYPLOC
	MOVEM TTT,THSLOC
	PUSHJ P,CHKLOC
	SKIPN RDVER		;**RDVER
	JRST OLDVR3
	PUSH P,TTT		;SAVE LOCATION
	PUSHJ P,WORDIN		;GET PID
	TLNN TTT,-1
	JRST PPIDF		;JUST POINT
	PUSHJ P,FFNDID
	JRST NOBPFN		;BODY PIN NOT FOUND
	POP P,(P)
	JRST OLDVR4

NOBPFN:	JUMPE D,[OUTSTR[ASCIZ/BODY NOT FOUND/]
		JRST PFLSH]
	HLRZ D,(D)
	HRRZ D,1(D)
	MOVEM D,OLDTYP
	OUTSTR[ASCIZ/PIN NOT FOUND ON /]  
	MOVE B,OLDTYP
	PUSHJ P,OUTIT
PFLSH:	OUTSTR[ASCIZ/, PIN WILL BE DELETED!
/]
	POP P,(P)		;LOSE POINT LOC
	MOVEI T,5		;SKIP NEIGHBORS AND END WITH BITS
	PUSHJ P,WORDIN
	SOJG T,.-1
	SKIPN RDVER		;**RDVER ONLY VERY OLD STUFF
	TRNN TTT,400000		;NEW FORMAT?
	JRST NPFLSH		;NO
	PUSHJ P,WORDIN		;SKIP NUMBER WORD
	PUSHJ P,WORDIN		;READ REAL BITS (I HOPE)
NPFLSH:	TLZ TTT,FOUNDP
	MOVE A,TTT		;SAVE BITS
	MOVE T,RDVER		;**RDVER
	CAIL T,3		;THESE HAVE TEXT SIZE IN TTT
	PUSHJ P,WORDIN		;THESE HAVE IT IN NEXT WORD
	TRNN TTT,-1
	JRST NTFLSH
	CAILE T,4		;**RDVER THESE HAVE NO OFFSET
	PUSHJ P,WORDIN		;THESE HAVE
	PUSHJ P,SKPSTR		;SKIP TEXT
	JFCL
NTFLSH:	TLNN A,CPIN		;CONNECTOR PIN?
	JRST RDPNT
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST RDPNT

PPIDF:	EXCH TTT,(P)
	MOVE T,TTT
	PUSHJ P,HSHPUT		;ADD POINT TO HASH LIST
	EXCH TTT,(P)
	ADD TTT,OLDPID
	HRRM TTT,@(P)
	CAMLE TTT,MAXPID	;LARGEST YET?
	MOVEM TTT,MAXPID	;NO, REMEMBER
	MOVE TT,TTT
	ANDI TT,LHASHP-1	;FORM HASH CODE FROM LOW BITS OF PIN ID
	HRRZ TTT,@PHASHP
	HRRM D,@PHASHP
	HRRM TTT,(D)
	SKIPN TTT
	HRLM D,@PHASHP		;NEW END OF BUCKET
	POP P,TTT
	JRST OLDVR4
;MORE READ POINT, LINES, D PROG
OLDVR3:	PUSHJ P,FIND.P		;FIND THE POINT (OR MAKE ONE)
OLDVR4:	PUSH P,T
	PUSH P,D
	PUSH P,E
	SETZB D,TT
	MOVE G,RDVER		;FOR INDEXING
	PUSHJ P,WORDIN		;DOWN
	MOVE T,@(P)
	TLNN T,-1
	XCT %IV10(G)		;**RDVER
	JRST NNDOWN
	CAMN TTT,THSLOC
	JRST NNDOWN
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P		;FIND HIM(OR MAKE HIM)
OLDVRD:	MOVE TTT,-1(P)		;THIS POINT
	CAMN TTT,D
	JRST NNDOWN		;NOT TO OURSELVES
	HRRM TTT,(E)		;UP OF DOWN POINT
	HRLM D,@(P)		;SAVE DOWN
	SETZB D,TT
NNDOWN:	PUSHJ P,WORDIN
	MOVE T,@(P)
	TRNN T,-1
	XCT %IV11(G)		;**RDVER
	JRST NNUP
	CAMN TTT,THSLOC
	JRST NNUP
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P		;FIND UP
OLDVRU:	MOVE TTT,-1(P)
	CAMN TTT,D
	JRST NNUP
	HRLM TTT,(E)
	HRRM D,@(P)
	SETZB D,TT
NNUP:	AOS (P)
	PUSHJ P,WORDIN
	MOVE T,@(P)
	TLNN T,-1
	XCT %IV12(G)		;**RDVER
	JRST NNLEFT
	CAMN TTT,THSLOC
	JRST NNLEFT
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P
OLDVRL:	MOVE TTT,-1(P)
	CAMN TTT,D
	JRST NNLEFT
	HRRM TTT,1(E)
	HRLM D,@(P)
	SETZB D,TT
NNLEFT:	PUSHJ P,WORDIN
	MOVE T,@(P)
	TRNN T,-1
	XCT %IV13(G)		;**RDVER
	JRST NNRIGHT
	CAMN TTT,THSLOC
	JRST NNRIGHT
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P
OLDVRR:	MOVE TTT,-1(P)
	CAMN TTT,D
	JRST NNRIGHT
	HRLM TTT,1(E)
	HRRM D,@(P)
NNRIGHT:POP P,E
	POP P,D
>;MD
;READ POINT, FIND, MAKE LINES, PC PROG
MPC<
DOPNTX:	MOVEI T,[ASCIZ/POINT/]
	MOVEM T,TYPLOC
	PUSHJ P,RDPNT
	FSWITCH
	PUSHJ P,RDPNT
	FSWITCH
	JRST RPNTDN

RDPNT:	PUSHJ P,WORDIN		;GET LOC OF POINT
	CAIN TTT,400000		;DONE?
	POPJ P,			;YES
	PUSHJ P,CHKLOC
	SKIPN RDVER		;**RDVER
	JRST OLDVR5
	PUSH P,TTT
	PUSHJ P,WORDIN
	TLNN TTT,-1
	JRST RDPOK
	PUSHJ P,FFNDID
	JRST RPLOSE
	POP P,(P)
	JRST OLDVR6

RDPOK:	EXCH TTT,(P)
	MOVE T,TTT
	PUSHJ P,HSHPUT
	EXCH TTT,(P)
	ADD TTT,OLDPID
	HRRM TTT,@(P)
	CAMLE TTT,MAXPID	;LARGEST YET?
	MOVEM TTT,MAXPID	;NO, REMEMBER
	MOVE TT,TTT
	ANDI TT,LHASHP-1	;FORM HASH CODE FROM LOW BITS OF PIN ID
	HRRZ TTT,@PHASHP
	HRRM D,@PHASHP
	HRRM TTT,(D)
	SKIPN TTT
	HRLM D,@PHASHP		;NEW END OF BUCKET
	POP P,TTT
	JRST OLDVR6
OLDVR5:	PUSHJ P,FIND.P		;FIND THE POINT (OR MAKE ONE)
OLDVR6:	MOVE H,D
	MOVE G,TTT
	PUSH P,T
RDSEG:	PUSHJ P,WORDIN
	SKIPE RDVER		;**RDVER
	JRST [	JUMPN TTT,OLDVR7
		JRST RDSEGN]
	CAIN TTT,400000
	JRST RDSEGN
	PUSHJ P,CHKLOC
OLDVR7:	SKIPE RDVER		;**RDVER
	JRST [	PUSHJ P,FFNDID
		JRST RDSEG	;NOT IN YET
		JRST .+2]
	PUSHJ P,FIND.P
	CAMN D,H
	JRST RDSEG		;NOT TO OURSELVES
	MOVE B,E
	MOVE A,H
	PUSHJ P,FNDLNK		;ALREADY A LINE?
	CAIA			;NO, MAKE ONE
	JRST RDSEG		;YES, NOT AGAIN
	MOVE T,G		;START AT FRONT
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	MOVE T,TTT
	PUSHJ P,FRELNK
	MOVE D,H
	XCT (T)PUTAB
	JRST RDSEG

RPLOSE:	OUTSTR[ASCIZ/PIN OR BODY NOT FOUND!
/]
	PUSHJ P,FUCKUP
	PUSHJ P,WORDIN		;SKIP NEIGHBORS
	JUMPN TTT,.-1
	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER
	TRNN TTT,400000
	JRST NPFLSH
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
NPFLSH:	MOVE T,RDVER
	CAIL T,6		;**RDVER
	PUSHJ P,WORDIN		;TEXT SIZE HERE FOR LATER VERSIONS
	TRNN TTT,-1		;ANY TEXT?
	JRST NTFLSH		;NO
	CAILE T,4		;**RDVER ANY OFFSET?
	PUSHJ P,WORDIN		;YES, SKIP IT
	PUSHJ P,SKPSTR		;SKIP TEXT
	JFCL
NTFLSH:	PUSHJ P,WORDIN		;SKIP FEEDTHROUGH
	JRST RDPNT

RDSEGN:	;FALL INTO CODE ON NEXT PAGE
>;MPC
;READ REST OF POINT INFO
	POP P,C
	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER ONLY VERY OLD STUFF
	TRNN TTT,400000		;NEW FORMAT?
	JRST NPFORM		;NO
	PUSHJ P,WORDIN		;SKIP NUMBER WORD
	PUSHJ P,WORDIN		;READ REAL BITS (I HOPE)
NPFORM:
	HLLZ TT,TTT
MPC,<	AND TT,[XWD PLANES,0]	;JUST THESE	>
MD,<	AND TT,[XWD CPIN!CPNBTS!FIXTXT!FIXRHT!FIXCON,0]		;JUST THESE
	MOVE T,RDVER
	CAIGE T,12		;**RDVER THESE GUYS HAVE IT
	TLZ TT,FIXTXT!FIXRHT!FIXCON;THESE DON'T
>;MD
	IORB TT,1(C)		;OR IN POWER AND GROUND BITS.
MPC,<	MOVE D,H	>
	TRNE MAKSET		;MAKING SET?
	TLNE TT,MPC,<CPIN!>ISPIN	;YES, PUT THIS ONE IN IT?
	CAIA			;NO
	PUSHJ P,VIRSET
	MOVE T,RDVER
	XCT %IV14(T)		;**RDVER READ PAD OR PIN #, ETC.
	TRNN TTT,-1
	JRST [	SETZ T,
		JRST RNOTXT]
	MOVE T,RDVER				;THIS WAS CLOBBERED BY PBSRC
	CAIGE T,4		;**RDVER
	TRZN TTT,10
	CAIA
	TRO TTT,400000
	HRRZ TT,TTT
	ANDI TTT,377777		;MASK JUST SIZE
	CAILE TTT,CSIZES	;LEGAL?
	JRST [	OUTSTR[ASCIZ/ILLEGAL SIZE IN POINT TEXT.
WILL CHANGE TO STANDARD SIZE.
/]
		TRZ TT,377777
		TRO TT,STDBIG
		JRST .+1]
	CAIG T,4		;**RDVER
	TDZA TTT,TTT
	PUSHJ P,WORDIN
	GETFS (T)
	MOVEM TTT,1(T)
	PUSH P,T
	PUSHJ P,RSTRZ
	JRST [	POP P,T
		FSTRET (T)
		SETZ T,
		JRST RNOTXT]
	HRLM TT,(T)
	HRRZM T,@(P)
	POP P,T
RNOTXT:	HRLM T,(C)
MD,<	MOVE TTT,1(C)
	TLNN TTT,CPIN		;DO WE HAVE TO READ CONNECTOR PIN LOC?
	JRST NRCPIN		;NO
	GETFS (T)
	HRRM T,(C)		;LINK IN NEW BLOCK
	PUSHJ P,WORDIN
	MOVE A,RDVER
	XCT %IV17(A)		;**RDVER
	MOVE A,RDVER
	CAILE A,24		;**RDVER
	JRST NRCPIN
	MOVSI TTT,CPNBTS	;CLEAR BITS IN OLD VERSIONS
	ANDCAM TTT,1(C)
	MOVE T,(T)
	PUSHJ P,CPNBCK		;CHECK FOR U PIN
	HRRZ T,1(C)
	PUSHJ P,CPNBCK		;CHECK THIS ALSO
NRCPIN:
>;MD
MPC,<	PUSHJ P,WORDIN
	CAIN TTT,400000
	JRST RDPNT
	SKIPE RDVER		;**RDVER
	JRST OLDVR8
	PUSHJ P,CHKLOC
	MOVE G,H
	PUSHJ P,RDFEED
	JFCL			;LOSERS LOSE
	JRST RDPNT

OLDVR8:	FSWITCH
	PUSHJ P,FFNDID
	JRST NOOLDV
	MOVE TT,1(T)
	TLNE TT,ISPIN!FEEDTH!CPIN
	JRST NOOLDV
	TLO TT,FEEDTH
	TLNE M,TYPNLY
	TRNE TT,-1
	CAIA
	HRRI TT,1
	MOVEM TT,1(T)
	HLRZ TT,(D)
	HRLM H,(TT)
	HLRZ TT,(H)
	HRLM D,(TT)
	HRRZ TT,1(TT)
	MOVE TTT,1(TT)
	TLO TTT,FEEDTH
	TLNE M,TYPNLY
	TRNE TTT,-1
	CAIA
	HRRI TTT,1
	MOVEM TTT,1(TT)
NOOLDV:	FSWITCH
>;MPC
	JRST RDPNT

VIRSET:	SKIPN T,DY3
	JRST VIRST1
	HRRZ TT,1(T)
	JUMPE TT,VIRST2
	HRRZ T,(T)
	JUMPN T,.-3
VIRST1:	GETFS(T)
	SETZM 1(T)
	MOVE TT,DY3
	HRRZM TT,(T)
	HRRZM T,DY3
VIRST2:	HRRM D,1(T)
	HLRE T,1(D)
	ADDM T,DX1
	HRRE T,1(D)
	ADDM T,DY1
	AOS DX3
	POPJ P,
;READ SETS
RPNTDN:	PUSHJ P,WORDIN
	CAIE TTT,400000
	CAIN TTT,400001
	JRST SETDON
	MOVEI G,NEWSET
	SETZM NEWSET
	PUSH P,TTT
RDSBOD:	PUSHJ P,WORDIN
	JUMPE TTT,SBODN		;END OF BODIES IN THIS SET
	SKIPE RDVER		;**RDVER
	JRST [	PUSHJ P,FNDBID
		JRST RDSBOD
		JRST OLDV10]
	MOVE T,TTT
	PUSHJ P,FIND.B
	JRST RDSBOD		;COULDN'T FIND, GO TO NEXT
OLDV10:	GETFS(A)		;GET BLOCK FOR IT
	HRLZM B,1(A)		;SAVE POINTER
	SETZM (A)		;CLEAR LINK
	MOVEM A,(G)		;LINK ON END OF SET
	MOVE G,A		;NEW END
	JRST RDSBOD		;NEXT
SBODN:	MOVEI G,NEWSET
	MOVE H,RDVER
RDSPNT:	PUSHJ P,WORDIN		;READ POINT LOC
	XCT %IV18(H)		;**RDVER
	JRST SPNTDN		;YES
MD,<	PUSHJ P,FIND.P		;FIND POINT>
MPC,<
	SKIPE D,PONPNT
	PUSHJ P,FP1
	CAIA
	JRST [	CHKOTH:	SKIPN A,NEWSET
			JRST THISOK
		CHKLOP:	HRRZ T,1(A)
			CAIN T,(D)
			JRST .+1
			HRRZ A,(A)
			JUMPN A,CHKLOP
			JRST THISOK]
	SKIPE D,PONPN2
	PUSHJ P,FP1
	CAIA
	JRST THISOK
	PUSHJ P,FP3
THISOK:	>;MPC
;SET IN, PUT IN STRUCTURE, OR FLUSH -- READ SPECIAL STRINGS -- CARD SUBR
OLDV11:
	HRRZ A,(G)
	JUMPN A,GOTIT		;WE HAVE A NEXT BLOCK
	GETFS(A)
	SETZM (A)		;CLEAR LINK
	SETZM 1(A)		;CLEAR DATA
	MOVEM A,(G)
GOTIT:	MOVE G,A
	HRRM D,1(G)		;SAVE POINT POINTER IN SET
	JRST RDSPNT
SPNTDN:	SKIPN NEWSET
	JRST [	OUTSTR[ASCIZ/FLUSHING NULL SET!
/]
		POP P,(P)	;POP OFF SET CENTER
		JRST RPNTDN]
	GETFS(A)
	POP P,1(A)		;SAVE CENTER OF SET
	HRLZ B,NEWSET
	HRR B,SETPNT
	MOVEM B,(A)		;LINK IN SET
	MOVEM A,SETPNT
	JRST RPNTDN		;READ ANOTHER
SETDON:
MD,<	MOVE T,RDVER		;**RDVER
	CAIGE T,4
	JRST NOTIT
FOR I IN(TAUTHOR,TIT1,TIT2)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
	MOVE T,RDVER		;**RDVER
	CAIGE T,10
	JRST NOTIT
	PUSHJ P,WORDIN
	CAMN TTT,CRDLOC
	JRST REVMOD
	JUMPE TTT,REVMOD
	EXCH TTT,CRDLOC		;CARD LOC FOR WHOLE CARD!
	JUMPE TTT,REVMOD
	OUTSTR[ASCIZ/NEW CRDLOC DIFFERENT FROM OLD ONE, WILL USE NEW ONE!
/]
REVMOD:	MOVE T,RDVER		;**RDVER
	CAIGE T,15
	JRST NOTIT
	MOVEI TT,TREV
	PUSHJ P,GSTR
	MOVE T,RDVER
	CAIL T,MODIOV		;**RDVER
	JRST HASMVP		;HAS MODULE, VARIABLE, PREFIX
	PUSHJ P,RSTRZ		;READ OLD MODULE STRING
	JRST NOTMVP		;NONE IS EASY
	PUSH P,T		;SAVE POINTER FOR RETURN
	ADD T,[POINT 7,1]
	PUSHJ P,SETTT7
	MOVEM A,TMODULE
TMODLP:	PUSHJ P,GETTT
	JRST MODEOF
	CAIN C,"-"
	JRST TMODDN
	PUTBYT (C)
	JRST TMODLP

TMODDN:	PUSHJ P,SETTT7
	MOVEM A,TVARIABLE
TVARLP:	PUSHJ P,GETTT
	JRST MODEOF
	CAIN C,"-"
	JRST TVARDN
	PUTBYT (C)
	JRST TVARLP

TVARDN:	PUSHJ P,SETTT7
	MOVEM A,TPREFIX
TPRFLP:	PUSHJ P,GETTT
	JRST MODEOF
	PUTBYT (C)
	JRST TPRFLP

MODEOF:	POP P,B
	PUSHJ P,PUTFS
	JRST NOTMVP

HASMVP:	FOR I IN(TMODULE,TVARIABLE,TPREFIX)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
NOTMVP:	MOVE T,RDVER		;**RDVER
	CAIGE T,16		;NEWEST STRINGS?
	JRST NOTIT		;NO
FOR I IN(TPROJ,TPAGE,TOF,TDCODE,SITE1,SITE2)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
DEC,<	MOVE T,RDVER
	CAIGE T,20
	JRST NOTIT
	MOVEI TT,TNXTHI
	PUSHJ P,GSTR
FOR @$I IN(DRN,CHK,ENG)
<	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM
	JUMPE TTT,NOR$I
	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM+1
	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM+3
NOR$I:
>
;BEGIN BUG FIX  ***********
	SETZM CHKNAM		;FLUSH CHECKED SIGNATURE
;END BUG FIX **************
>;DEC
NOTIT:	MOVE T,RDVER
	CAIN T,BRDIOV		;**RDVER
	PUSHJ P,RDBRD
	POPJ P,
>;MD
MPC,<	CAIE TTT,400001
	POPJ P,
	PUSHJ P,WORDIN
	MOVE T,RDVER
	XCT %IV20(T)		;**RDVER
	POPJ P,

;SEPERATE CALL ON THIS GUY TO AVOID ASSIGNING OLD POINT ID'S AND SCREWING SETS
CARDIO:	MOVE TTT,RDVER		;**RDVER
	CAIGE TTT,17
	JRST OLDCRD
	TRNN VIRGIN
	SKIPN CRDNAM
	CAIA
	JRST NOTNEW		;SKIP CARD IF ALREADY ONE AND NOT VIRGIN
	PUSHJ P,CRDREL
	PUSHJ P,WORDIN
	MOVEM TTT,CRDNAM
	PUSHJ P,WORDIN
	MOVEM TTT,CRDEXT
	PUSHJ P,WORDIN
	MOVEM TTT,CRDPPN
	SKIPN CRDNAM
	POPJ P,
	PUSHJ P,GETCRD
	JRST [	OUTSTR[ASCIZ/ERROR WHILE READING CARD!
/]
		JRST CRDREL]
	POPJ P,

NOTNEW:	PUSHJ P,WORDIN		;SKIP CARD NAME IF WE AREN'T GOING TO USE IT
	PUSHJ P,WORDIN
	JRST WORDIN

OLDCRD:	PUSHJ P,WORDIN
	JUMPE TTT,CPOPJ		;RETURN IF NO OLD CARD #
	OUTSTR[ASCIZ/OLD VERION USED CARD # /]
	MOVE T,TTT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
BUT NOW I NEED A FILENAME.
/]
	JRST DOCARD
>;MPC

;HERE TO READ AND DECODE BOARD TYPE

RDBRD:	MOVEI C,DEFBRD		;DEFAULT FOR OLD STYLE DRAWINGS
	MOVE T,RDVER
	CAIGE T,BRDIOV		;**RDVER
	JRST RDBRD1
	PUSHJ P,RSTRZ		;READ BOARD TYPE, ASCIZ STRING
	POPJ P,			;NO BOARD SPECIFIED
	MOVE B,T		;THE NAME WE JUST READ
	PUSHJ P,FNDBRD
	JRST [	OUTSTR [ASCIZ /UNKNOWN BOARD TYPE: /]
		MOVE T,B
		PUSHJ P,OUTTXT
		OUTSTR[ASCIZ/
/]
		JRST PUTFS]
	PUSHJ P,PUTFS		;PUT THE NAME BACK IN FREE STORAGE
RDBRD1:	TRNE BRDINH		;DON'T SET BOARD TYPE IF SEARCHING LIBRARY FOR BODY
	POPJ P,
	SKIPGE BRDTYP		;IF NO BOARD TYPE YET,
	EXCH C,BRDTYP		;THEN SET THIS
	CAMN C,BRDTYP		;DO BOARD TYPES AGREE?
	POPJ P,			;    YES, NO HASSLE
MD,<	TRNN FSTLIB		;IF TOP LEVEL, ONE MESSAGE
	JRST RDBRD2		;ELSE ANOTHER
>;MD
	JUMPL C,SETBRD		;JUMP IF BOARD PREVIOUSLY UNDEFINED
	OUTSTR [ASCIZ /BOARD TYPES OF FILE AND PROGRAM DISAGREE,
USING BOARD TYPE FROM FILE.
/]
	MOVEM C,BRDTYP
	JRST SETBRD

MD,<
RDBRD2:
NOITS,<
	OUTSTR[ASCIZ/LIBRARY BOARD TYPE DIFFERENT FROM DRAWING.
WILL IGNORE IT AND RETAIN DRAWING BOARD TYPE.
/]
>;NOITS
	POPJ P,
>;MD
;'ROU'		Read WAGNER's router files
MPC,<
DREADR:
NOWAG,<	JRST PERRET	>
WAG,<
	TLNN M,DSKACT!MACACT
NOHP,<	 OUTSTR[ASCIZ/ROUTER INPUT (DAT) /]
	MOVEI H,' ! '
	ADD H,LASTWR		;LAST WIRE FILE READ!
	EXCH H,LSTNAM		;TEMPORARILY MAKE THIS 
	MOVSI T,EXTROU
	PUSHJ P,SETNAM
	 JRST [	MOVEM H,LSTNAM
		POPJ P,]
	MOVEM H,LSTNAM
>;NOHP
HP,<	 OUTSTR	[ASCIZ/Output from ROUTE (.ROU) /]
	MOVSI	T,EXTROU
	PUSHJ	P,SETNAM	;Verify if user wants default file
	 POPJ	P,
>;HP
	INIT DAT,0
	 'DSK   '
	 IOHD
	 JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR [ASCIZ /Reading /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEM P,PERRSAV
	MOVE T,FILNAM
	MOVEM T,LASTWR		;SAVE LAST NAME READ SUCCESSFULLY
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVEI T,ROUXMM*ROUSCL
	MOVEM T,MINX
	MOVEI T,ROUYMM*ROUSCL
	MOVEM T,MINY
	MOVEM SID,SIDSAV	;REMEMBER WHICH SIDE WE STARTED ON
	PUSH P,M		;Save the status registre
	TLO M,XWINDOW		; and let CLSLIN find things anywhere
ROULP1:	PUSHJ P,GETXY		;Get first point of a subnet
	 JRST ROUDN		; end of file if 0,0
	EQV B,SID		;Is it on the current side ?
	JUMPL B,ROULP3
	 SWITCH			; No, start on proper side
ROULP3:	PUSHJ P,FIND.P		;Find or make this point
	HRL D,TTT		;Pack pointer to point_type
	MOVEM D,MAXY		; and pointer to XY block into MAXY
	PUSHJ P,ATWIRE		;TRY TO ATTACH POINT IN MAXY TO ANY LINE
ROULP2:	PUSHJ P,GETXY		;Get a continuation point in subroute
	 JRST ROUSGN		; unless end of this subnet.
	MOVE D,MAXY
	MOVEM D,MAXX		;Save packed pointers of previous point
	EQV B,SID		;Is this point on the current side?
	JUMPGE B,ROUFED		; or is it a feed through?
	CAMN TTT,1(D)		;Zero length segment?
	 JRST ROULP2		; Yes, loop back for another
	PUSHJ P,FIND.P		;Find or create next point
	HRL D,TTT		; and pack pointers to point_type
	MOVEM D,MAXY		;  and XY block into MAXY
	HLRZ T,MAXX		;Recover pointer to MAXX point_type block
	PUSHJ P,FRELNK		; and find a free neighbors cell
	XCT PUTAB(T)		;Make MAXY a neighbor of MAXX (link in D)
	HLRZ T,MAXY		;Recover pointer to MAXY point_type block
	PUSHJ P,FRELNK		; and find a free neighbors cell
	HRRZ D,MAXX
	XCT PUTAB(T)		;Make MAXX a neighbor of MAXY
	JRST ROULP2		; and get another point

ROUSGN:	HRRZ D,MAXY		;Get pointer to last point in subnet
	HRRZ B,MAXX		; and to one previous
	MOVE TTT,1(D)		;Fetch X,,Y of last point
	CAMN TTT,1(B)		;Did we end on a feed-through ?
	 JRST ROUCFT		; Yes, we have duplicate points. Delete one.
ROUSG1:	PUSHJ P,ATWIRE		;Try to connect terminal point of subroute
	JRST ROULP1		; then go back for another subroute

ROUCFT:	SKIPN H,PONPNT		;Search on this side for duplicate point
	 JRST ROUSG1		; unless there are no points
	SETZ G,			;Clear 'previous' pointer
ROUFE1:	CAIN H,(D)		;Is this the last point of our subroute ?
	 JRST ROUFNX		; Yes, no match
	CAMN TTT,1(H)		;Is this the point we are looking for ?
	 JRST ROUFE2		; Yes, just turn it into a feed through
ROUFNX:	MOVEI G,(H)		; No, save pointer to this point
	HRRZ H,(H)		;  and fetch pointer to next one
	JUMPN H,ROUFE1		;  unless there is none.
	JRST ROUSG1		;In that case, try to connect via ATWIRE

ROUFE2:	HLRZ TT,(H)		;Get pointer to matching point type block
	HRRZ A, 1(TT)		; and then to descriptor block
	MOVE A, 1(A)		;Get BITS,,pin/pad
	TLNE A, ISPIN!CPIN!FEEDTH ;Can we clobber this point
	 JRST 	[OUTSTR [ASCIZ/Cannot connect feedthrough at /]
		 MOVE TTT, 1(H)	;Report X,,Y location
		 PUSHJ P,CNTFED
		 JRST ROULP1]		;Get another subnet
	HLRZ F, 1(TT)		;Point to dying point neighbor list
	MOVEI A, (H)		; and set up target for FNDLNK
	JUMPE F, R.PDEL		;If no list, just delete this point
	HLRZ TT,(D)		;Get pointer to feedthrough point_type block
	HRLM F,1(TT)		; and hang the neighbors block on it
R.NBR0:	MOVEI E, 2
R.NBRS:	XCT (E)	[HLRZ TT, (F)	;Fetch a neighbor pointer
		 HRRZ TT,1(F)
		 HLRZ TT,1(F)]
	JUMPE TT, R.NXNB	;If NIL, check the next
	HLRZ B,(TT)		;Get address of neighboring type block
	HLRZ B, 1(B)		; and then his neighbors list
	PUSHJ P,FNDLNK		;Find a link pointing to us there
	 JRST ROU.NL		; No match, bitch
	XCT (T)[HRLM D,(B)	;Update the link to point to feedthrough point
		HRRM D,1(B)
		HRLM D,1(B)]
R.NXNB:	SOJGE E, R.NBRS		;Continue examining this block until done
	HRRZ F,(F)		;Get pointer to next neighbor block
	JUMPN F, R.NBR0		; and examine it too.
;The hard part is done.  Now, hang any neighbor list on the feedthrough,
; delete the descriptor, point_type, and XY blocks, returning
; the space to free storage.
R.PDEL:	HLRZ A, (H)		;Get pointer to point_type
	HRRZ TT, 1(A)		; and to descriptor
	FSTRET (TT)		;Return descriptor
	FSTRET (A)		; and point_type blocks
	HRRZ TT,(H)		;Link the next XY block to
	HRRM TT,(G)		; to the previous one
	FSTRET (H)		; and return it, too.
	JRST ROULP1		;Finally, return to input loop.

ROU.NL:	OUTSTR [ASCIZ /Missing neighbor link
/]
	PUSHJ P,FUCKUP
	JRST ROULP1

ROUFED:	HRRZ G,MAXX		;This is an attempt to feed through
	CAME TTT,1(G)		; so X,,Y of old and new points should be same
	 JRST ROUNFD		;  If not, complain, and go on
	PUSHJ P,RDFEED		;Try to feed through
	  JRST ROUNFD		; Couldn't, complain and go on
	HRL D,TTT		;D contains pointer to new XY block
	MOVEM D,MAXY		;Pack pointers of new point
	SWITCH			;Change to other side of board
	JRST ROULP2		; and continue the subnet.

ROUNFD:	OUTSTR [ASCIZ /Couldn't feed through at /]
	MOVE TTT,1(G)
	PUSHJ P,CNTFED
	SWITCH
	PUSHJ P,FIND.P
	HRL D,TTT
	MOVEM D,MAXY
	JRST ROULP2		;TRY TO GO ON

ATWIRE:	PUSH P,CURSE
	HRRZ D,MAXY
	MOVE T,1(D)		;Recover X,,Y of point we want
	MOVEM T,CURSE		; and pretend the cursor is there
	PUSHJ P,CLSLIN		;See if there is a closest line
	POP P,CURSE		; [Restore the real cursor position]
	JUMPE A,CPOPJ		;If not, return
	MOVE T,DIFSOF		;Is the distance between point and
	CAIL T,=10*=10*4/=25	; line less than 10 mils?
	 POPJ P,		;  No.  Make no connection
	HRRZ T,A		;  Yes, unpack XY_block addresses
	HLRZ TT,A		;   of endpoints from CLSLIN
	HRRZ D,MAXY		;Recover address of XY of point
	CAIE T,(D)		;Make sure new point isn't either endpoint
	 CAIN TT,(D)		; of closest line
	  POPJ P,
	PUSH P,A		;Save pointers to end_points of closest line
	HLRZ B,(A)
	HLRZ B,1(B)		;Fetch X,,Y of right_half point
	HLRZ A,(P)		; and address of left_half point
	PUSHJ P,FNDLNK		;Find cell in neighbor list of right point
	 JRST ROFERR
	HRRZ D,MAXY
	XCT PUTAB(T)		;  and deposit pointer to new point
	HLRZ T,MAXY		;Get address of type_block of new point
	PUSHJ P,FRELNK		; and find an empty spot in neighbors list
	HRRZ D,(P)		;Link new point to right_half old point
	XCT PUTAB(T)
	HLRZ B,(P)		;Recover address of left_half line end
	HLRZ B,(B)		; and get address of its neighbors
	HLRZ B,1(B)		;  block
	HRRZ A,(P)		;Look for link to right_half end point
	PUSHJ P,FNDLNK
	 JRST ROFERR
	HRRZ D,MAXY		;Link left_half end point to new point
	XCT PUTAB(T)
	HLRZ T,MAXY		;Find space in new point's neighbor list
	PUSHJ P,FRELNK
	HLRZ D,(P)		; and link new point to left_half end
	XCT PUTAB(T)
NOCLN1:	POP P,(P)
	POPJ P,

ROFERR:	OUTSTR[ASCIZ/MISSING LINE POINTER AT ATWIRE!
/]
	PUSHJ P,FUCKUP
	JRST NOCLN1

ROUDN:	RELEASE DAT,
	POP P,M			;Recover original status word
	TRO MCHG!NEEDCL
	MOVE T,SIDSAV		;GET SIDE WE STARTED ON
	EQV T,SID
	JUMPL T,CPOPJ		;ALREADY ON RIGHT SIDE?
	SWITCH			;NO, CHANGE
	POPJ P,

;This routine reads Wagner's result file (.ROU), getting one X,Y pair
; and returning it to the caller.  If that pair was 0,0 (end_route_segment),
; then return is to P+1.  Otherwise, it is to P+2
;At exit,   B/	indicator for which side (FRONT if component, 0 if solder)
;	  TTT/	X,,Y of point read.
;	 T,TT/ clobbered
GETXY:	PUSHJ P,GETN		;Get an X coordinate
	JUMPE T,GETZ		; if it is 0, Y should be too.
	CAIL T,SIDDIF*ROUSCL	;Which side is it on?
	 TLZA B,FRONT		; on solder side
	 TLOA B,FRONT		; on component side
	  SUBI T,SIDDIF*ROUSCL	;Convert to real X coordinate
	CAIL T,SIDDIF*ROUSCL	;Is X still too large ?
	 PUSHJ P,EVALUE		; Yes, complain
	SUB T,MINX		;Convert to our coordinates
	HRLM T,(P)		; and save X on stack
	PUSHJ P,GETN		;Get Y coordinate
	SKIPE T			;It must be .gt. 0 and 
	 CAIL T,ROUYMT*ROUSCL	; .lt. ROUYMT
	  PUSHJ P,EVALUE	;  else complain
	SUB T,MINY		;Convert to our coordinates
	HLL T,(P)		;Recover X in left halfword
	MOVE TTT,T		; and return X,,Y in TTT
	JRST CPOPJ1		;  taking P+2 return

EVALUE:	OUTSTR [ASCIZ /Illegal value at GETXY.
Will substitute 1.
/]
	MOVEI T,1
	POPJ P,

GETZ:	PUSHJ P,GETN
	JUMPE T,CPOPJ
	PUSHJ P,FUCKUP
	SETZ T,
	POPJ P,

;This routine reads one number in I4 format, multiplies it by ROUSCL
; to match the PC coordinate system, and returns.
;At exit,    T/	number*ROUSCL
;	TT,TTT/	clobbered
GETN:	SETZ T,			;Initialize accumulator
	MOVEI TT,4		; and set counter for I4 format
GETN1:	SOSG IOHD+2
	 IN DAT,
	CAIA
	 JRST [	OUTSTR[ASCIZ/UNEXPECTED EOF!
/]
		MOVEI TTT,"0"
		JRST .+2]
	ILDB TTT,IOHD+1		;Get a byte
	JUMPE TTT,GETN1		;If NUL or CRLF, discard, and try
	CAIE TTT,15		; again
	 CAIN TTT,12
	  JRST GETN1
	ANDI TTT,17		;Make a number out of it (space is 0)
	IMULI T,=10		;Multiply accumulator by 10
	ADD T,TTT		; and add new digit into it
	SOJG TT,GETN1		;  for 4 digits worth
	IMULI T,ROUSCL		;Make into internal form
	POPJ P,
>;WAG
>;MPC
;'WDR'	'LES'	READ LOGIC WIRE LIST AND MAKE INTERNAL POINTERS
UML,<
MD,<
IERRS:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LOGIC ERROR SUMMARY (LES) /]
	MOVSI T,EXTLES
	PUSHJ P,SETNAM
	POPJ P,
	TLO WFLAG
	JRST READWA
>;MD

READW:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LOGIC WIRE LIST (FROM WL PROG) (WDR) /]
	MOVSI T,EXTWDR
	PUSHJ P,SETNAM
	POPJ P,			;LET HIM OUT
	TLZ WFLAG
READWA:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,WORDIN
MD,<	TLNN WFLAG
	SKIPA TT,[WDRVER]
	MOVEI TT,LESVER
	CAME TTT,TT		;RIGHT VERSION?
>;MD
MPC,<	CAIE TTT,WDRVER	>
	JRST [	OUTSTR[ASCIZ/, VERSION # MISMATCH!
/]
		RELEASE DAT,
		POPJ P,]
	OUTSTR[ASCIZ/
/]
MD,<	TLNN WFLAG
	JRST GWVER
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/FILENAME OTHER THAN CURRENT DEFAULT?/]
	PUSHJ P,GETWRD
	CAIE C,12
	JRST INNERR		;LOSE
	JUMPN T,.+3
	SKIPN T,LSTNAM		;PICKUP DEFAULT
	JRST [	OUTSTR[ASCIZ/NO DEFAULT NAME!
/]
		RELEASE DAT,
		POPJ P,]
	MOVEM T,PARNAM
GWVER:
>;MD
	PUSHJ P,RELWIR		;Release any previous wirelist space
	SETZM COUNT		;CLEAR UNASSIGNED BODY LOC COUNTER
MPC,<	JRST RWWIR		; If PC, start reading name strings >
MD,<	SETZM %LAST			;INIT SIGNAL COUNTER
	TLNN WFLAG			;LES FILE?
	JRST RWWIR
TRYCAT:	PUSHJ P,WORDIN
	JUMPE TTT,RWDONE	;THAT'S ALL IF ZERO ERROR CODE
	MOVEM TTT,ERCODE
	PUSHJ P,RSTR
	MOVE B,T
	TLNN M,DSKACT!MACACT
	PUSHJ P,OUTTXT
	PUSHJ P,PUTFS
	PUSHJ P,YORN
	JRST RWDONE		;ALTMODE
	CAIA			;NO, SKIP THIS CATEGORY
	JRST RWWIR		;YES, READ THIS CATEGORY
SKPCAT:	PUSHJ P,SKPSTR
	JRST TRYCAT
SKPCT1:	PUSHJ P,SKPSTR
	JRST SKPCT2
	JRST SKPCT1

SKPCT2:	PUSHJ P,WORDIN
	JUMPE TTT,SKPCAT
	PUSHJ P,WORDIN
	JRST SKPCT2
>;MD

RWWIRX:	JUMPE H,RWWIR
MD,<	TLNE WFLAG		;IERRORS
	SKIPE DX1		;AND NO PINS READ?
	JRST IERSOM		;NOT IERRORS, OR FOUND SOME
	MOVE A,H		;FLUSH WIRES WITH NO PINS
NILERR:	HLRZ B,1(A)
	SKIPE B
	PUSHJ P,PUTFS
	HRRZ A,(A)
	JUMPN A,NILERR
	MOVE B,H
	PUSHJ P,PUTFS
	JRST RWWIR

IERSOM:
>;MD
	GETFS(T)		;Create signal header block
	HLL H,(P)		;Get accumulated TYPE bits
	MOVEM H,1(T)		; and put into signal header
	EXCH T,WIRLST		;Link header onto wire list
	HRRZM T,@WIRLST
RWWIR:	SETZ H,			;Initially, pointer to pin list is NIL
	HRRZS (P)		;Clear accumulated signal type bits
RWWIRS:	PUSHJ P,RSTRZ		;Read a signal name string
	 JRST [	MOVE G,H	; NIL, save list_head pointer,
		JUMPN H,RWWIRG	;  and, unless there is none, process signal
		JRST RWDONE]
	GETFS(TT)		;Get a new list element
	HRLZM T,1(TT)		;Deposit pointer to string
	HRRZM H,(TT)		; and link to any existing pin list
	MOVE H,TT		;  and save pointer to list head
MD,<	SETZM DX1		;NO PINS FOUND YET>
	JRST RWWIRS		;Read more, until nil

MD,<
RWWIRG:	AOSA %LAST		;INC COUNT OF SIGNALS
>;MD
RWWIR0:	AOS COUNT
MPC,<RWWIRG:>
RWWIR1:	PUSHJ P,WORDIN		;Get the next word
	JUMPE TTT,RWWIRX	; Loop if end of pins for this signal
MD,<	TLNN WFLAG
	 JRST RWWIRZ
	MOVE T,TTT
	PUSHJ P,WORDIN
	CAME TTT,PARNAM
	JRST RWWIR1		;NOT THIS FILE, SKIP IT
	MOVE TTT,T
	PUSHJ P,FNDID		;FIND BY PID
	JRST RWWIR0		;LOSE
	AOS DX1			;COUNT A PIN READ
	MOVE T,D
	JRST GWPNT

RWWIRZ:
>;MD
	TLNE TTT,-1		;Is this a connector pin?
	 JRST [	MOVSM TTT,LETTER ; Yes
MPC,<		HLRZ A,TTT	;ONLY TREAT AZ1,EZ1 SPECIAL IN PC
		PUSHJ P,QUPIN
		CAIA		;Not wild, skip always
		 JRST SAVRND	; Save random connector spec
>;MPC
		SETZM NUMBER	;Flag this as a CPIN for LOOK
		JRST LOKCON]
	PUSHJ P,WORDIN		;Get <Pin ID>,,pin_number
	HRRZM TTT,NUMBER	;NUMBER := pin_number
	HRRI TTT,
	IORM TTT,(P)		;Store bits on stack
	PUSHJ P,WORDIN
	MOVEM TTT,LETTER	;Get <pin_bits,,0>
LOKCON:	SKIPN LETTER
	 JRST RWWIR0
	PUSHJ P,LOOK		;Look for the pin on the right body
	 JRST RWNFND		; Did not find one, complain
GWPNT:	JUMPN G,RWGFST
	GETFS (G)		;Get another list element
	SETZM (G)		; and clear it
	SETZM 1(G)
	MOVE H,G
RWGFST:	HLRZ TT,(G)
	JUMPE TT,RWGFS1
	HRRZ TT,(G)		;Is there another block linked
	JUMPE TT,RWGFS2		; after this one
	MOVE G,TT		;  Yes, follow the list linkage
	JRST RWGFST

RWGFS2:	GETFS (TT)		;Get another list element
	HRRM TT,(G)		; link onto end of pin list
	MOVE G,TT		;  and point to it, and
	SETZM (G)		;   clear it.
	SETZM 1(G)
RWGFS1:	HRLM T,(G)		;Save pointer to XYblock we found
	JRST RWWIR1		; and do another point

MPC,<
SAVRND:	JUMPN G,RWGFXT
	GETFS (G)
	SETZM (G)
	SETZM 1(G)
	MOVE H,G
RWGFXT:	AOS 1(G)
	JRST RWWIR1
>;MPC

RWNFND:	PUSH P,PUTCHR		;change putchr to output from ttt
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	MOVS A,LETTER
	SKIPN NUMBER		;CON PIN?
	JRST RWNFNC		; YES
	PUSHJ P,SLTLPN		;output dip location letten
	MOVE A,NUMBER
	PUSHJ P,BPINPN		; location number
RWNFN1:	POP P,PUTCHR
	OUTSTR[ASCIZ/ NOT FOUND.
/]
	JRST RWWIR1

RWNFNC:	PUSHJ P,CSLTLP		;print connector pin spec
	JRST RWNFN1

RWDONE:	RELEASE DAT,		;RELEASE INPUT FILE
	SKIPN T,COUNT
	POPJ P,
	PUSHJ P,DECOUT
MD,<	TLNE WFLAG
	OUTSTR[ASCIZ/ PINS OR CPINS NOT FOUND BY FNDID!
/]
	TLNN WFLAG
>;MD
	OUTSTR[ASCIZ/ PINS ON BODIES WITH NO ASSIGNED LOCATIONS!
/]
	POPJ P,

RELWIR:	SKIPN A,WIRLST		;Is there any (more) wirelist?
	 POPJ P,		; No, we are done
RELWR1:	HRRZ C,1(A)		; Yes, get pointer to pin block
RELWR2:	HLRZ B,1(C)		;  and pointer to net string
	PUSHJ P,PUTFS
	HRRZ C,(C)
	JUMPN C,RELWR2
	HRRZ B,1(A)
	PUSHJ P,PUTFS
	HRRZ A,(A)
	JUMPN A,RELWR1
	MOVE B,WIRLST
	SETZM WIRLST
	JRST PUTFS
>;UML
;'DAT'		PARTITION FILE
PART,<
INPINS:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PARTITION INPUT (DAT) /]
	MOVE H,[IPNNAM]
	EXCH H,LSTNAM
	MOVSI T,EXTPAR
	PUSHJ P,SETNAM
	JRST [	MOVEM H,LSTNAM
		POPJ P,]
	MOVEM H,LSTNAM
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/FILENAME OTHER THAN CURRENT DEFAULT?/]
	PUSHJ P,GETWRD
	CAIE C,12
	JRST INNERR		;LOSE
	JUMPN T,.+3
	SKIPN T,LSTNAM		;PICKUP DEFAULT
	JRST [	OUTSTR[ASCIZ/NO DEFAULT NAME!
/]
		RELEASE DAT,
		POPJ P,]
	MOVEM T,PARNAM		;SAVE HERE FOR TESTS LATER
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SKIP CONNECTOR PINS/]
	PUSHJ P,YORN
	JRST [	RELEASE DAT,
		POPJ P,]
	TLZA WFLAG
	TLO WFLAG
	TRO MCHG
DPART1:	PUSHJ P,I5IN
	JRST PARLOS
	JUMPE T,[PUSHJ P,SKPLIN
		JRST PARLOS
		TLNE WFLAG	;SKIPPING CONNECTORS?
		JRST PARDON	;YES
		JRST CPART]
	MOVEM T,DX1		;X POS
	PUSHJ P,I5IN
	JRST PARLOS
	MOVEM T,DY1		;Y POS
	PUSHJ P,SKPLIN		;SKIP TO EOL
	JRST PARLOS
DPART2:	PUSHJ P,O6IN		;READ SLICE #
	JRST PARLOS
	MOVE B,T		;DO NOTHING WITH IT FOR NOW
	PUSHJ P,O6IN		;READ BODY ID
	JRST PARLOS
	JUMPE T,[JUMPN B,.+1
		PUSHJ P,SKPLIN
		JRST PARLOS
		JRST DPART1]	;END OF THIS DIP
	MOVE B,T		;SAVE BID
	PUSHJ P,FILCHK		;CHECK IF THIS FILE?
	JRST PARLOS
	JRST BSKIP		;NO, SKIP THIS BODY
	MOVE TTT,B
	PUSHJ P,FNDBID
	JRST BSKIPE
	HLRZ T,(B)
	HLRZ T,1(T)
	HRRZ TT,(T)
	JUMPN TT,DPARTL
	GETFS(TT)
	GETFS(F)
	HRLZM F,(TT)
	SETZM 1(F)
	HRRM TT,(T)
	MOVSI F,FIXLOC!FIXBLO
	IORM F,1(T)		;CONTINUE FIXING LOC
	HLRZ T,(B)
	HLRZ F,(T)		;SAVE ORIENTATION
	HRRZ T,1(T)		;TYPE POINTER
	HLRZ T,1(T)
	HLRZ T,(T)
	MOVE T,1(T)		;INITIAL LOC OFFSET FROM TYPE
	PUSHJ P,ORIENT		;ORIENT IT
	MOVEM T,1(TT)		;INTIALIZE OFFSET
DPARTL:	HLRZ TT,(TT)
	SETZM (TT)		;CLEAR OUT ANY OLD CRUFT THERE
	MOVE T,DX1
	DPB T,[POINT 12,(TT),35] ;THIS IS NUMBER PART
	MOVE T,DY1
	DPB T,[POINT 6,(TT),23]	;THIS IS LETTER PART
	PUSH P,B
	MOVE T,B
	PUSHJ P,OFFBLO
	POP P,B
	PUSHJ P,SKPLIN
	JRST PARLOS
	SETZ G,
	MOVEI F,G
DPARTN:	PUSHJ P,I5INC
	JRST DPARTI
	JRST [
	GIVLOS:	MOVE B,G
		PUSHJ P,PUTFS
		JRST PARLOS]
	GETFS(TT)
	HRRM TT,(F)
	MOVE F,TT
	HRLZM T,(F)
	SETZM 1(F)
	JRST DPARTN

DPARTI:	JUMPE G,DPART2		;NO PINS? GET ANOTHER BODY
	MOVE F,G
DPARTJ:	PUSHJ P,O6INC
	JRST [	OUTSTR[ASCIZ/TOO LITTLE DATA ON PIN ID LINE!
/]
		JRST DPART6]
	JRST GIVLOS
	MOVEM T,1(F)
	HRRZ F,(F)
	JUMPN F,DPARTJ
	PUSHJ P,F4CIN
	JRST GIVLOS
	CAIN TTT,12
	JRST DPART6
	OUTSTR[ASCIZ/EXTRA DATA ON PIN ID LINE!
/]
	PUSHJ P,SKPLIN
	JRST GIVLOS

DPART6:	SKIPN T,1(G)
	JRST DPART7
	MOVEM T,DX3
	HLRZ A,(G)
	HLRZ T,(B)
	TRZ TFLG		;FLAG NONE FOUND YET
	JRST DPART4		;NOW FIND PIN ID

DPART5:	HLRZ T,(T)
	HRRZ TT,1(T)
	HRRZ TTT,(TT)
	HLRZ TTT,(TTT)
	HRRZ TTT,1(TTT)		;PIN NAME FOR THIS
	CAME TTT,DX3		;SAME PIN?
	JRST DPART4
	HRRM A,1(TT)		;STO PIN #
	TRO TFLG		;FLAG THAT WE FOUND ONE
DPART4:	HRRZ T,(T)
	JUMPN T,DPART5
	TRNN TFLG
	OUTSTR[ASCIZ/PIN ID NOT FOUND AT DPART5!
/]
DPART7:	MOVE T,G
	HRRZ G,(G)
	FSTRET(T)
	JUMPN G,DPART6
	JRST DPART2

BSKIPE:	OUTSTR[ASCIZ/BODY NOT FOUND AT DPART2!
/]
BSKIP:	PUSHJ P,SKPLIN		;SKIP REST OF BODY LINE
	JRST PARLOS
	PUSHJ P,SKPLIN		;SKIP PIN # LINE
	JRST PARLOS
	PUSHJ P,SKPLIN		;SKIP PIN ID LINE
	JRST PARLOS
	JRST DPART2		;TRY ANOTHER

CPART0:	PUSHJ P,SKPLIN		;SKIP TO NEXT LINE
	JRST PARLOS
CPART:	PUSHJ P,O6IN
	JRST PARDON		;DO THIS FOR NOW, WAGNER DOESN'T END WITH A 0
	JUMPE T,PARDON		;DONE ON 0
	MOVE B,T		;SAVE POINT ID
	PUSHJ P,FILCHK
	JRST PARLOS
	JRST CPART0
	SKIPN T,PONPNT
	JRST CPARTL
	MOVSI A,ISPIN		;FOR TEST
CPART1:	HLRZ TT,(T)
	HRRZ TTT,1(TT)
	TDNE A,1(TTT)
	JRST CPART2
	HRRZ TT,(TT)
	CAMN TT,B
	JRST CPART3		;SAME ID, THIS IS IT
CPART2:	HRRZ T,(T)
	JUMPN T,CPART1
CPARTL:	OUTSTR[ASCIZ/CONNECTOR PIN NOT FOUND AT CPART1!
/]
	JRST CPART0

CPART3:	HRLM T,(P)		;SAVE POINT POINTER HERE
	MOVE T,1(TTT)
	TLNN T,CPIN
	JRST [	OUTSTR[ASCIZ/FOUND POINT AT CPART1, BUT IT ISN'T A CONNECTOR PIN ANY MORE!
/]
		JRST CPART0]
	MOVE A,TTT
	SETZM LETTER
	PUSHJ P,F4CIN		;GET PADDLE DIGIT
	JRST PARLOS
	ANDI TTT,17
	DPB TTT,[POINT 6,LETTER,23]
	PUSHJ P,F4CIN
	JRST PARLOS
	MOVE B,TTT
	ANDI B,17
	PUSHJ P,F4CIN
	JRST PARLOS
	ANDI TTT,17
	IMULI B,=10
	ADD B,TTT
	AOS LETTER		;AT LEAST 1
	TRNN B,1
	AOS LETTER		;ANOTHER ONE
	ADDI B,1
	LSH B,-1
	DPB B,[POINT 6,LETTER,29]
	PUSH P,C
	PUSH P,D
	MOVE D,A
	MOVE C,A
	HRRZ A,(A)
	MOVE B,A
	PUSHJ P,UBACK		;CHECK FOR UPIN BACKUP
	POP P,D
	MOVE B,LETTER
	MOVEM B,(A)
	MOVE T,B
	PUSHJ P,CPNBCK
	POP P,C
	JRST CPART0

PARLOS:	OUTSTR[ASCIZ/UNEXPECTED END OF FILE, I QUIT!
/]
PARDON:	RELEASE DAT,
	POPJ P,

FILCHK:	PUSHJ P,O12IN
	POPJ P,
	AOS (P)
	CAMN T,PARNAM
	AOS (P)			;RIGHT FILENAME, SKIP
	POPJ P,

SKPLIN:	PUSHJ P,F4CIN
	POPJ P,
	CAIE TTT,12
	JRST SKPLIN
	JRST CPOPJ1

O12IN:	PUSHJ P,O6IN
	POPJ P,
	HRLM T,(P)
	PUSHJ P,O6IN
	POPJ P,
	HLL T,(P)
	JRST CPOPJ1

I5INC:	PUSHJ P,F4CIN
	JRST CPOPJ1
	CAIN TTT,12
	POPJ P,
	MOVEI TT,5
	PUSH P,[=10]
	SETZ T,
	AOS -1(P)
	JRST GETN2

I5IN:	MOVEI TT,5
	PUSH P,[=10]
	JRST DIN

O6INC:	PUSHJ P,F4CIN
	JRST CPOPJ1
	CAIN TTT,12
	POPJ P,
	MOVEI TT,6
	PUSH P,[10]
	SETZ T,
	AOS -1(P)
	JRST GETN2

O6IN:	MOVEI TT,6
OIN:	PUSH P,[10]
DIN:	SETZ T,
GETN1:	PUSHJ P,F4CIN		;READ A CHARACTER
	JRST [	POP P,(P)
		POPJ P,]
GETN2:	CAIN TTT,40
	TDZA TTT,TTT		;SPACES ARE ZEROES
	SUBI TTT,60
	JUMPL TTT,F4LOSE
	CAML TTT,(P)		;LESS THAN RADIX?
	JRST F4LOSE
	IMUL T,(P)
	ADD T,TTT
	SOJG TT,GETN1
	POP P,(P)
	JRST CPOPJ1

F4LOSE:	OUTSTR[ASCIZ/INPUT LOSSAGE AT GETN2, NON-DIGIT SEEN!
/]
	MOVSI TTT,70000		;BACK UP SO WILL GET IT AGAIN
	ADDM TTT,IOHD+1
	AOS IOHD+2
	POP P,(P)
	SETZ T,
	JRST CPOPJ1		;TRY TO HOBBLE ON!

F4CIN:	SOSG IOHD+2
	IN DAT,
	CAIA
	POPJ P,
	ILDB TTT,IOHD+1
	JUMPE TTT,F4CIN
	CAIE TTT,14
	CAIN TTT,15
	JRST F4CIN
	JRST CPOPJ1
>;PART
;WORDIN, CHKLOC
WORDIN:	SOSG IOHD+2
	IN DAT,
	CAIA
	JRST INERR
	ILDB TTT,IOHD+1
	POPJ P,

INERR:	OUTSTR [ASCIZ/INPUT ERROR.
SHALL I CLOSE THE FILE AND RETURN(Y OR NO)?/]
	INCHRW TTT
	CAIE TTT,"Y"
	CAIN TTT,"y"
	CAIA
NODEC,<	HALT .+1	>
DEC,<	PUSHJ P,TODDT	>
	RELEASE DAT,
	MOVE P,PERRSAV
	POPJ P,


CHKLOC:	HLRE T,TTT
	MOVMS T
MPC,<	CAILE T,20000	>	;+ OR - 50 INCHES?
MD,<	CAILE T,20000	>	;+ OR - ???
	JRST WAYOFF
	HRRE T,TTT
	MOVMS T
MPC,<	CAIG T,20000	>	;+ OR - 50 INCHES?
MD,<	CAIG T,20000	>	;+ OR - ???
	POPJ P,			;OK
WAYOFF:	OUTSTR @TYPLOC		;WHAT IS IT
	OUTSTR[ASCIZ/, WAY OFF SCREEN AT /]
CNTFED:	HLRE T,TTT
	JUMPGE T,.+2
	OUTCHR["-"]
	MOVMS T
MPC,<	IMULI T,5	>
	ASH T,-1
	PUSHJ P,DECOUT
	OUTCHR[","]
	HRRE T,TTT
	JUMPGE T,.+2
	OUTCHR["-"]
	MOVMS T
MPC,<	IMULI T,5	>
	ASH T,-1
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,
;GSTR, RSTR, FIND.P
MD,<
GSTR:	PUSHJ P,RSTRZ
	POPJ P,
	EXCH T,(TT)
	JUMPE T,CPOPJ
	MOVE B,T
	JRST PUTFS
>;MD

;Read an ASCIZ string.  If there are any characters, put them
; into linked blocks as necessary, and take P+2 return.
; If the word read is all 0s, take P+1 return.
;At exit, T/ pointer to head of this list.
RSTRZ:	PUSHJ P,WORDIN		;Read the first word
	 JUMPE TTT,CPOPJ
	AOSA (P)		;Set return to P+2, and skip always
RSTR:	PUSHJ P,WORDIN		;GET SOME OF THE STRING
	MOVEI A,T
RS1:	GETFS(B)		;We need another block for these chars
	MOVEM B,(A)		;LINK IN
	MOVE A,B		;POINT TO IT
	MOVEM TTT,1(A)		;SAVE WORD
	SETZM (A)		;CLEAR LINK
	TRNN TTT,377		;Was the last character nil ?
	 POPJ P,		;Yes
	PUSHJ P,WORDIN		;No, get another piece
	 JUMPN TTT,RS1		; unless there isn't one
	POPJ P,

SKPSTR:	PUSHJ P,WORDIN
	JUMPN TTT,SKPST1
	POPJ P,

SKPST2:	PUSHJ P,WORDIN
SKPST1:	TRNE TTT,376
	JRST SKPST2
	JRST CPOPJ1

;Find a point (if none found, make one) with the given X,Y coordinates
;At entry,
;	  TTT/	X,,Y of desired point
;At exit,
;	    D/	pointer to XY block of point
;	  TTT/	pointer to point_type block
;	    T/	pointer to point descriptor block
;	    E/	pointer to neighbors block
FIND.P:	SKIPE D,PONPNT		;Search list of on-screen points
	 PUSHJ P,FP1		; (returns to P+1 if found,
	  JRST FP3		;  to P+2 otherwise)
	  JRST FP2

FP1:	CAMN TTT,1(D)		;Is this the point we are looking for ?
	JRST CPOPJ1		; Yes, take P+2 exit
	HRRZ D,(D)		; No, fetch pointer to next one
	JUMPN D,FP1		;  unless there is none.
	POPJ P,			;   Then take P+1 exit

FP3:	MOVE T,TTT		;No point matches the X,,Y we want
	JRST PNTPUT		;Create a point (pointers will be right)
FP2:	HLRZ TTT,(D)		;Fetch pointer to point_type block,
	HRRZ T,1(TTT)		; pointer to descriptor,
	HLRZ E,1(TTT)		;  and pointer to neighbors block 
	POPJ P,
;'UML'		READ REDAC PIN ASSIGMENTS
MD,<
INUML:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/UML INPUT /]
	MOVSI T,EXTUML
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
ASKCRD:	SETZM PARNAM		;IF GLOBAL CARD LOC, ZERO FOR MATCH
	SKIPE T,CRDLOC
	JRST ASKCR1
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/CARD LOCATION (<CR> IF ONLY ONE IN DRAWING).
^/]
	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
	PUSHJ P,GETSLT
	CAIA			;error return
	CAIE C,12		;crlf only (blank)
	JRST [	PUSHJ P,INNERR	;you didn't asked for paddle info,(LL#).
		JRST ASKCRD]
	MOVE T,LETTER
	HLLZM T,PARNAM		;USE THIS CELL
ASKCR1:	MOVEM P,ERRP
	MOVE D,[ANDCAM C,1(T)]	;CLEAR BITS
	PUSHJ P,STBITA		;IN BODIES AND POINTS
	SETZ D,			;D=0:NOTHING YES, D=1 PINS, D=2 BODIES
INUML1:	PUSHJ P,UMLIN
	MOVE T,1(B)
	CAMN T,[ASCIZ/END/]
	JRST INUML2
	CAMN T,[ASCII/BODIE/]
	JRST INUML3
	CAMN T,[ASCIZ/PINS/]
	JRST INUML4
INUML6:	HRRZ A,B
	ADD A,[POINT 7,1]
	MOVE T,[PUSHJ P,UREAD]	;Someone will want to do a GETCH later
	MOVEM T,GTCHRX		; so set up where to read from
	XCT URDTAB(D)
	JRST INUML5		;ERROR
	JRST INUML5		;CRLF ONLY (BLANK)
MD,<	CAIA			;LOC OK
	JRST INUML5		;BRS SEEN, LOSE
>;MD
	CAIE C,11
	JRST INUML5
	MOVE T,LETTER
	MOVEM T,NUMBER
	XCT URDTAB(D)
	JRST INUML5
	JRST INUML5
MD,<	CAIA
	JRST INUML5
>;MD
	JUMPN C,INUML5
	PUSH P,B
	XCT URDFND(D)
	POP P,B
	PUSHJ P,PUTFS
	JRST INUML1

INUML3:	HRRZ T,(B)
	JUMPE T,INUML6
	MOVE T,1(T)
	CAME T,[ASCIZ/S/]
	JRST INUML6
	PUSHJ P,PUTFS
	MOVEI D,2
	JRST INUML1

INUML4:	PUSHJ P,PUTFS
	MOVEI D,1
	JRST INUML1
;		FIND PIN OR BODY AND SET NEW LOC
URDFND:	JFCL		;OH WELL, JUST IN CASE
	PUSHJ P,UFNPIN
	PUSHJ P,UFNBOD

UFNPIN:	SKIPN A,PONPNT
	POPJ P,
UFNPN1:	HLRZ C,(A)
	HRRZ C,1(C)
	MOVE T,1(C)
	TLNE T,CPIN
	TLNE T,1
	JRST UFNPN2
	HRRZ B,(C)
	MOVE TT,(B)
	XOR TT,PARNAM
	CAME TT,NUMBER
	JRST UFNPN2
	PUSH P,D
	MOVE D,C
	PUSHJ P,UBACK		;CHECK FOR WILD PIN BACKUP
	MOVE TT,LETTER
	HRRM TT,(B)
	MOVSI T,1
	IORM T,1(C)
	PUSHJ P,FIXEM		;FIX OFFSET IF NEEDED
	POP P,D
UFNPN2:	HRRZ A,(A)
	JUMPN A,UFNPN1
	POPJ P,

UFNBOD:	SKIPN A,DBODPN
	POPJ P,
UFNBD1:	HLRZ C,(A)
	HLRZ C,1(C)
	MOVE T,1(C)
	TLNE T,BTMP1
	JRST UFNBD2
	HRRZ B,(C)
	JUMPE B,UFNBD2
	HLRZ B,(B)
	MOVE TT,(B)
	XOR TT,PARNAM
	CAME TT,NUMBER
	JRST UFNBD2
	MOVE TT,LETTER
	HRRM TT,(B)
	TLO T,BTMP1
	MOVEM T,1(C)
UFNBD2:	HRRZ A,(A)
	JUMPN A,UFNBD1
	POPJ P,
;		SUBRS FOR READING UML FILE
INUML5:	OUTSTR[ASCIZ/FORMAT ERROR, /]
	OUTSTR @(D)[[ASCIZ/PINS OR BODIES NOT SELECTED /]
		[ASCIZ/PIN LOC /]
		[ASCIZ/BODY LOC /]]
	OUTSTR[ASCIZ/IN LINE:
/]
	SETZ TT,
	SKIPN TTT,B
	JRST INUMLY
INUMLZ:	MOVE T,1(TTT)
	OUTSTR T
	HRRZ TTT,(TTT)
	JUMPN TTT,INUMLZ
INUMLY:	OUTSTR[ASCIZ/
/]
	PUSHJ P,PUTFS
	JRST INUML1

UMLIN:	GETFS (B)
	SETZM (B)
	SETZM 1(B)
	MOVE T,B
	ADD T,[POINT 7,1]
UMLIN1:	PUSHJ P,UWDIN
	CAIE C,15
	CAIN C,14
	JRST UMLIN1
	CAIN C,12
	JRST UMLIN4
	CAIL C,"a"
	CAILE C,"z"
	SKIPA
	SUBI C,40
	CAIE C,11		;MAKE ANY CONTIGUOUS BLANK CHARS,
	CAIN C,40		;LOOK LIKE A SINGLE TAB
	JRST [	MOVEI C,11
		LDB TT,T
		CAIE TT,11
		JUMPN TT,.+1
		JRST UMLIN1]
	TLNN T,760000
	JRST UMLIN2
UMLIN3:	IDPB C,T
	JRST UMLIN1

UMLIN2:	GETFS (TT)
	SETZM (TT)
	SETZM 1(TT)
	HRRM TT,-1(T)
	HRR T,TT
	JRST UMLIN3

UMLIN4:	SKIPN 1(B)
	JRST UMLIN1
	SETZ C,
	LDB TT,T
	CAIN TT,11		;IF END OF LINE IS BLANK CHAR,
	DPB C,T			;THEN MAKE IT NULL
	POPJ P,

UWDIN:	SOSG IOHD+2
	IN DAT,
	JRST UWDIN1
	GETSTS DAT,C
	TLNE C,740000
	OUTSTR[ASCIZ/DISK ERROR
/]
	TLNE C,20000
	OUTSTR[ASCIZ/PREMATURE END OF FILE
/]
	MOVE P,ERRP
INUML2:	RELEASE DAT,
	TRO MCHG
	JRST PUTFS

UWDIN1:	ILDB C,IOHD+1
	JUMPE C,UWDIN
	POPJ P,
;		READ LOCATION FROM STRING
URDTAB:	JFCL
	PUSHJ P,GTCONP
	PUSHJ P,GTSLTL

UREAD:	TLNN A,760000
	JRST [	TRNE A,-1
		HRR A,-1(A)
		TRNE A,-1
		JRST .+1
		SETZ C,
		POPJ P,]
	ILDB C,A
	POPJ P,
;INPUT SIGNAL NAME CHANGE FILE
ISIGCH:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SIGNAL NAME CHANGE (CHG) INPUT /]
	MOVSI T,EXTCHG
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVE E,PONPNT
	PUSHJ P,ACLRP
	SETZM FIND
	MOVSI C,17
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS
ISIGC1:	PUSHJ P,RSTRC
	JRST ISIGCF		;OK EOF, DONE
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGLE		;NULL, SKIP LINE
	CAIE TTT,11
	JRST ISIGLF
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
	POP P,B
	PUSHJ P,PUTFS
	PUSHJ P,RSTRC
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGLE		;NULL SIGNAL, LINE ERROR
	CAIE TTT,12
	JRST ISIGLF		;NOT EOL, LINE ERROR
	MOVEM B,DX1
	SKIPE H,PONPNT
	PUSHJ P,SIGCDO
	MOVE B,DX1
	PUSHJ P,PUTFS
	JRST ISIGC1

ISIGLF:	PUSHJ P,PUTFS
ISIGLE:	PUSHJ P,CHGSKP
	JRST ISIGCE
	OUTSTR[ASCIZ/ERROR IN INPUT LINE, SKIPPING LINE.
/]
	JRST ISIGC1

ISIGCE:	OUTSTR[ASCIZ/EOF WHERE NOT EXPECTED.
/]
ISIGCF:	RELEASE DAT,
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,.+2
	SETOM FIND
	SKIPN T,FNDNUM
	JRST [	OUTSTR[ASCIZ/NO/]
		JRST ISIGC2]
	PUSHJ P,DECOUT
ISIGC2:	OUTSTR[ASCIZ/ SIGNAL NAME/]
	MOVE T,FNDNUM
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/ CHANGED.
/]
	POPJ P,
;CHANGE FILE INPUT SUBRS
CHGSKP:	CAIN TTT,12
	JRST CPOPJ1
	PUSHJ P,ICHG
	POPJ P,
	JRST CHGSKP

ICHG:	SOSG IOHD+2
	IN DAT,
	JRST ICHG1
	GETSTS DAT,TTT
	TRNE TTT,740000
	OUTSTR[ASCIZ/INPUT IO ERROR.
/]
	POPJ P,			;ALWAYS GIVE EOF RETURN

ICHG1:	ILDB TTT,IOHD+1
	CAIN TTT,15
	JRST ICHG
	JUMPN TTT,CPOPJ1
	JRST ICHG

RSTRC:	PUSHJ P,ICHG
	POPJ P,
	CAIN TTT,11
	JRST RSTRC		;SKIP OVER TABS
	AOS (P)			;DIRECT RETURN IS FOR IMMEDIATE EOF
	CAIN TTT,12
	JRST CPOPJ1		;INDICATE NULL STRING
	GETFS(B)
	PUSH P,B
	ADD B,[POINT 7,0,34]
RSTRC1:	SETZM (B)
	SETZM 1(B)
RSTRC2:	IDPB TTT,B
	PUSHJ P,ICHG
	JRST RSTRCE
	CAIE TTT,11
	CAIN TTT,12
	JRST RSTRCF
	TLNE B,760000
	JRST RSTRC2
	PUSH P,TTT
	GETFS(TTT)
	HRRM TTT,-1(B)
	HRR B,TTT
	POP P,TTT
	JRST RSTRC1

RSTRCF:	POP P,B
	JRST CPOPJ2

RSTRCE:	POP P,B
	JRST PUTFS		;RETURN STRING AND INDICATE EOF
;INPUT SIGNAL NAME CHANGE FILE
ICPNCH:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/CONNECTOR PIN (CPN) INPUT /]
	MOVSI T,EXTCPN
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVE E,PONPNT
	PUSHJ P,ACLRP
	SETZM FIND
	MOVSI C,1		;MARK BIT
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR IT
ICPNC1:	PUSHJ P,RSTRC
	JRST ICPNCF		;OK EOF, DONE
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNLE		;NULL, SKIP LINE
	CAIE TTT,11
	JRST ICPNLF
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	MOVE T,[PUSHJ P,UREAD]
	MOVEM T,GTCHRX
	PUSHJ P,GTCONP
	JRST ICPNLF
	JRST ICPNLF
	CAIA			;LOC OK
	JRST INUML5		;BRS SEEN, LOSE
	JUMPN C,ICPNLF		;ERROR IF NOT EOS
	POP P,B
	PUSHJ P,PUTFS		;RETURN STRING
	PUSHJ P,RSTRC		;NOW GET SIGNAL NAME
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNLE		;NULL SIGNAL, LINE ERROR
	CAIE TTT,12
	JRST ICPNLF		;NOT EOL, LINE ERROR
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
	POP P,B
	PUSHJ P,PUTFS
	SKIPE H,PONPNT
	PUSHJ P,CPNDO		;DO THIS LINE
	JRST ICPNC1

ICPNLF:	PUSHJ P,PUTFS
ICPNLE:	PUSHJ P,CHGSKP
	JRST ICPNCE
	OUTSTR[ASCIZ/ERROR IN INPUT LINE, SKIPPING LINE.
/]
	JRST ICPNC1

ICPNCE:	OUTSTR[ASCIZ/EOF WHERE NOT EXPECTED.
/]
ICPNCF:	RELEASE DAT,
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,.+2
	SETOM FIND
	SKIPN T,FNDNUM
	JRST [	OUTSTR[ASCIZ/NO/]
		JRST ICPNC2]
	PUSHJ P,DECOUT
ICPNC2:	OUTSTR[ASCIZ/ CONNECTOR PIN/]
	MOVE T,FNDNUM
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/ SET.
/]
	POPJ P,
;IMPLEMENT ONE CHANGE LINE
CPNDO:	HLRZ G,(H)
	HRRZ G,1(G)
	MOVE T,1(G)
	TLNE T,CPIN!1		;DON'T DO IF ALREADY CONNECTOR PIN, OR PEVIOUSLY LOOKED AT
	JRST CPNDO1
	HLRZ A,(G)
	JUMPE A,CPNDO1		;ALSO IF NO TEXT
	HRRZ A,(A)
	ADD A,[POINT 7,1]
	MOVEI B,SIGTAB
	PUSHJ P,SIGMAT		;COMPARE TO PREVIOUSLY READ STRING
	JRST CPNDO1		;NO MATCH
	JFCL			;EQUIVALENT IS CLOSE ENOUGH
	MOVE T,H		;GET PIN
	PUSH P,H
	MOVE H,[1,,CPNCHK]
	PUSHJ P,RECUR1		;SETUP WDOLST
	SKIPN WDOLST		;ANYTHING IN LIST
	JRST CPNDO2
	TLZ WFLAG
	PUSHJ P,RECCHK
	TLNE WFLAG
	JRST CPNDO2
	MOVE A,(P)
	PUSHJ P,SETLET		;PUT CONNECTOR PIN HERE
	POP P,H
	HLRZ TT,(H)
	HRRZ TT,1(TT)
	MOVSI T,FOUNDP
	IORM T,1(TT)
	AOSA FIND
CPNDO2:	POP P,H
CPNDO1:	HRRZ H,(H)
	JUMPN H,CPNDO
	POPJ P,

CPNCHK:	JFCL
	HLRZ T,(A)
	HRRZ T,1(T)
	HLL T,1(T)
	TLNN T,CPIN
	JRST JRECUR
	TLO WFLAG
	SKIPE B,WDOLST
	PUSHJ P,PUTFS
	SETZM WDOLST
	POPJ P,
>;MD
;RDVER TABLES!
MD,<
%IV6:	ANDI TTT,3
	ANDI TTT,3
	ANDI TTT,3
REPEAT IOVER-2,<ANDI TTT,7>
;**RDVER

%IV7:	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNNEW0
	PUSHJ P,LNNEW
REPEAT IOVER-6,<PUSHJ P,LNNEWS>
;**RDVER

LNOLD:	LDB A,[POINT 6,TT,8]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 12,LETTER,11]
	HLRZ A,TT
	DPB A,[POINT 6,LETTER,23]
	PUSHJ P,WORDIN
	DPB TTT,[POINT 6,LETTER,29]
	HLRZ TTT,TTT
	DPB TTT,[POINT 6,LETTER,17]
	JRST LNNEWB

LNNEW0:	PUSHJ P,WORDIN
	LDB TT,[POINT 6,TTT,5]
	DPB TT,[POINT 4,TTT,3]
	LDB TT,[POINT 6,TTT,11]
	LSH TT,3
	SKIPE TT
	TRO TT,3
	DPB TT,[POINT 8,TTT,11]
	PUSHJ P,LNNEWT
	JRST LNNEWB

LNNEW:	PUSHJ P,LNNEWS
	JRST LNNEWB

LNNEWS:	PUSHJ P,WORDIN
LNNEWT:	MOVEM TTT,LETTER
	PUSHJ P,WORDIN
	MOVEM TTT,NUMBER
	POPJ P,
>;MD

LNNEWB:
MD,<	LDB TT,[POINT 5,LETTER,8]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 5,LETTER,8]
>;MD
	LDB TT,[POINT 6,LETTER,23]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 6,LETTER,23]
	POPJ P,

MPC,<
%IV8:	PUSHJ P,LNOLD0
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNNEW
	PUSHJ P,LNNEW
	PUSHJ P,LNNEWS
REPEAT IOVER-7,<HLRZM TT,LETTER	;STORE LOC, NO MORE OFFSET>
;**RDVER

LNOLD0:	TRNN TT,400000		;VERY OLD VERSION?
	JRST LNOLD		;NO, GO TO LNOLD
	HLRZ TT,TT
	DPB TT,[POINT 6,LETTER,23]
	PUSHJ P,WORDIN
	DPB TT,[POINT 6,LETTER,29]
	JRST LNNEWB

LNOLD:	LSH TT,-9
	DPB TT,[POINT 6,LETTER,23]
	LSH TT,-9
	DPB TT,[POINT 6,LETTER,29]
	JRST LNNEWB

LNNEW:	PUSHJ P,LNNEWS
	JRST LNNEWB

LNNEWS:	HLRZM TT,LETTER
	PUSHJ P,WORDIN		;GET X,Y OFFSET
	MOVEM TTT,NUMBER
	POPJ P,
>;MPC

MD,<
%IV10:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3D>
;**RDVER

RDV3D:	PUSHJ P,FFNDID
	JRST NNDOWN
	JRST OLDVRD

%IV11:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3U>
;**RDVER

RDV3U:	PUSHJ P,FFNDID
	JRST NNUP
	JRST OLDVRU

%IV12:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3L>
;**RDVER

RDV3L:	PUSHJ P,FFNDID
	JRST NNLEFT
	JRST OLDVRL

%IV13:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3R>
;**RDVER

RDV3R:	PUSHJ P,FFNDID
	JRST NNRIGHT
	JRST OLDVRR
>;MD

%IV14:		JFCL		;DON'T CHANGE OLD PIN #'S
		JFCL
		JFCL
MPC,<		PUSHJ P,PADPIN
		PUSHJ P,PADPIN
		PUSHJ P,PADPIN
>;MPC
REPEAT IOVER-2,<	PUSHJ P,GPADPN	>
;**RDVER

MPC,<
PADPIN:	TLNE TT,FEEDTH		;PINS WERE DEFAULTED BY BPYES
	AOS 1(C)		;TYPE 1 PAD FOR FEEDTHROUGHS
	TLNE TT,2000		;OLD UNPADDED FEEDTHROUGH BIT!
	HLLZS 1(C)		;IN WHICH CASE 0
	JRST WORDIN
;	POPJ P,
>;MPC

GPADPN:
MPC,<	TLNE TT,ISPIN		;IS IT A HOLE?
	TLNN M,TYPNLY		;AND SPECIAL INPUT MODE
	JRST NPDCNG		;NO
	TRNN TTT,-1		;PAD TYPE ALREADY?
	HRRI TTT,1		;NO PAD IT
NPDCNG:	HLLI TTT,
	CAMLE TTT,MXPADN
	MOVEM TTT,MXPADN
>;MPC
	HRRM TTT,1(C)		;STO PIN OR PAD NUMBER
	JRST WORDIN

MD,<
%IV17:	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD0
	PUSHJ P,LNNEW1
REPEAT IOVER-6,<PUSHJ P,LNNWS1>
;**RDVER

LNOLD1:	DPB TTT,[POINT 6,(T),23]
	LDB A,[POINT 6,TTT,26]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 12,(T),11]
	HLRZ TTT,TTT
	ROT TTT,-1
	ADDI TTT,1
	DPB TTT,[POINT 6,(T),35] ;USE THIS AS NUM
	ROT TTT,1
	ANDI TTT,1
	ADDI TTT,1
	DPB TTT,[POINT 6,(T),29] ;AND THIS AS LET
	PUSHJ P,WORDIN
	HLRZ TTT,TTT
	DPB TTT,[POINT 6,(T),17]
	SETZM 1(T)
	JRST LNNEWC

LNOLD0:	LDB A,[POINT 6,TTT,5]
	DPB A,[POINT 4,TTT,3]
	LDB A,[POINT 6,TTT,11]
	LDB TT,[POINT 6,TTT,23]	;THIS IS TO CATCH POOR LOSERS
	JUMPE TT,[DPB A,[POINT 24,TTT,23]
		JRST LNNEW1]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 8,TTT,11]
LNNEW1:	PUSHJ P,LNNWS1
	JRST LNNEWC

LNNWS1:	MOVEM TTT,(T)
	PUSHJ P,WORDIN
	MOVEM TTT,1(T)
	POPJ P,
>;MD
LNNEWC:	LDB TT,[POINT 6,(T),29]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 6,(T),29]
MD,<	LDB TT,[POINT 5,(T),8]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 5,(T),8]
>;MD
	LDB TT,[POINT 6,(T),23]
	MOVE TT,L2N-1(TT)
	DPB TT,[POINT 6,(T),23]
	POPJ P,

%IV18:	CAIN TTT,400000		;DONE?
REPEAT IOVER,<JUMPN TTT,RDV3S>
;**RDVER

RDV3S:
MPC,<	PUSHJ P,FFNDID
	CAIA
	JRST OLDV11		;FOUND IT
	FSWITCH
>;MPC
	PUSHJ P,FFNDID		;TRY THIS SIDE!
	JRST RDSPNT		;LOSE
	JRST OLDV11

MPC,<
%IV20:	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO0
	PUSHJ P,CLOCOS
REPEAT IOVER-6,<MOVEM TTT,CRDLOC>
;**RDVER

CLOCO:	DPB TTT,[POINT 6,CRDLOC,17] ;NUMBER
	HLRZ TTT,TTT
	ANDI TTT,77
	LSH TTT,3
	SKIPE TTT
	TRO TTT,3
	DPB TTT,[POINT 12,CRDLOC,11]
	JRST CLOCOT

CLOCO0:	MOVEM TTT,CRDLOC
	LDB TTT,[POINT 6,CRDLOC,5]
	DPB TTT,[POINT 4,CRDLOC,3]
	LDB TTT,[POINT 6,CRDLOC,11]
	LSH TTT,3
	SKIPE TTT
	TRO TTT,3
	DPB TTT,[POINT 8,CRDLOC,11]
	JRST CLOCOT

CLOCOS:	MOVEM TTT,CRDLOC
CLOCOT:	LDB TTT,[POINT 5,CRDLOC,8]
	MOVE TTT,L2N-1(TTT)
	DPB TTT,[POINT 5,CRDLOC,8]
	POPJ P,
>;MPC
                                                     