00100	TITLE	DISKIO I/O ROUTINE TO STORE DATA ON THE STANFORD UNIVERSAL DESIGN SYSTEM
00200	
00300	;BEGIN TEMP			TEMPARARY I/O HANDLING.
00400	
00500	OPDEF	RESET	[CALLI	0	]
00600	OPDEF	OUTCHR	[TTCALL	1,	]
00700	OPDEF	OUTSTR	[TTCALL	3,	]
00800	OPDEF	INCHWL	[TTCALL	4,	]
00900	
01000	;END TEMP
01100	
01200	OPDEF	SLEEP	[CALLI	,31	]	;WAIT FOR (ACCUMULATOR) SECONDS
01300	OPDEF	SETUWP	[CALLI	,36	]	;HIGH SEG WRITE PROTECTION (BIT 35 OF AC  0=WRITE PRIVILEGES)
01400	
01500	
01600	;BITS FOR OPEN OF THE DISK CHANNEL
01700	.IODMP_17			;DUMP ONE RECORD WITHOUT CORE BUFFERING
01800	
01900	;BITS FOR ERROR TRAPING
02000	ER.ICC__2			;FOR USE IN TRAPPING ^Cs.
02100	
02200	
02300	;I/O CHANNELS
02400	DISKIO_6			;MAKE THE DISK IO CHANNEL=6.
02500					;THIS WILL HAVE TO BE CHANGED WHEN
02600					;THIS PROGRAM IS MERGED WITH SUDS
02700	
02800	;ACCUMULATORS
02900	
03000	A_1
03100	B_2
03200	
03300	;BEGIN TEMP			ACCUMULATORS
03400	
03500	C_3
03600	D_4
03700	
03800	;END TEMP			ACCUMULATORS
03900	
04000	P_17				;SAME PDL POINTER AS SUDS
04100	
04200	
04300		TWOSEG
04400	SET	LOWER,.
04500	RELOC	400000
04600	SET	UPPER,.
04700	
04800	
04900	LPDL_20				;MAKE THE LENGTH OF THE PDL20 BASE 10
05000	
05100	USE	LOWER
05200	;BEGIN TEMP			SET UP A PUSH DOWN LIST
05300	PDL:	BLOCK	LPDL		;THIS IS THE PUSH DOWN LIST
05400	;END TEMP			SET UP A PUSH DOWN LIST
05500	
05600	TMPAC3:	0			;TEMPORARY STORAGE PLACE FOR AC 3
05700	
05800	USE	UPPER
     	00100	;BEGIN TEMP			TEMPARARY ROUTINE TO TEST PROGRAM CONCEPT
00200	
00300	STRT:	MOVE	P,	[IOWD	LPDL,	PDL	]	;SETUP THE PUSH DOWN LIST
00400		PUSHJ	P,	INITTB	;INITIALIZE THE DATA TABLE
00500		OUTSTR	[ASCIZ	/WE ARE NOW READY TO ACCEPT SO COMMAND-/]
00600		SKIPA
00700	MAINLP:	OUTSTR	[ASCIZ/
00800	NEXT COMMAND-/]
00900		PUSHJ	P,	GetTTY		;GET SOME INPUT  NOTE:ITS RETURNS...
01000		OUTSTR	[ASCIZ/BAD ADDRESS BUT CONTINUING ANY WAY.
01100	/]
01200		OUTSTR	[ASCIZ/BAD OPPERATOR BUT CONTINUING ANY WAY.
01300	/]
01400		JRST	PRNT		;GO AND PRINT OUT THE TABLE LOCATION
01500		JRST	DEPOSIT		;ADD THE NUMBER TO THE IN THE TABLE
01600	PRNT:	OUTSTR	[ASCIZ/
01700	TABLE LOCATION /]
01800		MOVE	B,	TABLTM(A)	;STORE THE REAL ADDRESS IN B
01900		PUSHJ	P,	PRINT	;PRINT OUT THE ADDRESS
02000		MOVE	A,	B	;NOW LOAD A WITH THE CONTENCE OF
02100					;THAT TABLE LOCATION
02200		OUTSTR	[ASCIZ/ CONTAINS /]
02300		PUSHJ	P,	PRINT	;AND PRINT OUT ITS CONTENT
02400		JRST	MAINLP		;NOW GET NEXT COMMAND
02500	
02600	DEPOSIT:SETZ	D,		;CLEAR D FOR WRITE-UNPROTECTION OF HIGH SEGMENT
02700		SETUWP	D,		;UNPROTECT HIGH SEGMENT
02800		OUTSTR	[ASCIZ/HIGH SEGMENT WONT SWITCH TO BE WRITABLE./]	;ERROR
02900	
03000		ADDM	B,	TABLTM(A);ADD B TO MEMORY FOR THE NICE MAN
03100	
03200		SETO	D,		;SET D FOR WRITE-PROTECTION OF HIGH SEGMENT
03300		SETUWP	D,		;PROTECT THE HIGH SEGMENT
03400		OUTSTR	[ASCIZ/HIGH SEGMENT WONT SWITCH TO BE UNWRITABLE./]	;ERROR
03500		JRST	MAINLP		;GET NEXT COMMAND
03600	;END TEMP			MAIN
     	00100	;BEGIN TEMP			PRINT OUT A TABLE LOCATION
00200	BEGIN PRINTR
00300	
00400	;PRINT:		SAMPLE CALL	PUSHJ	P,PRINT
00500	;				(RETURN  NUMBER HAS BEEN PRINTED)
00600	
00700	^PRINT:
00800		SETZ	D,		;CLEAR AC D TO BE A COUNTER
00900	LOOP:
01000		MOVE	C,	A	;PUT NUMBER IN C TO WORK ON
01100		LSH	A,	-3	;DIVIDE A BY 8
01200		AOJ	D,		;INCRIMENT THE COUNTER OF NUMBER OF DIGITS
01300		TRZ	C,	777770	;MASK ALL UNWANTED BITS
01400		PUSH	P,	C	;PUSH IT ON THE STACK
01500		CAIE	A,	0	;IS THE WHOLE NUMBER STACKED?
01600		JRST	LOOP		;NO SO GO BACK AGAIN
01700	
01800	PRTIT:	SOJL	D,	RET	;IF NEGATIVE THEN WE ARE DONE
01900		POP	P,	C	;BRING BACK A DIGIT
02000		TRO	C,	60	;TURN IT INTO ASCII
02100		OUTCHR	C		;OUTPUT THE DIGIT TO THE TTY
02200		JRST	PRTIT		;GET THE NEXT CHARACTER
02300	RET:	POPJ	P,
02400	BEND PRINTR
02500	;END TEMP			PRINT OUT A TABLE LOCATION
     	00100	;BEGIN TEMP			GET INPUT FROM THE TELETYPE
00200	BEGIN	TTYIN
00300	;GetTTY:	SAMPLE CALL	PUSHJ	P,	GetTTY
00400	;				JRST	(error in address)
00500	;				JRST	(error in operator)
00600	;				JRST	(print contence of location A)
00700	;				JRST	(deposit B at location A)
00800	
00900	;				NOTE:  INPUT AT THE TTY IS OF THE FORM
01000	;					ADDRESS OPPERATOR NUMBER
01100	;					THE NUMBER IS NOT NEEDED IF
01200	;					A PRINT IS REQUESTED.  THE
01300	;					OPERATOR OPTIONS ARE:
01400	;						D	FOR DEPOSIT
01500	;						E	FOR EXIT
01600	;						P	FOR PRINT
01700	;				NOTE ALSO:	LINES ARE TERMINATED
01800	;						WITH AN ESC OR ALT.
01900	
02000	^GetTTY:
02100		SETZ	A,		;ZERO OUT THE ADDRESS
02200		SETZ	B,		;ZERO OUT NUMBER TO BE ADDED
02300		INCHWL	C		;INSERT THE CHARACTER TO AC C
02400	LOOP:	CAIG	C,	"}"	;DID WE GET AN ALTMODE?
02500		JRST	RET		;YES DONE
02600		CAIG	C,"7"		;IS THE INPUT GREATER THAN 7
02700		CAIGE	C,"0"		;IS THE INPUT LESS THAN 0??
02800		JRST	MODE		;IT ISNT AN ALT OR A LEGITIMATE NUMBER SO MUST
02900					;BE A MODE
03000		TRZ	C,777770	;MASK THE NUMBER TO ONE DIGIT BASE EIGHT
03100		LSH	B,3		;MULTIPLY THE NUMBER BY 8
03200		ADD	B,C		;ADD IN THE NEW NUMBER
03300	LOPRTN:	INCHRS	C		;GET NEXT CHARACTER IN THE BUFFER
03400		JRST	RETURN		;SHOULD NEVER HAPPEN
03500		JRST	LOOP		;GET ANOTHER CHARACTER
03600	
03700	MODE:	MOVE	A,B		;PUT THE NUMBER ACCUMULATED THUS FAR INTO A
03800		CAIGE	A,=4096 	;CHECK THE NUMBER (ADDRESS) TO BE SMALL ENOUGH
03900		CAIGE	A,0		;MAKE SURE THE NUMBER ISN'T NEGATIVE
04000		JRST	ERRET		;ERROR MEMORY ADDRESS IS OUT OF BOUNDS
04100		AOS	(P)		;ADD ONE TO THE RETURN POINTER
04200		CAIE	C,"D"		;DID WE GET DEPOSIT MODE??
04300		JRST	PRINTM		;TRY PRINT MODE
04400		AOS	(P)		;INCREMENT THE RETURN SINCE WE ARE DEPOSITING
04500		SETZ	B,		;CLEAR OUT THE REGISTER WE WILL BE LOADING
04600		JRST	LOPRTN		;GET THE NUMBER TO BE ADDED TO LOCATION IN AC A
04700	
04800	PRINTM:	CAIE	C,"P"		;ARE WE GOING TO PRINT OUT DATA??
04900		JRST	EXIT		;MAYBE HE WANTS TO EXIT
05000		AOS	(P)		;INCRIMENT THE RETURN POINTER BY ONE
05100	ERRET:
05200	RETURN:	OUTSTR	[ASCIZ/
05300	/]				;GIVE HIM A RETURN SO IT ALL LOOKS NICE
05400		INCHRS	C		;CLEAR OUT THE INPUT BUFFER
05500		SKIPA			;CLEAR OUT THE INPUT BUFFER
05600		JRST	.-2		;CLEAR OUT THE INPUT BUFFER
05700		POPJ	P,		;RETURN
05800	
05900	RET:	AOS	(P)		;IF THE DUMB CLUTZ TYPES TWO D'S HE'S GOING TO RETURN
06000		JRST	RETURN		;TO PRINT  IF HE TYPES THREE OR MORE, WORSE THINGS HAPPEN
     	00100	EXIT:	CAIE	C,	"E"	;DOES HE WANT TO EXIT?
00200		JRST	ERRET		;NO HE WANTS AN ERROR MESSAGE
00300		PUSHJ	P,	FINISH	;FINISH UP WITH DATA TABLE
00400		EXIT	A,		;END  HACK THIS USES THE REGISTER FIELD IMEDIATE IE. 1
00500	BEND	TTYIN
00600	;END TEMP			GET INPUT FROM THE TELETYPE
     	00100	TABLTM:	BLOCK	=4096
00200					;SET UP A 4K TABLE FOR TIMES
00300					;USED IN DIFFERENT SECTIONS OF
00400					;SUDS
00500	
00600	USE LOWER
00700	
00800	IMIT:		-1		;0 IF I AM RESPONSIBLE FOR WRITING OUT THE FILE
00900	
01000	USE UPPER
01100	
01200	X335AD0L:DATPPN
01300	ELOWCOR:	0		;END OF LOWCOR BEFORE GETTING BLOCK OF CORE
01400	MI1ST:		-1			;AM I FIRST (<0IF I AM FIRST  >=0 IF I AMNOT FIRST)
01500	UTAKIT:		-1		;=-1 IF NO ONE IS RESPONSIBLE
01600					;FOR DOING THE WRITING
01700	
01800	
01900	GETCOR:				;GET =4096 WORDS OF CORE
02000		HRRZ	A,	.JBREL^^;GET THE CURRENT END OF LOWCOR
02100		HRRZM	A,	ELOWCOR	;SAVE THE PRESENT END OF LOWCOR
02200		ADDI	A,	=4096	;WE ARE GOING TO WANT AN ADDITIONAL 4K OF CORE
02300		CORE	A,
02400		JRST	[OUTSTR	[ASCIZ/NOT ENOUGH CORE.  /]
02500			EXIT	0,	];EXIT WITH NO CONTINUE CAPIBILITY
02600		HRRZ	A,	ELOWCOR	;GET THE BEGINNING ADDRESS OF
02700		POPJ	P,		;RETURN
02800	
02900	
03000	RETCOR:				;RETURN THE CORE TAKEN BY GETCOR:
03100		HRRZ	A,	ELOWCOR	;GET THE ADDRESS OF THE ORIGINAL END OF LOWCOR BEFORE GETCOR:
03200		CORE	A,		;GIVE BACK THE CORE
03300		JRST	[OUTSTR	[ASCIZ/ERROR IN GIVING BACK CORE TO THE MONITOR.  /]
03400			EXIT	0,	];EXIT WITH NO CONTINUE CAPIBILITY
03500		POPJ	P,		;RETURN
03600	
03700	
03800	OPENDK:	OPEN	DISKIO,	IOSPEC	;OPEN TEMP WITH CHANNEL DISKIO
03900		JRST	[OUTSTR	[ASCIZ/ERROR UPON OPENING A DISK CHANNEL TO TEMP:.  TRY ASSIGNING DSKB: TO BE TEMP:.
04000	/]
04100		EXIT	0,	]	;EXIT WITH NO CONTINUE
04200		POPJ	P,		;RETURN
04300	
04400	
04500	ENTERI:	MOVE	A,	X335AD0L;SET UP FOR ENTERI:  GET MY PPN
04600		MOVEM	A,	INNAME+3;SET UP FOR ENTERI:  PUT PPN IN LABEL INFORMATION
04700		ENTER	DISKIO,	INNAME	;PREPARE TO WRITE TEMP:TMDATA.TBL[]
04800		JRST	[OUTSTR	[ASCIZ/ERROR WHILE ENTERING TEMP:TADATA.TBL[].
04900	/]
05000		EXIT	0,	]	;EXIT WITH NO CONTINUE CAPABILITY
05100		POPJ	P,		;RETURN
05200	
05300	
05400	IOSPEC:		.IODMP		;I/O SPECIFACATION BLOCK FOR DEVICE TEMP:
05500		SIXBIT	/TEMP/		;DEVICE TEMP:
05600		XWD	0,	0
05700	
05800	
05900	USE	LOWER
06000	INNAME:	SIXBIT	/TMDATA/	;FILENAME   FILE DATA FOR TIME DATA TABLE
06100		SIXBIT	/TBL/		;EXTENTION LH   RH (RETURNS DATES)
06200		0			;(RETURNS DATES)
06300		DATPPN
06400	
06500	
06600	LOCDATA:IOWD	=4096,	ELOWCOR	;DISK IN LENGTH , CORE STARTING ADRESS (REDEPOSITED EACH TIME)
06700			0		;TERMINATOR
06800	
06900	
07000	USE	UPPER
     	00100	BEGIN	INIT
00200	
00300	AVAILABLE:	0		;IS THE TABLTM AVAILABLE (-1=YES)
00400	
00500	^INITTB:				;INITIALIZE THE DATA COLLECTION TABLE
00600		PUSH 	P,	A	;GET A REGISTER TO WORK WITH
00700		SETZ	A,		;SET ZEROS TO A FOR UNWRITE-PROTECTING SHARED SEGMENT
00800		SETUWP	A,		;UNPROTECT SHARED HIGH SEGMENT
00900		OUTSTR	[ASCIZ/ERROR IN UNPROTECTING SHARED HIGH SEGMENT CONTINUEING ANYWAY.
01000	/]				;ERROR RETURN FORM SETUWP  T,
01100		AOSE	MI1ST		;FIND OUT IF I AM THE FIRST TO START USING THIS PROGRAM
01200		JRST	IM2ND		;I AM NOT THE FIRST
01300		AOSGE	UTAKIT		;TELL EVERYONE SOMEONE IS TAKING RESPONSIBILITY FOR WRITING
01400		OUTSTR	[ASCIZ/ERROR NO CPU-TIME DATA BEING TAKEN.
01500	/]				;SHOULD CONTINUE OK
01600		PUSHJ	P,	OPENDK	;OPEN I/O CHANNEL TO TEMP
01700		LOOKUP	DISKIO,	INNAME	;FIND FILE TEMP:TMDATA.TBL
01800		JRST	[OUTSTR	[ASCIZ/FILE TEMP:TMDATA.TBL[] MUST NOT EXIST.
01900	/]
02000		EXIT	0,	]	;EXIT THE PROGRAM WITH NO CONTINUE CAPABILITY
02100		PUSH	P,	A	;GET A REGISTER FOR CHANGING CORE SIZE & ENTERI:.
02200		PUSHJ	P,	GETCOR	;GET 4K OF CORE
02300		HRRM	A,	LOCDATA	;DEPOSIT THE STARTING LOCATION FOR IN
02400		IN	DISKIO,	LOCDATA	;READ THE WHOLE TABLE IN
02500		SKIPA			;SINCE THIS IS THE NORMAL RETURN ALWAYS SKIP
02600		JRST	[OUTSTR	[ASCIZ/ERROR WHILE READING TEMP:TMDATA.TBL[].
02700	/]
02800		EXIT	0,	]	;EXIT WITH NO CONTINUE CAPABILITY
02900		HRLZI	A,	1(A)	;SET UP FOR BLT		INPUT STARTING ADRESS
03000		HRRI	A,	TABLTM	;SET UP FOR BLT		OUTPUT STARTING ADRESS
03100		BLT	A,	TABLTM+=4096-1;     BLT		OUTPUT FINISHING ADRESS
03200		PUSHJ	P,	RETCOR	;RETURN THE CORE TO THE MONITOR
03300		SETZM	IMIT		;LET MYSELF KNOW I DO THE WRITING OF THE TABLE
03400		SETOM	AVAILABLE	;ALLOW OTHERS TO USE THE TABLE
03500		PUSHJ	P,	ENTERI	;SET UP TO WRITE THE FILE WHEN APPLICABLE
03600		POP	P,	A	;RETURN THE REGISTER TAKEN FOR GETTING CORE
03700	INIRET:
03800		SETUWP	A,		;REPROTECT THE SHARED SEGMENT AS IT WAS
03900		OUTSTR	[ASCIZ/ERROR IN PRITECTING SHARED SEGMENT.
04000	/]				;ERROR RETURN FROM SETUWP  T,
04100		POP	P,	A	;RESTORE REGISTER A
04200		POPJ	P,		;RETURN
04300	
04400	IM2ND:	SKIPN	AVAILABLE	;SEE IF THE TABLE IS AVAILABLE
04500		JRST	WAIT		;SLEEP FOR A SECOND AND THEN COME BACK
04600		OUTSTR	[ASCIZ/I AM NOT THE FIRST ONE ON.
04700	/]				;READ OUTSTR
04800		JRST	INIRET		;RETURN AFTER SETUWP AND POP P,T
04900	
05000	WAIT:	PUSH	P,	A	;GET A REGISTER
05100		HRRZI	A,	1	;WE WANT TO SLEEP FOR 1 SECOND
05200		SLEEP	A,		;WE WANT TO SLEEP FOR 1 SECOND
05300		POP	P,	A	;RESTORE THE REGISTER
05400		JRST	IM2ND		;NOW TRY AGAIN
05500	
05600	BEND	INIT
     	00100	BEGIN	WRITEF
00200	
00300	PUTOUT:	USETO	DISKIO,	1	;SET THE FILE POINTER TO THE BEGINING
00400		PUSH	P,	B	;GET ANOTHER REGISTER FOR BLT
00500		PUSHJ	P,	GETCOR	;GET 4K OF CORE
00600		HRRZ	B,	A	;SAVE THE FIRST ADRESS -1 OF THE 4K
00700		ADDI	A,	1	;BLT  MAKE A THE FIRST ADRESS OF THE 4K
00800		HRLI	A,	TABLTM	;BLT  FROM STARTING ADRESS
00900		BLT	A,	=4096(B);BLT  PUT TABLTM: IN LOWCOR FOR OUT
01000		HRLI	B,	-(=4096);TELL IT TO OUT 4K
01100		MOVEM	B,	LOCDATA	;STORE TABLTM: ADRESS IN RIGHT HALF OF LOCDATA
01200		POP	P,	B	;RETURN THE REGISTER
01300		OUT	DISKIO,	LOCDATA	;WRITE OUT TEMP:TMDATA.TBL[] (FROM SHARED SEGMENT)
01400		POPJ	P,		;NORMAL RETURN
01500		OUTSTR	[ASCIZ/ERROR WHILE OUTPUTING TEMP:TMDATA.TBL[]
01600	/]
01700		EXIT	0,		;EXIT WITH NO CONTINUE CAPABILITY
01800	
01900	
02000	
02100	^WRITE:				;CALLED WHEN HE MIGHT WANT TO WRITE
02200		PUSH	P,	A	;GET AN REGISTER
02300		SETZ	A,		;ZERO IT TO UNLOCK THE SHARED SEGMENT
02400		SETUWP	A,		;UNPROTECT THE SHARED SEGMENT
02500		OUTSTR	[ASCIZ/ERROR IN UNPROTECTING SHARED SEGMENT
02600	/]
02700		PUSH	P,	A	;GET A REGISTER FOR PUTOUT:
02800		AOSN	UTAKIT		;IS SOMEONE ELSE RESPONSIBLE?
02900		JRST	TAKOVR		;NO SO I AM
03000		SKIPE	IMIT		;AM I RESPONSIBLE FOR WRITING?
03100		JRST	RETURN		;NO I DONT WRITE IT OUT
03200		PUSHJ	P,	PUTOUT	;OUTPUT TEMP:TMDATA.TBL[]
03300	RETURN:	POP	P,	A	;RESTORE THE REGISTER
03400		SETUWP	A,		;REPROTECT THE SHARED SEGMENT AS IT WAS
03500		OUTSTR	[ASCIZ/ERROR IN RESTORING SHARED SEGMENT PROTECTION.
03600	/]
03700		POP	P,	A	;RESTORE REGISTER A
03800		POPJ	P,		;RETURN
03900	
04000	TAKOVR:	PUSHJ	P,	OPENDK	;OPEN DEVICE TEMP:
04100		PUSHJ	P,	ENTERI	;ENTER TEMP:TMDATA.TBL[].
04200		PUSHJ	P,	PUTOUT	;OUTPUT TEMP:TMDATA.TBL[]
04300		JRST	RETURN		;RETURN REPROTECTING SHARED SEGMENT
04400	
04500	BEND	WRITEF
     	00100	BEGIN	FINIS
00200	XAVAILABLE:	-1		;AVAILABLE FOR EXITING THE PROGRAM? (-1 MEANS AVAILABLE)
00300	
00400	^FINISH:PUSH	P,	A	;GET A REGISTER
00500		SETZ	A,		;GET READY FOR UNPROTECTING SHARED SEGMENT
00600		SETUWP	A,		;UNPROTECT SHARED SEGMENT
00700		OUTSTR	[ASCIZ/ERROR IN UNPROTECTING SHARED SEGMENT.
00800	/]
00900	FINI:	AOSLE	XAVAILABLE	;IS THE TABLE AVAILABLE FOR MY EXIT?
01000		JRST	WAIT		;NO  SLEEP A SHORT WHILE THEN TRY AGAIN
01100		PUSHJ	P,	WRITE	;WRITE A FILE IF WE NEED TO
01200		RELEASE	DISKIO,		;CLOSE AND RELEASE TEMP:TMDATA.TBL[]
01300		SETOM	UTAKIT		;LET SOMEONE ELSE TAKE RESPONSIBILITY
01400		SETOM	XAVAILABLE	;MARK IT AVAILABLE FOR AN EXIT
01500		SETUWP	A,		;RESTORE SHARED SEGMENT PROTECTION
01600		OUTSTR	[ASCIZ/ERROR IN RESTORING SHARED SEGMENT PROTECTION.
01700	/]
01800		POP	P,	A	;RESTORE THE REGISTER
01900		POPJ	P,		;RETURN
02000	
02100	WAIT:	PUSH	P,	A	;GET A REGISTER
02200		HRRZI	A,	1	;GET A 1 FOR SLEEP
02300		SLEEP	A,		;SLEEP FOR 1 SECOND
02400		POP	P,	A	;RESTORE THE REGISTER
02500		JRST	FINI		;TRY AGAIN
02600	BEND FINIS
     	00100	;			CONTROL C TRAPPING
00200	
00300	;THIS PIECE OF CODE IS HERE TO REMIND THE USER TO TYPE "E" TO EXIT THIS PROGRAM.
00400	;A USER CAN PROBABLY TYPE ^Cs FASTER THAN THE PROGRAM CAN PROCESS THEM, THEREFOR
00500	;THIS IS ONLY A REMINDER.
00600	
00700	;THIS ROUTINE ENABLES CONTROL-C INTERCEPT AND HANDLING.
00800	
00900	LOC	134;.JBINT^^		;RELOCATE TO LOCATION 134
01000		INTBLK			;LEAVE THE ADDRESS OF THE CONTROL-C ROUTINE
01100	RELOC
01200	
01300	USE	LOWER
01400	INTBLK:	XWD	4,	INTRUT	;4 WORDS LONG,,PLACE TO START
01500		XWD	0,	2	;NO MESSAGE CONTROL,,TYPE 2  (^C)
01600				0	;GETS LAST USER PC
01700				0	;LEFT HALF GETS INTERRUPT TYPE
01800	USE UPPER
01900	
02000	;THE INTERUPT ROUTINE
02100	
02200	INTRUT:	MOVEM	C,	TMPAC3	;SAVE AC 3
02300		HLRZ	C,	INTBLK+3;GET REASON FOR INTERRUPT
02400		CAIE	C,	ER.ICC	;SEE IF CONTROL-C
02500		HALT	.		;ERROR IF NOT
02600						;RELEASE ANY SPECIAL RESOURCES HERE
02700						;  BUT BE CAREFUL THAT THIS DOES NOT
02800						;  TAKE VERY LONG OR CAUSE A LOOP.
02900		OUTSTR	[ASCIZ	/TYPE E TO EXIT.
03000	/]				;SEND HIM A LITTLE MESSAGE
03100		MOVE	C,	TMPAC3	;RESTORE AC 3
03200		PUSH	P,	INTBLK+2;SAVE RETURN ADDRESS
03300		SETZM		INTBLK+2;CLEAR INTERUPT TO ALLOW ANOTHER
03400		POPJ	P,		;RETURN
03500	END STRT
